--- linux-2.6.19.2/drivers/video/Kconfig	2006-12-11 12:32:53.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/Kconfig	2007-01-10 15:35:26.000000000 -0700
@@ -262,6 +262,10 @@ config FB_CLPS711X
 	  Say Y to enable the Framebuffer driver for the CLPS7111 and
 	  EP7212 processors.
 
+if ARCH_MXC
+source "drivers/video/mxc/Kconfig"
+endif
+
 config FB_SA1100
 	bool "SA-1100 LCD support"
 	depends on (FB = y) && ARM && ARCH_SA1100
@@ -511,7 +515,7 @@ config FB_STI
 	  BIOS routines contained in a ROM chip in HP PA-RISC based machines.
 	  Enabling this option will implement the linux framebuffer device
 	  using calls to the STI BIOS routines for initialisation.
-	
+
 	  If you enable this option, you will get a planar framebuffer device
 	  /dev/fb which will work on the most common HP graphic cards of the
 	  NGLE family, including the artist chips (in the 7xx and Bxxx series),
@@ -791,36 +795,36 @@ config FB_I810
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 	help
-	  This driver supports the on-board graphics built in to the Intel 810 
+	  This driver supports the on-board graphics built in to the Intel 810
           and 815 chipsets.  Say Y if you have and plan to use such a board.
 
           To compile this driver as a module, choose M here: the
 	  module will be called i810fb.
 
-          For more information, please read 
+          For more information, please read
 	  <file:Documentation/fb/intel810.txt>
 
 config FB_I810_GTF
 	bool "use VESA Generalized Timing Formula"
 	depends on FB_I810
 	help
-	  If you say Y, then the VESA standard, Generalized Timing Formula 
+	  If you say Y, then the VESA standard, Generalized Timing Formula
           or GTF, will be used to calculate the required video timing values
-	  per video mode.  Since the GTF allows nondiscrete timings 
+	  per video mode.  Since the GTF allows nondiscrete timings
           (nondiscrete being a range of values as opposed to discrete being a
-          set of values), you'll be able to use any combination of horizontal 
+          set of values), you'll be able to use any combination of horizontal
 	  and vertical resolutions, and vertical refresh rates without having
 	  to specify your own timing parameters.  This is especially useful
-	  to maximize the performance of an aging display, or if you just 
-          have a display with nonstandard dimensions. A VESA compliant 
+	  to maximize the performance of an aging display, or if you just
+          have a display with nonstandard dimensions. A VESA compliant
 	  monitor is recommended, but can still work with non-compliant ones.
-	  If you need or want this, then select this option. The timings may 
-	  not be compliant with Intel's recommended values. Use at your own 
+	  If you need or want this, then select this option. The timings may
+	  not be compliant with Intel's recommended values. Use at your own
 	  risk.
 
-          If you say N, the driver will revert to discrete video timings 
+          If you say N, the driver will revert to discrete video timings
 	  using a set recommended by Intel in their documentation.
-  
+
           If unsure, say N.
 
 config FB_I810_I2C
@@ -931,10 +935,10 @@ config FB_MATROX_G
 	  framebuffer section. G450/G550 secondary head and digital output
 	  are supported without additional modules.
 
-	  The driver starts in monitor mode. You must use the matroxset tool 
-	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
-	  swap primary and secondary head outputs, or to change output mode.  
-	  Secondary head driver always start in 640x480 resolution and you 
+	  The driver starts in monitor mode. You must use the matroxset tool
+	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to
+	  swap primary and secondary head outputs, or to change output mode.
+	  Secondary head driver always start in 640x480 resolution and you
 	  must use fbset to change it.
 
 	  Do not forget that second head supports only 16 and 32 bpp
@@ -1034,7 +1038,7 @@ config FB_RADEON
 	  "I2C support" and "I2C bit-banging support" in the character devices
 	  section.
 
-	  If you say M here then "I2C support" and "I2C bit-banging support" 
+	  If you say M here then "I2C support" and "I2C bit-banging support"
 	  can be build either as modules or built-in.
 
 	  There is a product page at
@@ -1045,7 +1049,7 @@ config FB_RADEON_I2C
 	depends on FB_RADEON
 	default y
 	help
-	  Say Y here if you want DDC/I2C support for your Radeon board. 
+	  Say Y here if you want DDC/I2C support for your Radeon board.
 
 config FB_RADEON_BACKLIGHT
 	bool "Support for backlight control"
@@ -1220,7 +1224,7 @@ config FB_NEOMAGIC
 	select FB_CFB_IMAGEBLIT
 	help
 	  This driver supports notebooks with NeoMagic PCI chips.
-	  Say Y if you have such a graphics card. 
+	  Say Y if you have such a graphics card.
 
 	  To compile this driver as a module, choose M here: the
 	  module will be called neofb.
@@ -1266,7 +1270,7 @@ config FB_VOODOO1
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
 	---help---
-	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or 
+	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or
 	  Voodoo2 (cvg) based graphics card.
 
 	  To compile this driver as a module, choose M here: the
--- linux-2.6.19.2/drivers/video/Makefile	2006-12-11 12:32:53.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/Makefile	2007-01-10 15:35:26.000000000 -0700
@@ -99,6 +99,7 @@ obj-$(CONFIG_FB_IMX)              += imx
 obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
 obj-$(CONFIG_FB_PNX4008_DUM)	  += pnx4008/
 obj-$(CONFIG_FB_PNX4008_DUM_RGB)  += pnx4008/
+obj-$(CONFIG_FB_MXC)		  += mxc/
 
 # Platform or fallback drivers go here
 obj-$(CONFIG_FB_VESA)             += vesafb.o
--- linux-2.6.19.2/drivers/video/mxc/fs453.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/fs453.c	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,491 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file fs453.c
+ * @brief Driver for FS453/4 TV encoder
+ *
+ * @ingroup Framebuffer
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/ioctl.h>
+#include <linux/video_encoder.h>
+
+#include "fs453.h"
+
+/*
+ * FIXME: VGA mode is not defined by video_encoder.h
+ * while FS453 supports VGA output.
+ */
+#ifndef VIDEO_ENCODER_VGA
+#define VIDEO_ENCODER_VGA	32
+#endif
+
+/*!
+ * This stucture contains the status of FS453.
+ */
+struct fs453_data {
+	int norm;
+	int input;
+	int output;
+	int enable;
+};
+
+/*!
+ * This structure contains all the register values needed to program the
+ * TV encoder chip.  This structure is instantiated and initialized for
+ * each supported output standard.
+ */
+struct fs453_presets {
+	u32 mode;		/*! Video mode */
+	u16 qpr;		/*! Quick Program Register */
+	u16 pwr_mgmt;		/*! Power Management */
+	u16 iho;		/*! Input Horizontal Offset */
+	u16 ivo;		/*! Input Vertical Offset */
+	u16 ihw;		/*! Input Horizontal Width */
+	u16 vsc;		/*! Vertical Scaling Coefficient */
+	u16 hsc;		/*! Horizontal Scaling Coefficient */
+	u16 bypass;		/*! Bypass */
+	u16 misc;		/*! Miscellaneous Bits Register */
+	u8 misc46;		/*! Miscellaneous Bits Register 46 */
+	u8 misc47;		/*! Miscellaneous Bits Register 47 */
+	u32 ncon;		/*! Numerator of NCO Word */
+	u32 ncod;		/*! Denominator of NCO Word */
+	u16 pllm;		/*! PLL M and Pump Control */
+	u16 plln;		/*! PLL N */
+	u16 pllpd;		/*! PLL Post-Divider */
+	u16 vid_cntl0;		/*! Video Control 0 */
+	u16 dac_cntl;		/*! DAC Control */
+	u16 fifo_lat;		/*! FIFO Latency */
+};
+
+static struct fs453_presets fs453_vga_presets = {
+	.mode = VIDEO_ENCODER_VGA,
+	.qpr = 0x9cb0,
+	.pwr_mgmt = 0x0408,
+	.misc = 0x0103,
+	.ncon = 0x00000000,
+	.ncod = 0x00000000,
+	.misc46 = 0xa9,
+	.misc47 = 0x00,
+	.pllm = 0x317f,
+	.plln = 0x008e,
+	.pllpd = 0x0202,
+	.vid_cntl0 = 0x4006,
+	.dac_cntl = 0x00e4,
+	.fifo_lat = 0x0082,
+};
+
+static struct fs453_presets fs453_ntsc_presets = {
+	.mode = VIDEO_ENCODER_NTSC,
+	.qpr = 0x9c48,
+	.pwr_mgmt = 0x0200,
+	.misc = 0x0103,
+	.ncon = 0x00000001,
+	.ncod = 0x00000001,
+	.misc46 = 0x01,
+	.misc47 = 0x00,
+	.pllm = 0x4000 | (296 - 17),
+	.plln = 30 - 1,
+	.pllpd = ((10 - 1) << 8) | (10 - 1),
+	.iho = 0,
+	.ivo = 40,
+	.ihw = 768,
+	.vsc = 789,
+	.hsc = 0x0000,
+	.bypass = 0x000a,
+	.vid_cntl0 = 0x0340,
+	.dac_cntl = 0x00e4,
+	.fifo_lat = 0x0082,
+};
+
+static struct fs453_presets fs453_pal_presets = {
+	.mode = VIDEO_ENCODER_PAL,
+	.qpr = 0x9c41,
+	.pwr_mgmt = 0x0200,
+	.misc = 0x0103,
+	.ncon = 0x00000001,
+	.ncod = 0x00000001,
+	.misc46 = 0x01,
+	.misc47 = 0x00,
+	.pllm = 0x4000 | (296 - 17),
+	.plln = 30 - 1,
+	.pllpd = ((10 - 1) << 8) | (10 - 1),
+	.iho = 0,
+	.ivo = 19,
+	.ihw = 768,
+	.vsc = 8200,
+	.hsc = 0x0000,
+	.bypass = 0x000a,
+	.vid_cntl0 = 0x0340,
+	.dac_cntl = 0x00e4,
+	.fifo_lat = 0x0082,
+};
+
+static int fs453_preset(struct i2c_client *client,
+			struct fs453_presets *presets);
+static int fs453_enable(struct i2c_client *client, int enable);
+
+static struct i2c_driver fs453_driver;
+/*
+ * FIXME: fs453_client will represent the first FS453 device found by
+ * the I2C subsystem, which means fs453_ioctl() always works on the
+ * first FS453 device.
+ */
+static struct i2c_client *fs453_client = 0;
+
+static int fs453_command(struct i2c_client *client, unsigned int cmd, void *arg)
+{
+	int val;
+	char *smode = 0;
+	struct video_encoder_capability *cap;
+	struct fs453_data *data = i2c_get_clientdata(client);
+	int ret = 0;
+
+	switch (cmd) {
+	case ENCODER_GET_CAPABILITIES:
+		cap = arg;
+		cap->flags =
+		    VIDEO_ENCODER_PAL | VIDEO_ENCODER_NTSC | VIDEO_ENCODER_VGA;
+		cap->inputs = 1;
+		cap->outputs = 1;
+		break;
+	case ENCODER_SET_NORM:
+		val = *(int *)arg;
+		switch (val) {
+		case VIDEO_ENCODER_PAL:
+			ret = fs453_preset(client, &fs453_pal_presets);
+			smode = "PAL";
+			break;
+		case VIDEO_ENCODER_NTSC:
+			ret = fs453_preset(client, &fs453_ntsc_presets);
+			smode = "NTSC";
+			break;
+		case VIDEO_ENCODER_VGA:
+			ret = fs453_preset(client, &fs453_vga_presets);
+			smode = "VGA";
+			break;
+		default:
+			ret = -EINVAL;
+			break;
+		}
+		if (!ret) {
+			data->norm = val;
+			data->enable = 1;
+			pr_debug("FS453: switched to %s\n", smode);
+		}
+		break;
+	case ENCODER_SET_INPUT:
+		val = *(int *)arg;
+		/* We have only one input */
+		if (val != 0)
+			return -EINVAL;
+		data->input = val;
+		break;
+	case ENCODER_SET_OUTPUT:
+		val = *(int *)arg;
+		/* We have only one output */
+		if (val != 0)
+			return -EINVAL;
+		data->output = val;
+		break;
+	case ENCODER_ENABLE_OUTPUT:
+		val = *(int *)arg;
+		if ((ret = fs453_enable(client, val)) == 0)
+			data->enable = val;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int i2c_fs453_detect_client(struct i2c_adapter *adapter, int address,
+				   int kind)
+{
+	int chip_id;
+	struct i2c_client *client;
+	struct fs453_data *data;
+	const char *client_name = "FS453 I2C dev";
+
+	pr_debug("FS453: i2c-bus: %s; address: 0x%x\n", adapter->name, address);
+
+	/* Let's see whether this adapter can support what we need */
+	if (!i2c_check_functionality(adapter,
+				     I2C_FUNC_SMBUS_WORD_DATA |
+				     I2C_FUNC_SMBUS_BYTE_DATA)) {
+		pr_debug("FS453: SMBUS word/byte operations not permited.\n");
+		return 0;
+	}
+
+	client =
+	    kmalloc(sizeof(struct i2c_client) + sizeof(struct fs453_data),
+		    GFP_KERNEL);
+	if (!client)
+		return -ENOMEM;
+
+	data = (struct fs453_data *)(client + 1);
+	client->addr = address;
+	client->adapter = adapter;
+	client->driver = &fs453_driver;
+	client->flags = 0;
+
+	/*
+	 * The generic detection, that is skipped if any force
+	 * parameter was used.
+	 */
+	if (kind < 0) {
+		chip_id = i2c_smbus_read_word_data(client, FS453_ID);
+		if (chip_id != FS453_CHIP_ID) {
+			pr_info("FS453: TV encoder not present\n");
+			kfree(client);
+			return 0;
+		} else
+			pr_info("FS453: TV encoder present, ID=0x%04X\n",
+				chip_id);
+	}
+	strcpy(client->name, client_name);
+
+	/* FS453 default status */
+	data->input = 0;
+	data->output = 0;
+	data->norm = 0;
+	data->enable = 0;
+	i2c_set_clientdata(client, data);
+
+	if (i2c_attach_client(client)) {
+		pr_debug("FS453: i2c_attach_client() failed.\n");
+		kfree(client);
+	} else if (fs453_client == 0)
+		fs453_client = client;
+
+	return 0;
+}
+
+static unsigned short normal_i2c[] = { FS453_I2C_ADDR, I2C_CLIENT_END };
+
+/* Magic definition of all other variables and things */
+I2C_CLIENT_INSMOD;
+
+static int i2c_fs453_attach(struct i2c_adapter *adap)
+{
+	return i2c_probe(adap, &addr_data, &i2c_fs453_detect_client);
+}
+
+static int i2c_fs453_detach(struct i2c_client *client)
+{
+	int err;
+
+	if ((err = i2c_detach_client(client))) {
+		pr_debug("FS453: i2c_detach_client() failed\n");
+		return err;
+	}
+
+	if (fs453_client == client)
+		fs453_client = 0;
+
+	kfree(client);
+	return 0;
+}
+
+static struct i2c_driver fs453_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "FS453 driver",
+		   },
+	.attach_adapter = &i2c_fs453_attach,
+	.detach_client = &i2c_fs453_detach,
+	.command = fs453_command,
+};
+
+/*!
+ * @brief Function to read TV encoder registers on the i2c bus
+ * @param     client	I2C client structure
+ * @param     reg	The register number
+ * @param     value	Pointer to buffer to receive the read data
+ * @param     len	Number of 16-bit register words to read
+ * @return    0 on success, others on failure
+ */
+static int fs453_read(struct i2c_client *client, u8 reg, u32 * value, u32 len)
+{
+	if (len == 1)
+		*value = i2c_smbus_read_byte_data(client, reg);
+	else if (len == 2)
+		*value = i2c_smbus_read_word_data(client, reg);
+	else if (len == 4) {
+		*(u16 *) value = i2c_smbus_read_word_data(client, reg);
+		*((u16 *) value + 1) =
+		    i2c_smbus_read_word_data(client, reg + 2);
+	} else
+		return -EINVAL;
+
+	return 0;
+}
+
+/*!
+ * @brief Function to write a TV encoder register on the i2c bus
+ * @param     client	I2C client structure
+ * @param     reg	The register number
+ * @param     value	The value to write
+ * @param     len	Number of words to write (must be 1)
+ * @return    0 on success, others on failure
+ */
+static int fs453_write(struct i2c_client *client, u8 reg, u32 value, u32 len)
+{
+	if (len == 1)
+		return i2c_smbus_write_byte_data(client, reg, (u8) value);
+	else if (len == 2)
+		return i2c_smbus_write_word_data(client, reg, (u16) value);
+	else if (len == 4)
+		return i2c_smbus_write_block_data(client, reg, len,
+						  (u8 *) & value);
+	else
+		return -EINVAL;
+}
+
+/*!
+ * @brief Function to initialize the TV encoder
+ * @param     client	I2C client structure
+ * @param     presets	FS453 pre-defined register values
+ * @return    0 on success; ENODEV if the encoder wasn't found
+ */
+static int fs453_preset(struct i2c_client *client,
+			struct fs453_presets *presets)
+{
+	u32 data;
+
+	if (!client)
+		return -ENODEV;
+
+	/* set the clock level */
+	fs453_write(client, FS453_CR, CR_GCC_CK_LVL, 2);
+
+	/* soft reset the encoder */
+	fs453_read(client, FS453_CR, &data, 2);
+	fs453_write(client, FS453_CR, data | CR_SRESET, 2);
+	fs453_write(client, FS453_CR, data & ~CR_SRESET, 2);
+
+	fs453_write(client, FS453_BYPASS, presets->bypass, 2);
+
+	/* Write the QPR (Quick Programming Register). */
+	fs453_write(client, FS453_QPR, presets->qpr, 2);
+
+	if (presets->mode != VIDEO_ENCODER_VGA) {
+		/* set up the NCO and PLL */
+		fs453_write(client, FS453_NCON, presets->ncon, 4);
+		fs453_write(client, FS453_NCOD, presets->ncod, 4);
+		fs453_write(client, FS453_PLL_M_PUMP, presets->pllm, 2);
+		fs453_write(client, FS453_PLL_N, presets->plln, 2);
+		fs453_write(client, FS453_PLL_PDIV, presets->pllpd, 2);
+
+		/* latch the NCO and PLL settings */
+		fs453_read(client, FS453_CR, &data, 2);
+		fs453_write(client, FS453_CR, data | CR_NCO_EN, 2);
+		fs453_write(client, FS453_CR, data & ~CR_NCO_EN, 2);
+	}
+
+	/* customize */
+	fs453_write(client, FS453_PWR_MGNT, presets->pwr_mgmt, 2);
+
+	fs453_write(client, FS453_IHO, presets->iho, 2);
+	fs453_write(client, FS453_IVO, presets->ivo, 2);
+	fs453_write(client, FS453_IHW, presets->ihw, 2);
+	fs453_write(client, FS453_VSC, presets->vsc, 2);
+	fs453_write(client, FS453_HSC, presets->hsc, 2);
+
+	fs453_write(client, FS453_MISC, presets->misc, 2);
+
+	fs453_write(client, FS453_VID_CNTL0, presets->vid_cntl0, 2);
+	fs453_write(client, FS453_MISC_46, presets->misc46, 1);
+	fs453_write(client, FS453_MISC_47, presets->misc47, 1);
+
+	fs453_write(client, FS453_DAC_CNTL, presets->dac_cntl, 2);
+	fs453_write(client, FS453_FIFO_LAT, presets->fifo_lat, 2);
+
+	return 0;
+}
+
+/*!
+ * @brief Function to enable/disable the TV encoder
+ * @param     client	I2C client structure
+ * @param     enable	0 to disable, others to enable
+ * @return    0 on success; ENODEV if the encoder wasn't found
+ */
+static int fs453_enable(struct i2c_client *client, int enable)
+{
+	struct fs453_data *data;
+
+	if (!client)
+		return -ENODEV;
+
+	data = i2c_get_clientdata(client);
+
+	if (enable)
+		return fs453_command(client, ENCODER_SET_NORM, &data->norm);
+	else
+		return fs453_write(client, FS453_PWR_MGNT, 0x3BFF, 2);
+}
+
+/*!
+ * @brief FS453 control routine
+ * @param	cmd	Control command
+ * @param	arg	Control argument
+ * @return	0 on success, others on failure
+ */
+int fs453_ioctl(unsigned int cmd, void *arg)
+{
+	if (!fs453_client)
+		return -ENODEV;
+
+	return fs453_command(fs453_client, cmd, arg);
+}
+
+/*!
+ * @brief Probe for the TV enocder and initialize the driver
+ * @return    0 on success, others on failure
+ */
+static int __init fs453_init(void)
+{
+	int err;
+
+	pr_info("FS453/4 driver, (c) 2005 Freescale Semiconductor, Inc.\n");
+
+	if ((err = i2c_add_driver(&fs453_driver))) {
+		pr_info("FS453: driver registration failed\n");
+		return err;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Module exit routine
+ */
+static void __exit fs453_exit(void)
+{
+	i2c_del_driver(&fs453_driver);
+}
+
+module_init(fs453_init);
+module_exit(fs453_exit);
+
+EXPORT_SYMBOL(fs453_ioctl);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("FS453/4 TV encoder driver");
+MODULE_LICENSE("GPL");
--- linux-2.6.19.2/drivers/video/mxc/fs453.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/fs453.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,134 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+ /*!
+  * @file fs453.h
+  * @brief Driver for FS453/4 TV encoder
+  *
+  * @ingroup Framebuffer
+  */
+
+#ifndef __FS453_H__
+#define __FS453_H__
+
+/* I2C address of the FS453 chip */
+
+#define I2C1_BUS	0
+#define FS453_I2C_ADDR	0x6A
+
+/*!
+ *
+ * FS453 register file
+ *
+ */
+#define FS453_IHO		0x00	/*! Input Horizontal Offset */
+#define FS453_IVO		0x02	/*! Input Vertical Offset */
+#define FS453_IHW		0x04	/*! Input Horizontal Width */
+#define FS453_VSC		0x06	/*! Vertical Scaling Coefficient */
+#define FS453_HSC		0x08	/*! Horizontal Scaling Coefficient */
+#define FS453_BYPASS		0x0A	/*! BYPASS */
+#define FS453_CR		0x0C	/*! Command Register */
+#define FS453_MISC		0x0E	/*! Miscellaneous Bits Register */
+#define FS453_NCON		0x10	/*! Numerator of NCO Word */
+#define FS453_NCOD		0x14	/*! Denominator of NCO Word */
+#define FS453_PLL_M_PUMP	0x18	/*! PLL M and Pump Control */
+#define FS453_PLL_N		0x1A	/*! PLL N */
+#define FS453_PLL_PDIV		0x1C	/*! PLL Post-Divider */
+#define FS453_SHP		0x24	/*! Sharpness Filter */
+#define FS453_FLK		0x26	/*! Filcker Filter Coefficient */
+#define FS453_GPIO		0x28	/*! General Purpose I/O, Output Enab */
+#define FS453_ID		0x32	/*! Part Identification Number */
+#define FS453_STATUS		0x34	/*! Status Port */
+#define FS453_FIFO_SP		0x36	/*! FIFO Status Port Fill/Underrun */
+#define FS453_FIFO_LAT		0x38	/*! FIFO Latency */
+#define FS453_CHR_FREQ		0x40	/*! Chroma Subcarrier Frequency */
+#define FS453_CHR_PHASE		0x44	/*! Chroma Phase */
+#define FS453_MISC_45		0x45	/*! Miscellaneous Bits Register 45 */
+#define FS453_MISC_46		0x46	/*! Miscellaneous Bits Register 46 */
+#define FS453_MISC_47		0x47	/*! Miscellaneous Bits Register 47 */
+#define FS453_HSYNC_WID		0x48	/*! HSync Width */
+#define FS453_BURST_WID		0x49	/*! Burst Width */
+#define FS453_BPORCH		0x4A	/*! Back Porch Width */
+#define FS453_CB_BURST		0x4B	/*! Cb Burst Amplitude */
+#define FS453_CR_BURST		0x4C	/*! Cr Burst Amplitude */
+#define FS453_MISC_4D		0x4D	/*! Miscellaneous Bits Register 4D */
+#define FS453_BLACK_LVL		0x4E	/*! Black Level */
+#define FS453_BLANK_LVL		0x50	/*! Blank Level */
+#define FS453_NUM_LINES		0x57	/*! Number of Lines */
+#define FS453_WHITE_LVL		0x5E	/*! White Level */
+#define FS453_CB_GAIN		0x60	/*! Cb Color Saturation */
+#define FS453_CR_GAIN		0x62	/*! Cr Color Saturation */
+#define FS453_TINT		0x65	/*! Tint */
+#define FS453_BR_WAY		0x69	/*! Width of Breezeway */
+#define FS453_FR_PORCH		0x6C	/*! Front Porch */
+#define FS453_NUM_PIXELS	0x71	/*! Total num. of luma/chroma Pixels */
+#define FS453_1ST_LINE		0x73	/*! First Video Line */
+#define FS453_MISC_74		0x74	/*! Miscellaneous Bits Register 74 */
+#define FS453_SYNC_LVL		0x75	/*! Sync Level */
+#define FS453_VBI_BL_LVL	0x7C	/*! VBI Blank Level */
+#define FS453_SOFT_RST		0x7E	/*! Encoder Soft Reset */
+#define FS453_ENC_VER		0x7F	/*! Encoder Version */
+#define FS453_WSS_CONFIG	0x80	/*! WSS Configuration Register */
+#define FS453_WSS_CLK		0x81	/*! WSS Clock */
+#define FS453_WSS_DATAF1	0x83	/*! WSS Data Field 1 */
+#define FS453_WSS_DATAF0	0x86	/*! WSS Data Field 0 */
+#define FS453_WSS_LNF1		0x89	/*! WSS Line Number Field 1 */
+#define FS453_WSS_LNF0		0x8A	/*! WSS Line Number Field 0 */
+#define FS453_WSS_LVL		0x8B	/*! WSS Level */
+#define FS453_MISC_8D		0x8D	/*! Miscellaneous Bits Register 8D */
+#define FS453_VID_CNTL0		0x92	/*! Video Control 0 */
+#define FS453_HD_FP_SYNC	0x94	/*! Horiz. Front Porch & HSync Width */
+#define FS453_HD_YOFF_BP	0x96	/*! HDTV Lum. Offset & Back Porch */
+#define FS453_SYNC_DL		0x98	/*! Sync Delay Value */
+#define FS453_LD_DET		0x9C	/*! DAC Load Detect */
+#define FS453_DAC_CNTL		0x9E	/*! DAC Control */
+#define FS453_PWR_MGNT		0xA0	/*! Power Management */
+#define FS453_RED_MTX		0xA2	/*! RGB to YCrCb Matrix Red Coeff. */
+#define FS453_GRN_MTX		0xA4	/*! RGB to YCrCb Matrix Green Coeff. */
+#define FS453_BLU_MTX		0xA6	/*! RGB to YCrCb Matrix Blue Coeff. */
+#define FS453_RED_SCL		0xA8	/*! RGB to YCrCb Scaling Red Coeff. */
+#define FS453_GRN_SCL		0xAA	/*! RGB to YCrCb Scaling Green Coeff. */
+#define FS453_BLU_SCL		0xAC	/*! RGB to YCrCb Scaling Blue Coeff. */
+#define FS453_CC_FIELD_1	0xAE	/*! Closed Caption Field 1 Data */
+#define FS453_CC_FIELD_2	0xB0	/*! Closed Caption Field 2 Data */
+#define FS453_CC_CONTROL	0xB2	/*! Closed Caption Control */
+#define FS453_CC_BLANK_VALUE	0xB4	/*! Closed Caption Blanking Value */
+#define FS453_CC_BLANK_SAMPLE	0xB6	/*! Closed Caption Blanking Sample */
+#define FS453_HACT_ST		0xB8	/*! HDTV Horizontal Active Start */
+#define FS453_HACT_WD		0xBA	/*! HDTV Horizontal Active Width */
+#define FS453_VACT_ST		0xBC	/*! HDTV Veritical Active Width */
+#define FS453_VACT_HT		0xBE	/*! HDTV Veritical Active Height */
+#define FS453_PR_PB_SCALING	0xC0	/*! Pr and Pb Relative Scaling */
+#define FS453_LUMA_BANDWIDTH	0xC2	/*! Luminance Frequency Response */
+#define FS453_QPR		0xC4	/*! Quick Program Register */
+
+/*! Command register bits */
+
+#define CR_GCC_CK_LVL		0x2000	/*! Graphics Controller switching lev */
+#define CR_P656_LVL		0x1000	/*! Pixel Port Output switching level */
+#define CR_P656_IN		0x0800	/*! Pixel Port In */
+#define CR_P656_OUT		0x0400	/*! Pixel Port Out */
+#define CR_CBAR_480P		0x0200	/*! 480P Color Bars */
+#define CR_PAL_NTSCIN		0x0100	/*! PAL or NTSC input */
+#define CR_SYNC_MS		0x0080	/*! Sync Master or Slave */
+#define CR_FIFO_CLR		0x0040	/*! FIFO Clear */
+#define CR_CACQ_CLR		0x0020	/*! CACQ Clear */
+#define CR_CDEC_BP		0x0010	/*! Chroma Decimator Bypass */
+#define CR_NCO_EN		0x0002	/*! Enable NCO Latch */
+#define CR_SRESET		0x0001	/*! Soft Reset */
+
+/*! Chip ID register bits */
+
+#define FS453_CHIP_ID		0xFE05	/*! Chip ID register expected value */
+
+#endif				/* __FS453_H__ */
--- linux-2.6.19.2/drivers/video/mxc/Kconfig	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/Kconfig	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,63 @@
+config FB_MXC
+	tristate "MXC Framebuffer support"
+	depends on FB && (MXC_IPU || ARCH_MX27)
+	select FB_CFB_FILLRECT
+	select FB_CFB_COPYAREA
+	select FB_CFB_IMAGEBLIT
+	default y
+	help
+	  This is a framebuffer device for the MXC LCD Controller.
+	  See <http://www.linux-fbdev.org/> for information on framebuffer
+	  devices.
+
+	  If you plan to use the LCD display with your MXC system, say
+	  Y here.
+
+config FB_MXC_SYNC_PANEL
+	depends on FB_MXC
+	tristate "Synchronous Panel Framebuffer"
+	default y
+
+config FB_MXC_TVOUT
+	bool "TV Out Encoder"
+	depends on FB_MXC_SYNC_PANEL
+	default n
+
+config FB_MXC_OVERLAY
+	bool "Framebuffer Overlay Plane"
+	depends on FB_MXC_SYNC_PANEL
+	default n
+
+config FB_MXC_ASYNC_PANEL
+	depends on FB_MXC
+	bool "Asynchronous Panels"
+	default n
+
+menu "Asynchronous Panel Type"
+	depends on FB_MXC_ASYNC_PANEL && FB_MXC
+
+config FB_MXC_EPSON_PANEL
+    depends on FB_MXC_ASYNC_PANEL
+	default n
+	bool "Epson 176x220 Panel"
+
+
+
+endmenu
+
+choice
+	prompt "Async Panel Interface Type"
+	depends on FB_MXC_ASYNC_PANEL && FB_MXC
+	default FB_MXC_ASYNC_PANEL_IFC_16_BIT
+
+config FB_MXC_ASYNC_PANEL_IFC_8_BIT
+	bool "8-bit Parallel Bus Interface"
+
+config FB_MXC_ASYNC_PANEL_IFC_16_BIT
+	bool "16-bit Parallel Bus Interface"
+
+config FB_MXC_ASYNC_PANEL_IFC_SERIAL
+	bool "Serial Bus Interface"
+
+endchoice
+
--- linux-2.6.19.2/drivers/video/mxc/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/Makefile	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,12 @@
+ifeq ($(CONFIG_ARCH_MX27),y)
+	obj-$(CONFIG_FB_MXC_TVOUT)              += fs453.o
+	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mx2fb.o mxcfb_modedb.o
+	obj-$(CONFIG_FB_MXC_EPSON_PANEL)        += mx2fb_epson.o
+else
+	obj-$(CONFIG_FB_MXC_TVOUT)              += fs453.o
+	obj-$(CONFIG_FB_MXC_SYNC_PANEL)         += mxcfb.o mxcfb_modedb.o
+	obj-$(CONFIG_FB_MXC_EPSON_PANEL)        += mxcfb_epson.o
+	obj-$(CONFIG_FB_MXC_EPSON_QVGA_PANEL)   += mxcfb_epson_qvga.o
+	obj-$(CONFIG_FB_MXC_TOSHIBA_QVGA_PANEL) += mxcfb_toshiba_qvga.o
+	obj-$(CONFIG_FB_MXC_SHARP_128_PANEL)    += mxcfb_sharp_128x128.o
+endif
--- linux-2.6.19.2/drivers/video/mxc/mx2fb.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/mx2fb.c	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,1214 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for MX27 ADS.
+ */
+
+/*!
+ * @file mx2fb.c
+ *
+ * @brief Frame buffer driver for MX27 ADS.
+ *
+ * @ingroup Framebuffer
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/init.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <asm/uaccess.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mxcfb.h>
+
+#include "mx2fb.h"
+
+#define MX2FB_TYPE_BG          0
+#define MX2FB_TYPE_GW          1
+
+extern void gpio_lcdc_active(void);
+extern void gpio_lcdc_inactive(void);
+extern void board_power_lcd(int on);
+
+static char *fb_mode = 0;
+static int fb_enabled = 0;
+static unsigned long default_bpp = 16;
+static unsigned char brightness = 255;
+
+/*!
+ * @brief Structure containing the MX2 specific framebuffer information.
+ */
+struct mx2fb_info {
+	int type;
+	char *id;
+	int registered;
+	int blank;
+	unsigned long pseudo_palette[16];
+};
+
+/* Framebuffer APIs */
+static int mx2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info);
+static int mx2fb_set_par(struct fb_info *info);
+static int mx2fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned transp,
+			   struct fb_info *info);
+static int mx2fb_pan_display(struct fb_var_screeninfo *var,
+			     struct fb_info *info);
+static int mx2fb_blank(int blank_mode, struct fb_info *info);
+static int mx2fb_ioctl(struct fb_info *info, unsigned int cmd,
+		       unsigned long arg);
+
+/* Driver entries */
+int __init mx2fb_init(void);
+void __exit mx2fb_exit(void);
+#ifndef MODULE
+static int __init mx2fb_setup(char *);
+#endif
+
+/* Internal functions */
+static int __init _init_fbinfo(struct fb_info *info,
+			       struct platform_device *pdev);
+static int __init _install_fb(struct fb_info *info,
+			      struct platform_device *pdev);
+static void __exit _uninstall_fb(struct fb_info *info);
+static int _map_video_memory(struct fb_info *info);
+static void _unmap_video_memory(struct fb_info *info);
+static void _set_fix(struct fb_info *info);
+static void _enable_lcdc(struct fb_info *info);
+static void _disable_lcdc(struct fb_info *info);
+static void _enable_graphic_window(struct fb_info *info);
+static void _disable_graphic_window(struct fb_info *info);
+static void _update_lcdc(struct fb_info *info);
+static void _set_brightness(unsigned char level);
+
+#ifdef CONFIG_PM
+static int mx2fb_suspend(struct platform_device *pdev, pm_message_t state);
+static int mx2fb_resume(struct platform_device *pdev);
+#else
+#define mx2fb_suspend	0
+#define mx2fb_resume	0
+#endif
+
+static int mx2fb_probe(struct platform_device *pdev);
+
+#ifdef CONFIG_FB_MXC_TVOUT
+#include <linux/video_encoder.h>
+/*
+ * FIXME: VGA mode is not defined by video_encoder.h
+ * while FS453 supports VGA output.
+ */
+#ifndef VIDEO_ENCODER_VGA
+#define VIDEO_ENCODER_VGA	32
+#endif
+
+#define MODE_PAL		"TV-PAL"
+#define MODE_NTSC		"TV-NTSC"
+#define MODE_VGA		"TV-VGA"
+
+extern int fs453_ioctl(unsigned int cmd, void *arg);
+#endif
+
+struct mx2fb_info mx2fbi_bg = {
+	.type = MX2FB_TYPE_BG,
+	.id = "DISP0 BG",
+	.registered = 0,
+};
+
+#ifdef CONFIG_FB_MXC_OVERLAY
+static struct mx2fb_info mx2fbi_gw = {
+	.type = MX2FB_TYPE_GW,
+	.id = "DISP0 FG",
+	.registered = 0,
+};
+#endif
+
+/*! Current graphic window information */
+static struct fb_gwinfo g_gwinfo = {
+	.enabled = 0,
+	.alpha_value = 255,
+	.ck_enabled = 0,
+	.ck_red = 0,
+	.ck_green = 0,
+	.ck_blue = 0,
+	.xpos = 0,
+	.ypos = 0,
+};
+
+/*!
+ * @brief Framebuffer information structures.
+ * There are up to 3 framebuffers: background, TVout, and graphic window.
+ * If graphic window is configured, it must be the last framebuffer.
+ */
+static struct fb_info mx2fb_info[] = {
+	{.par = &mx2fbi_bg},
+#ifdef CONFIG_FB_MXC_OVERLAY
+	{.par = &mx2fbi_gw},
+#endif
+};
+
+/*!
+ * @brief This structure contains pointers to the power management
+ * callback functions.
+ */
+static struct platform_driver mx2fb_driver = {
+	.driver = {
+		   .name = "mxc_sdc_fb",
+		   .owner = THIS_MODULE,
+		   .bus = &platform_bus_type,
+		   },
+	.probe = mx2fb_probe,
+	.suspend = mx2fb_suspend,
+	.resume = mx2fb_resume,
+};
+
+/*!
+ * @brief Framebuffer file operations
+ */
+static struct fb_ops mx2fb_ops = {
+	.owner = THIS_MODULE,
+	.fb_check_var = mx2fb_check_var,
+	.fb_set_par = mx2fb_set_par,
+	.fb_setcolreg = mx2fb_setcolreg,
+	.fb_blank = mx2fb_blank,
+	.fb_pan_display = mx2fb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	//.fb_cursor = soft_cursor,
+	.fb_ioctl = mx2fb_ioctl,
+};
+
+/*!
+ * @brief Validates a var passed in.
+ *
+ * @param var	Frame buffer variable screen structure
+ * @param info	Frame buffer structure that represents a single frame buffer
+ *
+ * @return	Negative errno on error, or zero on success.
+ *
+ * Checks to see if the hardware supports the state requested by var passed
+ * in. This function does not alter the hardware state! If the var passed in
+ * is slightly off by what the hardware can support then we alter the var
+ * PASSED in to what we can do. If the hardware doesn't support mode change
+ * a -EINVAL will be returned by the upper layers.
+ *
+ */
+static int mx2fb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	unsigned long htotal, vtotal;
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if (var->xoffset < 0)
+		var->xoffset = 0;
+
+	if (var->yoffset < 0)
+		var->yoffset = 0;
+
+	if (var->xoffset + info->var.xres > info->var.xres_virtual)
+		var->xoffset = info->var.xres_virtual - info->var.xres;
+
+	if (var->yoffset + info->var.yres > info->var.yres_virtual)
+		var->yoffset = info->var.yres_virtual - info->var.yres;
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&
+	    (var->bits_per_pixel != 16)) {
+		var->bits_per_pixel = default_bpp;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		var->red.length = 5;
+		var->red.offset = 11;
+		var->red.msb_right = 0;
+
+		var->green.length = 6;
+		var->green.offset = 5;
+		var->green.msb_right = 0;
+
+		var->blue.length = 5;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 24:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 32:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		var->transp.msb_right = 0;
+		break;
+	}
+
+	if (var->pixclock < 1000) {
+		htotal = var->xres + var->right_margin + var->hsync_len +
+		    var->left_margin;
+		vtotal = var->yres + var->lower_margin + var->vsync_len +
+		    var->upper_margin;
+		var->pixclock = (vtotal * htotal * 6UL) / 100UL;
+		var->pixclock = KHZ2PICOS(var->pixclock);
+		dev_dbg(info->device,
+			"pixclock set for 60Hz refresh = %u ps\n",
+			var->pixclock);
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+
+	/* Copy nonstd field to/from sync for fbset usage */
+	var->sync |= var->nonstd;
+	var->nonstd |= var->sync;
+
+	return 0;
+}
+
+/*!
+ * @brief Alters the hardware state.
+ *
+ * @param info	Frame buffer structure that represents a single frame buffer
+ *
+ * @return Zero on success others on failure
+ *
+ * Using the fb_var_screeninfo in fb_info we set the resolution of this
+ * particular framebuffer. This function alters the fb_fix_screeninfo stored
+ * in fb_info. It doesn't not alter var in fb_info since we are using that
+ * data. This means we depend on the data in var inside fb_info to be
+ * supported by the hardware. mx2fb_check_var is always called before
+ * mx2fb_set_par to ensure this.
+ */
+static int mx2fb_set_par(struct fb_info *info)
+{
+	unsigned long len;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	_set_fix(info);
+
+	len = info->var.yres_virtual * info->fix.line_length;
+	if (len > info->fix.smem_len) {
+		if (info->fix.smem_start)
+			_unmap_video_memory(info);
+
+		/* Memory allocation for framebuffer */
+		if (_map_video_memory(info)) {
+			dev_err(info->device, "Unable to allocate fb memory\n");
+			return -ENOMEM;
+		}
+	}
+
+	_update_lcdc(info);
+	if (info->fbops->fb_blank)
+		info->fbops->fb_blank(mx2fbi->blank, info);
+
+	return 0;
+}
+
+/*!
+ * @brief Sets a color register.
+ *
+ * @param regno		Which register in the CLUT we are programming
+ * @param red		The red value which can be up to 16 bits wide
+ * @param green		The green value which can be up to 16 bits wide
+ * @param blue		The blue value which can be up to 16 bits wide.
+ * @param transp	If supported the alpha value which can be up to
+ *                      16 bits wide.
+ * @param info		Frame buffer info structure
+ *
+ * @return		Negative errno on error, or zero on success.
+ *
+ * Set a single color register. The values supplied have a 16 bit magnitude
+ * which needs to be scaled in this function for the hardware. Things to take
+ * into consideration are how many color registers, if any, are supported with
+ * the current color visual. With truecolor mode no color palettes are
+ * supported. Here a psuedo palette is created which we store the value in
+ * pseudo_palette in struct fb_info. For pseudocolor mode we have a limited
+ * color palette.
+ */
+static int mx2fb_setcolreg(unsigned regno, unsigned red, unsigned green,
+			   unsigned blue, unsigned transp, struct fb_info *info)
+{
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (info->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (info->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = info->pseudo_palette;
+			u32 v;
+
+#define CNVT_TOHW(val,width) ((((val)<<(width))+0x7FFF-(val))>>16)
+			red = CNVT_TOHW(red, info->var.red.length);
+			green = CNVT_TOHW(green, info->var.green.length);
+			blue = CNVT_TOHW(blue, info->var.blue.length);
+			transp = CNVT_TOHW(transp, info->var.transp.length);
+#undef CNVT_TOHW
+
+			v = (red << info->var.red.offset) |
+			    (green << info->var.green.offset) |
+			    (blue << info->var.blue.offset) |
+			    (transp << info->var.transp.offset);
+
+			pal[regno] = v;
+			ret = 0;
+		}
+		break;
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*!
+ * @brief Pans the display.
+ *
+ * @param var	Frame buffer variable screen structure
+ * @param info	Frame buffer structure that represents a single frame buffer
+ *
+ * @return	Negative errno on error, or zero on success.
+ *
+ * Pan (or wrap, depending on the `vmode' field) the display using the
+ * 'xoffset' and 'yoffset' fields of the 'var' structure. If the values
+ * don't fit, return -EINVAL.
+ */
+static int mx2fb_pan_display(struct fb_var_screeninfo *var,
+			     struct fb_info *info)
+{
+	if ((info->var.xoffset == var->xoffset) &&
+	    (info->var.yoffset == var->yoffset)) {
+		return 0;	/* No change, do nothing */
+	}
+
+	if (var->xoffset < 0 || var->yoffset < 0
+	    || var->xoffset + info->var.xres > info->var.xres_virtual
+	    || var->yoffset + info->var.yres > info->var.yres_virtual)
+		return -EINVAL;
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+
+	_update_lcdc(info);
+
+	if (var->vmode & FB_VMODE_YWRAP) {
+		info->var.vmode |= FB_VMODE_YWRAP;
+	} else {
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Blanks the display.
+ *
+ * @param blank_mode	The blank mode we want.
+ * @param info		Frame buffer structure that represents a single frame buffer
+ *
+ * @return		Negative errno on error, or zero on success.
+ *
+ * Blank the screen if blank_mode != 0, else unblank. Return 0 if blanking
+ * succeeded, != 0 if un-/blanking failed.
+ * blank_mode == 2: suspend vsync
+ * blank_mode == 3: suspend hsync
+ * blank_mode == 4: powerdown
+ */
+static int mx2fb_blank(int blank_mode, struct fb_info *info)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	dev_dbg(info->device, "blank mode = %d\n", blank_mode);
+
+	mx2fbi->blank = blank_mode;
+
+	switch (blank_mode) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		_disable_lcdc(info);
+		break;
+	case FB_BLANK_UNBLANK:
+		_enable_lcdc(info);
+		break;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Ioctl function to support customized ioctl operations.
+ *
+ * @param info	Framebuffer structure that represents a single frame buffer
+ * @param cmd	The command number
+ * @param arg	Argument which depends on cmd
+ *
+ * @return	Negative errno on error, or zero on success.
+ */
+static int mx2fb_ioctl(struct fb_info *info, unsigned int cmd,
+		       unsigned long arg)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+	struct mx2fb_gbl_alpha ga;
+	struct mx2fb_color_key ck;
+	unsigned char level;
+
+	switch (cmd) {
+	case MX2FB_SET_GBL_ALPHA:
+		if (mx2fbi->type != MX2FB_TYPE_GW)
+			return -ENODEV;
+
+		if (!arg)
+			return -EINVAL;
+
+		/* set graphic window information */
+		if (copy_from_user((void *)&ga, (void *)arg, sizeof(ga)))
+			return -EFAULT;
+
+		g_gwinfo.alpha_value = ga.alpha;
+
+		if (g_gwinfo.enabled)
+			_enable_graphic_window(info);
+		else
+			_disable_graphic_window(info);
+		break;
+	case MX2FB_SET_CLR_KEY:
+		if (mx2fbi->type != MX2FB_TYPE_GW)
+			return -ENODEV;
+
+		if (!arg)
+			return -EINVAL;
+
+		/* set graphic window information */
+		if (copy_from_user((void *)&ck, (void *)arg, sizeof(ck)))
+			return -EFAULT;
+
+		g_gwinfo.ck_enabled = ck.enable;
+		g_gwinfo.ck_red = (ck.color_key & 0x003F0000) >> 16;
+		g_gwinfo.ck_green = (ck.color_key & 0x00003F00) >> 8;
+		g_gwinfo.ck_blue = ck.color_key & 0x0000003F;
+
+		if (g_gwinfo.enabled)
+			_enable_graphic_window(info);
+		else
+			_disable_graphic_window(info);
+		break;
+	case MX2FB_SET_BRIGHTNESS:
+		if (copy_from_user((void *)&level, (void *)arg, sizeof(level)))
+			return -EFAULT;
+		brightness = level;
+		_set_brightness(level);
+		break;
+	case FBIOGET_GWINFO:
+		if (mx2fbi->type != MX2FB_TYPE_GW)
+			return -ENODEV;
+
+		if (!arg)
+			return -EINVAL;
+
+		/* get graphic window information */
+		if (copy_to_user((void *)arg, (void *)&g_gwinfo,
+				 sizeof(g_gwinfo)))
+			return -EFAULT;
+		break;
+	case FBIOPUT_GWINFO:
+		if (mx2fbi->type != MX2FB_TYPE_GW)
+			return -ENODEV;
+
+		if (!arg)
+			return -EINVAL;
+
+		/* set graphic window information */
+		if (copy_from_user((void *)&g_gwinfo, (void *)arg,
+				   sizeof(g_gwinfo)))
+			return -EFAULT;
+
+		if (g_gwinfo.enabled)
+			_enable_graphic_window(info);
+		else
+			_disable_graphic_window(info);
+		break;
+#ifdef CONFIG_FB_MXC_TVOUT
+	case ENCODER_GET_CAPABILITIES:{
+			int ret;
+			struct video_encoder_capability cap;
+
+			if (mx2fbi->type != MX2FB_TYPE_BG)
+				return -ENODEV;
+
+			ret = fs453_ioctl(cmd, &cap);
+			if (ret)
+				return ret;
+
+			if (copy_to_user((void *)arg, &cap, sizeof(cap)))
+				return -EFAULT;
+			break;
+		}
+	case ENCODER_SET_NORM:{
+			int ret;
+			unsigned long mode;
+			char *smode;
+			struct fb_var_screeninfo var;
+
+			if (mx2fbi->type != MX2FB_TYPE_BG)
+				return -ENODEV;
+
+			if (copy_from_user(&mode, (void *)arg, sizeof(mode)))
+				return -EFAULT;
+			if ((ret = fs453_ioctl(cmd, &mode)))
+				return ret;
+
+			if (mode == VIDEO_ENCODER_PAL)
+				smode = MODE_PAL;
+			else if (mode == VIDEO_ENCODER_NTSC)
+				smode = MODE_NTSC;
+			else
+				smode = MODE_VGA;
+
+			var = info->var;
+			var.nonstd = 0;
+			ret = fb_find_mode(&var, info, smode, mxcfb_modedb,
+					   mxcfb_modedb_sz, NULL, default_bpp);
+			if ((ret != 1) && (ret != 2))	/* specified mode not found */
+				return -ENODEV;
+
+			info->var = var;
+			fb_mode = smode;
+			return mx2fb_set_par(info);
+		}
+	case ENCODER_SET_INPUT:
+	case ENCODER_SET_OUTPUT:
+	case ENCODER_ENABLE_OUTPUT:{
+			unsigned long varg;
+
+			if (mx2fbi->type != MX2FB_TYPE_BG)
+				return -ENODEV;
+
+			if (copy_from_user(&varg, (void *)arg, sizeof(varg)))
+				return -EFAULT;
+			return fs453_ioctl(cmd, &varg);
+		}
+#endif
+	default:
+		dev_dbg(info->device, "Unknown ioctl command (0x%08X)\n", cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param info	framebuffer information pointer
+ * @return	Negative errno on error, or zero on success.
+ */
+static void _set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	strncpy(fix->id, mx2fbi->id, strlen(mx2fbi->id));
+	fix->line_length = var->xres_virtual * var->bits_per_pixel / 8;
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+}
+
+/*!
+ * @brief Initialize framebuffer information structure.
+ *
+ * @param info	framebuffer information pointer
+ * @param pdev	pointer to struct device
+ * @return	Negative errno on error, or zero on success.
+ */
+static int __init _init_fbinfo(struct fb_info *info,
+			       struct platform_device *pdev)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	info->device = &pdev->dev;
+	info->var.activate = FB_ACTIVATE_NOW;
+	info->fbops = &mx2fb_ops;
+	info->flags = FBINFO_FLAG_DEFAULT;
+	info->pseudo_palette = &mx2fbi->pseudo_palette;
+
+	/* Allocate colormap */
+	fb_alloc_cmap(&info->cmap, 16, 0);
+
+	return 0;
+}
+
+/*!
+ * @brief Install framebuffer into the system.
+ *
+ * @param info	framebuffer information pointer
+ * @param pdev  pointer to struct device
+ * @return	Negative errno on error, or zero on success.
+ */
+static int __init _install_fb(struct fb_info *info,
+			      struct platform_device *pdev)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	if (_init_fbinfo(info, pdev))
+		return -EINVAL;
+
+	if (fb_mode == 0)
+		fb_mode = pdev->dev.platform_data;
+
+	if (!fb_find_mode(&info->var, info, fb_mode, mxcfb_modedb,
+			  mxcfb_modedb_sz, NULL, default_bpp)) {
+		fb_dealloc_cmap(&info->cmap);
+		return -EBUSY;
+	}
+
+	/* Default Y virtual size is 2x panel size */
+	/* info->var.yres_virtual = info->var.yres << 1; */
+
+	if (mx2fbi->type == MX2FB_TYPE_GW)
+		mx2fbi->blank = FB_BLANK_NORMAL;
+	else
+		mx2fbi->blank = FB_BLANK_UNBLANK;
+
+	if (mx2fb_set_par(info)) {
+		fb_dealloc_cmap(&info->cmap);
+		return -EINVAL;
+	}
+
+	if (register_framebuffer(info) < 0) {
+		_unmap_video_memory(info);
+		fb_dealloc_cmap(&info->cmap);
+		return -EINVAL;
+	}
+
+	mx2fbi->registered = 1;
+	dev_info(info->device, "fb%d: %s fb device registered successfully.\n",
+		 info->node, info->fix.id);
+
+	return 0;
+}
+
+/*!
+ * @brief Uninstall framebuffer from the system.
+ *
+ * @param info	framebuffer information pointer
+ */
+static void __exit _uninstall_fb(struct fb_info *info)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	if (!mx2fbi->registered)
+		return;
+
+	unregister_framebuffer(info);
+	_unmap_video_memory(info);
+	if (&info->cmap)
+		fb_dealloc_cmap(&info->cmap);
+
+	mx2fbi->registered = 0;
+}
+
+/*!
+ * @brief Allocate memory for framebuffer.
+ *
+ * @param info	framebuffer information pointer
+ * @return	Negative errno on error, or zero on success.
+ */
+static int _map_video_memory(struct fb_info *info)
+{
+	info->fix.smem_len = info->fix.line_length * info->var.yres_virtual;
+	info->screen_base = dma_alloc_coherent(0,
+					       info->fix.smem_len,
+					       (dma_addr_t *) & info->fix.
+					       smem_start,
+					       GFP_DMA | GFP_KERNEL);
+
+	if (info->screen_base == 0) {
+		dev_err(info->device, "Unable to allocate fb memory\n");
+		return -EBUSY;
+	}
+	dev_dbg(info->device, "Allocated fb @ paddr=0x%08X, size=%d.\n",
+		info->fix.smem_start, info->fix.smem_len);
+
+	info->screen_size = info->fix.smem_len;
+
+	/* Clear the screen */
+	memset((char *)info->screen_base, 0, info->fix.smem_len);
+
+	return 0;
+}
+
+/*!
+ * @brief Release memory for framebuffer.
+ * @param info	framebuffer information pointer
+ */
+static void _unmap_video_memory(struct fb_info *info)
+{
+	dma_free_coherent(0, info->fix.smem_len, info->screen_base,
+			  (dma_addr_t) info->fix.smem_start);
+
+	info->screen_base = 0;
+	info->fix.smem_start = 0;
+	info->fix.smem_len = 0;
+}
+
+/*!
+ * @brief Enable LCD controller.
+ * @param info	framebuffer information pointer
+ */
+static void _enable_lcdc(struct fb_info *info)
+{
+	static int first_enable = 1;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	/*
+	 * Graphic window can only be enabled while the HCLK to the LCDC
+	 * is disabled. Once enabled it can subsequently be disabled and
+	 * enabled without turning off the HCLK.
+	 * The graphic window is enabled and then disabled here. So next
+	 * time to enable graphic window the HCLK to LCDC does not need
+	 * to be disabled, and the flicker (due to disabling of HCLK to
+	 * LCDC) is avoided.
+	 */
+	if (first_enable) {
+		_enable_graphic_window(info);
+		_disable_graphic_window(info);
+		first_enable = 0;
+	}
+
+	if (mx2fbi->type == MX2FB_TYPE_GW)
+		_enable_graphic_window(info);
+	else if (!fb_enabled) {
+		mxc_clks_enable(LCDC_CLK);
+		gpio_lcdc_active();
+		board_power_lcd(1);
+		_set_brightness(brightness);
+		fb_enabled++;
+#ifdef CONFIG_FB_MXC_TVOUT
+		if (fb_mode) {
+			unsigned long mode = 0;
+
+			if (strcmp(fb_mode, MODE_VGA) == 0)
+				mode = VIDEO_ENCODER_VGA;
+			else if (strcmp(fb_mode, MODE_NTSC) == 0)
+				mode = VIDEO_ENCODER_NTSC;
+			else if (strcmp(fb_mode, MODE_PAL) == 0)
+				mode = VIDEO_ENCODER_PAL;
+			if (mode)
+				fs453_ioctl(ENCODER_SET_NORM, &mode);
+		}
+#endif
+	}
+}
+
+/*!
+ * @brief Disable LCD controller.
+ * @param info	framebuffer information pointer
+ */
+static void _disable_lcdc(struct fb_info *info)
+{
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	if (mx2fbi->type == MX2FB_TYPE_GW)
+		_disable_graphic_window(info);
+	else {
+		if (fb_enabled) {
+			gpio_lcdc_inactive();
+			board_power_lcd(0);
+			_set_brightness(0);
+			mxc_clks_disable(LCDC_CLK);
+			fb_enabled = 0;
+		}
+#ifdef CONFIG_FB_MXC_TVOUT
+		if (fb_mode) {
+			int enable = 0;
+
+			if ((strcmp(fb_mode, MODE_VGA) == 0)
+			    || (strcmp(fb_mode, MODE_NTSC) == 0)
+			    || (strcmp(fb_mode, MODE_PAL) == 0))
+				fs453_ioctl(ENCODER_ENABLE_OUTPUT, &enable);
+		}
+#endif
+	}
+}
+
+/*!
+ * @brief Enable graphic window.
+ * @param info	framebuffer information pointer
+ */
+static void _enable_graphic_window(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+
+	g_gwinfo.enabled = 1;
+
+	g_gwinfo.base = (var->yoffset * var->xres_virtual + var->xoffset);
+	g_gwinfo.base *= (var->bits_per_pixel) / 8;
+	g_gwinfo.base += info->fix.smem_start;
+
+	g_gwinfo.xres = var->xres;
+	g_gwinfo.yres = var->yres;
+	g_gwinfo.xres_virtual = var->xres_virtual;
+
+	mx2_gw_set(&g_gwinfo);
+}
+
+/*!
+ * @brief Disable graphic window.
+ * @param info	framebuffer information pointer
+ */
+static void _disable_graphic_window(struct fb_info *info)
+{
+	unsigned long i = 0;
+
+	g_gwinfo.enabled = 0;
+
+	/*
+	 * Set alpha value to zero and reduce gw size, otherwise the graphic
+	 * window will not be able to be enabled again.
+	 */
+	__raw_writel(__raw_readl(LCDC_REG(LCDC_LGWCR)) & 0x00FFFFFF,
+		     LCDC_REG(LCDC_LGWCR));
+	__raw_writel(((16 >> 4) << 20) + 16, LCDC_REG(LCDC_LGWSR));
+	while (i < 1000)
+		i++;
+
+	/* Now disable graphic window */
+	__raw_writel(__raw_readl(LCDC_REG(LCDC_LGWCR)) & ~0x00400000,
+		     LCDC_REG(LCDC_LGWCR));
+
+	dev_dbg(info->device, "Graphic window disabled.\n");
+}
+
+/*!
+ * @brief Setup graphic window properties.
+ * @param gwinfo	graphic window information pointer
+ */
+void mx2_gw_set(struct fb_gwinfo *gwinfo)
+{
+	int width, height, xpos, ypos;
+	int width_bg, height_bg;
+	unsigned long lgwcr = 0x00400000;	/* Graphic window control register */
+
+	if (!gwinfo->enabled) {
+		_disable_graphic_window(0);
+		return;
+	}
+
+	/* Graphic window start address register */
+	__raw_writel(gwinfo->base, LCDC_REG(LCDC_LGWSAR));
+
+	/*
+	 * The graphic window width, height, x position and y position
+	 * must be synced up width the background window, otherwise there
+	 * may be flickering.
+	 */
+	width_bg = (__raw_readl(LCDC_REG(LCDC_LSR)) & 0x03F00000) >> 16;
+	height_bg = __raw_readl(LCDC_REG(LCDC_LSR)) & 0x000003FF;
+
+	width = (gwinfo->xres > width_bg) ? width_bg : gwinfo->xres;
+	height = (gwinfo->yres > height_bg) ? height_bg : gwinfo->yres;
+
+	xpos = gwinfo->xpos;
+	ypos = gwinfo->ypos;
+
+	if (xpos + width > width_bg)
+		xpos = width_bg - width;
+	if (ypos + height > height_bg)
+		ypos = height_bg - height;
+
+	/* Graphic window size register */
+	__raw_writel(((width >> 4) << 20) + height, LCDC_REG(LCDC_LGWSR));
+
+	/* Graphic window virtual page width register */
+	__raw_writel(gwinfo->xres_virtual >> 1, LCDC_REG(LCDC_LGWVPWR));
+
+	/* Graphic window position register */
+	__raw_writel(((xpos & 0x000003FF) << 16) | (ypos & 0x000003FF),
+		     LCDC_REG(LCDC_LGWPR));
+
+	/* Graphic window panning offset register */
+	__raw_writel(0, LCDC_REG(LCDC_LGWPOR));
+
+	/* Graphic window DMA control register */
+	__raw_writel(0x00020010, LCDC_REG(LCDC_LGWDCR));
+
+	/* Graphic window control register */
+	lgwcr |= (gwinfo->alpha_value & 0x000000FF) << 24;
+	lgwcr |= gwinfo->ck_enabled ? 0x00800000 : 0;
+	lgwcr |= gwinfo->vs_reversed ? 0x00200000 : 0;
+
+	/*
+	 * Color keying value
+	 * Todo: assume always use RGB565
+	 */
+	lgwcr |= (gwinfo->ck_red & 0x0000003F) << 12;
+	lgwcr |= (gwinfo->ck_green & 0x0000003F) << 6;
+	lgwcr |= gwinfo->ck_blue & 0x0000003F;
+
+	__raw_writel(lgwcr, LCDC_REG(LCDC_LGWCR));
+
+	pr_debug("Graphic window enabled.\n");
+}
+
+/*!
+ * @brief Update LCDC registers
+ * @param info	framebuffer information pointer
+ */
+static void _update_lcdc(struct fb_info *info)
+{
+	unsigned long base;
+	unsigned long perclk3, pcd, pcr;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mx2fb_info *mx2fbi = (struct mx2fb_info *)info->par;
+
+	if (mx2fbi->type == MX2FB_TYPE_GW) {
+		_enable_graphic_window(info);
+		return;
+	}
+
+	base = (var->yoffset * var->xres_virtual + var->xoffset);
+	base *= (var->bits_per_pixel) / 8;
+	base += info->fix.smem_start;
+
+	/* Screen start address register */
+	__raw_writel(base, LCDC_REG(LCDC_LSSAR));
+
+	/* Size register */
+	dev_dbg(info->device, "xres = %d, yres = %d\n",
+		info->var.xres, info->var.yres);
+	__raw_writel(((info->var.xres >> 4) << 20) + info->var.yres,
+		     LCDC_REG(LCDC_LSR));
+
+	/* Virtual page width register */
+	__raw_writel(info->var.xres_virtual >> 1, LCDC_REG(LCDC_LVPWR));
+
+	/* To setup LCDC pixel clock */
+	mxc_set_clocks_div(LCDC_CLK, 1);
+
+	/* Calculate pixel clock divider, and round to the nearest integer */
+	perclk3 = mxc_get_clocks(PERCLK3);
+	pcd = (perclk3 * 10 / (PICOS2KHZ(var->pixclock) * 1000UL) + 5) / 10;
+	if (--pcd > 0x3F)
+		pcd = 0x3F;
+
+	/* Panel configuration register */
+	pcr = 0xFA008B80 | pcd;
+	pcr |= (var->sync & FB_SYNC_CLK_INVERT) ? 0x01000000 : 0;
+	pcr |= (var->sync & FB_SYNC_SHARP_MODE) ? 0x00000040 : 0;
+	pcr |= (var->sync & FB_SYNC_OE_ACT_HIGH) ? 0 : 0x00100000;
+	__raw_writel(pcr, LCDC_REG(LCDC_LPCR));
+
+	/* Horizontal and vertical configuration register */
+	__raw_writel(((var->hsync_len - 1) << 26)
+		     + ((var->right_margin - 1) << 8)
+		     + (var->left_margin - 3), LCDC_REG(LCDC_LHCR));
+	__raw_writel((var->vsync_len << 26)
+		     + (var->lower_margin << 8)
+		     + var->upper_margin, LCDC_REG(LCDC_LVCR));
+
+	/* Sharp configuration register */
+	__raw_writel(0x00120300, LCDC_REG(LCDC_LSCR));
+
+	/* Refresh mode control reigster */
+	__raw_writel(0x00000000, LCDC_REG(LCDC_LRMCR));
+
+	/* DMA control register */
+	__raw_writel(0x00020010, LCDC_REG(LCDC_LDCR));
+
+	/* PWM contrast control register */
+	_set_brightness(brightness);
+}
+
+/*!
+ * @brief Set LCD brightness
+ * @param level	brightness level
+ */
+static void _set_brightness(unsigned char level)
+{
+	/* Set LCDC PWM contract control register */
+	__raw_writel(0x00A90300 | level, LCDC_REG(LCDC_LPCCR));
+}
+
+#ifdef CONFIG_PM
+/*
+ * Power management hooks. Note that we won't be called from IRQ context,
+ * unlike the blank functions above, so we may sleep.
+ */
+
+/*!
+ * @brief Suspends the framebuffer and blanks the screen.
+ * Power management support
+ */
+static int mx2fb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	_disable_lcdc(&mx2fb_info[0]);
+
+	return 0;
+}
+
+/*!
+ * @brief Resumes the framebuffer and unblanks the screen.
+ * Power management support
+ */
+static int mx2fb_resume(struct platform_device *pdev)
+{
+	_enable_lcdc(&mx2fb_info[0]);
+
+	return 0;
+}
+
+#endif				/* CONFIG_PM */
+
+/*!
+ * @brief Probe routine for the framebuffer driver. It is called during the
+ *        driver binding process.
+ *
+ * @return Appropriate error code to the kernel common code
+ */
+static int mx2fb_probe(struct platform_device *pdev)
+{
+	int ret, i;
+
+	for (i = 0; i < sizeof(mx2fb_info) / sizeof(struct fb_info); i++) {
+		if ((ret = _install_fb(&mx2fb_info[i], pdev))) {
+			dev_err(&pdev->dev,
+				"Failed to register framebuffer %d\n", i);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+/*!
+ * @brief Initialization
+ */
+int __init mx2fb_init(void)
+{
+	/*
+	 * For kernel boot options (in 'video=xxxfb:<options>' format)
+	 */
+#ifndef MODULE
+	{
+		char *option;
+
+		if (fb_get_options("mxcfb", &option))
+			return -ENODEV;
+		mx2fb_setup(option);
+	}
+#endif
+	return platform_driver_register(&mx2fb_driver);
+}
+
+/*!
+ * @brief Cleanup
+ */
+void __exit mx2fb_exit(void)
+{
+	int i;
+
+	for (i = sizeof(mx2fb_info) / sizeof(struct fb_info); i > 0; i--)
+		_uninstall_fb(&mx2fb_info[i - 1]);
+
+	platform_driver_unregister(&mx2fb_driver);
+}
+
+#ifndef MODULE
+/*!
+ * @brief Setup
+ * Parse user specified options
+ * Example: video=mxcfb:240x320,bpp=16,Sharp-QVGA
+ */
+static int __init mx2fb_setup(char *options)
+{
+	char *opt;
+
+	if (!options || !*options)
+		return 0;
+
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+
+		if (!strncmp(opt, "bpp=", 4))
+			default_bpp = simple_strtoul(opt + 4, NULL, 0);
+		else
+			fb_mode = opt;
+	}
+
+	return 0;
+}
+#endif
+
+/* Modularization */
+module_init(mx2fb_init);
+module_exit(mx2fb_exit);
+
+EXPORT_SYMBOL(mx2_gw_set);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MX2 framebuffer driver");
+MODULE_LICENSE("GPL");
--- linux-2.6.19.2/drivers/video/mxc/mx2fb_epson.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/mx2fb_epson.c	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,2174 @@
+#error "please port this file to linux 2.6.18"
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!@example slcdctest.c test driver using EPSON L2F50032T00 serial mode */
+
+/**
+ * 
+ * @defgroup SLCDC 			SLCDC driver
+ **/
+/**@{*/
+/**
+ * @file   mx2fb_epson.c
+ * @brief   slcdc driver source code
+ *
+ * This is the basic release for SLCDC driver, which is to support EPSON 
+ * L2F50032T00 16bit seria mode5-6-5 and parallel mode. This driver acts as a 
+ * standard character device, which can be dinamically loaded.
+ * For example, you can refer to slcdctest.c file.
+ *
+ * Modification History:
+ * 15,Dec,2003 Karen Kang
+ *
+ * 21,Feb,2006 Vasanthan S
+ *
+ * @bug
+ **/
+
+#ifndef __KERNEL__
+#  define __KERNEL__
+#endif
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/version.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/poll.h>
+#include <linux/miscdevice.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ptrace.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/fb.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/pm.h>
+
+#include "../console/fbcon.h"
+#include "../../mxc/mempool/mempool.h"
+#include <linux/timer.h>
+
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>	/* get_user,copy_to_user */
+#include <asm/irq.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/irqs.h>
+#include <asm/arch/mx27.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+
+#include <linux/devfs_fs_kernel.h>
+
+#ifdef CONFIG_ARCH_MX2ADS
+#include <asm/arch/mx2.h>
+#endif
+
+#define MODULE_NAME "slcdc"
+
+#define DBMX_DEBUG 1
+#ifdef DBMX_DEBUG
+#define TRACE(fmt, args...) \
+	{ \
+		printk("\n %s:%d:%s:",__FILE__, __LINE__,__FUNCTION__); \
+		printk(fmt, ## args);\
+	}
+#else
+#define TRACE(fmt, args...)
+#endif
+
+#define FAILED(fmt, args...) \
+	{ \
+		printk("\n %s:%d:%s:",__FILE__, __LINE__,__FUNCTION__); \
+		printk(fmt, ## args);\
+	}
+
+#define INFO(fmt, args...) \
+	{ \
+		printk("\n"); \
+		printk(fmt, ## args);\
+	}
+
+/*@brief definition for SLCDC_LCD_TXCONFIG */
+#define SLCDC_IMG_8L	0x00020000
+
+/*@name SLCDC connection configuration
+ *@brief config macro for serial mode or parallel mode. SLCDC can operate in
+ *       serial or parallel mode. This macro reflects the hardware configuration
+ *       and is not a software configuration. 
+ */
+/**@{*/
+#define SLCDC_SERIAL_MODE
+/* #define SLCDC_PARALLE_MODE */
+/**@}*/
+
+/*@name SLCDC IO MUX configuration
+ *@brief configuration macro for the pin mux detail. This tells which pins are 
+ *       configured for SLCDC. For more information refer processor data sheet.
+ *       Most cases only one of the following macros should be enabled.
+ */
+/**@{*/
+#define SLCDC_MUX_SSI3_SLCDC2	/*!< 1. SLCDC is mux.ed with SSI3 */
+ //#define SLCDC_MUX_SD_SLCDC1  /*!< 2. SLCDC is mux.ed with SD2 */
+ //#define SLCDC_MUX_LCD_SLCDC1 /*!< 3. SLCDC is mux.ed with LCD */
+/**@}*/
+
+/*@brief configuration macro which tells whether the interrupt should be used
+ *        or not for SLCDC. SLCDC will provide an interrupt on a completed 
+ *        transfer, which can be used for refreshing the data.
+ */
+#define USING_INTERRUPT_SLCDC
+
+/**
+ *@name ioctl command macro definitions
+ *@brief definition for SLCDC ioctl cmd,these command definition is different 
+ *       for serial \nmode and paralel mode ,in this driver, we have not 
+ *       supported all these commands, \n please check the ioctl function for 
+ *       details.
+ **/
+/**@{*/
+/* definition for SLCDC cmd */
+/* same as Epson 10043 & 50052 */
+#ifdef SLCDC_SERIAL_MODE
+#define SLCDC_CMD_DISON			0xaf00	/*!< 1. display on */
+#define SLCDC_CMD_DISOFF		0xae00	/*!< 2. display off */
+#define SLCDC_CMD_DISNOR		0xa600	/*!< 3. normal display */
+#define SLCDC_CMD_DISINV		0xa700	/*!< 4. inverse display */
+#define SLCDC_CMD_DISCTL		0xca00	/*!< 5. display control */
+#define SLCDC_CMD_SLPIN			0x9500	/*!< 10.sleep in */
+#define SLCDC_CMD_SLPOUT		0x9400	/*!< 11.sleep out */
+#define SLCDC_CMD_SD_PSET		0x7500	/*!< 12.page address set */
+#define SLCDC_CMD_SD_CSET		0x1500	/*!< 14.column address set */
+
+#define SLCDC_CMD_DATCTL		0xbc	/*!< 16.data scan direction, etc. */
+#define SLCDC_CMD_RAMWR			0x5c00	/*!< 17.writing to memory */
+#define SLCDC_CMD_PTLIN			0xa800	/*!< 19.partial display in */
+#define SLCDC_CMD_PTLOUT		0xa900	/*!< 20.partial display out */
+
+/* value different from 10043 but same as 50052 */
+#define SLCDC_CMD_VOLCTR		0xc600	/*!< 25.Electronic volume control */
+
+/* commands not found in 10043 but in 50052*/
+#define SLCDC_CMD_GCP64			0xcb00	/*!< 6. 64 grayscale pulse positon set */
+#define SLCDC_CMD_GCP16			0xcc00	/*!< 7. 16 grayscale pulse positon set */
+#define SLCDC_CMD_GSSET			0xcd00	/*!< 8. grayscale set */
+#define SLCDC_CMD_RAMRD			0x5d00	/*!< 18.memory read */
+#define SLCDC_CMD_ASCSET		0xaa00	/*!< 21.area scroll set */
+#define SLCDC_CMD_SCSTART		0xab00	/*!< 22.scroll start set */
+#define SLCDC_CMD_EPCTIN		0x6100	/*!< 26.Power IC control for EVR */
+#define SLCDC_CMD_EPCTOUT		0x6200	/*!< 27.Power IC control for EVR */
+
+#else
+#define SLCDC_CMD_DISON			0xaf	/*!<1. display on */
+#define SLCDC_CMD_DISOFF		0xae	/*!<2. display off */
+#define SLCDC_CMD_DISNOR		0xa6	/*!<3. normal display */
+#define SLCDC_CMD_DISINV		0xa7	/*!<4. inverse display */
+#define SLCDC_CMD_DISCTL		0xca	/*!<5. display control */
+#define SLCDC_CMD_SLPIN			0x95	/*!<10.sleep in */
+#define SLCDC_CMD_SLPOUT		0x94	/*!<11.sleep out */
+#define SLCDC_CMD_SD_PSET		0x75	/*!<12.page address set */
+#define SLCDC_CMD_SD_CSET		0x15	/*!<14.column address set */
+
+#define SLCDC_CMD_DATCTL		0xbc	/*!<16.data scan direction, etc. */
+//#define SLCDC_CMD_DATCTL              0xbc00  /*!<16.data scan direction, etc.*/
+#define SLCDC_CMD_RAMWR			0x5c	/*!<17.writing to memory */
+#define SLCDC_CMD_PTLIN			0xa8	/*!<19.partial display in */
+#define SLCDC_CMD_PTLOUT		0xa9	/*!<20.partial display out */
+
+/* value different from 10043 but same as 50052 */
+#define SLCDC_CMD_VOLCTR		0xc6	/*!<25.Electronic volume control */
+
+/* commands not found in 10043 but in 50052*/
+#define SLCDC_CMD_GCP64			0xcb	/*!<6. 64 grayscale pulse positon set */
+#define SLCDC_CMD_GCP16			0xcc	/*!<7. 16 grayscale pulse positon set */
+#define SLCDC_CMD_GSSET			0xcd	/*!<8. grayscale set */
+#define SLCDC_CMD_RAMRD			0x5d	/*!<18.memory read */
+#define SLCDC_CMD_ASCSET		0xaa	/*!<21.area scroll set */
+#define SLCDC_CMD_SCSTART		0xab	/*!<22.scroll start set */
+#define SLCDC_CMD_EPCTIN		0x61	/*!<26.Power IC control for EVR */
+#define SLCDC_CMD_EPCTOUT		0x62	/*!<27.Power IC control for EVR */
+#endif
+
+/**@}*/
+
+#define SLCDC_IRQ	INT_SLCDC
+#define SLCDC_CMD_MEM_SIZE		4
+#define SLCDC_WIDTH				176
+#define SLCDC_HIGH				220
+#define SLCDC_BPP				16
+#define SLCDC_PIXEL_MEM_SIZE	(SLCDC_WIDTH*SLCDC_HIGH*SLCDC_BPP)/8
+#define SLCDC_MEM_SIZE  (SLCDC_WIDTH*SLCDC_HIGH)
+#define _SLCDC_DATA_SIZE_		(SLCDC_PIXEL_MEM_SIZE + 32)
+#define SLCDC_DATA_MEM_SIZE	\
+                    ((unsigned)(PAGE_ALIGN(_SLCDC_DATA_SIZE_ + PAGE_SIZE * 2)))
+
+//bit mask definition in STAT/CTRL register
+#define SLCDC_TRANSFER_BUSY		0x4
+#define SLCDC_TRANSFER_ERROR	0x10
+
+//<<<<<< Global Variable
+/*used for SLCDC data buffer */
+__attribute__ ((aligned(4)))
+u16 *g_slcdc_dbuffer_address;
+
+/* physical address for SLCDC data buffer*/
+__attribute__ ((aligned(4)))
+u16 *g_slcdc_dbuffer_phyaddress;
+
+/* used for SLCDC command buffer */
+__attribute__ ((aligned(4)))
+u16 *g_slcdc_cbuffer_address;
+
+/* physical address for SLCDC command buffer */
+__attribute__ ((aligned(4)))
+u16 *g_slcdc_cbuffer_phyaddress;
+
+static wait_queue_head_t slcdc_wait;
+static int slcdc_device_num;
+static int g_slcdc_status;
+
+static int slcdc_major;
+module_param(slcdc_major, int, 0444);
+MODULE_PARM_DESC(slcdc_major,
+		 "slcdc char device major number. If this number is"
+		 " set to zero, then automatic major number allocation will be done");
+
+static int slcdc_minor;
+module_param(slcdc_minor, int, 0444);
+MODULE_PARM_DESC(slcdc_minor, "slcdc char device minor number");
+
+#define SLCDC_OPEN_STATUS		0x0001
+#define SLCDC_SUSPEND_STATUS	0x0002
+
+#define SLCDC_MAJOR_NUM 10	/*!< SLCDC char dev default major number */
+#define SLCDC_MINOR_NUM 156	/*!< SLCDC char dev default minor number */
+
+#define FBCON_HAS_CFB4
+#define FBCON_HAS_CFB8
+#define FBCON_HAS_CFB16
+
+static struct cdev slcdc_dev;
+
+extern void gpio_slcdc_active(int type);
+extern void gpio_slcdc_inactive(int type);
+
+int slcdc_open(struct inode *inode, struct file *filp);
+int slcdc_release(struct inode *inode, struct file *filp);
+static int slcdc_ioctl(struct inode *inode, struct file *filp,
+		       u_int cmd, u_long arg);
+static int slcdc_mmap(struct file *filp, struct vm_area_struct *vma);
+static void __init _init_fbinfo(void);
+
+typedef struct {
+	u16 *screen_start_address;
+	u16 *v_screen_start_address;
+} slcdc_par_t;
+
+slcdc_par_t slcdc_par;
+
+struct file_operations g_slcdc_fops = {
+      open:slcdc_open,
+      release:slcdc_release,
+      ioctl:slcdc_ioctl,
+      mmap:slcdc_mmap,
+};
+
+//>>>>>> Global Variable
+
+#ifdef DBMX_DEBUG
+#define FUNC_START	TRACE(KERN_ERR"start of %s\n", __FUNCTION__);
+#define FUNC_END	TRACE(KERN_ERR"end of %s\n", __FUNCTION__);
+#else
+#define FUNC_START
+#define FUNC_END
+#endif
+
+#define RED		0xf00
+#define GREEN	0xf0
+#define BLUE	0x0f
+
+/**@brief Local LCD controller parameters*/
+struct slcdcfb_par {
+	u_char *screen_start_address;	/*!< Screen Start Address */
+	u_char *v_screen_start_address;	/*!< Virtul Screen Start Address */
+	unsigned long screen_memory_size;	/*!< Screen memory size */
+	unsigned int palette_size;	/*!<Palette size */
+	unsigned int max_xres;	/*!<Maximum x resolution */
+	unsigned int max_yres;	/*!<Maximum x resolution */
+	unsigned int xres;	/*!<X resolution */
+	unsigned int yres;	/*!<Y resolution */
+	unsigned int xres_virtual;	/*!<Vitual x resolution */
+	unsigned int yres_virtual;	/*!<Vitual y resolution */
+	unsigned int max_bpp;	/*!<Maximum bit per pixel */
+	unsigned int bits_per_pixel;	/*!<Bits per pixel */
+	unsigned int currcon;	/*!<Current console ID */
+	unsigned int visual;	/*!<Vitual color type */
+	unsigned int TFT:1;	/*!<TFT flag */
+	unsigned int color:1;	/*!<Color flag */
+	unsigned int sharp:1;	/*!< Sharp LCD flag */
+};
+
+/* Frame buffer device API */
+static int slcdcfb_set_var(struct fb_info *info);
+/* perform fb specific mmap */
+static int slcdcfb_mmap(struct fb_info *info, struct file *file,
+			struct vm_area_struct *vma);
+/* perform fb specific ioctl (optional) */
+static int slcdcfb_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info *info);
+static int slcdcfb_open(struct fb_info *info, int user);
+static int slcdcfb_release(struct fb_info *info, int user);
+
+static int _check_var(struct fb_var_screeninfo *var, struct fb_info *info);
+static int _decode_var(struct fb_info *info);
+static int slcdcfb_blank(int blank, struct fb_info *info);
+
+/*
+ *  Framebuffer file operations
+ */
+static struct fb_ops slcdcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = slcdcfb_open,
+	.fb_release = slcdcfb_release,
+	.fb_check_var = _check_var,
+	.fb_set_par = _decode_var,
+	.fb_blank = slcdcfb_blank,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_cursor = soft_cursor,
+	.fb_ioctl = slcdcfb_ioctl,
+	.fb_mmap = slcdcfb_mmap,
+};
+
+static struct display global_disp;	/* Initial (default) Display Settings */
+static struct fb_info slcdc_fb_info;
+static struct fb_var_screeninfo init_var;
+static struct slcdcfb_par current_par;
+static struct timer_list slcdc_timer;
+static int start_fb_timer_flag = 0;	//0 is stop, 1 is start
+
+#define MIN_XRES        64
+#define MIN_YRES        64
+#define LCD_MAX_BPP		SLCDC_BPP
+#define MAX_PIXEL_MEM_SIZE SLCDC_PIXEL_MEM_SIZE
+#define SLCDC_REFRESH_RATE (HZ / 100)
+
+#define SLCDC2_CLK_PC31 31	/* refer iMX27 Pin Mux details */
+#define SLCDC2_CS_PC30  30
+#define SLCDC2_RS_PC29  29
+#define SLCDC2_D0_PC28  28
+
+#define SLCDC1_CLK_PB5 5
+#define SLCDC1_CS_PB8  8
+#define SLCDC1_RS_PB7  7
+#define SLCDC1_D0_PB6  6
+
+#define SLCDC1_DAT0_PA6 6
+
+/* Fake monspecs to fill in fbinfo structure */
+static struct fb_monspecs monspecs __initdata = {
+	.hfmin = 30000,
+	.hfmax = 70000,
+	.vfmin = 50,
+	.vfmax = 65,
+	.dpms = 0		/* Generic */
+};
+
+void slcdc_delay(int num)
+{
+	udelay(num);
+}
+
+/**
+ *@brief slcdc gpio configure routine for serial mode
+ *
+ * Function Name: slcdc_gpio_serial
+ *
+ *
+ * Description:This routine will implement gpio configurations for serial mode 
+ *             both for\n LCDC mux and SDHC2 mux, you can use macro 
+ *             SLCDC_MUX_SSI3_SLCDC2 or SLCDC_MUX_SD_SLCDC1 \n to choose the 
+ *             right way according to your hardware configuration.
+ *
+ *
+ *@return		None
+ *
+ * Modification History:
+ * 	Dec,2003			Karen update for MX21 TO2 
+ *  Jun,2004			Shirley update for LCDC mux
+ *  Mar,2006            Update for MX27 mux 
+ **/
+
+void slcdc_gpio_serial(void)
+{
+#ifdef SLCDC_MUX_SSI3_SLCDC2
+	/* we have to set SLCDC2_CLK, SLCDC2_CS, SLCDC2_RS and SLCDC2_D0 */
+	//gpio_request_mux(MX27_PIN_SSI3_CLK,  GPIO_MUX_ALT); /* CLK */   
+	//gpio_request_mux(MX27_PIN_SSI3_TXDAT,GPIO_MUX_ALT); /* CS  */
+	//gpio_request_mux(MX27_PIN_SSI3_RXDAT,GPIO_MUX_ALT); /* RS  */
+	//gpio_request_mux(MX27_PIN_SSI3_FS,   GPIO_MUX_ALT); /* D0  */   
+	gpio_slcdc_active(0);
+
+#endif
+#ifdef SLCDC_MUX_SD_SLCDC1
+	//gpio_request_mux(MX27_PIN_SD2_D1, GPIO_MUX_GPIO); /* CLK */
+	//gpio_request_mux(MX27_PIN_SD2_D2, GPIO_MUX_GPIO); /* D0  */
+	//gpio_request_mux(MX27_PIN_SD2_D3, GPIO_MUX_GPIO); /* RS  */
+	//gpio_request_mux(MX27_PIN_SD2_CMD,GPIO_MUX_GPIO); /* CS  */ 
+	gpio_slcdc_active(1);
+
+#endif
+}
+
+/**
+ *@brief slcdc gpio configure routine for parallel mode
+ *
+ * Function Name: slcdc_gpio_paralle
+ *
+ *
+ * Description:This routine will implement gpio configurations for parralel 
+ *             mode both for\n LCDC mux and SDHC2 mux, you can use macro 
+ *             SLCDC_MUX_SSI3_SLCDC2 or SLCDC_MUX_SD_SLCDC1 \n to choose the 
+ *             right way according to your hardware configuration.
+ *
+ *
+ *@return		None
+ *
+ * Modification History:
+ *  Jun,2004			Shirley update for LCDC mux
+ *  Mar,2006            Update for MX27 mux 
+ **/
+#ifndef SLCDC_MUX_SSI3_SLCDC2
+void slcdc_gpio_paralle(void)
+{
+#ifdef SLCDC_MUX_LCD_SLCDC1
+	/* Make sure the actual hardware connection is based on this, if other port
+	   is used then the following code has to be modified accordingly. 
+	   For further details refer Pin Mux details in iMX27 Spec. */
+	/* gpio_request_mux(MX27_PIN_LD0,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD1,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD2,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD3,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD4,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD5,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD6,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD7,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD8,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD9,  GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD10, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD11, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD12, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD13, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD14, GPIO_MUX_GPIO);
+	   gpio_request_mux(MX27_PIN_LD15, GPIO_MUX_GPIO);
+	 */
+	gpio_slcdc_active(2);
+
+#endif
+}
+#endif
+
+void slcdc_reset(int level)
+{
+	if (level == 0) {
+#if 0
+#ifdef SLCDC_MUX_SSI3_SLCDC2
+		/* OE_ACD as a reset pin */
+		_reg_GPIO_GIUS(GPIOA) |= 0x80000000;
+		_reg_GPIO_OCR2(GPIOA) |= 0xc0000000;
+		_reg_GPIO_DDIR(GPIOA) |= 0x80000000;
+
+		/* set reset pin to low */
+		_reg_GPIO_DR(GPIOA) &= 0x7fffffff;
+#endif
+#ifdef SLCDC_MUX_SD_SLCDC1
+		/* SD2_D1 as reset pin */
+		_reg_GPIO_GIUS(GPIOB) |= 0x00000020;
+		_reg_GPIO_OCR1(GPIOB) |= 0x00000c00;
+		_reg_GPIO_DDIR(GPIOB) |= 0x00000020;
+
+		/* set reset pin to low */
+		_reg_GPIO_DR(GPIOB) &= 0xffffffdf;
+#endif
+	} else {
+#ifdef SLCDC_MUX_SSI3_SLCDC2
+		/* set reset pin to high */
+		_reg_GPIO_DR(GPIOA) |= 0x80000000;
+#endif
+#ifdef SLCDC_MUX_SD_SLCDC1
+		/* set reset pin to high */
+		_reg_GPIO_DR(GPIOB) |= 0x00000020;
+#endif
+#endif
+	}
+
+}
+
+/**
+ *@brief slcdc hardware initialization
+ *
+ * Function Name: slcdc_init_dev
+ *
+ * Description  : This routine will enable the SLCDC and the clock for it
+ *             
+ **/
+void slcdc_init_dev(void)
+{
+	volatile unsigned long reg;
+
+	reg = __raw_readl(IO_ADDRESS(MAX_BASE_ADDR + 0x100 * 3 + 0x10));
+	reg = reg | 0x00040000;
+	__raw_writel(reg, IO_ADDRESS(MAX_BASE_ADDR + 0x100 * 3 + 0x10));
+
+	reg = __raw_readl(IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x58));	/* _reg_SYS_PCSR */
+	reg = reg | 0x00000004;	/* set LCD/SLCD bus master high priority */
+	__raw_writel(reg, IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x58));
+
+	/* enable the slcd clk */
+	reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR + 0x20));	/* _reg_CRM_PCCR0 */
+	reg |= 0x02200000;
+	__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR + 0x20));
+}
+
+/**
+ *@brief slcdc register initialization
+ *
+ * Function Name: slcdc_init_reg
+ *
+ * Description:This routine will setup the SLCDC register for first time 
+ *             
+ **/
+void slcdc_init_reg(void)
+{
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x04));	/* _reg_SLCDC_DBUF_SIZE */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x08));	/* _reg_SLCDC_CBADDR */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x0C));	/* _reg_SLCDC_CBUF_SIZE */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x10));	/* _reg_SLCDC_CBUF_SSIZE */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x14));	/* _reg_SLCDC_FIFO_CONFIG */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x18));	/* _reg_SLCDC_LCD_CONFIG */
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x1C));
+						     /*_reg_SLCDC_LCD_TXCONFIG*/
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	__raw_writel(0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x24));
+						    /*_reg_SLCDC_LCD_CLKCONFIG*/
+}
+
+/**
+ *@brief slcdc initial configuration
+ *
+ * Function Name: slcdc_config
+ *
+ * Description:This routine will fist time configuration like buffer address
+ *             FIFO configuration etc. 
+ *             
+ **/
+void slcdc_config(int datlen)
+{
+	u32 xfrmode, sckpol, worddefcom, imgend = 0, worddefwrite =
+	    0, worddefdat = 0;
+	volatile unsigned long reg;
+
+	if (datlen == 8) {
+		imgend = 0x2;	/*8-bit little endian; */
+		worddefdat = 0;	/* 8-bit data */
+		worddefwrite = 10;
+	} else if (datlen == 16) {
+		imgend = 0x1;	/* 16-bit little endian; */
+		worddefdat = 1;	/* 16-bit data */
+		worddefwrite = 1;
+	} else {
+		FAILED(":invaild parameter, 8 or 16 is the value required");
+	}
+	worddefcom = 1;
+#ifdef SLCDC_SERIAL_MODE
+	xfrmode = 0;		/* serial mode */
+#else
+	xfrmode = 1;		/* paralle mode */
+#endif
+	sckpol = 1;		/* falling edge */
+	/* config to be little endian serial 16bit */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x1C));
+						       /*_reg_SLCDC_LCD_TXCONFIG*/
+	reg =
+	    (imgend << 16) | (worddefdat << 4) | (worddefcom << 3) | (xfrmode <<
+								      2) |
+	    (sckpol);
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x1C));
+
+	/* printk("SLCDC_TXCONFIG = %x \n",_reg_SLCDC_LCD_TXCONFIG); */
+	/* config dma setting */
+	__raw_writel(5, IO_ADDRESS(SLCDC_BASE_ADDR + 0x14));	/* _reg_SLCDC_FIFO_CONFIG,
+								   burst length is 4 32-bit words */
+	/* config buffer address setting */
+	__raw_writel((u32) (slcdc_par.screen_start_address), IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+	__raw_writel((u32) g_slcdc_cbuffer_phyaddress, IO_ADDRESS(SLCDC_BASE_ADDR + 0x08));	/* _reg_SLCDC_CBADDR */
+
+	/* config clk setting */
+	__raw_writel((u32) 0x3, IO_ADDRESS(SLCDC_BASE_ADDR + 0x24));
+						   /*_reg_SLCDC_LCD_CLKCONFIG*/
+	/* set GO 0 */
+	__raw_writel((u32) 0x0, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						   /*_reg_SLCDC_LCD_CTRL_STAT*/
+
+	slcdc_delay(5000);
+
+}
+
+/**
+ *@brief slcdc send command routine 
+ *
+ * Function Name: slcdc_send_cmd
+ *
+ * Description:This help routine sends command to the SLCD from SLCDC
+ *             
+ *@return		0 on success, any other value otherwise
+ **/
+/* for command transfer, it is very short, will not use interrupt */
+int slcdc_send_cmd(u32 length)
+{
+	u32 status;
+	volatile unsigned long reg;
+
+	/* disable interrupt */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+					       /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg = reg & 0xffffff7f;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* set length */
+	__raw_writel(length, IO_ADDRESS(SLCDC_BASE_ADDR + 0x04));	/* _reg_SLCDC_DBUF_SIZE */
+
+	/* set automode 00 for command */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+	reg = reg & 0x000001ff;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* set GO */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+	reg |= 0x1;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* polling for data transfer finish */
+
+	status = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+	while ((!(status & SLCDC_TRANSFER_ERROR))
+	       && (status & SLCDC_TRANSFER_BUSY)) {
+		status = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+	}
+
+	if (status & SLCDC_TRANSFER_ERROR) {
+		TRACE("send cmd error status=0x%x \n", status);
+		return 1;
+	} else {
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+		reg |= 0x40;
+		__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));	/* _reg_SLCDC_LCD_CTRL_STAT */
+		reg |= 0x20;
+		__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+		return 0;
+	}
+}
+
+/**
+ *@brief slcdc send data routine 
+ *
+ * Function Name: slcdc_send_data
+ *
+ * Description: This help routine sends data to the SLCD from SLCDC
+ *             
+ *@return		0 on success, any other value otherwise
+ **/
+void slcdc_send_data(u32 length)
+{
+	volatile unsigned long reg;
+
+	/* enable interrupt */
+#ifdef USING_INTERRUPT_SLCDC
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= ~0xffffff7f;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+#endif
+	/* set length */
+	__raw_writel(length, IO_ADDRESS(SLCDC_BASE_ADDR + 0x04));	/* _reg_SLCDC_DBUF_SIZE */
+	/* set automode 01 for data */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x00000800;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* set GO  */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x1;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+#ifdef USING_INTERRUPT_SLCDC
+	interruptible_sleep_on(&slcdc_wait);
+#else
+	do {
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	} while ((reg & 0x00000004) != 0);
+
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x40;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x20;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+#endif
+	return;
+
+}
+
+/**
+ *@brief slcdc isr 
+ *
+ * Function Name: slcdc_isr
+ *
+ * Description: This ISR routine takes interrupt from SLCDC and does refresh of
+ *              display data if necessary
+ *             
+ *@return		0 on success, any other value otherwise
+ **/
+static irqreturn_t slcdc_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	volatile u32 reg;
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+
+	/* clear interrupt */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x40;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	wake_up_interruptible(&slcdc_wait);
+
+	if (start_fb_timer_flag == 1) {
+		/*        while((_reg_SLCDC_LCD_CTRL_STAT &0x00000004)!=0);        */
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+		reg |= 0x40;
+		__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+		reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+		reg |= 0x20;
+		__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+		mod_timer(&slcdc_timer, jiffies + SLCDC_REFRESH_RATE);
+		TRACE("slcdc_isr\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ *@brief slcdc buffer initialization
+ *
+ * Function Name: slcdc_init_buffer
+ *
+ *
+ * Description:This routine will allocate physical memory for SLCDC data and 
+ *             for SLCDC command. 
+ *             
+ *@return		0 on success, appropriate error value on error
+ **/
+int slcdc_init_buffer(void)
+{
+
+	TRACE("slcdc data buffer size = %x \n",
+	      (unsigned int)SLCDC_DATA_MEM_SIZE);
+
+	if (g_slcdc_dbuffer_phyaddress != NULL)
+		return -EINVAL;
+
+	if (g_slcdc_cbuffer_phyaddress != NULL)
+		return -EINVAL;
+
+	g_slcdc_dbuffer_phyaddress = (u16 *) mxc_malloc(SLCDC_DATA_MEM_SIZE);
+	g_slcdc_cbuffer_phyaddress = (u16 *) mxc_malloc(SLCDC_CMD_MEM_SIZE);
+
+	if (!g_slcdc_dbuffer_phyaddress || !g_slcdc_cbuffer_phyaddress) {
+		if (g_slcdc_dbuffer_phyaddress != (u16 *) 0)
+			mxc_free((u32) g_slcdc_dbuffer_phyaddress);
+
+		if (g_slcdc_cbuffer_phyaddress != (u16 *) 0)
+			mxc_free((u32) g_slcdc_cbuffer_phyaddress);
+
+		FAILED("can not allocated memory\n");
+		return -ENOMEM;
+	} else {
+
+		TRACE
+		    ("allocated cmd_buffer=0x%x size=%d, data_buffer=0x%x size=%d",
+		     (int)g_slcdc_cbuffer_phyaddress, SLCDC_CMD_MEM_SIZE,
+		     (int)g_slcdc_dbuffer_phyaddress, SLCDC_DATA_MEM_SIZE);
+
+		if ((!request_mem_region((u32) g_slcdc_dbuffer_phyaddress,
+					 SLCDC_DATA_MEM_SIZE,
+					 slcdc_fb_info.fix.id))
+		    ||
+		    (!request_mem_region
+		     ((u32) g_slcdc_cbuffer_phyaddress, SLCDC_CMD_MEM_SIZE,
+		      slcdc_fb_info.fix.id))) {
+			FAILED("request mem region failed.");
+			return -EBUSY;
+		}
+
+		if (!(slcdc_fb_info.screen_base = ioremap((u32)
+							  g_slcdc_dbuffer_phyaddress,
+							  SLCDC_DATA_MEM_SIZE)))
+		{
+			release_mem_region((u32) g_slcdc_dbuffer_phyaddress,
+					   SLCDC_DATA_MEM_SIZE);
+			FAILED("Unable to map fb memory to virtual address");
+			return -EIO;
+		} else {
+			g_slcdc_dbuffer_address =
+			    (u16 *) slcdc_fb_info.screen_base;
+		}
+
+		if (!
+		    (g_slcdc_cbuffer_address =
+		     ioremap((u32) g_slcdc_cbuffer_phyaddress,
+			     SLCDC_CMD_MEM_SIZE))) {
+			release_mem_region((u32) g_slcdc_dbuffer_phyaddress,
+					   SLCDC_DATA_MEM_SIZE);
+			release_mem_region((u32) g_slcdc_cbuffer_phyaddress,
+					   SLCDC_CMD_MEM_SIZE);
+			FAILED("Unable to map fb memory to virtual address");
+			return -EIO;
+		}
+	}
+
+	TRACE("slcdc data buffer address = %x cmd buffer address= %x \n",
+	      (unsigned int)slcdc_par.screen_start_address,
+	      (unsigned int)g_slcdc_cbuffer_address);
+
+	return 0;
+}
+
+/**
+ *@brief slcdc buffer de initialization
+ *
+ * Function Name: slcdc_free_buffer
+ *
+ *
+ * Description:This routine will deallocate the physical memory allocated by 
+ *             slcdc_init_buffer. 
+ *             
+ *@return		0 on success
+ **/
+int slcdc_free_buffer(void)
+{
+
+	FUNC_START;
+
+	iounmap(g_slcdc_dbuffer_address);
+	iounmap(g_slcdc_cbuffer_address);
+
+	release_mem_region((unsigned long)g_slcdc_dbuffer_phyaddress,
+			   SLCDC_DATA_MEM_SIZE);
+	release_mem_region((unsigned long)g_slcdc_cbuffer_phyaddress,
+			   SLCDC_CMD_MEM_SIZE);
+
+	mxc_free((u32) g_slcdc_dbuffer_phyaddress);
+	mxc_free((u32) g_slcdc_cbuffer_phyaddress);
+
+	FUNC_END;
+	return 0;
+}
+
+/**
+ *@brief slcdc mmap function
+ *
+ * Function Name: slcdc_mmap
+ *
+ *
+ * Description: This is the memory map routine for this driver,will setup the
+ *              memory map used in this driver.
+ *
+ *@param	filp	the pointer to the file descripter
+ *@param	vma		the pointer to the vma structure related to the driver
+ *
+ *@return	int   return status
+ *			@li 0  sucessful
+ *			@li other failed
+ * Modification History:
+ * 	Dec,2003,			Karen first version
+ *   
+ **/
+
+static int slcdc_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	unsigned long page, pos;
+	unsigned long start = (unsigned long)vma->vm_start;
+	unsigned long size = (unsigned long)(vma->vm_end - vma->vm_start);
+
+	if (size > SLCDC_DATA_MEM_SIZE)
+		return -EINVAL;
+
+	TRACE("slcdc_mmap is called 1\n");
+	pos = (unsigned long)slcdc_par.v_screen_start_address;
+
+	while (size > 0) {
+		page = virt_to_phys((void *)pos);
+
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+		/* This is an IO map - tell maydump to skip this VMA  */
+		vma->vm_flags |= VM_IO;
+
+		if (remap_pfn_range
+		    (vma, start, page >> PAGE_SHIFT, PAGE_SIZE, PAGE_SHARED))
+			return -EAGAIN;
+		start += PAGE_SIZE;
+		pos += PAGE_SIZE;
+		size -= PAGE_SIZE;
+	}
+
+	return 0;
+}
+
+/**
+ *@brief slcdc mmap function called from framebuffer
+ *
+ * Function Name: slcdcfb_mmap
+ *
+ *
+ * Description: This is the memory map routine for this driver,will setup the
+ *              memory map used in this driver. 
+ *             
+ *@return		0 on success any other value for failure
+ **/
+static int slcdcfb_mmap(struct fb_info *info, struct file *file,
+			struct vm_area_struct *vma)
+{
+
+	return slcdc_mmap(file, vma);
+
+}
+
+/**
+ *@brief slcdc display-on function
+ *
+ * Function Name: slcdc_display_on
+ *
+ * Description:This helper routine will send the command to the SLCD for display
+ *             on. 
+ *             
+ **/
+void slcdc_display_on(void)
+{
+	u16 *databuffer = NULL;
+
+	__raw_writel((u32) g_slcdc_cbuffer_phyaddress,
+		     IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));
+
+	/* put cmd into cmd buffer */
+	databuffer = g_slcdc_cbuffer_address;
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_DISON;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	/* delay */
+	slcdc_delay(0xffff);
+	/* send cmd */
+	slcdc_send_cmd(1);
+	/* delay  */
+	slcdc_delay(0xffff);
+}
+
+/**
+ *@brief slcdc display-off function
+ *
+ * Function Name: slcdc_display_off
+ *
+ * Description:This helper routine will send the command to the SLCD for display
+ *             off. 
+ *             
+ **/
+void slcdc_display_off(void)
+{
+	u16 *databuffer = NULL;
+	/* Cause LCD module to enter sleep mode.Bu sure to input display OFF command 
+	   to turn off the display before inputting the SLPIN command
+	   Keep the logic power supply turned on for 40ms after the LCD module 
+	   enters the sleep mode.  */
+	/* put cmd into cmd buffer */
+	databuffer = slcdc_par.v_screen_start_address;
+	/* send cmd SLPIN */
+	*databuffer = SLCDC_CMD_SLPIN;
+	slcdc_send_cmd(1);
+	/* put reset high */
+
+#if 0
+#ifdef SLCDC_MUX_SSI3_SLCDC2
+	/* set reset pin to high */
+	_reg_GPIO_DR(GPIOA) |= 0x80000000;
+#endif
+#ifdef SLCDC_MUX_SD_SLCDC1
+	/* set reset pin to high */
+	_reg_GPIO_DR(GPIOB) |= 0x00000020;
+#endif
+#endif
+
+	/* delay      for 50ms */
+	slcdc_delay(0xffff);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_DISOFF;
+	/* send cmd DISOFF */
+	slcdc_send_cmd(1);
+	TRACE("disoff \n");
+	slcdc_delay(0xffff);
+}
+
+/**
+ *@brief slcdc display-off function
+ *
+ * Function Name: slcdc_display_normal
+ *
+ * Description:This helper routine will send the command to the SLCD for display
+ *             normal. 
+ *             
+ **/
+void slcdc_display_normal(void)
+{
+	u16 *databuffer = NULL;
+	databuffer = slcdc_par.v_screen_start_address;
+	*databuffer = SLCDC_CMD_DISNOR;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	/* delay */
+	slcdc_delay(100);
+}
+
+/**
+ *@brief slcdc display sleep out function
+ *
+ * Function Name: slcdc_sleep_out
+ *
+ * Description:This helper routine will send the command to the SLCD for wakeup
+ *             from sleep. 
+ *             
+ **/
+void slcdc_sleep_out(void)
+{
+	u16 *databuffer = NULL;
+	databuffer = slcdc_par.v_screen_start_address;
+	*databuffer = SLCDC_CMD_SLPOUT;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	/* delay */
+	slcdc_delay(0xffff);
+}
+
+/** @brief sends control command to SLCD */
+void slcdc_display_ctl(void)
+{
+	int i;
+#ifdef SLCDC_SERIAL_MODE
+	u16 disctl[11] = { 0x1c00, 0x0200, 0x8200, 0x0000,
+		0x1e00, 0xe000, 0x0000, 0xdc00,
+		0x0000, 0x0200, 0x0000
+	};
+#else
+	u16 disctl[11] = { 0x1c, 0x02, 0x82, 0x00,
+		0x1e, 0xe0, 0x00, 0xdc,
+		0x00, 0x02, 0x00
+	};
+#endif
+	u16 *databuffer = NULL;
+	/* It make various display timing settings. */
+	databuffer = slcdc_par.v_screen_start_address;
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_DISCTL;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(2000);
+	/* put parameter into data buffer */
+	for (i = 0; i < 11; i++) {
+		*databuffer = disctl[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(11);
+
+}
+
+/**
+ *@brief slcd page set function
+ *
+ * Function Name: slcdc_page_set
+ *
+ * Description:This helper routine will send the command to the SLCD to set the
+ *             page inside video ram 
+ *             
+ **/
+void slcdc_page_set(void)
+{
+	/* It specify a page address area in order to access the display data
+	   RAM from the MPU. Be sure to set both starting and ending pages. */
+	int i;
+	u16 *databuffer = NULL;
+#ifdef SLCDC_SERIAL_MODE
+	u16 pset[4] = { 0x0000, 0x0000, 0xb100, 0x0000 };
+#else
+	u16 pset[4] = { 0x00, 0x00, 0xb1, 0x00 };
+#endif
+	databuffer = (u16 *) (slcdc_par.v_screen_start_address);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_SD_PSET;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(20000);
+
+	/* put parameter into data buffer */
+	for (i = 0; i < 4; i++) {
+		*databuffer = pset[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(4);
+
+	slcdc_delay(20000);
+}
+
+/**
+ *@brief slcd column set function
+ *
+ * Function Name: slcdc_col_set
+ *
+ * Description:This helper routine will send the command to the SLCD to set the
+ *             column inside video ram 
+ *             
+ **/
+void slcdc_col_set(void)
+{
+	/* It specify starting and ending collumns. */
+	int i;
+#ifdef SLCDC_SERIAL_MODE
+	u16 cset[4] = { 0x0200, 0x0000, 0xb100, 0x0000 };
+#else
+	u16 cset[4] = { 0x02, 0x00, 0xb1, 0x00 };
+#endif
+	u16 *databuffer = NULL;
+	databuffer = (u16 *) (slcdc_par.v_screen_start_address);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_SD_CSET;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(20000);
+	/* put parameter into data buffer */
+	for (i = 0; i < 4; i++) {
+		*databuffer = cset[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(4);
+	slcdc_delay(20000);
+
+}
+
+void slcdc_data_ctl(void)
+{
+	u8 *databuffer = NULL;
+	databuffer = (u8 *) (slcdc_par.v_screen_start_address);
+	*databuffer = SLCDC_CMD_DATCTL;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(20000);
+	*databuffer = 0x28;
+	/* send data */
+	slcdc_send_data(1);
+	slcdc_delay(20000);
+}
+
+void slcdc_volctl(void)
+{
+	u16 *databuffer = NULL;
+	databuffer = slcdc_par.v_screen_start_address;
+	*databuffer = SLCDC_CMD_VOLCTR;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(20000);
+#ifdef SLCDC_SERIAL_MODE
+	*databuffer = 0x9f00;
+#else
+	*databuffer = 0x9f;
+#endif
+	/* send data */
+	slcdc_send_data(1);
+	slcdc_delay(20000);
+}
+
+void slcdc_ascset(void)
+{
+	int i;
+#ifdef SLCDC_SERIAL_MODE
+	u16 lcd_para_ASCSET[7] = { 0x0000, 0x0000, 0x1f00, 0x0100,
+		0x1f00, 0x0100, 0x0300
+	};
+#else
+	u16 lcd_para_ASCSET[7] = { 0x00, 0x00, 0x1f, 0x01,
+		0x1f, 0x01, 0x03
+	};
+
+#endif
+	u16 *databuffer = NULL;
+	databuffer = (u16 *) (slcdc_par.v_screen_start_address);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_ASCSET;
+	/* put parameter into data buffer */
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(2000);
+	for (i = 0; i < 7; i++) {
+		*databuffer = lcd_para_ASCSET[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(7);
+	slcdc_delay(20000);
+}
+
+void slcdc_scstart(void)
+{
+	int i;
+	u16 lcd_para_SCSTART[2] = { 0x00, 0x00 };
+	u16 *databuffer = NULL;
+	databuffer = (u16 *) (slcdc_par.v_screen_start_address);
+	/* put cmd into cmd buffer */
+	*databuffer = SLCDC_CMD_SCSTART;
+	/* put parameter into data buffer */
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(10000);
+	for (i = 0; i < 2; i++) {
+		*databuffer = lcd_para_SCSTART[i];
+		databuffer++;
+	}
+	/* send data */
+	slcdc_send_data(2);
+	slcdc_delay(20000);
+
+}
+
+void slcdc_config_panel(void)
+{
+	int i;
+#if 1
+	/* set data format */
+	slcdc_config(8);
+	slcdc_delay(0xffff);
+	slcdc_reset(1);		/* pull reset signal high */
+
+	/* set data format */
+	slcdc_delay(20000);
+	slcdc_data_ctl();
+	slcdc_delay(1000);
+	slcdc_config(16);
+
+	/* sleep out */
+	slcdc_sleep_out();
+	slcdc_delay(20000);
+
+	for (i = 0; i < 8; i++) {
+		slcdc_volctl();
+		slcdc_delay(2000);
+	}
+	slcdc_delay(0xffff);
+	slcdc_delay(0xffff);
+	slcdc_delay(0xffff);
+
+	slcdc_display_on();
+	slcdc_delay(0xffff);
+	/* set col address */
+	slcdc_col_set();
+	/* set page address */
+	slcdc_page_set();
+	/* set area in screen to be used for scrolling */
+	slcdc_ascset();
+	slcdc_delay(20000);
+	/* set top scroll page within the scroll area */
+	slcdc_scstart();
+	mdelay(4);
+#endif
+#if 0
+
+	//set data format
+	slcdc_config(8);
+	slcdc_delay(0xffff);
+	slcdc_reset(1);		//pull reset signal high
+
+	//set data format
+	slcdc_delay(20000);
+	slcdc_data_ctl();
+	slcdc_delay(1000);
+	slcdc_config(16);
+	//sleep out
+	slcdc_sleep_out();
+	slcdc_delay(0xffff);
+	//set col address
+	slcdc_col_set();
+	//set page address
+	slcdc_page_set();
+	//set area in screen to be used for scrolling
+	slcdc_ascset();
+	slcdc_delay(20000);
+	//set top scroll page within the scroll area
+	slcdc_scstart();
+	slcdc_delay(0xffff);
+	//turn on slcd display
+	slcdc_display_on();
+	slcdc_delay(0xffff);
+	slcdc_delay(0xffff);
+
+	for (i = 0; i < 8; i++) {
+		slcdc_volctl();
+		slcdc_delay(2000);
+	}
+#endif
+}
+
+/**
+ *@brief slcdc ioctl routine
+ *
+ * Function Name: slcdc_ioctl
+ * Description:This routine will implement driver-specific functions
+ *
+ *@param 		inode	:	the pointer to driver-related inode.
+ *@param 		filp	:	the pointer to driver-related file structure.
+ *@param		cmd	:	the command number.
+ *@param		arg:	argument which depends on command.
+ *
+ *@return	int   return status
+ *			@li 0  sucess
+ *			@li 1  failure
+ *
+ * Modification History:
+ * 	Dec,2003			Karen first version for MX21 TO2 
+ *   
+ **/
+
+static int slcdc_ioctl(struct inode *inode, struct file *filp,
+		       u_int cmd, u_long arg)
+{
+	u16 *databuffer = NULL;
+
+	switch (cmd) {
+	case SLCDC_CMD_DISON:
+		slcdc_display_on();
+		break;
+
+	case SLCDC_CMD_DISOFF:
+		slcdc_display_off();
+		break;
+
+	case SLCDC_CMD_DISNOR:
+		slcdc_display_normal();
+		break;
+
+	case SLCDC_CMD_DISINV:
+		/* put cmd into cmd buffer */
+		databuffer = slcdc_par.v_screen_start_address;
+		*databuffer = SLCDC_CMD_DISINV;
+		/* send cmd */
+		slcdc_send_cmd(1);
+		slcdc_delay(100);
+		break;
+
+	case SLCDC_CMD_DATCTL:
+		break;
+
+	case SLCDC_CMD_RAMWR:
+		/* Causes the MPU to be a data entry mode,allowing it to serite data 
+		   in the display memory. Inputting any other cmds other than NOP 
+		   cancels the data entry mode. */
+
+		__raw_writel((u32) g_slcdc_cbuffer_phyaddress, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+
+		/* put cmd into cmd buffer */
+		databuffer = g_slcdc_cbuffer_address;
+		/* put cmd into cmd buffer */
+		*databuffer = SLCDC_CMD_RAMWR;
+		/* send cmd */
+		slcdc_send_cmd(1);
+		slcdc_delay(2000);
+
+		/* this is to display one data per time, it is ok.  */
+		slcdc_delay(0xffff);
+		__raw_writel((u32) slcdc_par.screen_start_address, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+
+		slcdc_delay(0xffff);
+		slcdc_send_data(SLCDC_MEM_SIZE);
+		slcdc_delay(0xffff);
+
+		break;
+
+	case SLCDC_CMD_RAMRD:
+		break;
+
+	case SLCDC_CMD_PTLIN:
+		/* This command is used to display a partial screen for power saving. */
+		break;
+
+	case SLCDC_CMD_PTLOUT:
+		/* This command is used to exit the partila diaplay mode. */
+		break;
+
+	case SLCDC_CMD_GCP64:
+		/* make 63 pulse position settings of GCP for 64 gray scales. */
+		/* send cmd into cmd buffer
+		   send parameter into data buffer
+		   send cmd
+		   send data  */
+		break;
+
+	case SLCDC_CMD_GCP16:
+		break;
+
+	case SLCDC_CMD_GSSET:
+		break;
+
+	case SLCDC_CMD_ASCSET:
+		/* make partial screen scroll settings. */
+		/* send cmd into cmd buffer
+		   send parameter into data buffer
+		   send cmd
+		   delay
+		   send data
+		   delay */
+		break;
+
+	case SLCDC_CMD_SCSTART:
+		/* set a scroll starting page in the scrolling area.Be sure to send 
+		   this cmd after ASCSET . */
+		/* send cmd into cmd buffer
+		   send parameter into data buffer
+		   send cmd
+		   delay
+		   send data
+		   delay */
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int slcdcfb_ioctl(struct inode *inode, struct file *file,
+			 unsigned int cmd, unsigned long arg,
+			 struct fb_info *info)
+{
+	return slcdc_ioctl(inode, file, cmd, arg);
+}
+
+/**
+ *@brief slcdc close function
+ *
+ * Function Name: slcdc_release
+ *
+ *
+ * Description: This is the release routine for the driver. And this function \n
+ *	   will be called while the module being closed. In this function, it will\n
+ *	   unregister the apm	
+ *
+ *@param	inode the pointer to the inode descripter
+ *@param	filp  the pointer to the file descripter
+ *
+ *@return	int   return status
+ *			@li 0  sucessful
+ *			@li other failed
+ * Modification History:
+ * 	Dec,2003			Karen first version 
+ *   
+ **/
+
+int slcdc_release(struct inode *inode, struct file *filp)
+{
+	TRACE("slcdc_release: ----\n");
+	del_timer_sync(&slcdc_timer);
+	return 0;
+}
+
+/**
+ *@brief slcdc timer call back function
+ *
+ * Function Name: slcdc_timer_func
+ *
+ * Description:This helper routine prepare the SLCDC for data transfer
+ *             
+ **/
+static void slcdc_timer_func(unsigned long args)
+{
+	volatile unsigned long reg;
+	/* Causes the MPU to be a data entry mode,allowing it to serite data in the 
+	   display memory. Inputting any other cmds other than NOP cancels the data 
+	   entry mode. */
+
+	__raw_writel((u32) g_slcdc_cbuffer_phyaddress, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+
+	/* put cmd into cmd buffer */
+	*g_slcdc_cbuffer_address = SLCDC_CMD_RAMWR;
+	/* send cmd */
+	slcdc_send_cmd(1);
+	slcdc_delay(2000);
+
+	/* this is to display one data per time, it is ok. */
+	slcdc_delay(0xffff);
+	__raw_writel((u32) slcdc_par.screen_start_address, IO_ADDRESS(SLCDC_BASE_ADDR + 0x00));	/* _reg_SLCDC_DBADDR */
+
+	slcdc_delay(0xffff);
+	/* slcdc_send_data( SLCDC_MEM_SIZE); */
+
+	/* enable interrupt */
+#ifdef USING_INTERRUPT_SLCDC
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= ~0xffffff7f;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+#endif
+	/* set length */
+	__raw_writel(SLCDC_MEM_SIZE, IO_ADDRESS(SLCDC_BASE_ADDR + 0x04));	/* _reg_SLCDC_DBUF_SIZE */
+	/* set automode 01 for data */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+	reg |= 0x00000800;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+
+	/* set GO  */
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+						    /*_reg_SLCDC_LCD_CTRL_STAT*/
+
+	reg |= 0x1;
+	__raw_writel(reg, IO_ADDRESS(SLCDC_BASE_ADDR + 0x20));
+	slcdc_delay(0xffff);
+
+	return;
+}
+
+/**
+ *@brief slcdc timer initialization 
+ *
+ * Function Name: init_slcdc_timer
+ *
+ * Description:This helper routine prepare the SLCDC timer for refreshing the
+ *             screen
+ *             
+ **/
+static void init_slcdc_timer(void)
+{
+
+	init_timer(&slcdc_timer);
+	slcdc_timer.expires = jiffies + SLCDC_REFRESH_RATE;
+	slcdc_timer.data = 0;
+	slcdc_timer.function = slcdc_timer_func;
+	add_timer(&slcdc_timer);
+	start_fb_timer_flag = 1;
+}
+
+/**
+ *@brief slcdc open function
+ *
+ * Function Name: slcdc_open
+ *
+ *
+ * Description: This is the open routine for the driver. And this function \n
+ *	   will be called while the module being opened. In this function, it will\n
+ *			@li	configure GPIO for serial/parallel
+ *			@li	slcdc reset
+ *			@li init slcd registers 
+ *			@li init waitqueue
+ *			@li get rca, select the card
+ *			@li send some command for panel configuration
+ *
+ *@param	inode the pointer to the inode descripter
+ *@param	filp  the pointer to the file descripter
+ *
+ *@return	int   return status
+ *			@li 0  sucessful
+ *			@li other failed
+ * Modification History:
+ * 	Dec,2003,			Karen first version
+ *  June,2004,			Shirley update for Parallel mode 
+ *   
+ **/
+
+int slcdc_open(struct inode *inode, struct file *filp)
+{
+	volatile unsigned long reg;
+
+	TRACE("slcdc_open: ----\n");
+
+	/* init dev */
+#ifdef SLCDC_SERIAL_MODE
+	slcdc_gpio_serial();
+#else
+	slcdc_gpio_paralle();
+#endif
+
+	slcdc_init_dev();
+	slcdc_reset(0);		/*pull reset low */
+	/* init slcd registers */
+	slcdc_init_reg();
+
+	/* init waitqueue */
+	init_waitqueue_head(&slcdc_wait);
+	/* send some command for panel configuration */
+	slcdc_config_panel();
+	reg = __raw_readl(IO_ADDRESS(SLCDC_BASE_ADDR + 0x1C));
+						    /*_reg_SLCDC_LCD_TXCONFIG*/
+	TRACE("TRANS_CONFIG_REG=%x \n", (unsigned int)reg);
+
+	/* init slcdc timer, and start timer */
+	init_slcdc_timer();
+	return 0;
+}
+
+/**
+ *@brief slcdc init function
+ *
+ * Function Name: slcdc_init
+ *
+ *
+ *@return	int   return status
+ *			@li 0  sucess
+ *			@li other failure
+ *
+ * Description: This is the initialization routine for the driver. And this 
+ *              function \n will be called while the module being installed. 
+ *              In this function, it will \n register char device,request 
+ *              slcdc irq, initialize the buffer,register to\npower management. 
+ *
+ * Modification History:
+ * 	Dec,2003,			Karen update for MX21 TO2 
+ *   
+ **/
+
+int __init slcdc_init(void)
+{
+	int tmp, err;
+
+	INFO("SLCDC Driver \n");
+	INFO("Motorola SPS-SuZhou \n");
+
+	_init_fbinfo();
+
+	if (slcdcfb_set_var(&slcdc_fb_info)) ;	/* current_par.allow_modeset = 0; */
+
+	register_framebuffer(&slcdc_fb_info);
+
+	devfs_mk_cdev(slcdc_device_num, S_IFCHR | S_IRUGO | S_IWUSR, "slcdc");
+
+	if (slcdc_major != 0) {
+		/* use user supplied major number */
+		slcdc_device_num = MKDEV(slcdc_major, slcdc_minor);
+
+		err = register_chrdev_region(slcdc_device_num, 1, MODULE_NAME);
+	} else {
+		/* auto create device major number */
+		err =
+		    alloc_chrdev_region(&slcdc_device_num, slcdc_minor, 1,
+					MODULE_NAME);
+	}
+
+	if (err < 0) {
+		TRACE("%s driver: Unable to register chrdev region\n",
+		      MODULE_NAME);
+		return err;
+	}
+
+	cdev_init(&slcdc_dev, &g_slcdc_fops);
+	slcdc_dev.owner = THIS_MODULE;
+	slcdc_dev.ops = &g_slcdc_fops;
+
+	if ((err = cdev_add(&slcdc_dev, slcdc_device_num, 1))) {
+		TRACE
+		    ("%s driver: Unable to create character device. Error code=%d\n",
+		     MODULE_NAME, err);
+		return -ENODEV;
+	}
+
+	/* init interrupt */
+	tmp = request_irq(SLCDC_IRQ,
+			  (void *)slcdc_isr,
+			  SA_INTERRUPT | SA_SHIRQ, MODULE_NAME, MODULE_NAME);
+	if (tmp) {
+		printk("slcdc_init:cannot init major= %d irq=%d\n",
+		       MAJOR(slcdc_device_num), SLCDC_IRQ);
+		devfs_remove(MODULE_NAME);
+		cdev_del(&slcdc_dev);
+		return -1;
+	}
+
+	/* init buffer */
+	/* initialize buffer address */
+	g_slcdc_dbuffer_address = NULL;
+	g_slcdc_dbuffer_phyaddress = NULL;
+	g_slcdc_cbuffer_address = NULL;
+	g_slcdc_cbuffer_phyaddress = NULL;
+	slcdc_init_buffer();
+
+	g_slcdc_status = 0;
+
+	return 0;
+}
+
+/**
+ *@brief slcdc cleanup function
+ *
+ * Function Name: slcdc_cleanup
+ *
+ *@return	None
+ *
+ * Description: This is the cleanup routine for the driver. And this function \n
+ *	 will be called while the module being removed. In this function, it will \n
+ *	 cleanup all the registered entries 
+ *
+ * Modification History:
+ * 	Dec 2003,			Karen update for MX21 TO2 
+ *   
+ **/
+
+void __exit slcdc_cleanup(void)
+{
+
+	unregister_chrdev_region(slcdc_device_num, 1);
+
+	devfs_remove(MODULE_NAME);
+
+	/*Do some cleanup work */
+	free_irq(SLCDC_IRQ, MODULE_NAME);
+
+	unregister_framebuffer(&slcdc_fb_info);
+
+	slcdc_free_buffer();
+
+	cdev_del(&slcdc_dev);
+
+	return;
+}
+
+module_init(slcdc_init);
+module_exit(slcdc_cleanup);
+
+/*////////////// Frame Buffer Suport /////////////////////////////////// */
+
+/**
+ * _check_var - Validates a var passed in. 
+ * @var: frame buffer variable screen structure
+ * @info: frame buffer structure that represents a single frame buffer 
+ *
+ * Checks to see if the hardware supports the state requested by var passed
+ * in. This function does not alter the hardware state! If the var passed in
+ * is slightly off by what the hardware can support then we alter the var
+ * PASSED in to what we can do. If the hardware doesn't support mode change
+ * a -EINVAL will be returned by the upper layers.
+ *
+ * Returns negative errno on error, or zero on success.
+ */
+static int _check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	const struct slcdcfb_par *par = (const struct slcdcfb_par *)info->par;
+
+	if (var->xres > current_par.max_xres)
+		var->xres = current_par.max_xres;
+	if (var->yres > current_par.max_yres)
+		var->yres = current_par.max_yres;
+
+	var->xres_virtual = var->xres_virtual < par->xres
+	    ? par->xres : var->xres_virtual;
+	var->yres_virtual = var->yres_virtual < par->yres
+	    ? par->yres : var->yres_virtual;
+	var->bits_per_pixel = par->bits_per_pixel;
+
+	switch (var->bits_per_pixel) {
+	case 2:
+	case 4:
+	case 8:
+		var->red.length = 4;
+		var->green = var->red;
+		var->blue = var->red;
+		var->transp.length = 0;
+		break;
+
+	case 12:		/*  RGB 444 */
+	case 16:		/* RGB 565 */
+		TRACE("16->a\n");
+		var->red.length = 4;
+		var->blue.length = 4;
+		var->green.length = 4;
+		var->transp.length = 0;
+#ifdef __LITTLE_ENDIAN
+		TRACE("16->b\n");
+		var->red.offset = 8;
+		var->green.offset = 4;
+		var->blue.offset = 0;
+		var->transp.offset = 0;
+#endif				/* __LITTLE_ENDIAN */
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	/* *var->screen_start_address=(u_char*)((u_long)g_slcdc_dbuffer_phyaddress );
+	 *var->v_screen_start_address=(u_char*)((u_long)g_slcdc_dbuffer_address  ); */
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+	var->nonstd = 0;
+
+	var->pixclock = -1;
+	var->left_margin = -1;
+	var->right_margin = -1;
+	var->upper_margin = -1;
+	var->lower_margin = -1;
+	var->hsync_len = -1;
+	var->vsync_len = -1;
+
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->sync = 0;
+
+	return 0;
+}
+
+/**
+ *@brief Use current_par to set a var structure
+ *
+ *@param 	var Input var data
+ *@param	par LCD controller parameters
+ *
+ *@return  If no error, return 0
+ *
+ */
+static int _encode_var(struct fb_var_screeninfo *var, struct slcdcfb_par *par)
+{
+	FUNC_START
+	    /* Don't know if really want to zero var on entry.
+	       Look at set_var to see.  If so, may need to add extra params to par   */
+	    memset(var, 0, sizeof(*var));
+	var->xres = par->xres;
+	TRACE("var->xress=%d\n", var->xres);
+	var->yres = par->yres;
+	TRACE("var->yres=%d\n", var->yres);
+	var->xres_virtual = par->xres_virtual;
+	TRACE("var->xres_virtual=%d\n", var->xres_virtual);
+	var->yres_virtual = par->yres_virtual;
+	TRACE("var->yres_virtual=%d\n", var->yres_virtual);
+
+	var->bits_per_pixel = par->bits_per_pixel;
+	TRACE("var->bits_per_pixel=%d\n", var->bits_per_pixel);
+
+	switch (var->bits_per_pixel) {
+	case 2:
+	case 4:
+	case 8:
+		var->red.length = 4;
+		var->green = var->red;
+		var->blue = var->red;
+		var->transp.length = 0;
+		break;
+	case 12:		/* This case should differ for Active/Passive mode */
+	case 16:
+		TRACE("16->a\n");
+		var->red.length = 4;
+		var->blue.length = 4;
+		var->green.length = 4;
+		var->transp.length = 0;
+#ifdef __LITTLE_ENDIAN
+		TRACE("16->b\n");
+		var->red.offset = 8;
+		var->green.offset = 4;
+		var->blue.offset = 0;
+		var->transp.offset = 0;
+#endif				/* __LITTLE_ENDIAN */
+		break;
+	}
+
+	FUNC_END return 0;
+}
+
+/**
+ *@brief Get the video params out of 'var'. If a value doesn't fit, 
+ * 		round it up,if it's too big, return -EINVAL.
+ *
+ *@warning Round up in the following order: bits_per_pixel, xres,
+ * 	yres, xres_virtual, yres_virtual, xoffset, yoffset, grayscale,
+ * 	bitfields, horizontal timing, vertical timing. 			
+ *
+ *@param 	var Input var data
+ *@param	par LCD controller parameters
+ *  
+ *@return If no error, return 0
+ */
+static int _decode_var(struct fb_info *info)
+{
+	struct fb_var_screeninfo *var = &info->var;
+	struct slcdcfb_par par_var;
+	struct slcdcfb_par *par = &par_var;
+
+	FUNC_START *par = current_par;
+
+	if ((par->xres = var->xres) < MIN_XRES)
+		par->xres = MIN_XRES;
+	if ((par->yres = var->yres) < MIN_YRES)
+		par->yres = MIN_YRES;
+	if (par->xres > current_par.max_xres)
+		par->xres = current_par.max_xres;
+	if (par->yres > current_par.max_yres)
+		par->yres = current_par.max_yres;
+	par->xres_virtual = var->xres_virtual < par->xres
+	    ? par->xres : var->xres_virtual;
+	par->yres_virtual = var->yres_virtual < par->yres
+	    ? par->yres : var->yres_virtual;
+	par->bits_per_pixel = var->bits_per_pixel;
+
+	switch (par->bits_per_pixel) {
+
+	case 4:
+		par->visual = FB_VISUAL_PSEUDOCOLOR;
+		par->palette_size = 16;
+		break;
+
+	case 8:
+		par->visual = FB_VISUAL_PSEUDOCOLOR;
+		par->palette_size = 256;
+		break;
+
+	case 12:		/* RGB 444 */
+	case 16:		/* RGB 565 */
+		par->visual = FB_VISUAL_TRUECOLOR;
+		par->palette_size = 0;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	par->screen_start_address =
+	    (u_char *) ((u_long) g_slcdc_dbuffer_phyaddress);
+	par->v_screen_start_address =
+	    (u_char *) ((u_long) g_slcdc_dbuffer_address);
+
+	/* update_lcd ? */
+
+	FUNC_END return 0;
+}
+
+/**
+ *@brief Set current_par by var, also set display data, specially the console 
+ * 	   related file operations, then enable the SLCD controller, and set cmap to
+ * 	   hardware.
+ *
+ *@param	var	Iuput data pointer
+ *@param	con	Console ID
+ *@param	info	Frame buffer information 
+ * 
+ *@return   If no error, return 0.
+ *
+ **/
+static int slcdcfb_set_var(struct fb_info *info)
+{
+	struct display *display;
+	int err;
+	struct slcdcfb_par par;
+	struct fb_var_screeninfo *var = &info->var;
+
+	FUNC_START;
+
+	display = &global_disp;	/* Default display settings */
+
+	/* Decode var contents into a par structure, adjusting any */
+	/* out of range values. */
+	if ((err = _decode_var(info))) {
+		TRACE("decode var error!");
+		return err;
+	}
+
+	/* Store adjusted par values into var structure */
+	_encode_var(var, &par);
+
+	if ((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_TEST)
+		return 0;
+
+	else if (((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NOW) &&
+		 ((var->activate & FB_ACTIVATE_MASK) != FB_ACTIVATE_NXTOPEN))
+		return -EINVAL;
+
+	display->inverse = 0;
+
+	init_var = *var;	/* TODO:gcc support structure copy? */
+
+	FUNC_END;
+	return 0;
+}
+
+/**
+ *@brief Blank the screen, if blank, disable LCD controller, while if no blank
+ * 		set cmap and enable LCD controller
+ *
+ *@param	blank Blank flag
+ *@param	info	Frame buffer database
+ *
+ *@return  VOID
+ */
+static int slcdcfb_blank(int blank, struct fb_info *info)
+{
+
+	if (blank) {
+		slcdc_display_off();
+	} else {
+		slcdc_display_normal();
+	}
+
+	return 0;
+}
+
+/**
+ *@brief Initialize frame buffer. While 16bpp is used to store a 12 bits pixels 
+ *      packet, it is not a really 16bpp system, maybe in-compatiable with
+ * 		other system or GUI.There are some field in var which specify
+ *		the red/green/blue offset in a 16bit word, just little endian is
+ * 		concerned
+ *
+ *@return  VOID
+ **/
+static void __init _init_fbinfo(void)
+{
+	FUNC_START;
+
+	slcdc_fb_info.node = -1;
+	slcdc_fb_info.flags = 0;	/* Low-level driver is not a module */
+	slcdc_fb_info.fbops = &slcdcfb_ops;
+	slcdc_fb_info.monspecs = monspecs;
+
+	strcpy(slcdc_fb_info.fix.id, "SLCDC");
+	/* FIXME... set fix parameters */
+	/*
+	 * * setup initial parameters
+	 * */
+	memset(&init_var, 0, sizeof(init_var));
+	memset(&current_par, 0, sizeof(current_par));
+
+	init_var.transp.length = 0;
+	init_var.nonstd = 0;
+	init_var.activate = FB_ACTIVATE_NOW;
+	init_var.xoffset = 0;
+	init_var.yoffset = 0;
+	init_var.height = -1;
+	init_var.width = -1;
+	init_var.vmode = FB_VMODE_NONINTERLACED;
+
+	/*xres and yres might be set when loading the module, if this driver is 
+	   built as module */
+	current_par.max_xres = SLCDC_WIDTH;
+	current_par.max_yres = SLCDC_HIGH;
+
+	current_par.max_bpp = SLCDC_BPP;
+	init_var.red.length = 5;
+	init_var.green.length = 6;
+	init_var.blue.length = 5;
+#ifdef __LITTLE_ENDIAN
+	init_var.red.offset = 11;
+	init_var.green.offset = 5;
+	init_var.blue.offset = 0;
+#endif				/* __LITTLE_ENDIAN */
+	init_var.grayscale = 16;
+	init_var.sync = 0;
+	init_var.pixclock = 171521;
+
+	current_par.screen_start_address = NULL;
+	current_par.v_screen_start_address = NULL;
+	current_par.screen_memory_size = MAX_PIXEL_MEM_SIZE;
+	current_par.currcon = -1;
+
+	init_var.xres = current_par.max_xres;
+	init_var.yres = current_par.max_yres;
+	init_var.xres_virtual = init_var.xres;
+	init_var.yres_virtual = init_var.yres;
+	init_var.bits_per_pixel = current_par.max_bpp;
+
+	current_par.xres = init_var.xres;
+	current_par.yres = init_var.yres;
+	current_par.xres_virtual = init_var.xres;
+	current_par.yres_virtual = init_var.yres;
+
+	/* initialize current screen information */
+	memcpy(&slcdc_fb_info.var, &init_var, sizeof(init_var));
+
+	FUNC_END;
+}
+
+/**
+ *@brief slcdc framebuffer open call
+ *
+ * Function Name: slcdcfb_open
+ *
+ * Description  : This function is called by the framebuffer when the 
+ *                application requests. 
+ *             
+ *@return		0 on success any other value for failure
+ **/
+static int slcdcfb_open(struct fb_info *info, int user)
+{
+	return slcdc_open(NULL, 0);
+}
+
+/**
+ *@brief slcdc framebuffer release call
+ *
+ * Function Name: slcdcfb_release
+ *
+ * Description  : This function is called by the framebuffer when the 
+ *                application closes the link to framebuffer. 
+ *             
+ *@return		0 on success any other value for failure
+ **/
+static int slcdcfb_release(struct fb_info *info, int user)
+{
+	start_fb_timer_flag = 0;
+	return slcdc_release(NULL, 0);
+}
+
+/*\@}*/
+
+MODULE_PARM(irq_mask, "i");
+MODULE_PARM(irq_list, "1-4i");
+MODULE_LICENSE("GPL");
--- linux-2.6.19.2/drivers/video/mxc/mx2fb.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/mx2fb.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file    mx2fb.h
+ *
+ * @brief Header file for the MX27 Frame buffer 
+ * 
+ * @ingroup Framebuffer
+ */
+#ifndef __MX2FB_H__
+#define __MX2FB_H__
+
+/*! @brief MX27 LCDC graphic window information */
+struct fb_gwinfo {
+	/*! Non-zero if graphic window is enabled */
+	__u32 enabled;
+
+	/* The fields below are valid only when graphic window is enabled */
+
+	/*! Graphic window alpha value from 0 to 255 */
+	__u32 alpha_value;
+
+	/*! Non-zero if graphic window color keying is enabled. */
+	__u32 ck_enabled;
+
+	/* 
+	 * The fields ck_red, ck_green and ck_blue are valid only when
+	 * graphic window and the color keying are enabled. They are the
+	 * color component of graphic window color keying.
+	 */
+
+	/*! Color keying red component */
+	__u32 ck_red;
+
+	/*! Color keying green component */
+	__u32 ck_green;
+
+	/*! Color keying blue component */
+	__u32 ck_blue;
+
+	/*! Graphic window x position */
+	__u32 xpos;
+
+	/*! Graphic window y position */
+	__u32 ypos;
+
+	/*! Non-zero if graphic window vertical scan in reverse direction. */
+	__u32 vs_reversed;
+
+	/*
+	 * The following fields are valid for FBIOGET_GWINFO and
+	 * mx2_gw_set(). FBIOPUT_GWINFO ignores these fields.
+	 */
+	__u32 base;		/* Graphic window start address */
+	__u32 xres;		/* Visible x resolution */
+	__u32 yres;		/* Visible y resolution */
+	__u32 xres_virtual;	/* Virtual x resolution */
+};
+
+/*
+ * LCDC register definitions
+ */
+#define LCDC_LSSAR		0x00
+#define LCDC_LSR		0x04
+#define LCDC_LVPWR		0x08
+#define LCDC_LCPR		0x0C
+#define LCDC_LCWHBR		0x10
+#define LCDC_LCCMR		0x14
+#define LCDC_LPCR		0x18
+#define LCDC_LHCR		0x1C
+#define LCDC_LVCR		0x20
+#define LCDC_LPOR		0x24
+#define LCDC_LSCR		0x28
+#define LCDC_LPCCR		0x2C
+#define LCDC_LDCR		0x30
+#define LCDC_LRMCR		0x34
+#define LCDC_LICR		0x38
+#define LCDC_LIER		0x3C
+#define LCDC_LISR		0x40
+#define LCDC_LGWSAR		0x50
+#define LCDC_LGWSR		0x54
+#define LCDC_LGWVPWR		0x58
+#define LCDC_LGWPOR		0x5C
+#define LCDC_LGWPR		0x60
+#define LCDC_LGWCR		0x64
+#define LCDC_LGWDCR		0x68
+#define LCDC_LAUSCR		0x80
+#define LCDC_LAUSCCR		0x84
+
+#define LCDC_REG(reg)		(IO_ADDRESS(LCDC_BASE_ADDR) + reg)
+
+/* 0x46E0-0x46FF are reserved for MX27 */
+#define FBIOGET_GWINFO		0x46E0	/*!< Get graphic window information */
+#define FBIOPUT_GWINFO		0x46E1	/*!< Set graphic window information */
+
+struct mx2fb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mx2fb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+#define MX2FB_SET_GBL_ALPHA	_IOW('M', 0, struct mx2fb_gbl_alpha)
+#define MX2FB_SET_CLR_KEY	_IOW('M', 1, struct mx2fb_color_key)
+#define MX2FB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MX2FB_SET_BRIGHTNESS	_IOW('M', 3, __u8)
+
+void mx2_gw_set(struct fb_gwinfo *gwinfo);
+
+#endif				/* __MX2FB_H__ */
--- linux-2.6.19.2/drivers/video/mxc/mxcfb.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/mxcfb.c	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,1225 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup Framebuffer Framebuffer Driver for SDC and ADC.
+ */
+
+/*!
+ * @file mxcfb.c
+ *
+ * @brief MXC Frame buffer driver for SDC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/dma-mapping.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/uaccess.h>
+#include <asm/arch/ipu.h>
+#include <asm/arch/mxcfb.h>
+
+/*
+ * Driver name
+ */
+#define MXCFB_NAME      "mxc_sdc_fb"
+/*!
+ * Structure containing the MXC specific framebuffer information.
+ */
+struct mxcfb_info {
+	int blank;
+	ipu_channel_t ipu_ch;
+	uint32_t ipu_ch_irq;
+	uint32_t cur_ipu_buf;
+
+	u32 pseudo_palette[16];
+
+	struct semaphore flip_sem;
+	spinlock_t fb_lock;
+};
+
+struct mxcfb_data {
+	struct fb_info *fbi;
+	struct fb_info *fbi_ovl;
+	volatile int32_t vsync_flag;
+	wait_queue_head_t vsync_wq;
+	wait_queue_head_t suspend_wq;
+	bool suspended;
+	int backlight_level;
+};
+
+static struct mxcfb_data mxcfb_drv_data;
+
+static char *fb_mode = NULL;
+static unsigned long default_bpp = 16;
+
+static uint32_t bpp_to_pixfmt(int bpp)
+{
+	uint32_t pixfmt = 0;
+	switch (bpp) {
+	case 24:
+		pixfmt = IPU_PIX_FMT_BGR24;
+		break;
+	case 32:
+		pixfmt = IPU_PIX_FMT_BGR32;
+		break;
+	case 16:
+		pixfmt = IPU_PIX_FMT_RGB565;
+		break;
+	}
+	return pixfmt;
+}
+
+extern void gpio_lcd_active(void);
+extern void gpio_lcd_inactive(void);
+#ifdef CONFIG_FB_MXC_TVOUT
+#include <linux/video_encoder.h>
+/*
+ * FIXME: VGA mode is not defined by video_encoder.h
+ * while FS453 supports VGA output.
+ */
+#ifndef VIDEO_ENCODER_VGA
+#define VIDEO_ENCODER_VGA	32
+#endif
+
+#define MODE_PAL		"TV-PAL"
+#define MODE_NTSC		"TV-NTSC"
+#define MODE_VGA		"TV-VGA"
+
+extern int fs453_ioctl(unsigned int cmd, void *arg);
+#endif
+static irqreturn_t mxcfb_irq_handler(int irq, void *dev_id,
+				     struct pt_regs *regs);
+static int mxcfb_blank(int blank, struct fb_info *info);
+static int mxcfb_map_video_memory(struct fb_info *fbi, bool use_internal_ram);
+static int mxcfb_unmap_video_memory(struct fb_info *fbi);
+
+/*
+ * Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	if (mxc_fbi->ipu_ch == MEM_SDC_FG)
+		strncpy(fix->id, "DISP3 FG", 8);
+	else
+		strncpy(fix->id, "DISP3 BG", 8);
+
+	fix->line_length = var->xres_virtual * var->bits_per_pixel / 8;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 1;
+	fix->ypanstep = 1;
+
+	return 0;
+}
+
+/*
+ * Set framebuffer parameters and change the operating mode.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_par(struct fb_info *fbi)
+{
+	int retval;
+	bool use_iram = false;
+	u32 mem_len;
+	ipu_di_signal_cfg_t sig_cfg;
+	ipu_panel_t mode = IPU_PANEL_TFT;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	ipu_disable_irq(mxc_fbi->ipu_ch_irq);
+	ipu_disable_channel(mxc_fbi->ipu_ch, true);
+	ipu_clear_irq(mxc_fbi->ipu_ch_irq);
+	mxcfb_set_fix(fbi);
+
+	mem_len = fbi->var.yres_virtual * fbi->fix.line_length;
+	if (mem_len > fbi->fix.smem_len) {
+		if (fbi->fix.smem_start)
+			mxcfb_unmap_video_memory(fbi);
+
+		if (mxcfb_map_video_memory(fbi, use_iram) < 0)
+			return -ENOMEM;
+	}
+
+	ipu_init_channel(mxc_fbi->ipu_ch, NULL);
+
+	if (mxc_fbi->ipu_ch == MEM_SDC_BG) {
+		memset(&sig_cfg, 0, sizeof(sig_cfg));
+		if (fbi->var.sync & FB_SYNC_HOR_HIGH_ACT)
+			sig_cfg.Hsync_pol = true;
+		if (fbi->var.sync & FB_SYNC_VERT_HIGH_ACT)
+			sig_cfg.Vsync_pol = true;
+		if (fbi->var.sync & FB_SYNC_CLK_INVERT)
+			sig_cfg.clk_pol = true;
+		if (fbi->var.sync & FB_SYNC_DATA_INVERT)
+			sig_cfg.data_pol = true;
+		if (fbi->var.sync & FB_SYNC_OE_ACT_HIGH)
+			sig_cfg.enable_pol = true;
+		if (fbi->var.sync & FB_SYNC_CLK_IDLE_EN)
+			sig_cfg.clkidle_en = true;
+		if (fbi->var.sync & FB_SYNC_SHARP_MODE)
+			mode = IPU_PANEL_SHARP_TFT;
+
+		dev_dbg(fbi->device, "pixclock = %ul Hz\n",
+			(u32) (PICOS2KHZ(fbi->var.pixclock) * 1000UL));
+
+		if (ipu_sdc_init_panel(mode,
+				       (PICOS2KHZ(fbi->var.pixclock)) * 1000UL,
+				       fbi->var.xres, fbi->var.yres,
+				       (fbi->var.sync & FB_SYNC_SWAP_RGB) ?
+				       IPU_PIX_FMT_BGR666 : IPU_PIX_FMT_RGB666,
+				       fbi->var.left_margin,
+				       fbi->var.hsync_len,
+				       fbi->var.right_margin +
+				       fbi->var.hsync_len,
+				       fbi->var.upper_margin,
+				       fbi->var.vsync_len,
+				       fbi->var.lower_margin +
+				       fbi->var.vsync_len, sig_cfg) != 0) {
+			dev_err(fbi->device,
+				"mxcfb: Error initializing panel.\n");
+			return -EINVAL;
+		}
+	}
+
+	ipu_sdc_set_window_pos(mxc_fbi->ipu_ch, 0, 0);
+
+	mxc_fbi->cur_ipu_buf = 0;
+	sema_init(&mxc_fbi->flip_sem, 1);
+
+	ipu_init_channel_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+				bpp_to_pixfmt(fbi->var.bits_per_pixel),
+				fbi->var.xres, fbi->var.yres,
+				fbi->var.xres_virtual,
+				IPU_ROTATE_NONE,
+				fbi->fix.smem_start, fbi->fix.smem_start, 0, 0);
+
+	ipu_select_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER, 0);
+
+	if (fbi->fbops->fb_blank)
+		fbi->fbops->fb_blank(mxc_fbi->blank, fbi);
+
+	return 0;
+}
+
+/*
+ * Check framebuffer variable parameters and adjust to valid values.
+ *
+ * @param       var      framebuffer variable parameters
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	u32 vtotal;
+	u32 htotal;
+
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&
+	    (var->bits_per_pixel != 16)) {
+		var->bits_per_pixel = default_bpp;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		var->red.length = 5;
+		var->red.offset = 11;
+		var->red.msb_right = 0;
+
+		var->green.length = 6;
+		var->green.offset = 5;
+		var->green.msb_right = 0;
+
+		var->blue.length = 5;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 24:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 32:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		var->transp.msb_right = 0;
+		break;
+	}
+
+	if (var->pixclock < 1000) {
+		htotal = var->xres + var->right_margin + var->hsync_len +
+		    var->left_margin;
+		vtotal = var->yres + var->lower_margin + var->vsync_len +
+		    var->upper_margin;
+		var->pixclock = (vtotal * htotal * 6UL) / 100UL;
+		var->pixclock = KHZ2PICOS(var->pixclock);
+		dev_dbg(info->device,
+			"pixclock set for 60Hz refresh = %u ps\n",
+			var->pixclock);
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+
+	/* Copy nonstd field to/from sync for fbset usage */
+	var->sync |= var->nonstd;
+	var->nonstd |= var->sync;
+
+	return 0;
+}
+
+static inline u_int _chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+static int
+mxcfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+		u_int trans, struct fb_info *fbi)
+{
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fbi->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (fbi->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fbi->pseudo_palette;
+
+			val = _chan_to_field(red, &fbi->var.red);
+			val |= _chan_to_field(green, &fbi->var.green);
+			val |= _chan_to_field(blue, &fbi->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Function to handle custom ioctls for MXC framebuffer.
+ *
+ * @param       inode   inode struct
+ *
+ * @param       file    file struct
+ *
+ * @param       cmd     Ioctl command to handle
+ *
+ * @param       arg     User pointer to command arguments
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	switch (cmd) {
+	case MXCFB_SET_GBL_ALPHA:
+		{
+			struct mxcfb_gbl_alpha ga;
+			if (copy_from_user(&ga, (void *)arg, sizeof(ga))) {
+				retval = -EFAULT;
+				break;
+			}
+			retval =
+			    ipu_sdc_set_global_alpha((bool) ga.enable,
+						     ga.alpha);
+			dev_dbg(fbi->device, "Set global alpha to %d\n",
+				ga.alpha);
+			break;
+		}
+	case MXCFB_SET_CLR_KEY:
+		{
+			struct mxcfb_color_key key;
+			if (copy_from_user(&key, (void *)arg, sizeof(key))) {
+				retval = -EFAULT;
+				break;
+			}
+			retval = ipu_sdc_set_color_key(MEM_SDC_BG, key.enable,
+						       key.color_key);
+			dev_dbg(fbi->device, "Set color key to 0x%08X\n",
+				key.color_key);
+			break;
+		}
+	case MXCFB_WAIT_FOR_VSYNC:
+		{
+#ifndef CONFIG_ARCH_MX3
+			mxcfb_drv_data.vsync_flag = 0;
+			ipu_enable_irq(IPU_IRQ_SDC_DISP3_VSYNC);
+			if (!wait_event_interruptible_timeout
+			    (mxcfb_drv_data.vsync_wq,
+			     mxcfb_drv_data.vsync_flag != 0, 1 * HZ)) {
+				dev_err(fbi->device,
+					"MXCFB_WAIT_FOR_VSYNC: timeout\n");
+				retval = -ETIME;
+				break;
+			} else if (signal_pending(current)) {
+				dev_err(fbi->device,
+					"MXCFB_WAIT_FOR_VSYNC: interrupt received\n");
+				retval = -ERESTARTSYS;
+				break;
+			}
+#endif
+			break;
+		}
+	case MXCFB_SET_BRIGHTNESS:
+		{
+			uint8_t level;
+			if (copy_from_user(&level, (void *)arg, sizeof(level))) {
+				retval = -EFAULT;
+				break;
+			}
+
+			mxcfb_drv_data.backlight_level = level;
+			retval = ipu_sdc_set_brightness(level);
+			dev_dbg(fbi->device, "Set brightness to %d\n", level);
+			break;
+		}
+#ifdef CONFIG_FB_MXC_TVOUT
+	case ENCODER_GET_CAPABILITIES:
+		{
+			struct video_encoder_capability cap;
+
+			if ((retval = fs453_ioctl(cmd, &cap)))
+				break;
+
+			if (copy_to_user((void *)arg, &cap, sizeof(cap)))
+				retval = -EFAULT;
+			break;
+		}
+	case ENCODER_SET_NORM:
+		{
+			unsigned long mode;
+			char *smode;
+			struct fb_var_screeninfo var;
+
+			if (copy_from_user(&mode, (void *)arg, sizeof(mode))) {
+				retval = -EFAULT;
+				break;
+			}
+			if ((retval = fs453_ioctl(cmd, &mode)))
+				break;
+
+			if (mode == VIDEO_ENCODER_PAL)
+				smode = MODE_PAL;
+			else if (mode == VIDEO_ENCODER_NTSC)
+				smode = MODE_NTSC;
+			else
+				smode = MODE_VGA;
+
+			var = fbi->var;
+			var.nonstd = 0;
+			retval = fb_find_mode(&var, fbi, smode, mxcfb_modedb,
+					      mxcfb_modedb_sz, NULL,
+					      default_bpp);
+			if ((retval != 1) && (retval != 2)) {	/* specified mode not found */
+				retval = -ENODEV;
+				break;
+			}
+
+			fbi->var = var;
+			fb_mode = smode;
+			retval = mxcfb_set_par(fbi);
+			break;
+		}
+	case ENCODER_SET_INPUT:
+	case ENCODER_SET_OUTPUT:
+	case ENCODER_ENABLE_OUTPUT:
+		{
+			unsigned long varg;
+
+			if (copy_from_user(&varg, (void *)arg, sizeof(varg))) {
+				retval = -EFAULT;
+				break;
+			}
+			retval = fs453_ioctl(cmd, &varg);
+			break;
+		}
+#endif
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*
+ * mxcfb_blank():
+ *      Blank the display.
+ */
+static int mxcfb_blank(int blank, struct fb_info *info)
+{
+	int retval;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	dev_dbg(info->device, "blank = %d\n", blank);
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		ipu_disable_channel(MEM_SDC_BG, true);
+		gpio_lcd_inactive();
+		ipu_sdc_set_brightness(0);
+#ifdef CONFIG_FB_MXC_TVOUT
+		if (fb_mode) {
+			int enable = 0;
+
+			if ((strcmp(fb_mode, MODE_VGA) == 0)
+			    || (strcmp(fb_mode, MODE_NTSC) == 0)
+			    || (strcmp(fb_mode, MODE_PAL) == 0))
+				fs453_ioctl(ENCODER_ENABLE_OUTPUT, &enable);
+		}
+#endif
+		break;
+	case FB_BLANK_UNBLANK:
+		gpio_lcd_active();
+		ipu_enable_channel(MEM_SDC_BG);
+		ipu_sdc_set_brightness(mxcfb_drv_data.backlight_level);
+#ifdef CONFIG_FB_MXC_TVOUT
+		if (fb_mode) {
+			unsigned long mode = 0;
+
+			if (strcmp(fb_mode, MODE_VGA) == 0)
+				mode = VIDEO_ENCODER_VGA;
+			else if (strcmp(fb_mode, MODE_NTSC) == 0)
+				mode = VIDEO_ENCODER_NTSC;
+			else if (strcmp(fb_mode, MODE_PAL) == 0)
+				mode = VIDEO_ENCODER_PAL;
+			if (mode)
+				fs453_ioctl(ENCODER_SET_NORM, &mode);
+		}
+#endif
+		break;
+	}
+	return 0;
+}
+
+#ifdef CONFIG_FB_MXC_OVERLAY
+/*
+ * mxcfb_blank_ovl():
+ *      Blank the display.
+ */
+static int mxcfb_blank_ovl(int blank, struct fb_info *info)
+{
+	int retval;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	dev_dbg(info->device, "ovl blank = %d\n", blank);
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		ipu_disable_channel(MEM_SDC_FG, true);
+		break;
+	case FB_BLANK_UNBLANK:
+		ipu_enable_channel(MEM_SDC_FG);
+		break;
+	}
+	return 0;
+}
+#endif
+
+/*
+ * Pan or Wrap the Display
+ *
+ * This call looks only at xoffset, yoffset and the FB_VMODE_YWRAP flag
+ *
+ * @param               var     Variable screen buffer information
+ * @param               info    Framebuffer information pointer
+ */
+static int
+mxcfb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+	uint32_t lock_flags = 0;
+	int retval;
+	u_int y_bottom;
+	unsigned long base;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	if (var->xoffset > 0) {
+		dev_dbg(info->device, "x panning not supported\n");
+		return -EINVAL;
+	}
+
+	if ((info->var.xoffset == var->xoffset) &&
+	    (info->var.yoffset == var->yoffset)) {
+		return 0;	// No change, do nothing
+	}
+
+	y_bottom = var->yoffset;
+
+	if (!(var->vmode & FB_VMODE_YWRAP)) {
+		y_bottom += var->yres;
+	}
+
+	if (y_bottom > info->var.yres_virtual) {
+		return -EINVAL;
+	}
+
+	base = (var->yoffset * var->xres_virtual + var->xoffset);
+	base *= (var->bits_per_pixel) / 8;
+	base += info->fix.smem_start;
+
+	down(&mxc_fbi->flip_sem);
+
+	spin_lock_irqsave(&mxc_fbi->fb_lock, lock_flags);
+
+	dev_dbg(info->device, "Updating SDC BG buf %ld address=0x%08X\n",
+		mxc_fbi->cur_ipu_buf, base);
+
+	mxc_fbi->cur_ipu_buf = !mxc_fbi->cur_ipu_buf;
+	if (ipu_update_channel_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+				      mxc_fbi->cur_ipu_buf, base) == 0) {
+		ipu_select_buffer(mxc_fbi->ipu_ch, IPU_INPUT_BUFFER,
+				  mxc_fbi->cur_ipu_buf);
+		ipu_clear_irq(mxc_fbi->ipu_ch_irq);
+		ipu_enable_irq(mxc_fbi->ipu_ch_irq);
+	} else {
+		dev_err(info->device,
+			"Error updating SDC buf %d to address=0x%08X\n",
+			mxc_fbi->cur_ipu_buf, (uint32_t) base);
+	}
+
+	spin_unlock_irqrestore(&mxc_fbi->fb_lock, lock_flags);
+
+	dev_dbg(info->device, "Update complete\n");
+
+	info->var.xoffset = var->xoffset;
+	info->var.yoffset = var->yoffset;
+
+	if (var->vmode & FB_VMODE_YWRAP) {
+		info->var.vmode |= FB_VMODE_YWRAP;
+	} else {
+		info->var.vmode &= ~FB_VMODE_YWRAP;
+	}
+
+	return 0;
+}
+
+/*!
+ * This structure contains the pointers to the control functions that are
+ * invoked by the core framebuffer driver to perform operations like
+ * blitting, rectangle filling, copy regions and cursor definition.
+ */
+static struct fb_ops mxcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_pan_display = mxcfb_pan_display,
+	.fb_ioctl = mxcfb_ioctl,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank,
+//      .fb_cursor = soft_cursor,
+};
+
+#ifdef CONFIG_FB_MXC_OVERLAY
+static struct fb_ops mxcfb_ovl_ops = {
+	.owner = THIS_MODULE,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_pan_display = mxcfb_pan_display,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank_ovl,
+//      .fb_cursor = soft_cursor,
+};
+#endif
+
+static irqreturn_t mxcfb_vsync_irq_handler(int irq, void *dev_id,
+					   struct pt_regs *regs)
+{
+	struct mxcfb_data *fb_data = dev_id;
+
+	ipu_disable_irq(irq);
+
+	fb_data->vsync_flag = 1;
+	wake_up_interruptible(&fb_data->vsync_wq);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mxcfb_irq_handler(int irq, void *dev_id,
+				     struct pt_regs *regs)
+{
+	struct fb_info *fbi = dev_id;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	up(&mxc_fbi->flip_sem);
+	ipu_disable_irq(irq);
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_PM
+/*
+ * Power management hooks.      Note that we won't be called from IRQ context,
+ * unlike the blank functions above, so we may sleep.
+ */
+
+/*
+ * Suspends the framebuffer and blanks the screen. Power management support
+ */
+static int mxcfb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)drv_data->fbi->par;
+#ifdef CONFIG_FB_MXC_OVERLAY
+	struct mxcfb_info *mxc_fbi_ovl =
+	    (struct mxcfb_info *)drv_data->fbi_ovl->par;
+#endif
+
+	drv_data->suspended = true;
+#ifdef CONFIG_FB_MXC_OVERLAY
+	if (mxc_fbi_ovl->blank == FB_BLANK_UNBLANK) {
+		ipu_disable_channel(MEM_SDC_FG, true);
+	}
+#endif
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK) {
+		ipu_disable_channel(MEM_SDC_BG, true);
+		gpio_lcd_inactive();
+		ipu_sdc_set_brightness(0);
+#ifdef CONFIG_FB_MXC_TVOUT
+		if (fb_mode) {
+			int enable = 0;
+
+			if ((strcmp(fb_mode, MODE_VGA) == 0)
+			    || (strcmp(fb_mode, MODE_NTSC) == 0)
+			    || (strcmp(fb_mode, MODE_PAL) == 0))
+				fs453_ioctl(ENCODER_ENABLE_OUTPUT, &enable);
+		}
+#endif
+	}
+	return 0;
+}
+
+/*
+ * Resumes the framebuffer and unblanks the screen. Power management support
+ */
+static int mxcfb_resume(struct platform_device *pdev)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)drv_data->fbi->par;
+#ifdef CONFIG_FB_MXC_OVERLAY
+	struct mxcfb_info *mxc_fbi_ovl =
+	    (struct mxcfb_info *)drv_data->fbi_ovl->par;
+#endif
+
+	drv_data->suspended = false;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK) {
+		ipu_enable_channel(MEM_SDC_BG);
+		gpio_lcd_active();
+		ipu_sdc_set_brightness(drv_data->backlight_level);
+#ifdef CONFIG_FB_MXC_TVOUT
+		if (fb_mode) {
+			u32 mode = 0;
+
+			if (strcmp(fb_mode, MODE_VGA) == 0)
+				mode = VIDEO_ENCODER_VGA;
+			else if (strcmp(fb_mode, MODE_NTSC) == 0)
+				mode = VIDEO_ENCODER_NTSC;
+			else if (strcmp(fb_mode, MODE_PAL) == 0)
+				mode = VIDEO_ENCODER_PAL;
+			if (mode)
+				fs453_ioctl(ENCODER_SET_NORM, &mode);
+		}
+#endif
+	}
+#ifdef CONFIG_FB_MXC_OVERLAY
+	if (mxc_fbi_ovl->blank == FB_BLANK_UNBLANK) {
+		ipu_enable_channel(MEM_SDC_FG);
+	}
+#endif
+
+	wake_up_interruptible(&drv_data->suspend_wq);
+	return 0;
+}
+#else
+#define mxcfb_suspend   NULL
+#define mxcfb_resume    NULL
+#endif
+
+/*
+ * Main framebuffer functions
+ */
+
+/*!
+ * Allocates the DRAM memory for the frame buffer.      This buffer is remapped
+ * into a non-cached, non-buffered, memory region to allow palette and pixel
+ * writes to occur without flushing the cache.  Once this area is remapped,
+ * all virtual memory access to the video memory should occur at the new region.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_map_video_memory(struct fb_info *fbi, bool use_internal_ram)
+{
+	int retval = 0;
+
+	{
+		fbi->fix.smem_len = fbi->var.yres_virtual *
+		    fbi->fix.line_length;
+		fbi->screen_base =
+		    dma_alloc_writecombine(fbi->device,
+					   fbi->fix.smem_len,
+					   (dma_addr_t *) & fbi->fix.smem_start,
+					   GFP_DMA);
+
+		if (fbi->screen_base == 0) {
+			dev_err(fbi->device,
+				"Unable to allocate framebuffer memory\n");
+			retval = -EBUSY;
+			goto err0;
+		}
+	}
+
+	dev_dbg(fbi->device, "allocated fb @ paddr=0x%08X, size=%d.\n",
+		(uint32_t) fbi->fix.smem_start, fbi->fix.smem_len);
+
+	fbi->screen_size = fbi->fix.smem_len;
+
+	/* Clear the screen */
+	memset((char *)fbi->screen_base, 0, fbi->fix.smem_len);
+
+	return 0;
+
+      err0:
+	return retval;
+}
+
+/*!
+ * De-allocates the DRAM memory for the frame buffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_unmap_video_memory(struct fb_info *fbi)
+{
+	{
+		dma_free_writecombine(fbi->device, fbi->fix.smem_len,
+				      fbi->screen_base, fbi->fix.smem_start);
+	}
+	fbi->screen_base = 0;
+	fbi->fix.smem_start = 0;
+	fbi->fix.smem_len = 0;
+	return 0;
+}
+
+/*!
+ * Initializes the framebuffer information pointer. After allocating
+ * sufficient memory for the framebuffer structure, the fields are
+ * filled with custom information passed in from the configurable
+ * structures.  This includes information such as bits per pixel,
+ * color maps, screen width/height and RGBA offsets.
+ *
+ * @return      Framebuffer structure initialized with our information
+ */
+static struct fb_info *mxcfb_init_fbinfo(struct device *dev, struct fb_ops *ops)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+
+	/*
+	 * Allocate sufficient memory for the fb structure
+	 */
+	fbi = framebuffer_alloc(sizeof(struct mxcfb_info), dev);
+	if (!fbi)
+		return NULL;
+
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	fbi->var.activate = FB_ACTIVATE_NOW;
+
+	fbi->fbops = ops;
+	fbi->flags = FBINFO_FLAG_DEFAULT;
+	fbi->pseudo_palette = mxcfbi->pseudo_palette;
+
+	spin_lock_init(&mxcfbi->fb_lock);
+
+	/*
+	 * Allocate colormap
+	 */
+	fb_alloc_cmap(&fbi->cmap, 16, 0);
+
+	return fbi;
+}
+
+/*!
+ * Probe routine for the framebuffer driver. It is called during the
+ * driver binding process.      The following functions are performed in
+ * this routine: Framebuffer initialization, Memory allocation and
+ * mapping, Framebuffer registration, IPU initialization.
+ *
+ * @return      Appropriate error code to the kernel common code
+ */
+static int mxcfb_probe(struct platform_device *pdev)
+{
+	char *mode = pdev->dev.platform_data;
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+#ifdef CONFIG_FB_MXC_OVERLAY
+	struct fb_info *fbi_ovl;
+#endif
+	int ret = 0;
+
+	/*
+	 * Initialize FB structures
+	 */
+	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
+	if (!fbi) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	mxcfbi->ipu_ch_irq = IPU_IRQ_SDC_BG_EOF;
+	mxcfbi->cur_ipu_buf = 0;
+	mxcfbi->ipu_ch = MEM_SDC_BG;
+
+	ipu_sdc_set_brightness(255);
+	ipu_sdc_set_global_alpha(true, 0xFF);
+	ipu_sdc_set_color_key(MEM_SDC_BG, false, 0);
+
+	if (ipu_request_irq(IPU_IRQ_SDC_BG_EOF, mxcfb_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(&pdev->dev, "Error registering BG irq handler.\n");
+		ret = -EBUSY;
+		goto err1;
+	}
+	ipu_disable_irq(IPU_IRQ_SDC_BG_EOF);
+
+	if (fb_mode == NULL) {
+		fb_mode = mode;
+	}
+
+	if (!fb_find_mode(&fbi->var, fbi, fb_mode, mxcfb_modedb,
+			  mxcfb_modedb_sz, NULL, default_bpp)) {
+		ret = -EBUSY;
+		goto err2;
+	}
+	/* Default Y virtual size is 2x panel size */
+	fbi->var.yres_virtual = fbi->var.yres * 2;
+
+	mxcfb_drv_data.fbi = fbi;
+	mxcfb_drv_data.backlight_level = 255;
+	mxcfb_drv_data.suspended = false;
+	init_waitqueue_head(&mxcfb_drv_data.suspend_wq);
+
+	ret = mxcfb_set_par(fbi);
+	if (ret < 0) {
+		goto err2;
+	}
+
+	/*
+	 * Register framebuffer
+	 */
+	ret = register_framebuffer(fbi);
+	if (ret < 0) {
+		goto err2;
+	}
+#ifdef CONFIG_FB_MXC_OVERLAY
+	/*
+	 * Initialize Overlay FB structures
+	 */
+	fbi_ovl = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ovl_ops);
+	if (!fbi_ovl) {
+		ret = -ENOMEM;
+		goto err3;
+	}
+	mxcfb_drv_data.fbi_ovl = fbi_ovl;
+	mxcfbi = (struct mxcfb_info *)fbi_ovl->par;
+
+	mxcfbi->ipu_ch_irq = IPU_IRQ_SDC_FG_EOF;
+	mxcfbi->cur_ipu_buf = 0;
+	mxcfbi->ipu_ch = MEM_SDC_FG;
+
+	if (ipu_request_irq(IPU_IRQ_SDC_FG_EOF, mxcfb_irq_handler, 0,
+			    MXCFB_NAME, fbi_ovl) != 0) {
+		dev_err(fbi->device, "Error registering FG irq handler.\n");
+		ret = -EBUSY;
+		goto err4;
+	}
+	ipu_disable_irq(mxcfbi->ipu_ch_irq);
+
+	/* Default Y virtual size is 2x panel size */
+	fbi_ovl->var = fbi->var;
+	fbi_ovl->var.yres_virtual = fbi->var.yres * 2;
+
+	/* Overlay is blanked by default */
+	mxcfbi->blank = FB_BLANK_NORMAL;
+
+	ret = mxcfb_set_par(fbi_ovl);
+	if (ret < 0) {
+		goto err5;
+	}
+
+	/*
+	 * Register overlay framebuffer
+	 */
+	ret = register_framebuffer(fbi_ovl);
+	if (ret < 0) {
+		goto err5;
+	}
+#else
+	mxcfb_drv_data.fbi_ovl = NULL;
+#endif
+	platform_set_drvdata(pdev, &mxcfb_drv_data);
+
+	init_waitqueue_head(&mxcfb_drv_data.vsync_wq);
+	if (!cpu_is_mx31()) {
+		if ((ret = ipu_request_irq(IPU_IRQ_SDC_DISP3_VSYNC,
+					   mxcfb_vsync_irq_handler,
+					   0, MXCFB_NAME,
+					   &mxcfb_drv_data)) < 0) {
+			goto err6;
+		}
+		ipu_disable_irq(IPU_IRQ_SDC_DISP3_VSYNC);
+	}
+
+	printk(KERN_INFO "mxcfb: fb registered, using mode %s\n", fb_mode);
+	return 0;
+
+      err6:
+#ifdef CONFIG_FB_MXC_OVERLAY
+	unregister_framebuffer(fbi_ovl);
+      err5:
+	ipu_free_irq(IPU_IRQ_SDC_FG_EOF, fbi_ovl);
+      err4:
+	fb_dealloc_cmap(&fbi_ovl->cmap);
+	framebuffer_release(fbi_ovl);
+      err3:
+	unregister_framebuffer(fbi);
+#endif
+      err2:
+	ipu_free_irq(IPU_IRQ_SDC_BG_EOF, fbi);
+      err1:
+	fb_dealloc_cmap(&fbi->cmap);
+	framebuffer_release(fbi);
+      err0:
+	printk(KERN_ERR "mxcfb: failed to register fb\n");
+	return ret;
+}
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcfb_driver = {
+	.driver = {
+		   .name = MXCFB_NAME,
+		   },
+	.probe = mxcfb_probe,
+	.suspend = mxcfb_suspend,
+	.resume = mxcfb_resume,
+};
+
+/*
+ * Parse user specified options (`video=trident:')
+ * example:
+ * 	video=trident:800x600,bpp=16,noaccel
+ */
+int mxcfb_setup(char *options)
+{
+	char *opt;
+	if (!options || !*options)
+		return 0;
+	while ((opt = strsep(&options, ",")) != NULL) {
+		if (!*opt)
+			continue;
+		if (!strncmp(opt, "bpp=", 4))
+			default_bpp = simple_strtoul(opt + 4, NULL, 0);
+		else
+			fb_mode = opt;
+	}
+	return 0;
+}
+
+/*!
+ * Main entry function for the framebuffer. The function registers the power
+ * management callback functions with the kernel and also registers the MXCFB
+ * callback functions with the core Linux framebuffer driver \b fbmem.c
+ *
+ * @return      Error code indicating success or failure
+ */
+int __init mxcfb_init(void)
+{
+	int ret = 0;
+#ifndef MODULE
+	char *option = NULL;
+#endif
+
+#ifndef MODULE
+	if (fb_get_options("mxcfb", &option))
+		return -ENODEV;
+	mxcfb_setup(option);
+#endif
+
+	ret = platform_driver_register(&mxcfb_driver);
+	return ret;
+}
+
+void mxcfb_exit(void)
+{
+	struct fb_info *fbi = mxcfb_drv_data.fbi;
+
+	if (fbi) {
+		mxcfb_unmap_video_memory(fbi);
+
+		if (&fbi->cmap)
+			fb_dealloc_cmap(&fbi->cmap);
+
+		unregister_framebuffer(fbi);
+		framebuffer_release(fbi);
+	}
+
+	fbi = mxcfb_drv_data.fbi_ovl;
+	if (fbi) {
+		mxcfb_unmap_video_memory(fbi);
+
+		if (&fbi->cmap)
+			fb_dealloc_cmap(&fbi->cmap);
+
+		unregister_framebuffer(fbi);
+		framebuffer_release(fbi);
+	}
+#ifndef CONFIG_ARCH_MX3
+	ipu_free_irq(IPU_IRQ_SDC_DISP3_VSYNC, &mxcfb_drv_data);
+#endif
+
+	platform_driver_unregister(&mxcfb_driver);
+}
+
+module_init(mxcfb_init);
+module_exit(mxcfb_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC framebuffer driver");
+MODULE_SUPPORTED_DEVICE("fb");
--- linux-2.6.19.2/drivers/video/mxc/mxcfb_epson.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/mxcfb_epson.c	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,1245 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxcfb_epson.c
+ *
+ * @brief MXC Frame buffer driver for ADC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/uaccess.h>
+#include <asm/arch/ipu.h>
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+#include <asm/arch/pmic_power.h>
+#include <asm/arch/pmic_light.h>
+#endif
+
+#include <asm/arch/mxcfb.h>
+
+#define PARTIAL_REFRESH
+#define MXCFB_REFRESH_DEFAULT MXCFB_REFRESH_PARTIAL
+/*
+ * Driver name
+ */
+#define MXCFB_NAME      "MXCFB_EPSON"
+
+#define MXCFB_SCREEN_TOP_OFFSET         0
+#define MXCFB_SCREEN_LEFT_OFFSET        2
+#define MXCFB_SCREEN_WIDTH              176
+#define MXCFB_SCREEN_HEIGHT             220
+
+/*!
+ * Enum defining Epson panel commands.
+ */
+enum {
+	DISON = 0xAF,
+	DISOFF = 0xAE,
+	DISCTL = 0xCA,
+	SD_CSET = 0x15,
+	SD_PSET = 0x75,
+	DATCTL = 0xBC,
+	SLPIN = 0x95,
+	SLPOUT = 0x94,
+	DISNOR = 0xA6,
+	RAMWR = 0x5C,
+	VOLCTR = 0xC6,
+	GCP16 = 0xCC,
+	GCP64 = 0xCB,
+};
+
+struct mxcfb_info {
+	int open_count;
+	int blank;
+	uint32_t disp_num;
+
+	u32 pseudo_palette[16];
+
+	int32_t cur_update_mode;
+	dma_addr_t alloc_start_paddr;
+	void *alloc_start_vaddr;
+	u32 alloc_size;
+	uint32_t snoop_window_size;
+};
+
+struct mxcfb_data {
+	struct fb_info *fbi;
+	volatile int32_t vsync_flag;
+	wait_queue_head_t vsync_wq;
+	wait_queue_head_t suspend_wq;
+	bool suspended;
+	int backlight_level;
+};
+
+static struct mxcfb_data mxcfb_drv_data;
+static unsigned long default_bpp = 16;
+
+void slcd_gpio_config(void);
+extern void gpio_lcd_active(void);
+static int mxcfb_blank(int blank, struct fb_info *fbi);
+
+static uint32_t bpp_to_pixfmt(int bpp)
+{
+	uint32_t pixfmt = 0;
+	switch (bpp) {
+	case 24:
+		pixfmt = IPU_PIX_FMT_BGR24;
+		break;
+	case 32:
+		pixfmt = IPU_PIX_FMT_BGR32;
+		break;
+	case 16:
+		pixfmt = IPU_PIX_FMT_RGB565;
+		break;
+	}
+	return pixfmt;
+}
+
+/*!
+ * This function sets display region in the Epson panel
+ *
+ * @param        disp    display panel to config
+ * @param	 x1	 x-coordinate of one vertex.
+ * @param	 x2	 x-coordinate of second vertex.
+ * @param	 y1	 y-coordinate of one vertex.
+ * @param	 y2	 y-coordinate of second vertex.
+ */
+void set_panel_region(int disp, uint32_t x1, uint32_t x2,
+		      uint32_t y1, uint32_t y2)
+{
+	uint32_t param[8];
+
+	memset(param, 0, sizeof(uint32_t) * 8);
+	param[0] = x1;
+	param[2] = x2;
+	param[4] = y1;
+	param[6] = y2;
+
+	// SD_CSET
+	ipu_adc_write_cmd(disp, CMD, SD_CSET, param, 4);
+	// SD_PSET
+
+	ipu_adc_write_cmd(disp, CMD, SD_PSET, &(param[4]), 4);
+}
+
+/*!
+ * Function to create and initiate template command buffer for ADC. This
+ * template will be written to Panel memory.
+ */
+static void init_channel_template(int disp)
+{
+	/* template command buffer for ADC is 32 */
+	uint32_t tempCmd[TEMPLATE_BUF_SIZE];
+	uint32_t i = 0;
+
+	memset(tempCmd, 0, sizeof(uint32_t) * TEMPLATE_BUF_SIZE);
+	/* setup update display region */
+	/* whole the screen during init */
+	/*WRITE Y COORDINATE CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, SD_PSET);
+	/*WRITE Y START ADDRESS CMND LSB[22:8] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_YADDR, 1, SINGLE_STEP, 0x01);
+	/*WRITE Y START ADDRESS CMND MSB[22:16] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_YADDR, 1, SINGLE_STEP, 0x09);
+	/*WRITE Y STOP ADDRESS CMND LSB */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP,
+					    MXCFB_SCREEN_HEIGHT - 1);
+	/*WRITE Y STOP ADDRESS CMND MSB */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP, 0);
+	/*WRITE X COORDINATE CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, SD_CSET);
+	/*WRITE X ADDRESS CMND LSB[7:0] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_XADDR, 1, SINGLE_STEP, 0x01);
+	/*WRITE X ADDRESS CMND MSB[22:8] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP, 0);
+	/*WRITE X STOP ADDRESS CMND LSB */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP,
+					    MXCFB_SCREEN_WIDTH + 1);
+	/*WRITE X STOP ADDRESS CMND MSB */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP, 0);
+	/*WRITE MEMORY CMND MSB */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, RAMWR);
+	/*WRITE DATA CMND and STP */
+	tempCmd[i++] = ipu_adc_template_gen(WR_DATA, 1, STOP, 0);
+
+	ipu_adc_write_template(disp, tempCmd, true);
+}
+
+/*!
+ * Function to initialize the panel. First it resets the panel and then
+ * initilizes panel.
+ */
+static void _init_panel(int disp)
+{
+	uint32_t cmd_param;
+	uint32_t i;
+
+	gpio_lcd_active();
+	slcd_gpio_config();
+
+	// DATCTL
+#ifdef CONFIG_FB_MXC_ASYNC_PANEL_IFC_16_BIT
+	// 16-bit 565 mode
+	cmd_param = 0x28;
+#else
+	// 8-bit 666 mode
+	cmd_param = 0x08;
+#endif
+	ipu_adc_write_cmd(disp, CMD, DATCTL, &cmd_param, 1);
+
+	// Sleep OUT
+	ipu_adc_write_cmd(disp, CMD, SLPOUT, 0, 0);
+
+	// Set display to white
+	// Setup page and column addresses
+	set_panel_region(disp, MXCFB_SCREEN_LEFT_OFFSET,
+			 MXCFB_SCREEN_WIDTH + MXCFB_SCREEN_LEFT_OFFSET - 1,
+			 0, MXCFB_SCREEN_HEIGHT - 1);
+	// Do RAM write cmd
+	ipu_adc_write_cmd(disp, CMD, RAMWR, 0, 0);
+#ifdef CONFIG_FB_MXC_ASYNC_PANEL_IFC_16_BIT
+	for (i = 0; i < (MXCFB_SCREEN_WIDTH * MXCFB_SCREEN_HEIGHT); i++)
+#else
+	for (i = 0; i < (MXCFB_SCREEN_WIDTH * MXCFB_SCREEN_HEIGHT * 3); i++)
+#endif
+		ipu_adc_write_cmd(disp, DAT, 0xFFFF, 0, 0);
+
+	// Pause 80 ms
+	mdelay(80);
+
+	// Display ON
+	ipu_adc_write_cmd(disp, CMD, DISON, 0, 0);
+	// Pause 200 ms
+	mdelay(200);
+
+	pr_debug("initialized panel\n");
+}
+
+#ifdef PARTIAL_REFRESH
+static irqreturn_t mxcfb_sys2_eof_irq_handler(int irq, void *dev_id,
+					      struct pt_regs *regs)
+{
+	ipu_channel_params_t params;
+	struct fb_info *fbi = dev_id;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+	uint32_t stat[2], seg_size;
+	uint32_t lsb, msb;
+	uint32_t update_height, start_line, start_addr, end_line, end_addr;
+	uint32_t stride_pixels = (fbi->fix.line_length * 8) /
+	    fbi->var.bits_per_pixel;
+
+	ipu_adc_get_snooping_status(&stat[0], &stat[1]);
+	//DPRINTK("snoop status = 0x%08X%08X\n", stat[1], stat[0]);
+
+	if (!stat[0] && !stat[1]) {
+		dev_err(fbi->device, "error no bus snooping bits set\n");
+		return IRQ_HANDLED;
+	}
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+
+	lsb = ffs(stat[0]);
+	if (lsb) {
+		lsb--;
+	} else {
+		lsb = ffs(stat[1]);
+		lsb += 32 - 1;
+	}
+	msb = fls(stat[1]);
+	if (msb) {
+		msb += 32;
+	} else {
+		msb = fls(stat[0]);
+	}
+
+	seg_size = mxc_fbi->snoop_window_size / 64;
+
+	start_addr = lsb * seg_size;	// starting address offset
+	start_line = start_addr / fbi->fix.line_length;
+	start_addr = start_line * fbi->fix.line_length;	// Addr aligned to line
+	start_addr += fbi->fix.smem_start;
+
+	end_addr = msb * seg_size;	// ending address offset
+	end_line = end_addr / fbi->fix.line_length;
+	end_line++;
+
+	if (end_line > fbi->var.yres) {
+		end_line = fbi->var.yres;
+	}
+
+	update_height = end_line - start_line;
+	dev_dbg(fbi->device, "updating rows %d to %d, start addr = 0x%08X\n",
+		start_line, end_line, start_addr);
+
+	ipu_uninit_channel(ADC_SYS1);
+	params.adc_sys1.disp = mxc_fbi->disp_num;
+	params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+	params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+	params.adc_sys1.out_top = start_line;
+	ipu_init_channel(ADC_SYS1, &params);
+
+	ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+				bpp_to_pixfmt(fbi->var.bits_per_pixel),
+				MXCFB_SCREEN_WIDTH,
+				update_height,
+				stride_pixels,
+				IPU_ROTATE_NONE, (dma_addr_t) start_addr, 0,
+				0, 0);
+	ipu_enable_channel(ADC_SYS1);
+	ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+	ipu_enable_irq(IPU_IRQ_ADC_SYS1_EOF);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mxcfb_sys1_eof_irq_handler(int irq, void *dev_id,
+					      struct pt_regs *regs)
+{
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_disable_channel(ADC_SYS1, false);
+
+	ipu_enable_channel(ADC_SYS2);
+	ipu_enable_irq(IPU_IRQ_ADC_SYS2_EOF);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/*!
+ * Function to initialize Asynchronous Display Controller. It also initilizes
+ * the ADC System 1 channel. Configure ADC display 0 parallel interface for
+ * the panel.
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static void mxcfb_init_panel(struct fb_info *fbi)
+{
+	int msb;
+	int panel_stride;
+	ipu_channel_params_t params;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+#ifdef CONFIG_FB_MXC_ASYNC_PANEL_IFC_16_BIT
+	uint32_t pix_fmt = IPU_PIX_FMT_RGB565;
+	ipu_adc_sig_cfg_t sig = { 0, 0, 0, 0, 0, 0, 0, 0,
+		IPU_ADC_BURST_WCS,
+		IPU_ADC_IFC_MODE_SYS80_TYPE2,
+		16, 0, 0, IPU_ADC_SER_NO_RW
+	};
+	mxc_fbi->disp_num = DISP0;
+#elif defined(CONFIG_FB_MXC_ASYNC_PANEL_IFC_8_BIT)
+	uint32_t pix_fmt = IPU_PIX_FMT_RGB666;
+	ipu_adc_sig_cfg_t sig = { 0, 0, 0, 0, 0, 0, 0, 0,
+		IPU_ADC_BURST_WCS,
+		IPU_ADC_IFC_MODE_SYS80_TYPE2,
+		8, 0, 0, IPU_ADC_SER_NO_RW
+	};
+	mxc_fbi->disp_num = DISP0;
+#else
+	uint32_t pix_fmt = IPU_PIX_FMT_RGB565;
+	ipu_adc_sig_cfg_t sig = { 0, 1, 0, 0, 0, 0, 0, 0,
+		IPU_ADC_BURST_SERIAL,
+		IPU_ADC_IFC_MODE_5WIRE_SERIAL_CLK,
+		16, 0, 0, IPU_ADC_SER_NO_RW
+	};
+	fbi->disp_num = DISP1;
+#endif
+
+#ifdef PARTIAL_REFRESH
+	if (ipu_request_irq(IPU_IRQ_ADC_SYS2_EOF, mxcfb_sys2_eof_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering SYS2 irq handler.\n");
+		return;
+	}
+
+	if (ipu_request_irq(IPU_IRQ_ADC_SYS1_EOF, mxcfb_sys1_eof_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering SYS1 irq handler.\n");
+		return;
+	}
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+#endif
+	// Init DI interface
+	msb = fls(MXCFB_SCREEN_WIDTH);
+	if (!(MXCFB_SCREEN_WIDTH & ((1UL << msb) - 1)))
+		msb--;		// Already aligned to power 2
+	panel_stride = 1UL << msb;
+	ipu_adc_init_panel(mxc_fbi->disp_num,
+			   MXCFB_SCREEN_WIDTH + MXCFB_SCREEN_LEFT_OFFSET,
+			   MXCFB_SCREEN_HEIGHT,
+			   pix_fmt, panel_stride, sig, XY, 0, VsyncInternal);
+
+	ipu_adc_init_ifc_timing(mxc_fbi->disp_num, true,
+				190, 17, 104, 190, 5000000);
+	ipu_adc_init_ifc_timing(mxc_fbi->disp_num, false, 123, 17, 68, 0, 0);
+
+	// Needed to turn on ADC clock for panel init
+	memset(&params, 0, sizeof(params));
+	params.adc_sys1.disp = mxc_fbi->disp_num;
+	params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+	params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+	params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET;
+	ipu_init_channel(ADC_SYS1, &params);
+
+	_init_panel(mxc_fbi->disp_num);
+	init_channel_template(mxc_fbi->disp_num);
+}
+
+int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+			   struct mxcfb_rect *update_region)
+{
+	unsigned long start_addr;
+	int ret_mode;
+	uint32_t dummy;
+	ipu_channel_params_t params;
+	struct mxcfb_rect rect;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+	uint32_t stride_pixels = (fbi->fix.line_length * 8) /
+	    fbi->var.bits_per_pixel;
+	uint32_t memsize = fbi->fix.smem_len;
+
+	if (mxc_fbi->cur_update_mode == mode)
+		return mode;
+
+	ret_mode = mxc_fbi->cur_update_mode;
+
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE, 0, 0, 0);
+#ifdef PARTIAL_REFRESH
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+	ipu_adc_set_update_mode(ADC_SYS2, IPU_ADC_REFRESH_NONE, 0, 0, 0);
+#endif
+
+	ipu_disable_channel(ADC_SYS1, true);
+	ipu_clear_irq(IPU_IRQ_ADC_SYS1_EOF);
+#ifdef PARTIAL_REFRESH
+	ipu_disable_channel(ADC_SYS2, true);
+	ipu_clear_irq(IPU_IRQ_ADC_SYS2_EOF);
+#endif
+	ipu_adc_get_snooping_status(&dummy, &dummy);
+
+	mxc_fbi->cur_update_mode = mode;
+
+	switch (mode) {
+	case MXCFB_REFRESH_OFF:
+		if (ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		if (ipu_adc_set_update_mode(ADC_SYS2, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+#if 1
+		ipu_init_channel_buffer(ADC_SYS2, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					1, 1, 4,
+					IPU_ROTATE_NONE,
+					fbi->fix.smem_start,
+					fbi->fix.smem_start, 0, 0);
+		ipu_enable_channel(ADC_SYS2);
+		ipu_select_buffer(ADC_SYS2, IPU_INPUT_BUFFER, 0);
+		ipu_select_buffer(ADC_SYS2, IPU_INPUT_BUFFER, 1);
+		msleep(10);
+#endif
+#ifdef PARTIAL_REFRESH
+		ipu_uninit_channel(ADC_SYS2);
+#endif
+		break;
+	case MXCFB_REFRESH_PARTIAL:
+#ifdef PARTIAL_REFRESH
+		params.adc_sys2.disp = DISP0;
+		params.adc_sys2.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys2.out_left = 0;
+		params.adc_sys2.out_top = 0;
+		ipu_init_channel(ADC_SYS2, &params);
+
+		if (ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0) {
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		}
+		if (ipu_adc_set_update_mode
+		    (ADC_SYS2, IPU_ADC_AUTO_REFRESH_SNOOP, 30,
+		     fbi->fix.smem_start, &memsize) < 0) {
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		}
+		mxc_fbi->snoop_window_size = memsize;
+
+		ipu_init_channel_buffer(ADC_SYS2, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					1, 1, 4,
+					IPU_ROTATE_NONE,
+					fbi->fix.smem_start, 0, 0, 0);
+
+		params.adc_sys1.disp = mxc_fbi->disp_num;
+		params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+		params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET;
+		ipu_init_channel(ADC_SYS1, &params);
+
+		ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					MXCFB_SCREEN_WIDTH, MXCFB_SCREEN_HEIGHT,
+					stride_pixels, IPU_ROTATE_NONE,
+					fbi->fix.smem_start, 0, 0, 0);
+		ipu_enable_channel(ADC_SYS1);
+		ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+		ipu_enable_irq(IPU_IRQ_ADC_SYS1_EOF);
+		break;
+#endif
+	case MXCFB_REFRESH_AUTO:
+		if (update_region == NULL) {
+			update_region = &rect;
+			rect.top = 0;
+			rect.left = 0;
+			rect.height = MXCFB_SCREEN_HEIGHT;
+			rect.width = MXCFB_SCREEN_WIDTH;
+		}
+		params.adc_sys1.disp = mxc_fbi->disp_num;
+		params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET +
+		    update_region->left;
+		params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET +
+		    update_region->top;
+		ipu_init_channel(ADC_SYS1, &params);
+
+		// Address aligned to line
+		start_addr = update_region->top * fbi->fix.line_length;
+		start_addr += fbi->fix.smem_start;
+		start_addr += update_region->left * fbi->var.bits_per_pixel / 8;
+
+		ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					update_region->width,
+					update_region->height, stride_pixels,
+					IPU_ROTATE_NONE, start_addr, 0, 0, 0);
+		ipu_enable_channel(ADC_SYS1);
+		ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+
+		if (ipu_adc_set_update_mode
+		    (ADC_SYS1, IPU_ADC_AUTO_REFRESH_SNOOP, 30,
+		     fbi->fix.smem_start, &memsize) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+
+		mxc_fbi->snoop_window_size = memsize;
+
+		break;
+	}
+	return ret_mode;
+}
+
+/*
+ * Open the main framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       user    Set if opened by user or clear if opened by kernel
+ */
+static int mxcfb_open(struct fb_info *fbi, int user)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	if (mxc_fbi->open_count == 0) {
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_power_regulator_on(SW_SW3);
+		pmic_power_regulator_set_lp_mode(SW_SW3, LOW_POWER_CTRL_BY_PIN);
+
+		pmic_bklit_tcled_master_enable();
+		pmic_bklit_enable_edge_slow();
+		pmic_bklit_set_cycle_time(0);
+#endif
+	}
+	mxc_fbi->open_count++;
+
+	retval = mxcfb_blank(FB_BLANK_UNBLANK, fbi);
+	return retval;
+}
+
+/*
+ * Close the main framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       user    Set if opened by user or clear if opened by kernel
+ */
+static int mxcfb_release(struct fb_info *fbi, int user)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	--mxc_fbi->open_count;
+	if (mxc_fbi->open_count == 0) {
+		retval = mxcfb_blank(FB_BLANK_POWERDOWN, fbi);
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_power_regulator_off(SW_SW3);
+		pmic_power_regulator_set_lp_mode(SW_SW3, LOW_POWER_CTRL_BY_PIN);
+#endif
+	}
+	return retval;
+}
+
+/*
+ * Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	// Set framebuffer id to IPU display number.
+	strcpy(fix->id, "DISP0 FB");
+	fix->id[4] = '0' + mxc_fbi->disp_num;
+
+	// Init settings based on the panel size
+	fix->line_length = MXCFB_SCREEN_WIDTH * var->bits_per_pixel / 8;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 0;
+	fix->ypanstep = 0;
+
+	return 0;
+}
+
+/*
+ * Set framebuffer parameters and change the operating mode.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_par(struct fb_info *fbi)
+{
+	int retval = 0;
+	int mode;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mode = mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+
+	mxcfb_set_fix(fbi);
+
+	if (mode != MXCFB_REFRESH_OFF) {
+#ifdef PARTIAL_REFRESH
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_PARTIAL, NULL);
+#else
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_AUTO, NULL);
+#endif
+	}
+	return 0;
+}
+
+/*
+ * Check framebuffer variable parameters and adjust to valid values.
+ *
+ * @param       var      framebuffer variable parameters
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)
+{
+	if (var->xres > MXCFB_SCREEN_WIDTH)
+		var->xres = MXCFB_SCREEN_WIDTH;
+	if (var->yres > MXCFB_SCREEN_HEIGHT)
+		var->yres = MXCFB_SCREEN_HEIGHT;
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&
+	    (var->bits_per_pixel != 16)) {
+		var->bits_per_pixel = default_bpp;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		var->red.length = 5;
+		var->red.offset = 11;
+		var->red.msb_right = 0;
+
+		var->green.length = 6;
+		var->green.offset = 5;
+		var->green.msb_right = 0;
+
+		var->blue.length = 5;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 24:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 32:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		var->transp.msb_right = 0;
+		break;
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+	var->nonstd = 0;
+
+	var->pixclock = -1;
+	var->left_margin = -1;
+	var->right_margin = -1;
+	var->upper_margin = -1;
+	var->lower_margin = -1;
+	var->hsync_len = -1;
+	var->vsync_len = -1;
+
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->sync = 0;
+
+	return 0;
+}
+
+static inline u_int _chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int
+mxcfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+		u_int trans, struct fb_info *fbi)
+{
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fbi->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (fbi->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fbi->pseudo_palette;
+
+			val = _chan_to_field(red, &fbi->var.red);
+			val |= _chan_to_field(green, &fbi->var.green);
+			val |= _chan_to_field(blue, &fbi->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Function to handle custom ioctls for MXC framebuffer.
+ *
+ * @param       inode   inode struct
+ *
+ * @param       file    file struct
+ *
+ * @param       cmd     Ioctl command to handle
+ *
+ * @param       arg     User pointer to command arguments
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	switch (cmd) {
+	case MXCFB_SET_BRIGHTNESS:
+		{
+			uint8_t level;
+			if (copy_from_user(&level, (void *)arg, sizeof(level))) {
+				retval = -EFAULT;
+				break;
+			}
+			mxcfb_drv_data.backlight_level = level;
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+			pmic_bklit_set_current(BACKLIGHT_LED2,
+					       mxcfb_drv_data.backlight_level);
+			pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 15);
+#endif
+			dev_dbg(fbi->device, "Set brightness to %d\n", level);
+			break;
+		}
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*
+ * mxcfb_blank():
+ *      Blank the display.
+ */
+static int mxcfb_blank(int blank, struct fb_info *fbi)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	dev_dbg(fbi->device, "blank = %d\n", blank);
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_bklit_set_current(BACKLIGHT_LED2, 0);
+		pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 0);
+#endif
+		break;
+	case FB_BLANK_UNBLANK:
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_DEFAULT, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_bklit_set_current(BACKLIGHT_LED2, 7);
+		pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 15);
+#endif
+		break;
+	}
+	return 0;
+}
+
+/*!
+ * This structure contains the pointers to the control functions that are
+ * invoked by the core framebuffer driver to perform operations like
+ * blitting, rectangle filling, copy regions and cursor definition.
+ */
+static struct fb_ops mxcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = mxcfb_open,
+	.fb_release = mxcfb_release,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank,
+	.fb_ioctl = mxcfb_ioctl,
+};
+
+/*!
+ * Allocates the DRAM memory for the frame buffer.      This buffer is remapped
+ * into a non-cached, non-buffered, memory region to allow palette and pixel
+ * writes to occur without flushing the cache.  Once this area is remapped,
+ * all virtual memory access to the video memory should occur at the new region.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_map_video_memory(struct fb_info *fbi)
+{
+	u32 msb;
+	u32 offset;
+	struct mxcfb_info *mxcfbi = fbi->par;
+
+	fbi->fix.smem_len = fbi->var.xres_virtual * fbi->var.yres_virtual * 4;
+
+	// Set size to power of 2.
+	msb = fls(fbi->fix.smem_len);
+	if (!(fbi->fix.smem_len & ((1UL << msb) - 1)))
+		msb--;		// Already aligned to power 2
+	if (msb < 11)
+		msb = 11;
+	mxcfbi->alloc_size = (1UL << msb) * 2;
+
+	mxcfbi->alloc_start_vaddr = dma_alloc_coherent(fbi->device,
+						       mxcfbi->alloc_size,
+						       &mxcfbi->
+						       alloc_start_paddr,
+						       GFP_KERNEL | GFP_DMA);
+
+	if (mxcfbi->alloc_start_vaddr == 0) {
+		dev_err(fbi->device, "Unable to allocate framebuffer memory\n");
+		return -ENOMEM;
+	}
+	dev_dbg(fbi->device, "allocated fb memory @ paddr=0x%08X, size=%d.\n",
+		(uint32_t) mxcfbi->alloc_start_paddr, mxcfbi->alloc_size);
+
+	offset =
+	    ((mxcfbi->alloc_size / 2) - 1) & ~((mxcfbi->alloc_size / 2) - 1);
+	fbi->fix.smem_start = mxcfbi->alloc_start_paddr + offset;
+	dev_dbg(fbi->device, "aligned fb start @ paddr=0x%08lX, size=%u.\n",
+		fbi->fix.smem_start, fbi->fix.smem_len);
+
+	fbi->screen_base = mxcfbi->alloc_start_vaddr + offset;
+
+	/* Clear the screen */
+	memset(fbi->screen_base, 0, fbi->fix.smem_len);
+	return 0;
+}
+
+/*!
+ * De-allocates the DRAM memory for the frame buffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_unmap_video_memory(struct fb_info *fbi)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	dma_free_coherent(fbi->device, mxc_fbi->alloc_size,
+			  mxc_fbi->alloc_start_vaddr,
+			  mxc_fbi->alloc_start_paddr);
+	return 0;
+}
+
+/*!
+ * Initializes the framebuffer information pointer. After allocating
+ * sufficient memory for the framebuffer structure, the fields are
+ * filled with custom information passed in from the configurable
+ * structures.  This includes information such as bits per pixel,
+ * color maps, screen width/height and RGBA offsets.
+ *
+ * @return      Framebuffer structure initialized with our information
+ */
+static struct fb_info *mxcfb_init_fbinfo(struct device *dev, struct fb_ops *ops)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+
+	/*
+	 * Allocate sufficient memory for the fb structure
+	 */
+	fbi = framebuffer_alloc(sizeof(struct mxcfb_info), dev);
+	if (!fbi)
+		return NULL;
+
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	/*
+	 * Fill in fb_info structure information
+	 */
+	fbi->var.xres = fbi->var.xres_virtual = MXCFB_SCREEN_WIDTH;
+	fbi->var.yres = fbi->var.yres_virtual = MXCFB_SCREEN_HEIGHT;
+	fbi->var.activate = FB_ACTIVATE_NOW;
+	mxcfb_check_var(&fbi->var, fbi);
+
+	mxcfb_set_fix(fbi);
+
+	fbi->fbops = ops;
+	fbi->flags = FBINFO_FLAG_DEFAULT;
+	fbi->pseudo_palette = mxcfbi->pseudo_palette;
+
+	/*
+	 * Allocate colormap
+	 */
+	fb_alloc_cmap(&fbi->cmap, 16, 0);
+
+	return fbi;
+}
+
+/*!
+ * Probe routine for the framebuffer driver. It is called during the
+ * driver binding process.      The following functions are performed in
+ * this routine: Framebuffer initialization, Memory allocation and
+ * mapping, Framebuffer registration, IPU initialization.
+ *
+ * @return      Appropriate error code to the kernel common code
+ */
+static int mxcfb_probe(struct platform_device *pdev)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxc_fbi;
+	int ret;
+
+	platform_set_drvdata(pdev, &mxcfb_drv_data);
+
+	/*
+	 * Initialize FB structures
+	 */
+	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
+	if (!fbi) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+	mxcfb_drv_data.fbi = fbi;
+	mxc_fbi = fbi->par;
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	mxcfb_drv_data.backlight_level = 7;
+#endif
+	mxcfb_drv_data.suspended = false;
+	init_waitqueue_head(&mxcfb_drv_data.suspend_wq);
+
+	/*
+	 * Allocate memory
+	 */
+	ret = mxcfb_map_video_memory(fbi);
+	if (ret < 0) {
+		goto err1;
+	}
+
+	mxcfb_init_panel(fbi);
+
+	/*
+	 * Register framebuffer
+	 */
+	ret = register_framebuffer(fbi);
+	if (ret < 0) {
+		goto err2;
+	}
+
+	dev_info(&pdev->dev, "%s registered\n", MXCFB_NAME);
+
+	return 0;
+
+      err2:
+	mxcfb_unmap_video_memory(fbi);
+      err1:
+	if (&fbi->cmap)
+		fb_dealloc_cmap(&fbi->cmap);
+	framebuffer_release(fbi);
+      err0:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+/*!
+ * Power management hooks.      Note that we won't be called from IRQ context,
+ * unlike the blank functions above, so we may sleep.
+ */
+
+/*!
+ * Suspends the framebuffer and blanks the screen. Power management support
+ *
+ * @param	pdev	pointer to device structure.
+ * @param	state	state of the device.
+ *
+ * @return	success
+ */
+static int mxcfb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct fb_info *fbi = drv_data->fbi;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	drv_data->suspended = true;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK)
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	pmic_bklit_set_current(BACKLIGHT_LED2, 0);
+	pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 0);
+#endif
+	/* Display OFF */
+	ipu_adc_write_cmd(mxc_fbi->disp_num, CMD, DISOFF, 0, 0);
+
+	return 0;
+}
+
+/*!
+ * Resumes the framebuffer and unblanks the screen. Power management support
+ *
+ * @param       pdev     pointer to device structure.
+ *
+ * @return      success
+ */
+static int mxcfb_resume(struct platform_device *pdev)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct fb_info *fbi = drv_data->fbi;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	// Display ON
+	ipu_adc_write_cmd(mxc_fbi->disp_num, CMD, DISON, 0, 0);
+	drv_data->suspended = false;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK)
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_DEFAULT, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	pmic_bklit_set_current(BACKLIGHT_LED2, drv_data->backlight_level);
+	pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 15);
+#endif
+	wake_up_interruptible(&drv_data->suspend_wq);
+
+	return 0;
+}
+#else
+#define mxcfb_suspend   NULL
+#define mxcfb_resume    NULL
+#endif
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcfb_driver = {
+	.driver = {
+		   .name = MXCFB_NAME,
+		   },
+	.probe = mxcfb_probe,
+	.suspend = mxcfb_suspend,
+	.resume = mxcfb_resume,
+};
+
+/*!
+ * Device definition for the Framebuffer
+ */
+static struct platform_device mxcfb_device = {
+	.name = MXCFB_NAME,
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = 0xFFFFFFFF,
+		}
+};
+
+/*!
+ * Main entry function for the framebuffer. The function registers the power
+ * management callback functions with the kernel and also registers the MXCFB
+ * callback functions with the core Linux framebuffer driver \b fbmem.c
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&mxcfb_driver);
+	if (ret == 0) {
+		ret = platform_device_register(&mxcfb_device);
+		if (ret != 0) {
+			platform_driver_unregister(&mxcfb_driver);
+		}
+	}
+	return ret;
+}
+
+static void mxcfb_exit(void)
+{
+	struct fb_info *fbi = dev_get_drvdata(&mxcfb_device.dev);
+
+	if (fbi) {
+		mxcfb_unmap_video_memory(fbi);
+
+		if (&fbi->cmap)
+			fb_dealloc_cmap(&fbi->cmap);
+
+		unregister_framebuffer(fbi);
+		framebuffer_release(fbi);
+	}
+
+	platform_device_unregister(&mxcfb_device);
+	platform_driver_unregister(&mxcfb_driver);
+}
+
+module_init(mxcfb_init);
+module_exit(mxcfb_exit);
+
+EXPORT_SYMBOL(mxcfb_set_refresh_mode);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC Epson framebuffer driver");
+MODULE_SUPPORTED_DEVICE("fb");
--- linux-2.6.19.2/drivers/video/mxc/mxcfb_epson_qvga.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/mxcfb_epson_qvga.c	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,1236 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxcfb_epson_qvga.c
+ *
+ * @brief MXC Frame buffer driver for ADC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/uaccess.h>
+#include <asm/arch/ipu.h>
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+#include <asm/arch/pmic_power.h>
+#include <asm/arch/pmic_light.h>
+#endif
+
+#include <asm/arch/mxcfb.h>
+
+#define PARTIAL_REFRESH
+#define MXCFB_REFRESH_DEFAULT MXCFB_REFRESH_PARTIAL
+/*
+ * Driver name
+ */
+#define MXCFB_NAME      "MXCFB_EPSON"
+
+#define MXCFB_SCREEN_TOP_OFFSET         0
+#define MXCFB_SCREEN_LEFT_OFFSET        12
+#define MXCFB_SCREEN_WIDTH              240
+#define MXCFB_SCREEN_HEIGHT             320
+
+/*!
+ * Enum defining Epson panel commands.
+ */
+enum {
+	DISON = 0x29,
+	DISOFF = 0x28,
+	DISCTL = 0xB0,
+	SD_CSET = 0x2A,
+	SD_PSET = 0x2B,
+	SLPIN = 0x10,
+	SLPOUT = 0x11,
+	DISINOFF = 0x20,
+	RAMWR = 0x2C,
+	VOLCTL = 0xBE,
+};
+
+struct mxcfb_info {
+	int open_count;
+	int blank;
+	uint32_t disp_num;
+
+	u32 pseudo_palette[16];
+
+	int32_t cur_update_mode;
+	dma_addr_t alloc_start_paddr;
+	void *alloc_start_vaddr;
+	u32 alloc_size;
+	uint32_t snoop_window_size;
+};
+
+struct mxcfb_data {
+	struct fb_info *fbi;
+	volatile int32_t vsync_flag;
+	wait_queue_head_t vsync_wq;
+	wait_queue_head_t suspend_wq;
+	bool suspended;
+	int backlight_level;
+};
+
+static struct mxcfb_data mxcfb_drv_data;
+static unsigned long default_bpp = 16;
+
+void slcd_gpio_config(void);
+extern void gpio_lcd_active(void);
+static int mxcfb_blank(int blank, struct fb_info *fbi);
+
+static uint32_t bpp_to_pixfmt(int bpp)
+{
+	uint32_t pixfmt = 0;
+	switch (bpp) {
+	case 24:
+		pixfmt = IPU_PIX_FMT_BGR24;
+		break;
+	case 32:
+		pixfmt = IPU_PIX_FMT_BGR32;
+		break;
+	case 16:
+		pixfmt = IPU_PIX_FMT_RGB565;
+		break;
+	}
+	return pixfmt;
+}
+
+/*!
+ * This function sets display region in the Epson panel
+ *
+ * @param        disp    display panel to config
+ * @param	 x1	 x-coordinate of one vertex.
+ * @param	 x2	 x-coordinate of second vertex.
+ * @param	 y1	 y-coordinate of one vertex.
+ * @param	 y2	 y-coordinate of second vertex.
+ */
+void set_panel_region(int disp, uint32_t x1, uint32_t x2,
+		      uint32_t y1, uint32_t y2)
+{
+	uint32_t param[8];
+
+	memset(param, 0, sizeof(uint32_t) * 8);
+	param[0] = x1;
+	param[2] = x2;
+	param[4] = y1;
+	param[6] = y2;
+
+	// SD_CSET
+	ipu_adc_write_cmd(disp, CMD, SD_CSET, param, 4);
+	// SD_PSET
+
+	ipu_adc_write_cmd(disp, CMD, SD_PSET, &(param[4]), 4);
+}
+
+/*!
+ * Function to create and initiate template command buffer for ADC. This
+ * template will be written to Panel memory.
+ */
+static void init_channel_template(int disp)
+{
+	/* template command buffer for ADC is 32 */
+	uint32_t tempCmd[TEMPLATE_BUF_SIZE];
+	uint32_t i = 0;
+
+	memset(tempCmd, 0, sizeof(uint32_t) * TEMPLATE_BUF_SIZE);
+	/* setup update display region */
+	/* whole the screen during init */
+	/*WRITE Y COORDINATE CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, SD_PSET);
+	/*WRITE Y START ADDRESS CMND MSB[22:16] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_YADDR, 1, SINGLE_STEP, 0x09);
+	/*WRITE Y START ADDRESS CMND LSB[22:8] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_YADDR, 1, SINGLE_STEP, 0x01);
+	/*WRITE Y STOP ADDRESS CMND MSB */
+	tempCmd[i++] =
+	    ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP,
+				 (MXCFB_SCREEN_HEIGHT - 1) >> 8);
+	/*WRITE Y STOP ADDRESS CMND LSB */
+	tempCmd[i++] =
+	    ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP,
+				 MXCFB_SCREEN_HEIGHT - 1);
+	/*WRITE X COORDINATE CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, SD_CSET);
+	/*WRITE X ADDRESS CMND MSB[22:8] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP, 0);
+	/*WRITE X ADDRESS CMND LSB[7:0] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_XADDR, 1, SINGLE_STEP, 0x01);
+	/*WRITE X STOP ADDRESS CMND MSB */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP, 0);
+	/*WRITE X STOP ADDRESS CMND LSB */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP,
+					    MXCFB_SCREEN_WIDTH + 11);
+	/*WRITE MEMORY CMND MSB */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, RAMWR);
+	/*WRITE DATA CMND and STP */
+	tempCmd[i++] = ipu_adc_template_gen(WR_DATA, 1, STOP, 0);
+
+	ipu_adc_write_template(disp, tempCmd, true);
+}
+
+/*!
+ * Function to initialize the panel. First it resets the panel and then
+ * initilizes panel.
+ */
+static void _init_panel(int disp)
+{
+	uint32_t cmd_param;
+	uint32_t disctl_param[] =
+	    { 0x01, 0x98, 0x01, 0x48, 0x01, 0x40, 0x04, 0x01, 0x01, 0x41, 0x09,
+		0x00, 0x00, 0x40, 0x00
+	};
+	uint32_t i;
+
+	gpio_lcd_active();
+	slcd_gpio_config();
+
+	// 16-bit 565 mode
+	cmd_param = 0x03;
+	ipu_adc_write_cmd(disp, CMD, 0xC2, &cmd_param, 1);
+
+	ipu_adc_write_cmd(disp, CMD, DISCTL, disctl_param, 15);
+
+	cmd_param = 0x48;
+	ipu_adc_write_cmd(disp, CMD, 0x36, &cmd_param, 1);
+
+	// Sleep OUT
+	ipu_adc_write_cmd(disp, CMD, SLPOUT, 0, 0);
+
+	// Set display to white
+	// Setup page and column addresses
+	set_panel_region(disp, MXCFB_SCREEN_LEFT_OFFSET,
+			 MXCFB_SCREEN_WIDTH + MXCFB_SCREEN_LEFT_OFFSET - 1,
+			 0, MXCFB_SCREEN_HEIGHT - 1);
+	// Do RAM write cmd
+	ipu_adc_write_cmd(disp, CMD, RAMWR, 0, 0);
+	for (i = 0; i < (MXCFB_SCREEN_WIDTH * MXCFB_SCREEN_HEIGHT); i++)
+		ipu_adc_write_cmd(disp, DAT, 0xFFFF, 0, 0);
+
+	// Pause 80 ms
+	mdelay(80);
+
+	// Display ON
+	ipu_adc_write_cmd(disp, CMD, DISON, 0, 0);
+	// Pause 200 ms
+	mdelay(200);
+
+	pr_debug("initialized panel\n");
+}
+
+#ifdef PARTIAL_REFRESH
+static irqreturn_t mxcfb_sys2_eof_irq_handler(int irq, void *dev_id,
+					      struct pt_regs *regs)
+{
+	ipu_channel_params_t params;
+	struct fb_info *fbi = dev_id;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+	uint32_t stat[2], seg_size;
+	uint32_t lsb, msb;
+	uint32_t update_height, start_line, start_addr, end_line, end_addr;
+	uint32_t stride_pixels = (fbi->fix.line_length * 8) /
+	    fbi->var.bits_per_pixel;
+
+	ipu_adc_get_snooping_status(&stat[0], &stat[1]);
+	//DPRINTK("snoop status = 0x%08X%08X\n", stat[1], stat[0]);
+
+	if (!stat[0] && !stat[1]) {
+		dev_err(fbi->device, "error no bus snooping bits set\n");
+		return IRQ_HANDLED;
+	}
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+
+	lsb = ffs(stat[0]);
+	if (lsb) {
+		lsb--;
+	} else {
+		lsb = ffs(stat[1]);
+		lsb += 32 - 1;
+	}
+	msb = fls(stat[1]);
+	if (msb) {
+		msb += 32;
+	} else {
+		msb = fls(stat[0]);
+	}
+
+	seg_size = mxc_fbi->snoop_window_size / 64;
+
+	start_addr = lsb * seg_size;	// starting address offset
+	start_line = start_addr / fbi->fix.line_length;
+	start_addr = start_line * fbi->fix.line_length;	// Addr aligned to line
+	start_addr += fbi->fix.smem_start;
+
+	end_addr = msb * seg_size;	// ending address offset
+	end_line = end_addr / fbi->fix.line_length;
+	end_line++;
+
+	if (end_line > fbi->var.yres) {
+		end_line = fbi->var.yres;
+	}
+
+	update_height = end_line - start_line;
+	dev_dbg(fbi->device, "updating rows %d to %d, start addr = 0x%08X\n",
+		start_line, end_line, start_addr);
+
+	ipu_uninit_channel(ADC_SYS1);
+	params.adc_sys1.disp = mxc_fbi->disp_num;
+	params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+	params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+	params.adc_sys1.out_top = start_line;
+	ipu_init_channel(ADC_SYS1, &params);
+
+	ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+				bpp_to_pixfmt(fbi->var.bits_per_pixel),
+				MXCFB_SCREEN_WIDTH,
+				update_height,
+				stride_pixels,
+				IPU_ROTATE_NONE, (dma_addr_t) start_addr, 0, 0,
+				0);
+	ipu_enable_channel(ADC_SYS1);
+	ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+	ipu_enable_irq(IPU_IRQ_ADC_SYS1_EOF);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mxcfb_sys1_eof_irq_handler(int irq, void *dev_id,
+					      struct pt_regs *regs)
+{
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_disable_channel(ADC_SYS1, false);
+
+	ipu_enable_channel(ADC_SYS2);
+	ipu_enable_irq(IPU_IRQ_ADC_SYS2_EOF);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/*!
+ * Function to initialize Asynchronous Display Controller. It also initilizes
+ * the ADC System 1 channel. Configure ADC display 0 parallel interface for
+ * the panel.
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static void mxcfb_init_panel(struct fb_info *fbi)
+{
+	int msb;
+	int panel_stride;
+	ipu_channel_params_t params;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+#ifdef CONFIG_FB_MXC_ASYNC_PANEL_IFC_16_BIT
+	uint32_t pix_fmt = IPU_PIX_FMT_RGB565;
+	ipu_adc_sig_cfg_t sig = { 0, 0, 0, 0, 0, 0, 0, 0,
+		IPU_ADC_BURST_WCS,
+		IPU_ADC_IFC_MODE_SYS80_TYPE2,
+		16, 0, 0, IPU_ADC_SER_NO_RW
+	};
+	mxc_fbi->disp_num = DISP0;
+#elif defined(CONFIG_FB_MXC_ASYNC_PANEL_IFC_8_BIT)
+	uint32_t pix_fmt = IPU_PIX_FMT_RGB666;
+	ipu_adc_sig_cfg_t sig = { 0, 0, 0, 0, 0, 0, 0, 0,
+		IPU_ADC_BURST_WCS,
+		IPU_ADC_IFC_MODE_SYS80_TYPE2,
+		8, 0, 0, IPU_ADC_SER_NO_RW
+	};
+	mxc_fbi->disp_num = DISP0;
+#endif
+
+#ifdef PARTIAL_REFRESH
+	if (ipu_request_irq(IPU_IRQ_ADC_SYS2_EOF, mxcfb_sys2_eof_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering SYS2 irq handler.\n");
+		return;
+	}
+
+	if (ipu_request_irq(IPU_IRQ_ADC_SYS1_EOF, mxcfb_sys1_eof_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering SYS1 irq handler.\n");
+		return;
+	}
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+#endif
+	// Init DI interface
+	msb = fls(MXCFB_SCREEN_WIDTH);
+	if (!(MXCFB_SCREEN_WIDTH & ((1UL << msb) - 1)))
+		msb--;		// Already aligned to power 2
+	panel_stride = 1UL << msb;
+	ipu_adc_init_panel(mxc_fbi->disp_num,
+			   MXCFB_SCREEN_WIDTH + MXCFB_SCREEN_LEFT_OFFSET,
+			   MXCFB_SCREEN_HEIGHT,
+			   pix_fmt, panel_stride, sig, XY, 0, VsyncInternal);
+
+	ipu_adc_init_ifc_timing(mxc_fbi->disp_num, true,
+				190, 17, 104, 190, 5000000);
+	ipu_adc_init_ifc_timing(mxc_fbi->disp_num, false, 200, 17, 90, 0, 0);
+
+	// Needed to turn on ADC clock for panel init
+	memset(&params, 0, sizeof(params));
+	params.adc_sys1.disp = mxc_fbi->disp_num;
+	params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+	params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+	params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET;
+	ipu_init_channel(ADC_SYS1, &params);
+
+	_init_panel(mxc_fbi->disp_num);
+	init_channel_template(mxc_fbi->disp_num);
+}
+
+int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+			   struct mxcfb_rect *update_region)
+{
+	unsigned long start_addr;
+	int ret_mode;
+	uint32_t dummy;
+	ipu_channel_params_t params;
+	struct mxcfb_rect rect;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+	uint32_t stride_pixels = (fbi->fix.line_length * 8) /
+	    fbi->var.bits_per_pixel;
+	uint32_t memsize = fbi->fix.smem_len;
+
+	if (mxc_fbi->cur_update_mode == mode)
+		return mode;
+
+	ret_mode = mxc_fbi->cur_update_mode;
+
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE, 0, 0, 0);
+#ifdef PARTIAL_REFRESH
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+	ipu_adc_set_update_mode(ADC_SYS2, IPU_ADC_REFRESH_NONE, 0, 0, 0);
+#endif
+
+	ipu_disable_channel(ADC_SYS1, true);
+	ipu_clear_irq(IPU_IRQ_ADC_SYS1_EOF);
+#ifdef PARTIAL_REFRESH
+	ipu_disable_channel(ADC_SYS2, true);
+	ipu_clear_irq(IPU_IRQ_ADC_SYS2_EOF);
+#endif
+	ipu_adc_get_snooping_status(&dummy, &dummy);
+
+	mxc_fbi->cur_update_mode = mode;
+
+	switch (mode) {
+	case MXCFB_REFRESH_OFF:
+		if (ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		if (ipu_adc_set_update_mode(ADC_SYS2, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+#if 1
+		ipu_init_channel_buffer(ADC_SYS2, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					1, 1, 4,
+					IPU_ROTATE_NONE,
+					fbi->fix.smem_start,
+					fbi->fix.smem_start, 0, 0);
+		ipu_enable_channel(ADC_SYS2);
+		ipu_select_buffer(ADC_SYS2, IPU_INPUT_BUFFER, 0);
+		ipu_select_buffer(ADC_SYS2, IPU_INPUT_BUFFER, 1);
+		msleep(10);
+#endif
+#ifdef PARTIAL_REFRESH
+		ipu_uninit_channel(ADC_SYS2);
+#endif
+		break;
+	case MXCFB_REFRESH_PARTIAL:
+#ifdef PARTIAL_REFRESH
+		params.adc_sys2.disp = DISP0;
+		params.adc_sys2.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys2.out_left = 0;
+		params.adc_sys2.out_top = 0;
+		ipu_init_channel(ADC_SYS2, &params);
+
+		if (ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0) {
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		}
+		if (ipu_adc_set_update_mode
+		    (ADC_SYS2, IPU_ADC_AUTO_REFRESH_SNOOP, 30,
+		     fbi->fix.smem_start, &memsize) < 0) {
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		}
+		mxc_fbi->snoop_window_size = memsize;
+
+		ipu_init_channel_buffer(ADC_SYS2, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					1, 1, 4,
+					IPU_ROTATE_NONE,
+					fbi->fix.smem_start, 0, 0, 0);
+
+		params.adc_sys1.disp = mxc_fbi->disp_num;
+		params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+		params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET;
+		ipu_init_channel(ADC_SYS1, &params);
+
+		ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					MXCFB_SCREEN_WIDTH, MXCFB_SCREEN_HEIGHT,
+					stride_pixels, IPU_ROTATE_NONE,
+					fbi->fix.smem_start, 0, 0, 0);
+		ipu_enable_channel(ADC_SYS1);
+		ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+		ipu_enable_irq(IPU_IRQ_ADC_SYS1_EOF);
+		break;
+#endif
+	case MXCFB_REFRESH_AUTO:
+		if (update_region == NULL) {
+			update_region = &rect;
+			rect.top = 0;
+			rect.left = 0;
+			rect.height = MXCFB_SCREEN_HEIGHT;
+			rect.width = MXCFB_SCREEN_WIDTH;
+		}
+		params.adc_sys1.disp = mxc_fbi->disp_num;
+		params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET +
+		    update_region->left;
+		params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET +
+		    update_region->top;
+		ipu_init_channel(ADC_SYS1, &params);
+
+		// Address aligned to line
+		start_addr = update_region->top * fbi->fix.line_length;
+		start_addr += fbi->fix.smem_start;
+		start_addr += update_region->left * fbi->var.bits_per_pixel / 8;
+
+		ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					update_region->width,
+					update_region->height, stride_pixels,
+					IPU_ROTATE_NONE, start_addr, 0, 0, 0);
+		ipu_enable_channel(ADC_SYS1);
+		ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+
+		if (ipu_adc_set_update_mode
+		    (ADC_SYS1, IPU_ADC_AUTO_REFRESH_SNOOP, 30,
+		     fbi->fix.smem_start, &memsize) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+
+		mxc_fbi->snoop_window_size = memsize;
+
+		break;
+	}
+	return ret_mode;
+}
+
+/*
+ * Open the main framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       user    Set if opened by user or clear if opened by kernel
+ */
+static int mxcfb_open(struct fb_info *fbi, int user)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	if (mxc_fbi->open_count == 0) {
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_power_regulator_on(SW_SW3);
+		pmic_power_regulator_set_lp_mode(SW_SW3, LOW_POWER_CTRL_BY_PIN);
+
+		pmic_bklit_tcled_master_enable();
+		pmic_bklit_enable_edge_slow();
+		pmic_bklit_set_cycle_time(0);
+#endif
+	}
+	mxc_fbi->open_count++;
+
+	retval = mxcfb_blank(FB_BLANK_UNBLANK, fbi);
+	return retval;
+}
+
+/*
+ * Close the main framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       user    Set if opened by user or clear if opened by kernel
+ */
+static int mxcfb_release(struct fb_info *fbi, int user)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	--mxc_fbi->open_count;
+	if (mxc_fbi->open_count == 0) {
+		retval = mxcfb_blank(FB_BLANK_POWERDOWN, fbi);
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_power_regulator_off(SW_SW3);
+		pmic_power_regulator_set_lp_mode(SW_SW3, LOW_POWER_CTRL_BY_PIN);
+#endif
+	}
+	return retval;
+}
+
+/*
+ * Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	// Set framebuffer id to IPU display number.
+	strcpy(fix->id, "DISP0 FB");
+	fix->id[4] = '0' + mxc_fbi->disp_num;
+
+	// Init settings based on the panel size
+	fix->line_length = MXCFB_SCREEN_WIDTH * var->bits_per_pixel / 8;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 0;
+	fix->ypanstep = 0;
+
+	return 0;
+}
+
+/*
+ * Set framebuffer parameters and change the operating mode.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_par(struct fb_info *fbi)
+{
+	int retval = 0;
+	int mode;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mode = mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+
+	mxcfb_set_fix(fbi);
+
+	if (mode != MXCFB_REFRESH_OFF) {
+#ifdef PARTIAL_REFRESH
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_PARTIAL, NULL);
+#else
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_AUTO, NULL);
+#endif
+	}
+	return 0;
+}
+
+/*
+ * Check framebuffer variable parameters and adjust to valid values.
+ *
+ * @param       var      framebuffer variable parameters
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)
+{
+	if (var->xres > MXCFB_SCREEN_WIDTH)
+		var->xres = MXCFB_SCREEN_WIDTH;
+	if (var->yres > MXCFB_SCREEN_HEIGHT)
+		var->yres = MXCFB_SCREEN_HEIGHT;
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&
+	    (var->bits_per_pixel != 16)) {
+		var->bits_per_pixel = default_bpp;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		var->red.length = 5;
+		var->red.offset = 11;
+		var->red.msb_right = 0;
+
+		var->green.length = 6;
+		var->green.offset = 5;
+		var->green.msb_right = 0;
+
+		var->blue.length = 5;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 24:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 32:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		var->transp.msb_right = 0;
+		break;
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+	var->nonstd = 0;
+
+	var->pixclock = -1;
+	var->left_margin = -1;
+	var->right_margin = -1;
+	var->upper_margin = -1;
+	var->lower_margin = -1;
+	var->hsync_len = -1;
+	var->vsync_len = -1;
+
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->sync = 0;
+
+	return 0;
+}
+
+static inline u_int _chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int
+mxcfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+		u_int trans, struct fb_info *fbi)
+{
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fbi->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (fbi->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fbi->pseudo_palette;
+
+			val = _chan_to_field(red, &fbi->var.red);
+			val |= _chan_to_field(green, &fbi->var.green);
+			val |= _chan_to_field(blue, &fbi->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Function to handle custom ioctls for MXC framebuffer.
+ *
+ * @param       inode   inode struct
+ *
+ * @param       file    file struct
+ *
+ * @param       cmd     Ioctl command to handle
+ *
+ * @param       arg     User pointer to command arguments
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	switch (cmd) {
+	case MXCFB_SET_BRIGHTNESS:
+		{
+			uint8_t level;
+			if (copy_from_user(&level, (void *)arg, sizeof(level))) {
+				retval = -EFAULT;
+				break;
+			}
+			mxcfb_drv_data.backlight_level = level;
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+			pmic_bklit_set_current(BACKLIGHT_LED1,
+					       mxcfb_drv_data.backlight_level);
+			pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 15);
+#endif
+			dev_dbg(fbi->device, "Set brightness to %d\n", level);
+			break;
+		}
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*
+ * mxcfb_blank():
+ *      Blank the display.
+ */
+static int mxcfb_blank(int blank, struct fb_info *fbi)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	dev_dbg(fbi->device, "blank = %d\n", blank);
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_bklit_set_current(BACKLIGHT_LED1, 0);
+		pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 0);
+#endif
+		break;
+	case FB_BLANK_UNBLANK:
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_DEFAULT, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_bklit_set_current(BACKLIGHT_LED1, 7);
+		pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 15);
+#endif
+		break;
+	}
+	return 0;
+}
+
+/*!
+ * This structure contains the pointers to the control functions that are
+ * invoked by the core framebuffer driver to perform operations like
+ * blitting, rectangle filling, copy regions and cursor definition.
+ */
+static struct fb_ops mxcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = mxcfb_open,
+	.fb_release = mxcfb_release,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank,
+	.fb_ioctl = mxcfb_ioctl,
+};
+
+/*!
+ * Allocates the DRAM memory for the frame buffer.      This buffer is remapped
+ * into a non-cached, non-buffered, memory region to allow palette and pixel
+ * writes to occur without flushing the cache.  Once this area is remapped,
+ * all virtual memory access to the video memory should occur at the new region.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_map_video_memory(struct fb_info *fbi)
+{
+	u32 msb;
+	u32 offset;
+	struct mxcfb_info *mxcfbi = fbi->par;
+
+	fbi->fix.smem_len = fbi->var.xres_virtual * fbi->var.yres_virtual * 4;
+
+	// Set size to power of 2.
+	msb = fls(fbi->fix.smem_len);
+	if (!(fbi->fix.smem_len & ((1UL << msb) - 1)))
+		msb--;		// Already aligned to power 2
+	if (msb < 11)
+		msb = 11;
+	mxcfbi->alloc_size = (1UL << msb) * 2;
+
+	mxcfbi->alloc_start_vaddr = dma_alloc_coherent(fbi->device,
+						       mxcfbi->alloc_size,
+						       &mxcfbi->
+						       alloc_start_paddr,
+						       GFP_KERNEL | GFP_DMA);
+
+	if (mxcfbi->alloc_start_vaddr == 0) {
+		dev_err(fbi->device, "Unable to allocate framebuffer memory\n");
+		return -ENOMEM;
+	}
+	dev_dbg(fbi->device, "allocated fb memory @ paddr=0x%08X, size=%d.\n",
+		(uint32_t) mxcfbi->alloc_start_paddr, mxcfbi->alloc_size);
+
+	offset =
+	    ((mxcfbi->alloc_size / 2) - 1) & ~((mxcfbi->alloc_size / 2) - 1);
+	fbi->fix.smem_start = mxcfbi->alloc_start_paddr + offset;
+	dev_dbg(fbi->device, "aligned fb start @ paddr=0x%08lX, size=%u.\n",
+		fbi->fix.smem_start, fbi->fix.smem_len);
+
+	fbi->screen_base = mxcfbi->alloc_start_vaddr + offset;
+
+	/* Clear the screen */
+	memset(fbi->screen_base, 0, fbi->fix.smem_len);
+	return 0;
+}
+
+/*!
+ * De-allocates the DRAM memory for the frame buffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_unmap_video_memory(struct fb_info *fbi)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	dma_free_coherent(fbi->device, mxc_fbi->alloc_size,
+			  mxc_fbi->alloc_start_vaddr,
+			  mxc_fbi->alloc_start_paddr);
+	return 0;
+}
+
+/*!
+ * Initializes the framebuffer information pointer. After allocating
+ * sufficient memory for the framebuffer structure, the fields are
+ * filled with custom information passed in from the configurable
+ * structures.  This includes information such as bits per pixel,
+ * color maps, screen width/height and RGBA offsets.
+ *
+ * @return      Framebuffer structure initialized with our information
+ */
+static struct fb_info *mxcfb_init_fbinfo(struct device *dev, struct fb_ops *ops)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+
+	/*
+	 * Allocate sufficient memory for the fb structure
+	 */
+	fbi = framebuffer_alloc(sizeof(struct mxcfb_info), dev);
+	if (!fbi)
+		return NULL;
+
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	/*
+	 * Fill in fb_info structure information
+	 */
+	fbi->var.xres = fbi->var.xres_virtual = MXCFB_SCREEN_WIDTH;
+	fbi->var.yres = fbi->var.yres_virtual = MXCFB_SCREEN_HEIGHT;
+	fbi->var.activate = FB_ACTIVATE_NOW;
+	mxcfb_check_var(&fbi->var, fbi);
+
+	mxcfb_set_fix(fbi);
+
+	fbi->fbops = ops;
+	fbi->flags = FBINFO_FLAG_DEFAULT;
+	fbi->pseudo_palette = mxcfbi->pseudo_palette;
+
+	/*
+	 * Allocate colormap
+	 */
+	fb_alloc_cmap(&fbi->cmap, 16, 0);
+
+	return fbi;
+}
+
+/*!
+ * Probe routine for the framebuffer driver. It is called during the
+ * driver binding process.      The following functions are performed in
+ * this routine: Framebuffer initialization, Memory allocation and
+ * mapping, Framebuffer registration, IPU initialization.
+ *
+ * @return      Appropriate error code to the kernel common code
+ */
+static int mxcfb_probe(struct platform_device *pdev)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxc_fbi;
+	int ret;
+
+	platform_set_drvdata(pdev, &mxcfb_drv_data);
+
+	/*
+	 * Initialize FB structures
+	 */
+	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
+	if (!fbi) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+	mxcfb_drv_data.fbi = fbi;
+	mxc_fbi = fbi->par;
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	mxcfb_drv_data.backlight_level = 7;
+#endif
+	mxcfb_drv_data.suspended = false;
+	init_waitqueue_head(&mxcfb_drv_data.suspend_wq);
+
+	/*
+	 * Allocate memory
+	 */
+	ret = mxcfb_map_video_memory(fbi);
+	if (ret < 0) {
+		goto err1;
+	}
+
+	mxcfb_init_panel(fbi);
+
+	/*
+	 * Register framebuffer
+	 */
+	ret = register_framebuffer(fbi);
+	if (ret < 0) {
+		goto err2;
+	}
+
+	dev_info(&pdev->dev, "%s registered\n", MXCFB_NAME);
+
+	return 0;
+
+      err2:
+	mxcfb_unmap_video_memory(fbi);
+      err1:
+	if (&fbi->cmap)
+		fb_dealloc_cmap(&fbi->cmap);
+	framebuffer_release(fbi);
+      err0:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+/*!
+ * Power management hooks.      Note that we won't be called from IRQ context,
+ * unlike the blank functions above, so we may sleep.
+ */
+
+/*!
+ * Suspends the framebuffer and blanks the screen. Power management support
+ *
+ * @param	pdev	pointer to device structure.
+ * @param	state	state of the device.
+ *
+ * @return	success
+ */
+static int mxcfb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct fb_info *fbi = drv_data->fbi;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	drv_data->suspended = true;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK)
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	pmic_bklit_set_current(BACKLIGHT_LED1, 0);
+	pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 0);
+#endif
+	/* Display OFF */
+	ipu_adc_write_cmd(mxc_fbi->disp_num, CMD, DISOFF, 0, 0);
+
+	return 0;
+}
+
+/*!
+ * Resumes the framebuffer and unblanks the screen. Power management support
+ *
+ * @param       pdev     pointer to device structure.
+ *
+ * @return      success
+ */
+static int mxcfb_resume(struct platform_device *pdev)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct fb_info *fbi = drv_data->fbi;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	// Display ON
+	ipu_adc_write_cmd(mxc_fbi->disp_num, CMD, DISON, 0, 0);
+	drv_data->suspended = false;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK)
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_DEFAULT, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	pmic_bklit_set_current(BACKLIGHT_LED1, drv_data->backlight_level);
+	pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 15);
+#endif
+	wake_up_interruptible(&drv_data->suspend_wq);
+
+	return 0;
+}
+#else
+#define mxcfb_suspend   NULL
+#define mxcfb_resume    NULL
+#endif
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcfb_driver = {
+	.driver = {
+		   .name = MXCFB_NAME,
+		   },
+	.probe = mxcfb_probe,
+	.suspend = mxcfb_suspend,
+	.resume = mxcfb_resume,
+};
+
+/*!
+ * Device definition for the Framebuffer
+ */
+static struct platform_device mxcfb_device = {
+	.name = MXCFB_NAME,
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = 0xFFFFFFFF,
+		}
+};
+
+/*!
+ * Main entry function for the framebuffer. The function registers the power
+ * management callback functions with the kernel and also registers the MXCFB
+ * callback functions with the core Linux framebuffer driver \b fbmem.c
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&mxcfb_driver);
+	if (ret == 0) {
+		ret = platform_device_register(&mxcfb_device);
+		if (ret != 0) {
+			platform_driver_unregister(&mxcfb_driver);
+		}
+	}
+	return ret;
+}
+
+static void mxcfb_exit(void)
+{
+	struct fb_info *fbi = dev_get_drvdata(&mxcfb_device.dev);
+
+	if (fbi) {
+		mxcfb_unmap_video_memory(fbi);
+
+		if (&fbi->cmap)
+			fb_dealloc_cmap(&fbi->cmap);
+
+		unregister_framebuffer(fbi);
+		framebuffer_release(fbi);
+	}
+
+	platform_device_unregister(&mxcfb_device);
+	platform_driver_unregister(&mxcfb_driver);
+}
+
+module_init(mxcfb_init);
+module_exit(mxcfb_exit);
+
+EXPORT_SYMBOL(mxcfb_set_refresh_mode);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC Epson framebuffer driver");
+MODULE_SUPPORTED_DEVICE("fb");
--- linux-2.6.19.2/drivers/video/mxc/mxcfb_modedb.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/mxcfb_modedb.c	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/kernel.h>
+#include <asm/arch/mxcfb.h>
+
+const struct fb_videomode mxcfb_modedb[] = {
+	[0] = {
+	       /* 240x320 @ 60 Hz */
+	       "Sharp-QVGA", 60, 240, 320, 185925, 9, 16, 7, 9, 1, 1,
+	       FB_SYNC_HOR_HIGH_ACT | FB_SYNC_SHARP_MODE |
+	       FB_SYNC_CLK_INVERT | FB_SYNC_DATA_INVERT | FB_SYNC_CLK_IDLE_EN,
+	       FB_VMODE_NONINTERLACED,
+	       0,
+	       },
+	[1] = {
+	       /* 640x480 @ 60 Hz */
+	       "NEC-VGA", 60, 640, 480, 38255, 144, 0, 34, 40, 1, 1,
+	       FB_SYNC_VERT_HIGH_ACT | FB_SYNC_OE_ACT_HIGH,
+	       FB_VMODE_NONINTERLACED,
+	       0,
+	       },
+	[2] = {
+	       /* NTSC TV output */
+	       "TV-NTSC", 60, 640, 480, 37538,
+	       38, 858 - 640 - 38 - 3,
+	       36, 518 - 480 - 36 - 1,
+	       3, 1,
+	       0,
+	       FB_VMODE_NONINTERLACED,
+	       0,
+	       },
+	[3] = {
+	       /* PAL TV output */
+	       "TV-PAL", 50, 640, 480, 37538,
+	       38, 960 - 640 - 38 - 32,
+	       32, 555 - 480 - 32 - 3,
+	       32, 3,
+	       0,
+	       FB_VMODE_NONINTERLACED,
+	       0,
+	       },
+	[4] = {
+	       /* TV output VGA mode, 640x480 @ 65 Hz */
+	       "TV-VGA", 60, 640, 480, 40574, 35, 45, 9, 1, 46, 5,
+	       0, FB_VMODE_NONINTERLACED, 0,
+	       },
+};
+
+int mxcfb_modedb_sz = ARRAY_SIZE(mxcfb_modedb);
--- linux-2.6.19.2/drivers/video/mxc/mxcfb_sharp_128x128.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/mxcfb_sharp_128x128.c	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,1259 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxcfb_sharp_128x128.c
+ *
+ * @brief MXC Frame buffer driver for Sharp 128x128 panel
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/uaccess.h>
+#include <asm/arch/ipu.h>
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+#include <asm/arch/pmic_power.h>
+#include <asm/arch/pmic_light.h>
+#endif
+
+#include <asm/arch/mxcfb.h>
+
+//#define PARTIAL_REFRESH
+#define MXCFB_REFRESH_DEFAULT MXCFB_REFRESH_AUTO
+/*
+ * Driver name
+ */
+#define MXCFB_NAME      "mxcfb_sharp_128"
+
+#define MXCFB_SCREEN_TOP_OFFSET         0
+#define MXCFB_SCREEN_LEFT_OFFSET        2
+#define MXCFB_SCREEN_WIDTH              128
+#define MXCFB_SCREEN_HEIGHT             128
+
+/*!
+ * Enum defining panel commands.
+ */
+enum {
+	SWRESET = 0x01,
+	DISON = 0x29,
+	DISOFF = 0x28,
+	DISCTL = 0xB6,
+	TMPGRD = 0xB7,
+	SD_CSET = 0x2A,
+	SD_PSET = 0x2B,
+	SLPIN = 0x10,
+	SLPOUT = 0x11,
+	DISINOFF = 0x20,
+	RAMWR = 0x2C,
+	MADCTL = 0x36,
+	COLMOD = 0x3A,
+	GCPSET0 = 0xB3,
+	FRSET = 0xB1,
+	VOLCTL = 0xBA,
+	WRCNTR = 0x25,
+	GAMSET = 0x26,
+	DRPOS = 0xBB,
+	PAGEND = 0xBE,
+	MODSEL = 0xC0,
+	COLEND = 0xC3,
+};
+
+struct mxcfb_info {
+	int open_count;
+	int blank;
+	uint32_t disp_num;
+
+	u32 pseudo_palette[16];
+
+	int32_t cur_update_mode;
+	dma_addr_t alloc_start_paddr;
+	void *alloc_start_vaddr;
+	u32 alloc_size;
+	uint32_t snoop_window_size;
+};
+
+struct mxcfb_data {
+	struct fb_info *fbi;
+	volatile int32_t vsync_flag;
+	wait_queue_head_t vsync_wq;
+	wait_queue_head_t suspend_wq;
+	bool suspended;
+	int backlight_level;
+};
+
+static struct mxcfb_data mxcfb_drv_data;
+static unsigned long default_bpp = 16;
+
+void slcd_gpio_config(void);
+extern void gpio_lcd_active(void);
+static int mxcfb_blank(int blank, struct fb_info *fbi);
+
+static uint32_t bpp_to_pixfmt(int bpp)
+{
+	uint32_t pixfmt = 0;
+	switch (bpp) {
+	case 24:
+		pixfmt = IPU_PIX_FMT_BGR24;
+		break;
+	case 32:
+		pixfmt = IPU_PIX_FMT_BGR32;
+		break;
+	case 16:
+		pixfmt = IPU_PIX_FMT_RGB565;
+		break;
+	}
+	return pixfmt;
+}
+
+/*!
+ * This function sets display region in the panel
+ *
+ * @param        disp    display panel to config
+ * @param	 x1	 x-coordinate of one vertex.
+ * @param	 x2	 x-coordinate of second vertex.
+ * @param	 y1	 y-coordinate of one vertex.
+ * @param	 y2	 y-coordinate of second vertex.
+ */
+static void set_panel_region(int disp, uint32_t x1, uint32_t x2,
+			     uint32_t y1, uint32_t y2)
+{
+	uint32_t param[4];
+
+	param[0] = x1;
+	param[1] = x2;
+	param[2] = y1;
+	param[3] = y2;
+
+	// SD_CSET
+	ipu_adc_write_cmd(disp, CMD, SD_CSET, param, 2);
+	// SD_PSET
+
+	ipu_adc_write_cmd(disp, CMD, SD_PSET, &(param[2]), 2);
+}
+
+/*!
+ * Function to create and initiate template command buffer for ADC. This
+ * template will be written to Panel memory.
+ */
+static void init_channel_template(int disp)
+{
+	/* template command buffer for ADC is 32 */
+	uint32_t tempCmd[TEMPLATE_BUF_SIZE];
+	uint32_t i = 0;
+
+	memset(tempCmd, 0, sizeof(uint32_t) * TEMPLATE_BUF_SIZE);
+	/* setup update display region */
+	/* whole the screen during init */
+	/*WRITE Y COORDINATE CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, SD_PSET);
+	/*WRITE Y START ADDRESS CMND LSB[22:8] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_YADDR, 1, SINGLE_STEP, 0x01);
+	/*WRITE Y STOP ADDRESS CMND */
+	tempCmd[i++] =
+	    ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP,
+				 MXCFB_SCREEN_HEIGHT - 1);
+	/*WRITE X COORDINATE CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, SD_CSET);
+	/*WRITE X ADDRESS CMND LSB[7:0] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_XADDR, 1, SINGLE_STEP, 0x01);
+	/*WRITE X STOP ADDRESS CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 1, SINGLE_STEP,
+					    MXCFB_SCREEN_WIDTH +
+					    MXCFB_SCREEN_LEFT_OFFSET - 1);
+	/*WRITE MEMORY CMND MSB */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, RAMWR);
+	/*WRITE DATA CMND and STP */
+	tempCmd[i++] = ipu_adc_template_gen(WR_DATA, 1, STOP, 0);
+
+	ipu_adc_write_template(disp, tempCmd, true);
+}
+
+/*!
+ * Function to initialize the panel. First it resets the panel and then
+ * initilizes panel.
+ */
+static void _init_panel(int disp)
+{
+	uint32_t cmd_param[2];
+	uint32_t disctl_param[] = { 0x0C, 0x48, 0x20 };
+	uint32_t gcpset0_param[] = {
+		0xAF, 0x92, 0x83, 0x24,
+		0x52, 0x94, 0x4A, 0x47,
+		0xAB, 0x75, 0x6A, 0xDF,
+		0xAB, 0x4B, 0xA5, 0x54,
+		0x00
+	};
+	uint32_t i;
+
+	(void)gcpset0_param;
+
+	gpio_lcd_active();
+
+	ipu_adc_write_cmd(disp, CMD, SWRESET, 0, 0);
+	msleep(1);
+
+	ipu_adc_write_cmd(disp, CMD, DISCTL, disctl_param, 3);
+
+	// 16-bit 565 mode
+	cmd_param[0] = 0x05;
+	ipu_adc_write_cmd(disp, CMD, COLMOD, cmd_param, 1);
+
+	cmd_param[0] = 0x01;
+	ipu_adc_write_cmd(disp, CMD, TMPGRD, cmd_param, 1);
+
+	cmd_param[0] = 0x2F;
+	cmd_param[1] = 0x02;
+	ipu_adc_write_cmd(disp, CMD, VOLCTL, cmd_param, 2);
+
+	cmd_param[0] = 0x3F;
+	ipu_adc_write_cmd(disp, CMD, WRCNTR, cmd_param, 1);
+
+	cmd_param[0] = 0x00;
+	ipu_adc_write_cmd(disp, CMD, DRPOS, cmd_param, 1);
+
+	cmd_param[0] = 0x00;
+	ipu_adc_write_cmd(disp, CMD, MADCTL, cmd_param, 1);
+
+	cmd_param[0] = 0x05;
+	ipu_adc_write_cmd(disp, CMD, FRSET, cmd_param, 1);
+
+	cmd_param[0] = 0x80;
+	ipu_adc_write_cmd(disp, CMD, PAGEND, cmd_param, 1);
+
+	cmd_param[0] = 0x01;
+	ipu_adc_write_cmd(disp, CMD, GAMSET, cmd_param, 1);
+
+	cmd_param[0] = 0x04;
+	ipu_adc_write_cmd(disp, CMD, MODSEL, cmd_param, 1);
+
+	// Sleep OUT
+	ipu_adc_write_cmd(disp, CMD, SLPOUT, 0, 0);
+
+	// Set display to white
+	// Setup page and column addresses
+	set_panel_region(disp, MXCFB_SCREEN_LEFT_OFFSET,
+			 MXCFB_SCREEN_WIDTH + MXCFB_SCREEN_LEFT_OFFSET - 1,
+			 0, MXCFB_SCREEN_HEIGHT - 1);
+	// Do RAM write cmd
+	ipu_adc_write_cmd(disp, CMD, RAMWR, 0, 0);
+	for (i = 0; i < (MXCFB_SCREEN_WIDTH * MXCFB_SCREEN_HEIGHT); i++) {
+		ipu_adc_write_cmd(disp, DAT, 0xFF, 0, 0);
+		ipu_adc_write_cmd(disp, DAT, 0xFF, 0, 0);
+	}
+
+	msleep(100);
+
+	// Display ON
+	ipu_adc_write_cmd(disp, CMD, DISON, 0, 0);
+
+	pr_debug("initialized panel\n");
+}
+
+#ifdef PARTIAL_REFRESH
+static irqreturn_t mxcfb_sys2_eof_irq_handler(int irq, void *dev_id,
+					      struct pt_regs *regs)
+{
+	ipu_channel_params_t params;
+	struct fb_info *fbi = dev_id;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+	uint32_t stat[2], seg_size;
+	uint32_t lsb, msb;
+	uint32_t update_height, start_line, start_addr, end_line, end_addr;
+	uint32_t stride_pixels = (fbi->fix.line_length * 8) /
+	    fbi->var.bits_per_pixel;
+
+	ipu_adc_get_snooping_status(&stat[0], &stat[1]);
+	//DPRINTK("snoop status = 0x%08X%08X\n", stat[1], stat[0]);
+
+	if (!stat[0] && !stat[1]) {
+		dev_err(fbi->device, "error no bus snooping bits set\n");
+		return IRQ_HANDLED;
+	}
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+
+	lsb = ffs(stat[0]);
+	if (lsb) {
+		lsb--;
+	} else {
+		lsb = ffs(stat[1]);
+		lsb += 32 - 1;
+	}
+	msb = fls(stat[1]);
+	if (msb) {
+		msb += 32;
+	} else {
+		msb = fls(stat[0]);
+	}
+
+	seg_size = mxc_fbi->snoop_window_size / 64;
+
+	start_addr = lsb * seg_size;	// starting address offset
+	start_line = start_addr / fbi->fix.line_length;
+	start_addr = start_line * fbi->fix.line_length;	// Addr aligned to line
+	start_addr += fbi->fix.smem_start;
+
+	end_addr = msb * seg_size;	// ending address offset
+	end_line = end_addr / fbi->fix.line_length;
+	end_line++;
+
+	if (end_line > fbi->var.yres) {
+		end_line = fbi->var.yres;
+	}
+
+	update_height = end_line - start_line;
+	dev_dbg(fbi->device, "updating rows %d to %d, start addr = 0x%08X\n",
+		start_line, end_line, start_addr);
+
+	ipu_uninit_channel(ADC_SYS1);
+	params.adc_sys1.disp = mxc_fbi->disp_num;
+	params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+	params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+	params.adc_sys1.out_top = start_line;
+	ipu_init_channel(ADC_SYS1, &params);
+
+	ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+				bpp_to_pixfmt(fbi->var.bits_per_pixel),
+				MXCFB_SCREEN_WIDTH,
+				update_height,
+				stride_pixels,
+				IPU_ROTATE_NONE, (dma_addr_t) start_addr, 0, 0,
+				0);
+	ipu_enable_channel(ADC_SYS1);
+	ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+	ipu_enable_irq(IPU_IRQ_ADC_SYS1_EOF);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mxcfb_sys1_eof_irq_handler(int irq, void *dev_id,
+					      struct pt_regs *regs)
+{
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_disable_channel(ADC_SYS1, false);
+
+	ipu_enable_channel(ADC_SYS2);
+	ipu_enable_irq(IPU_IRQ_ADC_SYS2_EOF);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/*!
+ * Function to initialize Asynchronous Display Controller. It also initilizes
+ * the ADC System 1 channel. Configure ADC display 0 parallel interface for
+ * the panel.
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static void mxcfb_init_panel(struct fb_info *fbi)
+{
+	int msb;
+	int panel_stride;
+	ipu_channel_params_t params;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	uint32_t pix_fmt = IPU_PIX_FMT_RGB565;
+	ipu_adc_sig_cfg_t sig = { 0, 0, 0, 0, 0, 0, 0, 0,
+		IPU_ADC_BURST_WCS,
+		IPU_ADC_IFC_MODE_SYS80_TYPE2,
+		8, 0, 0, IPU_ADC_SER_NO_RW
+	};
+	mxc_fbi->disp_num = DISP2;
+
+#ifdef PARTIAL_REFRESH
+	if (ipu_request_irq(IPU_IRQ_ADC_SYS2_EOF, mxcfb_sys2_eof_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering SYS2 irq handler.\n");
+		return;
+	}
+
+	if (ipu_request_irq(IPU_IRQ_ADC_SYS1_EOF, mxcfb_sys1_eof_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering SYS1 irq handler.\n");
+		return;
+	}
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+#endif
+	// Init DI interface
+	msb = fls(MXCFB_SCREEN_WIDTH);
+	if (!(MXCFB_SCREEN_WIDTH & ((1UL << msb) - 1)))
+		msb--;		// Already aligned to power 2
+	panel_stride = 1UL << msb;
+	ipu_adc_init_panel(mxc_fbi->disp_num,
+			   MXCFB_SCREEN_WIDTH + MXCFB_SCREEN_LEFT_OFFSET,
+			   MXCFB_SCREEN_HEIGHT,
+			   pix_fmt, panel_stride, sig, XY, 0, VsyncInternal);
+
+	ipu_adc_init_ifc_timing(mxc_fbi->disp_num, true,
+				190, 17, 104, 190, 5000000);
+	ipu_adc_init_ifc_timing(mxc_fbi->disp_num, false, 110, 25, 80, 0, 0);
+
+	// Needed to turn on ADC clock for panel init
+	memset(&params, 0, sizeof(params));
+	params.adc_sys2.disp = mxc_fbi->disp_num;
+	params.adc_sys2.ch_mode = WriteTemplateNonSeq;
+	params.adc_sys2.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+	params.adc_sys2.out_top = MXCFB_SCREEN_TOP_OFFSET;
+	ipu_init_channel(ADC_SYS2, &params);
+
+	_init_panel(mxc_fbi->disp_num);
+	init_channel_template(mxc_fbi->disp_num);
+}
+
+static int _mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+				   struct mxcfb_rect *update_region)
+{
+	unsigned long start_addr;
+	int ret_mode;
+	ipu_channel_params_t params;
+	struct mxcfb_rect rect;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+	uint32_t stride_pixels = (fbi->fix.line_length * 8) /
+	    fbi->var.bits_per_pixel;
+	uint32_t memsize = fbi->fix.smem_len;
+
+	if (mxc_fbi->cur_update_mode == mode)
+		return mode;
+
+	ret_mode = mxc_fbi->cur_update_mode;
+
+	ipu_adc_set_update_mode(ADC_SYS2, IPU_ADC_REFRESH_NONE, 0, 0, 0);
+	ipu_disable_channel(ADC_SYS2, true);
+#ifdef PARTIAL_REFRESH
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE, 0, 0, 0);
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+
+	ipu_disable_channel(ADC_SYS1, true);
+	ipu_clear_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_disable_channel(ADC_SYS2, true);
+	ipu_clear_irq(IPU_IRQ_ADC_SYS2_EOF);
+#endif
+//      ipu_adc_get_snooping_status(&dummy, &dummy);
+
+	mxc_fbi->cur_update_mode = mode;
+
+	switch (mode) {
+	case MXCFB_REFRESH_OFF:
+//              if (ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE,
+//                                          0, 0, 0) < 0)
+//                      dev_err(fbi->device, "Error enabling auto refesh.\n");
+		if (ipu_adc_set_update_mode(ADC_SYS2, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+#if 1
+		ipu_init_channel_buffer(ADC_SYS2, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					1, 1, 4,
+					IPU_ROTATE_NONE,
+					fbi->fix.smem_start,
+					fbi->fix.smem_start, 0, 0);
+		ipu_enable_channel(ADC_SYS2);
+		ipu_select_buffer(ADC_SYS2, IPU_INPUT_BUFFER, 0);
+		ipu_select_buffer(ADC_SYS2, IPU_INPUT_BUFFER, 1);
+		msleep(10);
+#endif
+#ifdef PARTIAL_REFRESH
+		ipu_uninit_channel(ADC_SYS2);
+#endif
+		break;
+	case MXCFB_REFRESH_PARTIAL:
+#ifdef PARTIAL_REFRESH
+		params.adc_sys2.disp = mxc_fbi->disp_num;
+		params.adc_sys2.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys2.out_left = 0;
+		params.adc_sys2.out_top = 0;
+		ipu_init_channel(ADC_SYS2, &params);
+
+		if (ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0) {
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		}
+		if (ipu_adc_set_update_mode
+		    (ADC_SYS2, IPU_ADC_AUTO_REFRESH_SNOOP, 30,
+		     fbi->fix.smem_start, &memsize) < 0) {
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		}
+		mxc_fbi->snoop_window_size = memsize;
+
+		ipu_init_channel_buffer(ADC_SYS2, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					1, 1, 4,
+					IPU_ROTATE_NONE,
+					fbi->fix.smem_start, 0, 0, 0);
+
+		params.adc_sys1.disp = mxc_fbi->disp_num;
+		params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+		params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET;
+		ipu_init_channel(ADC_SYS1, &params);
+
+		ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					MXCFB_SCREEN_WIDTH, MXCFB_SCREEN_HEIGHT,
+					stride_pixels, IPU_ROTATE_NONE,
+					fbi->fix.smem_start, 0, 0, 0);
+		ipu_enable_channel(ADC_SYS1);
+		ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+		ipu_enable_irq(IPU_IRQ_ADC_SYS1_EOF);
+		break;
+#endif
+	case MXCFB_REFRESH_AUTO:
+		if (update_region == NULL) {
+			update_region = &rect;
+			rect.top = 0;
+			rect.left = 0;
+			rect.height = MXCFB_SCREEN_HEIGHT;
+			rect.width = MXCFB_SCREEN_WIDTH;
+		}
+		params.adc_sys2.disp = mxc_fbi->disp_num;
+		params.adc_sys2.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys2.out_left = MXCFB_SCREEN_LEFT_OFFSET +
+		    update_region->left;
+		params.adc_sys2.out_top = MXCFB_SCREEN_TOP_OFFSET +
+		    update_region->top;
+		ipu_init_channel(ADC_SYS2, &params);
+
+		// Address aligned to line
+		start_addr = update_region->top * fbi->fix.line_length;
+		start_addr += fbi->fix.smem_start;
+		start_addr += update_region->left * fbi->var.bits_per_pixel / 8;
+
+		ipu_init_channel_buffer(ADC_SYS2, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					update_region->width,
+					update_region->height, stride_pixels,
+					IPU_ROTATE_NONE, start_addr, 0, 0, 0);
+		ipu_enable_channel(ADC_SYS2);
+		ipu_select_buffer(ADC_SYS2, IPU_INPUT_BUFFER, 0);
+
+		if (ipu_adc_set_update_mode
+		    (ADC_SYS2, IPU_ADC_AUTO_REFRESH, 15,
+		     fbi->fix.smem_start, &memsize) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+
+		mxc_fbi->snoop_window_size = memsize;
+
+		break;
+	}
+	return ret_mode;
+}
+
+/*
+ * Open the main framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       user    Set if opened by user or clear if opened by kernel
+ */
+static int mxcfb_open(struct fb_info *fbi, int user)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	if (mxc_fbi->open_count == 0) {
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_power_regulator_on(SW_SW3);
+		pmic_power_regulator_set_lp_mode(SW_SW3, LOW_POWER_CTRL_BY_PIN);
+
+		pmic_bklit_tcled_master_enable();
+		pmic_bklit_enable_edge_slow();
+		pmic_bklit_set_cycle_time(0);
+#endif
+	}
+	mxc_fbi->open_count++;
+
+	retval = mxcfb_blank(FB_BLANK_UNBLANK, fbi);
+	return retval;
+}
+
+/*
+ * Close the main framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       user    Set if opened by user or clear if opened by kernel
+ */
+static int mxcfb_release(struct fb_info *fbi, int user)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	--mxc_fbi->open_count;
+	if (mxc_fbi->open_count == 0) {
+		retval = mxcfb_blank(FB_BLANK_POWERDOWN, fbi);
+/*
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_power_regulator_off(SW_SW3);
+		pmic_power_regulator_set_lp_mode(SW_SW3, LOW_POWER_CTRL_BY_PIN);
+#endif
+*/
+	}
+	return retval;
+}
+
+/*
+ * Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	// Set framebuffer id to IPU display number.
+	strcpy(fix->id, "DISP0 FB");
+	fix->id[4] = '0' + mxc_fbi->disp_num;
+
+	// Init settings based on the panel size
+	fix->line_length = MXCFB_SCREEN_WIDTH * var->bits_per_pixel / 8;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 0;
+	fix->ypanstep = 0;
+
+	return 0;
+}
+
+/*
+ * Set framebuffer parameters and change the operating mode.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_par(struct fb_info *fbi)
+{
+	int retval = 0;
+	int mode;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mode = _mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+
+	mxcfb_set_fix(fbi);
+
+	if (mode != MXCFB_REFRESH_OFF) {
+#ifdef PARTIAL_REFRESH
+		_mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_PARTIAL, NULL);
+#else
+		_mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_AUTO, NULL);
+#endif
+	}
+	return 0;
+}
+
+/*
+ * Check framebuffer variable parameters and adjust to valid values.
+ *
+ * @param       var      framebuffer variable parameters
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)
+{
+	if (var->xres > MXCFB_SCREEN_WIDTH)
+		var->xres = MXCFB_SCREEN_WIDTH;
+	if (var->yres > MXCFB_SCREEN_HEIGHT)
+		var->yres = MXCFB_SCREEN_HEIGHT;
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&
+	    (var->bits_per_pixel != 16)) {
+		var->bits_per_pixel = default_bpp;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		var->red.length = 5;
+		var->red.offset = 11;
+		var->red.msb_right = 0;
+
+		var->green.length = 6;
+		var->green.offset = 5;
+		var->green.msb_right = 0;
+
+		var->blue.length = 5;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 24:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 32:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		var->transp.msb_right = 0;
+		break;
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+	var->nonstd = 0;
+
+	var->pixclock = -1;
+	var->left_margin = -1;
+	var->right_margin = -1;
+	var->upper_margin = -1;
+	var->lower_margin = -1;
+	var->hsync_len = -1;
+	var->vsync_len = -1;
+
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->sync = 0;
+
+	return 0;
+}
+
+static inline u_int _chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int
+mxcfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+		u_int trans, struct fb_info *fbi)
+{
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fbi->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (fbi->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fbi->pseudo_palette;
+
+			val = _chan_to_field(red, &fbi->var.red);
+			val |= _chan_to_field(green, &fbi->var.green);
+			val |= _chan_to_field(blue, &fbi->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Function to handle custom ioctls for MXC framebuffer.
+ *
+ * @param       inode   inode struct
+ *
+ * @param       file    file struct
+ *
+ * @param       cmd     Ioctl command to handle
+ *
+ * @param       arg     User pointer to command arguments
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	switch (cmd) {
+	case MXCFB_SET_BRIGHTNESS:
+		{
+			uint8_t level;
+			if (copy_from_user(&level, (void *)arg, sizeof(level))) {
+				retval = -EFAULT;
+				break;
+			}
+			mxcfb_drv_data.backlight_level = level;
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+			pmic_bklit_set_current(BACKLIGHT_LED2,
+					       mxcfb_drv_data.backlight_level);
+			pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 15);
+#endif
+			dev_dbg(fbi->device, "Set brightness to %d\n", level);
+			break;
+		}
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*
+ * mxcfb_blank():
+ *      Blank the display.
+ */
+static int mxcfb_blank(int blank, struct fb_info *fbi)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	dev_dbg(fbi->device, "blank = %d\n", blank);
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		_mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_bklit_set_current(BACKLIGHT_LED2, 0);
+		pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 0);
+#endif
+		break;
+	case FB_BLANK_UNBLANK:
+		_mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_DEFAULT, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_bklit_set_current(BACKLIGHT_LED2, 7);
+		pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 15);
+#endif
+		break;
+	}
+	return 0;
+}
+
+/*!
+ * This structure contains the pointers to the control functions that are
+ * invoked by the core framebuffer driver to perform operations like
+ * blitting, rectangle filling, copy regions and cursor definition.
+ */
+static struct fb_ops mxcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = mxcfb_open,
+	.fb_release = mxcfb_release,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank,
+	.fb_ioctl = mxcfb_ioctl,
+};
+
+/*!
+ * Allocates the DRAM memory for the frame buffer.      This buffer is remapped
+ * into a non-cached, non-buffered, memory region to allow palette and pixel
+ * writes to occur without flushing the cache.  Once this area is remapped,
+ * all virtual memory access to the video memory should occur at the new region.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_map_video_memory(struct fb_info *fbi)
+{
+	u32 msb;
+	u32 offset;
+	struct mxcfb_info *mxcfbi = fbi->par;
+
+	fbi->fix.smem_len = fbi->var.xres_virtual * fbi->var.yres_virtual * 4;
+
+	// Set size to power of 2.
+	msb = fls(fbi->fix.smem_len);
+	if (!(fbi->fix.smem_len & ((1UL << msb) - 1)))
+		msb--;		// Already aligned to power 2
+	if (msb < 11)
+		msb = 11;
+	mxcfbi->alloc_size = (1UL << msb) * 2;
+
+	mxcfbi->alloc_start_vaddr = dma_alloc_coherent(fbi->device,
+						       mxcfbi->alloc_size,
+						       &mxcfbi->
+						       alloc_start_paddr,
+						       GFP_KERNEL | GFP_DMA);
+
+	if (mxcfbi->alloc_start_vaddr == 0) {
+		dev_err(fbi->device, "Unable to allocate framebuffer memory\n");
+		return -ENOMEM;
+	}
+	dev_dbg(fbi->device, "allocated fb memory @ paddr=0x%08X, size=%d.\n",
+		(uint32_t) mxcfbi->alloc_start_paddr, mxcfbi->alloc_size);
+
+	offset =
+	    ((mxcfbi->alloc_size / 2) - 1) & ~((mxcfbi->alloc_size / 2) - 1);
+	fbi->fix.smem_start = mxcfbi->alloc_start_paddr + offset;
+	dev_dbg(fbi->device, "aligned fb start @ paddr=0x%08lX, size=%u.\n",
+		fbi->fix.smem_start, fbi->fix.smem_len);
+
+	fbi->screen_base = mxcfbi->alloc_start_vaddr + offset;
+
+	/* Clear the screen */
+	memset(fbi->screen_base, 0, fbi->fix.smem_len);
+	return 0;
+}
+
+/*!
+ * De-allocates the DRAM memory for the frame buffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_unmap_video_memory(struct fb_info *fbi)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	dma_free_coherent(fbi->device, mxc_fbi->alloc_size,
+			  mxc_fbi->alloc_start_vaddr,
+			  mxc_fbi->alloc_start_paddr);
+	return 0;
+}
+
+/*!
+ * Initializes the framebuffer information pointer. After allocating
+ * sufficient memory for the framebuffer structure, the fields are
+ * filled with custom information passed in from the configurable
+ * structures.  This includes information such as bits per pixel,
+ * color maps, screen width/height and RGBA offsets.
+ *
+ * @return      Framebuffer structure initialized with our information
+ */
+static struct fb_info *mxcfb_init_fbinfo(struct device *dev, struct fb_ops *ops)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+
+	/*
+	 * Allocate sufficient memory for the fb structure
+	 */
+	fbi = framebuffer_alloc(sizeof(struct mxcfb_info), dev);
+	if (!fbi)
+		return NULL;
+
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	/*
+	 * Fill in fb_info structure information
+	 */
+	fbi->var.xres = fbi->var.xres_virtual = MXCFB_SCREEN_WIDTH;
+	fbi->var.yres = fbi->var.yres_virtual = MXCFB_SCREEN_HEIGHT;
+	fbi->var.activate = FB_ACTIVATE_NOW;
+	mxcfb_check_var(&fbi->var, fbi);
+
+	mxcfbi->disp_num = DISP2;
+	mxcfb_set_fix(fbi);
+
+	fbi->fbops = ops;
+	fbi->flags = FBINFO_FLAG_DEFAULT;
+	fbi->pseudo_palette = mxcfbi->pseudo_palette;
+
+	/*
+	 * Allocate colormap
+	 */
+	fb_alloc_cmap(&fbi->cmap, 16, 0);
+
+	return fbi;
+}
+
+/*!
+ * Probe routine for the framebuffer driver. It is called during the
+ * driver binding process.      The following functions are performed in
+ * this routine: Framebuffer initialization, Memory allocation and
+ * mapping, Framebuffer registration, IPU initialization.
+ *
+ * @return      Appropriate error code to the kernel common code
+ */
+static int mxcfb_probe(struct platform_device *pdev)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxc_fbi;
+	int ret;
+
+	platform_set_drvdata(pdev, &mxcfb_drv_data);
+
+	/*
+	 * Initialize FB structures
+	 */
+	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
+	if (!fbi) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+	mxcfb_drv_data.fbi = fbi;
+	mxc_fbi = fbi->par;
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	mxcfb_drv_data.backlight_level = 7;
+#endif
+	mxcfb_drv_data.suspended = false;
+	init_waitqueue_head(&mxcfb_drv_data.suspend_wq);
+
+	/*
+	 * Allocate memory
+	 */
+	ret = mxcfb_map_video_memory(fbi);
+	if (ret < 0) {
+		goto err1;
+	}
+
+	mxcfb_init_panel(fbi);
+
+	/*
+	 * Register framebuffer
+	 */
+	ret = register_framebuffer(fbi);
+	if (ret < 0) {
+		goto err2;
+	}
+
+	dev_info(&pdev->dev, "%s registered\n", MXCFB_NAME);
+
+	return 0;
+
+      err2:
+	mxcfb_unmap_video_memory(fbi);
+      err1:
+	if (&fbi->cmap)
+		fb_dealloc_cmap(&fbi->cmap);
+	framebuffer_release(fbi);
+      err0:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+/*!
+ * Power management hooks.      Note that we won't be called from IRQ context,
+ * unlike the blank functions above, so we may sleep.
+ */
+
+/*!
+ * Suspends the framebuffer and blanks the screen. Power management support
+ *
+ * @param	pdev	pointer to device structure.
+ * @param	state	state of the device.
+ *
+ * @return	success
+ */
+static int mxcfb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct fb_info *fbi = drv_data->fbi;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	drv_data->suspended = true;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK)
+		_mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	pmic_bklit_set_current(BACKLIGHT_LED2, 0);
+	pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 0);
+#endif
+	/* Display OFF */
+	ipu_adc_write_cmd(mxc_fbi->disp_num, CMD, DISOFF, 0, 0);
+
+	return 0;
+}
+
+/*!
+ * Resumes the framebuffer and unblanks the screen. Power management support
+ *
+ * @param       pdev     pointer to device structure.
+ *
+ * @return      success
+ */
+static int mxcfb_resume(struct platform_device *pdev)
+{
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct fb_info *fbi = drv_data->fbi;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	// Display ON
+	ipu_adc_write_cmd(mxc_fbi->disp_num, CMD, DISON, 0, 0);
+	drv_data->suspended = false;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK)
+		_mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_DEFAULT, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	pmic_bklit_set_current(BACKLIGHT_LED2, drv_data->backlight_level);
+	pmic_bklit_set_dutycycle(BACKLIGHT_LED2, 15);
+#endif
+	wake_up_interruptible(&drv_data->suspend_wq);
+
+	return 0;
+}
+#else
+#define mxcfb_suspend   NULL
+#define mxcfb_resume    NULL
+#endif
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcfb_driver = {
+	.driver = {
+		   .name = MXCFB_NAME,
+		   },
+	.probe = mxcfb_probe,
+	.suspend = mxcfb_suspend,
+	.resume = mxcfb_resume,
+};
+
+/*!
+ * Device definition for the Framebuffer
+ */
+static struct platform_device mxcfb_device = {
+	.name = MXCFB_NAME,
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = 0xFFFFFFFF,
+		}
+};
+
+/*!
+ * Main entry function for the framebuffer. The function registers the power
+ * management callback functions with the kernel and also registers the MXCFB
+ * callback functions with the core Linux framebuffer driver \b fbmem.c
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&mxcfb_driver);
+	if (ret == 0) {
+		ret = platform_device_register(&mxcfb_device);
+		if (ret != 0) {
+			platform_driver_unregister(&mxcfb_driver);
+		}
+	}
+	return ret;
+}
+
+static void mxcfb_exit(void)
+{
+	struct fb_info *fbi = dev_get_drvdata(&mxcfb_device.dev);
+
+	if (fbi) {
+		mxcfb_unmap_video_memory(fbi);
+
+		if (&fbi->cmap)
+			fb_dealloc_cmap(&fbi->cmap);
+
+		unregister_framebuffer(fbi);
+		framebuffer_release(fbi);
+	}
+
+	platform_device_unregister(&mxcfb_device);
+	platform_driver_unregister(&mxcfb_driver);
+}
+
+module_init(mxcfb_init);
+module_exit(mxcfb_exit);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC Sharp 128x128 framebuffer driver");
+MODULE_SUPPORTED_DEVICE("fb");
+MODULE_LICENSE("GPL");
--- linux-2.6.19.2/drivers/video/mxc/mxcfb_toshiba_qvga.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/drivers/video/mxc/mxcfb_toshiba_qvga.c	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,1298 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxcfb_toshiba_qvga.c
+ *
+ * @brief MXC Frame buffer driver for ADC
+ *
+ * @ingroup Framebuffer
+ */
+
+/*!
+ * Include files
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach-types.h>
+#include <asm/uaccess.h>
+#include <asm/arch/ipu.h>
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+#include <asm/arch/pmic_power.h>
+#include <asm/arch/pmic_light.h>
+#endif
+
+#include <asm/arch/mxcfb.h>
+
+//#define PARTIAL_REFRESH
+#define MXCFB_REFRESH_DEFAULT MXCFB_REFRESH_AUTO
+/*
+ * Driver name
+ */
+#define MXCFB_NAME      "mxcfb_toshiba_qvga"
+
+#define MXCFB_SCREEN_TOP_OFFSET         0
+#define MXCFB_SCREEN_LEFT_OFFSET        0
+#define MXCFB_SCREEN_WIDTH              240
+#define MXCFB_SCREEN_HEIGHT             320
+
+struct mxcfb_info {
+	int open_count;
+	int blank;
+	uint32_t disp_num;
+
+	u32 pseudo_palette[16];
+
+	int32_t cur_update_mode;
+	dma_addr_t alloc_start_paddr;
+	void *alloc_start_vaddr;
+	u32 alloc_size;
+	uint32_t snoop_window_size;
+};
+
+struct mxcfb_data {
+	struct fb_info *fbi;
+	volatile int32_t vsync_flag;
+	wait_queue_head_t vsync_wq;
+	wait_queue_head_t suspend_wq;
+	bool suspended;
+	int backlight_level;
+};
+
+static struct mxcfb_data mxcfb_drv_data;
+static unsigned long default_bpp = 16;
+
+void slcd_gpio_config(void);
+extern void gpio_lcd_active(void);
+static int mxcfb_blank(int blank, struct fb_info *fbi);
+
+static uint32_t bpp_to_pixfmt(int bpp)
+{
+	uint32_t pixfmt = 0;
+	switch (bpp) {
+	case 24:
+		pixfmt = IPU_PIX_FMT_BGR24;
+		break;
+	case 32:
+		pixfmt = IPU_PIX_FMT_BGR32;
+		break;
+	case 16:
+		pixfmt = IPU_PIX_FMT_RGB565;
+		break;
+	}
+	return pixfmt;
+}
+
+/*!
+ * Function to create and initiate template command buffer for ADC. This
+ * template will be written to Panel memory.
+ */
+static void init_channel_template(int disp)
+{
+	/* template command buffer for ADC is 32 */
+	uint32_t tempCmd[TEMPLATE_BUF_SIZE];
+	uint32_t i = 0;
+
+	memset(tempCmd, 0, sizeof(uint32_t) * TEMPLATE_BUF_SIZE);
+	/* setup update display region */
+	/* whole the screen during init */
+	/*WRITE Y COORDINATE CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, 0x07);
+	/*WRITE Y START ADDRESS CMND [22:8] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_YADDR, 1, SINGLE_STEP, 0x01);
+	/*WRITE X COORDINATE CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, 0x06);
+	/*WRITE X START ADDRESS CMND [7:0] */
+	tempCmd[i++] = ipu_adc_template_gen(WR_XADDR, 1, SINGLE_STEP, 0x01);
+	/*WRITE RAM CMND */
+	tempCmd[i++] = ipu_adc_template_gen(WR_CMND, 0, SINGLE_STEP, 0x0E);
+	/*WRITE DATA CMND and STP */
+	tempCmd[i++] = ipu_adc_template_gen(WR_DATA, 1, STOP, 0);
+
+	ipu_adc_write_template(disp, tempCmd, true);
+}
+
+/*!
+ * Function to initialize the panel. First it resets the panel and then
+ * initilizes panel.
+ */
+static void _init_panel(int disp)
+{
+	uint32_t cmd_param;
+	uint32_t i;
+
+	// Reset
+	cmd_param = 0x01;
+	ipu_adc_write_cmd(disp, CMD, 0x03, &cmd_param, 1);
+
+	// Turn on oscillator
+	cmd_param = 0x01;
+	ipu_adc_write_cmd(disp, CMD, 0x3A, &cmd_param, 1);
+
+	cmd_param = 0x02;
+	ipu_adc_write_cmd(disp, CMD, 0x32, &cmd_param, 1);
+
+	cmd_param = 0x01;
+	ipu_adc_write_cmd(disp, CMD, 0x33, &cmd_param, 1);
+
+	cmd_param = 0x00;
+	ipu_adc_write_cmd(disp, CMD, 0x37, &cmd_param, 1);
+
+	cmd_param = 0x0FFF;
+	ipu_adc_write_cmd(disp, CMD, 0x77, &cmd_param, 1);
+
+	cmd_param = 0x01;
+	ipu_adc_write_cmd(disp, CMD, 0x72, &cmd_param, 1);
+
+	cmd_param = 0x1C3B;
+	ipu_adc_write_cmd(disp, CMD, 0x1C, &cmd_param, 1);
+
+	cmd_param = 0x21;
+	ipu_adc_write_cmd(disp, CMD, 0x52, &cmd_param, 1);
+
+	cmd_param = 0x11;
+	ipu_adc_write_cmd(disp, CMD, 0x53, &cmd_param, 1);
+
+	cmd_param = 0x79;
+	ipu_adc_write_cmd(disp, CMD, 0x24, &cmd_param, 1);
+
+	cmd_param = 0x79;
+	ipu_adc_write_cmd(disp, CMD, 0x25, &cmd_param, 1);
+
+	cmd_param = 0x10;
+	ipu_adc_write_cmd(disp, CMD, 0x26, &cmd_param, 1);
+
+	cmd_param = 0x10;
+	ipu_adc_write_cmd(disp, CMD, 0x27, &cmd_param, 1);
+
+	cmd_param = 0x28;
+	ipu_adc_write_cmd(disp, CMD, 0x61, &cmd_param, 1);
+
+	cmd_param = 0x1A;
+	ipu_adc_write_cmd(disp, CMD, 0x62, &cmd_param, 1);
+
+	cmd_param = 0x1E;
+	ipu_adc_write_cmd(disp, CMD, 0x63, &cmd_param, 1);
+
+	cmd_param = 0x21;
+	ipu_adc_write_cmd(disp, CMD, 0x64, &cmd_param, 1);
+
+	cmd_param = 0x1B;
+	ipu_adc_write_cmd(disp, CMD, 0x65, &cmd_param, 1);
+
+	cmd_param = 0x29;
+	ipu_adc_write_cmd(disp, CMD, 0x66, &cmd_param, 1);
+
+	cmd_param = 0x205;
+	ipu_adc_write_cmd(disp, CMD, 0x4D, &cmd_param, 1);
+
+	cmd_param = 0x01;
+	ipu_adc_write_cmd(disp, CMD, 0x4E, &cmd_param, 1);
+
+	cmd_param = 0x104;
+	ipu_adc_write_cmd(disp, CMD, 0x4F, &cmd_param, 1);
+
+	cmd_param = 0x2F;
+	ipu_adc_write_cmd(disp, CMD, 0x2E, &cmd_param, 1);
+
+	cmd_param = 0x0;
+	ipu_adc_write_cmd(disp, CMD, 0x29, &cmd_param, 1);
+
+	cmd_param = 0x0;
+	ipu_adc_write_cmd(disp, CMD, 0x2A, &cmd_param, 1);
+
+	cmd_param = 0xEF;
+	ipu_adc_write_cmd(disp, CMD, 0x2B, &cmd_param, 1);
+
+	cmd_param = 0x13F;
+	ipu_adc_write_cmd(disp, CMD, 0x2C, &cmd_param, 1);
+
+	/* Window area setting */
+	cmd_param = 0x0;
+	ipu_adc_write_cmd(disp, CMD, 0x08, &cmd_param, 1);
+	cmd_param = 0xEF;
+	ipu_adc_write_cmd(disp, CMD, 0x09, &cmd_param, 1);
+	cmd_param = 0x0;
+	ipu_adc_write_cmd(disp, CMD, 0x0A, &cmd_param, 1);
+	cmd_param = 0x13F;
+	ipu_adc_write_cmd(disp, CMD, 0x0B, &cmd_param, 1);
+
+	/* Window mode setting */
+	cmd_param = 0x00;
+	ipu_adc_write_cmd(disp, CMD, 0x05, &cmd_param, 1);
+
+	/* Ram address setting */
+	cmd_param = 0x0;
+	ipu_adc_write_cmd(disp, CMD, 0x06, &cmd_param, 1);
+	cmd_param = 0x0;
+	ipu_adc_write_cmd(disp, CMD, 0x07, &cmd_param, 1);
+
+	/* Initialize RAM */
+	ipu_adc_write_cmd(disp, CMD, 0x0E, 0, 0);
+	for (i = 0; i < (MXCFB_SCREEN_WIDTH * MXCFB_SCREEN_HEIGHT); i++)
+		ipu_adc_write_cmd(disp, DAT, 0x3FFFF, 0, 0);
+
+	cmd_param = 0x1F6A;
+	ipu_adc_write_cmd(disp, CMD, 0x18, &cmd_param, 1);
+
+	cmd_param = 0x00A2;
+	ipu_adc_write_cmd(disp, CMD, 0x1A, &cmd_param, 1);
+
+	cmd_param = 0x0028;
+	ipu_adc_write_cmd(disp, CMD, 0x1B, &cmd_param, 1);
+
+	cmd_param = 0x1C3B;
+	ipu_adc_write_cmd(disp, CMD, 0x1C, &cmd_param, 1);
+
+	cmd_param = 0x0075;
+	ipu_adc_write_cmd(disp, CMD, 0x1D, &cmd_param, 1);
+
+	cmd_param = 0x003D;
+	ipu_adc_write_cmd(disp, CMD, 0x1F, &cmd_param, 1);
+
+	cmd_param = 0x0080;
+	ipu_adc_write_cmd(disp, CMD, 0x20, &cmd_param, 1);
+
+	/* DC/DC on */
+	cmd_param = 0x1F6B;
+	ipu_adc_write_cmd(disp, CMD, 0x18, &cmd_param, 1);
+	msleep(100);
+
+	/* VCOM on */
+	cmd_param = 0x0021;
+	ipu_adc_write_cmd(disp, CMD, 0x1E, &cmd_param, 1);
+
+	/* GOE1,GOE2 setting (Gate output enable) */
+	cmd_param = 0x0001;
+	ipu_adc_write_cmd(disp, CMD, 0x3B, &cmd_param, 1);
+
+	cmd_param = 0x00;
+	ipu_adc_write_cmd(disp, CMD, 0x2, &cmd_param, 1);
+	/* Display on */
+	cmd_param = 0x00;
+	ipu_adc_write_cmd(disp, CMD, 0x0, &cmd_param, 1);
+
+	msleep(10);
+
+	pr_debug("initialized panel\n");
+}
+
+#ifdef PARTIAL_REFRESH
+static irqreturn_t mxcfb_sys2_eof_irq_handler(int irq, void *dev_id,
+					      struct pt_regs *regs)
+{
+	ipu_channel_params_t params;
+	struct fb_info *fbi = dev_id;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+	uint32_t stat[2], seg_size;
+	uint32_t lsb, msb;
+	uint32_t update_height, start_line, start_addr, end_line, end_addr;
+	uint32_t stride_pixels = (fbi->fix.line_length * 8) /
+	    fbi->var.bits_per_pixel;
+
+	ipu_adc_get_snooping_status(&stat[0], &stat[1]);
+	//DPRINTK("snoop status = 0x%08X%08X\n", stat[1], stat[0]);
+
+	if (!stat[0] && !stat[1]) {
+		dev_err(fbi->device, "error no bus snooping bits set\n");
+		return IRQ_HANDLED;
+	}
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+
+	lsb = ffs(stat[0]);
+	if (lsb) {
+		lsb--;
+	} else {
+		lsb = ffs(stat[1]);
+		lsb += 32 - 1;
+	}
+	msb = fls(stat[1]);
+	if (msb) {
+		msb += 32;
+	} else {
+		msb = fls(stat[0]);
+	}
+
+	seg_size = mxc_fbi->snoop_window_size / 64;
+
+	start_addr = lsb * seg_size;	// starting address offset
+	start_line = start_addr / fbi->fix.line_length;
+	start_addr = start_line * fbi->fix.line_length;	// Addr aligned to line
+	start_addr += fbi->fix.smem_start;
+
+	end_addr = msb * seg_size;	// ending address offset
+	end_line = end_addr / fbi->fix.line_length;
+	end_line++;
+
+	if (end_line > fbi->var.yres) {
+		end_line = fbi->var.yres;
+	}
+
+	update_height = end_line - start_line;
+	dev_dbg(fbi->device, "updating rows %d to %d, start addr = 0x%08X\n",
+		start_line, end_line, start_addr);
+
+	ipu_uninit_channel(ADC_SYS1);
+	params.adc_sys1.disp = mxc_fbi->disp_num;
+	params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+	params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+	params.adc_sys1.out_top = start_line;
+	ipu_init_channel(ADC_SYS1, &params);
+
+	ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+				bpp_to_pixfmt(fbi->var.bits_per_pixel),
+				MXCFB_SCREEN_WIDTH,
+				update_height,
+				stride_pixels,
+				IPU_ROTATE_NONE, (dma_addr_t) start_addr, 0, 0,
+				0);
+	ipu_enable_channel(ADC_SYS1);
+	ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+	ipu_enable_irq(IPU_IRQ_ADC_SYS1_EOF);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mxcfb_sys1_eof_irq_handler(int irq, void *dev_id,
+					      struct pt_regs *regs)
+{
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_disable_channel(ADC_SYS1, false);
+
+	ipu_enable_channel(ADC_SYS2);
+	ipu_enable_irq(IPU_IRQ_ADC_SYS2_EOF);
+
+	return IRQ_HANDLED;
+}
+#endif
+
+/*!
+ * Function to initialize Asynchronous Display Controller. It also initilizes
+ * the ADC System 1 channel. Configure ADC display 0 parallel interface for
+ * the panel.
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static void mxcfb_init_panel(struct fb_info *fbi)
+{
+	int msb;
+	int panel_stride;
+	ipu_channel_params_t params;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+#ifdef CONFIG_FB_MXC_ASYNC_PANEL_IFC_16_BIT
+	uint32_t pix_fmt = IPU_PIX_FMT_RGB666;
+	ipu_adc_sig_cfg_t sig = { 0, 0, 0, 0, 0, 0, 0, 0,
+		IPU_ADC_BURST_WCS,
+		IPU_ADC_IFC_MODE_SYS80_TYPE2,
+		16, 0, 0, IPU_ADC_SER_NO_RW
+	};
+	mxc_fbi->disp_num = DISP0;
+#elif defined(CONFIG_FB_MXC_ASYNC_PANEL_IFC_8_BIT)
+	uint32_t pix_fmt = IPU_PIX_FMT_RGB666;
+	ipu_adc_sig_cfg_t sig = { 0, 0, 0, 0, 0, 0, 0, 0,
+		IPU_ADC_BURST_WCS,
+		IPU_ADC_IFC_MODE_SYS80_TYPE2,
+		8, 0, 0, IPU_ADC_SER_NO_RW
+	};
+	mxc_fbi->disp_num = DISP0;
+#endif
+
+#ifdef PARTIAL_REFRESH
+	if (ipu_request_irq(IPU_IRQ_ADC_SYS2_EOF, mxcfb_sys2_eof_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering SYS2 irq handler.\n");
+		return;
+	}
+
+	if (ipu_request_irq(IPU_IRQ_ADC_SYS1_EOF, mxcfb_sys1_eof_irq_handler, 0,
+			    MXCFB_NAME, fbi) != 0) {
+		dev_err(fbi->device, "Error registering SYS1 irq handler.\n");
+		return;
+	}
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+#endif
+	// Init DI interface
+	msb = fls(MXCFB_SCREEN_WIDTH);
+	if (!(MXCFB_SCREEN_WIDTH & ((1UL << msb) - 1)))
+		msb--;		// Already aligned to power 2
+	panel_stride = 1UL << msb;
+	ipu_adc_init_panel(mxc_fbi->disp_num,
+			   MXCFB_SCREEN_WIDTH + MXCFB_SCREEN_LEFT_OFFSET,
+			   MXCFB_SCREEN_HEIGHT,
+			   pix_fmt, panel_stride, sig, XY, 0, VsyncInternal);
+
+	ipu_adc_init_ifc_timing(mxc_fbi->disp_num, true,
+				190, 17, 104, 190, 5000000);
+	ipu_adc_init_ifc_timing(mxc_fbi->disp_num, false, 90, 10, 60, 0, 0);
+
+	// Needed to turn on ADC clock for panel init
+	memset(&params, 0, sizeof(params));
+	params.adc_sys1.disp = mxc_fbi->disp_num;
+	params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+	params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+	params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET;
+	ipu_init_channel(ADC_SYS1, &params);
+
+	_init_panel(mxc_fbi->disp_num);
+	init_channel_template(mxc_fbi->disp_num);
+}
+
+int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+			   struct mxcfb_rect *update_region)
+{
+	unsigned long start_addr;
+	int ret_mode;
+	uint32_t dummy;
+	ipu_channel_params_t params;
+	struct mxcfb_rect rect;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+	uint32_t stride_pixels = (fbi->fix.line_length * 8) /
+	    fbi->var.bits_per_pixel;
+	uint32_t memsize = fbi->fix.smem_len;
+
+	if (mxc_fbi->cur_update_mode == mode)
+		return mode;
+
+	ret_mode = mxc_fbi->cur_update_mode;
+
+	ipu_disable_irq(IPU_IRQ_ADC_SYS1_EOF);
+	ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE, 0, 0, 0);
+#ifdef PARTIAL_REFRESH
+	ipu_disable_irq(IPU_IRQ_ADC_SYS2_EOF);
+	ipu_adc_set_update_mode(ADC_SYS2, IPU_ADC_REFRESH_NONE, 0, 0, 0);
+#endif
+
+	ipu_disable_channel(ADC_SYS1, true);
+	ipu_clear_irq(IPU_IRQ_ADC_SYS1_EOF);
+#ifdef PARTIAL_REFRESH
+	ipu_disable_channel(ADC_SYS2, true);
+	ipu_clear_irq(IPU_IRQ_ADC_SYS2_EOF);
+#endif
+	ipu_adc_get_snooping_status(&dummy, &dummy);
+
+	mxc_fbi->cur_update_mode = mode;
+
+	switch (mode) {
+	case MXCFB_REFRESH_OFF:
+		if (ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+//              if (ipu_adc_set_update_mode(ADC_SYS2, IPU_ADC_REFRESH_NONE,
+//                                          0, 0, 0) < 0)
+//                      dev_err(fbi->device, "Error enabling auto refesh.\n");
+#if 0
+		ipu_init_channel_buffer(ADC_SYS2, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					1, 1, 4,
+					IPU_ROTATE_NONE,
+					fbi->fix.smem_start,
+					fbi->fix.smem_start, 0, 0);
+		ipu_enable_channel(ADC_SYS2);
+		ipu_select_buffer(ADC_SYS2, IPU_INPUT_BUFFER, 0);
+		ipu_select_buffer(ADC_SYS2, IPU_INPUT_BUFFER, 1);
+		msleep(10);
+#endif
+#ifdef PARTIAL_REFRESH
+		ipu_uninit_channel(ADC_SYS2);
+#endif
+		break;
+	case MXCFB_REFRESH_PARTIAL:
+#ifdef PARTIAL_REFRESH
+		params.adc_sys2.disp = DISP0;
+		params.adc_sys2.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys2.out_left = 0;
+		params.adc_sys2.out_top = 0;
+		ipu_init_channel(ADC_SYS2, &params);
+
+		if (ipu_adc_set_update_mode(ADC_SYS1, IPU_ADC_REFRESH_NONE,
+					    0, 0, 0) < 0) {
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		}
+		if (ipu_adc_set_update_mode
+		    (ADC_SYS2, IPU_ADC_AUTO_REFRESH_SNOOP, 30,
+		     fbi->fix.smem_start, &memsize) < 0) {
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+		}
+		mxc_fbi->snoop_window_size = memsize;
+
+		ipu_init_channel_buffer(ADC_SYS2, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					1, 1, 4,
+					IPU_ROTATE_NONE,
+					fbi->fix.smem_start, 0, 0, 0);
+
+		params.adc_sys1.disp = mxc_fbi->disp_num;
+		params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET;
+		params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET;
+		ipu_init_channel(ADC_SYS1, &params);
+
+		ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					MXCFB_SCREEN_WIDTH, MXCFB_SCREEN_HEIGHT,
+					stride_pixels, IPU_ROTATE_NONE,
+					fbi->fix.smem_start, 0, 0, 0);
+		ipu_enable_channel(ADC_SYS1);
+		ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+		ipu_enable_irq(IPU_IRQ_ADC_SYS1_EOF);
+		break;
+#endif
+	case MXCFB_REFRESH_AUTO:
+		if (update_region == NULL) {
+			update_region = &rect;
+			rect.top = 0;
+			rect.left = 0;
+			rect.height = MXCFB_SCREEN_HEIGHT;
+			rect.width = MXCFB_SCREEN_WIDTH;
+		}
+		params.adc_sys1.disp = mxc_fbi->disp_num;
+		params.adc_sys1.ch_mode = WriteTemplateNonSeq;
+		params.adc_sys1.out_left = MXCFB_SCREEN_LEFT_OFFSET +
+		    update_region->left;
+		params.adc_sys1.out_top = MXCFB_SCREEN_TOP_OFFSET +
+		    update_region->top;
+		ipu_init_channel(ADC_SYS1, &params);
+
+		// Address aligned to line
+		start_addr = update_region->top * fbi->fix.line_length;
+		start_addr += fbi->fix.smem_start;
+		start_addr += update_region->left * fbi->var.bits_per_pixel / 8;
+
+		ipu_init_channel_buffer(ADC_SYS1, IPU_INPUT_BUFFER,
+					bpp_to_pixfmt(fbi->var.bits_per_pixel),
+					update_region->width,
+					update_region->height, stride_pixels,
+					IPU_ROTATE_NONE, start_addr, 0, 0, 0);
+		ipu_enable_channel(ADC_SYS1);
+		ipu_select_buffer(ADC_SYS1, IPU_INPUT_BUFFER, 0);
+
+		if (ipu_adc_set_update_mode
+		    (ADC_SYS1, IPU_ADC_AUTO_REFRESH_SNOOP, 30,
+		     fbi->fix.smem_start, &memsize) < 0)
+			dev_err(fbi->device, "Error enabling auto refesh.\n");
+
+		mxc_fbi->snoop_window_size = memsize;
+
+		break;
+	}
+	return ret_mode;
+}
+
+/*
+ * Open the main framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       user    Set if opened by user or clear if opened by kernel
+ */
+static int mxcfb_open(struct fb_info *fbi, int user)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	if (mxc_fbi->open_count == 0) {
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_power_regulator_on(SW_SW3);
+		pmic_power_regulator_set_lp_mode(SW_SW3, LOW_POWER_CTRL_BY_PIN);
+
+		pmic_bklit_tcled_master_enable();
+		pmic_bklit_enable_edge_slow();
+		pmic_bklit_set_cycle_time(0);
+#endif
+	}
+	mxc_fbi->open_count++;
+
+	retval = mxcfb_blank(FB_BLANK_UNBLANK, fbi);
+	return retval;
+}
+
+/*
+ * Close the main framebuffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @param       user    Set if opened by user or clear if opened by kernel
+ */
+static int mxcfb_release(struct fb_info *fbi, int user)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	--mxc_fbi->open_count;
+	if (mxc_fbi->open_count == 0) {
+		retval = mxcfb_blank(FB_BLANK_POWERDOWN, fbi);
+/*
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_power_regulator_off(SW_SW3);
+		pmic_power_regulator_set_lp_mode(SW_SW3, LOW_POWER_CTRL_BY_PIN);
+#endif
+*/
+	}
+	return retval;
+}
+
+/*
+ * Set fixed framebuffer parameters based on variable settings.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_fix(struct fb_info *info)
+{
+	struct fb_fix_screeninfo *fix = &info->fix;
+	struct fb_var_screeninfo *var = &info->var;
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)info->par;
+
+	// Set framebuffer id to IPU display number.
+	strcpy(fix->id, "DISP0 FB");
+	fix->id[4] = '0' + mxc_fbi->disp_num;
+
+	// Init settings based on the panel size
+	fix->line_length = MXCFB_SCREEN_WIDTH * var->bits_per_pixel / 8;
+
+	fix->type = FB_TYPE_PACKED_PIXELS;
+	fix->accel = FB_ACCEL_NONE;
+	fix->visual = FB_VISUAL_TRUECOLOR;
+	fix->xpanstep = 0;
+	fix->ypanstep = 0;
+
+	return 0;
+}
+
+/*
+ * Set framebuffer parameters and change the operating mode.
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_set_par(struct fb_info *fbi)
+{
+	int retval = 0;
+	int mode;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mode = mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+
+	mxcfb_set_fix(fbi);
+
+	if (mode != MXCFB_REFRESH_OFF) {
+#ifdef PARTIAL_REFRESH
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_PARTIAL, NULL);
+#else
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_AUTO, NULL);
+#endif
+	}
+	return 0;
+}
+
+/*
+ * Check framebuffer variable parameters and adjust to valid values.
+ *
+ * @param       var      framebuffer variable parameters
+ *
+ * @param       info     framebuffer information pointer
+ */
+static int mxcfb_check_var(struct fb_var_screeninfo *var, struct fb_info *fbi)
+{
+	if (var->xres > MXCFB_SCREEN_WIDTH)
+		var->xres = MXCFB_SCREEN_WIDTH;
+	if (var->yres > MXCFB_SCREEN_HEIGHT)
+		var->yres = MXCFB_SCREEN_HEIGHT;
+	if (var->xres_virtual < var->xres)
+		var->xres_virtual = var->xres;
+	if (var->yres_virtual < var->yres)
+		var->yres_virtual = var->yres;
+
+	if ((var->bits_per_pixel != 32) && (var->bits_per_pixel != 24) &&
+	    (var->bits_per_pixel != 16)) {
+		var->bits_per_pixel = default_bpp;
+	}
+
+	switch (var->bits_per_pixel) {
+	case 16:
+		var->red.length = 5;
+		var->red.offset = 11;
+		var->red.msb_right = 0;
+
+		var->green.length = 6;
+		var->green.offset = 5;
+		var->green.msb_right = 0;
+
+		var->blue.length = 5;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 24:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 0;
+		var->transp.offset = 0;
+		var->transp.msb_right = 0;
+		break;
+	case 32:
+		var->red.length = 8;
+		var->red.offset = 16;
+		var->red.msb_right = 0;
+
+		var->green.length = 8;
+		var->green.offset = 8;
+		var->green.msb_right = 0;
+
+		var->blue.length = 8;
+		var->blue.offset = 0;
+		var->blue.msb_right = 0;
+
+		var->transp.length = 8;
+		var->transp.offset = 24;
+		var->transp.msb_right = 0;
+		break;
+	}
+
+	var->height = -1;
+	var->width = -1;
+	var->grayscale = 0;
+	var->nonstd = 0;
+
+	var->pixclock = -1;
+	var->left_margin = -1;
+	var->right_margin = -1;
+	var->upper_margin = -1;
+	var->lower_margin = -1;
+	var->hsync_len = -1;
+	var->vsync_len = -1;
+
+	var->vmode = FB_VMODE_NONINTERLACED;
+	var->sync = 0;
+
+	return 0;
+}
+
+static inline u_int _chan_to_field(u_int chan, struct fb_bitfield *bf)
+{
+	chan &= 0xffff;
+	chan >>= 16 - bf->length;
+	return chan << bf->offset;
+}
+
+static int
+mxcfb_setcolreg(u_int regno, u_int red, u_int green, u_int blue,
+		u_int trans, struct fb_info *fbi)
+{
+	unsigned int val;
+	int ret = 1;
+
+	/*
+	 * If greyscale is true, then we convert the RGB value
+	 * to greyscale no matter what visual we are using.
+	 */
+	if (fbi->var.grayscale)
+		red = green = blue = (19595 * red + 38470 * green +
+				      7471 * blue) >> 16;
+	switch (fbi->fix.visual) {
+	case FB_VISUAL_TRUECOLOR:
+		/*
+		 * 16-bit True Colour.  We encode the RGB value
+		 * according to the RGB bitfield information.
+		 */
+		if (regno < 16) {
+			u32 *pal = fbi->pseudo_palette;
+
+			val = _chan_to_field(red, &fbi->var.red);
+			val |= _chan_to_field(green, &fbi->var.green);
+			val |= _chan_to_field(blue, &fbi->var.blue);
+
+			pal[regno] = val;
+			ret = 0;
+		}
+		break;
+
+	case FB_VISUAL_STATIC_PSEUDOCOLOR:
+	case FB_VISUAL_PSEUDOCOLOR:
+		break;
+	}
+
+	return ret;
+}
+
+/*
+ * Function to handle custom ioctls for MXC framebuffer.
+ *
+ * @param       inode   inode struct
+ *
+ * @param       file    file struct
+ *
+ * @param       cmd     Ioctl command to handle
+ *
+ * @param       arg     User pointer to command arguments
+ *
+ * @param       fbi     framebuffer information pointer
+ */
+static int mxcfb_ioctl(struct fb_info *fbi, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	switch (cmd) {
+	case MXCFB_SET_BRIGHTNESS:
+		{
+			uint8_t level;
+			if (copy_from_user(&level, (void *)arg, sizeof(level))) {
+				retval = -EFAULT;
+				break;
+			}
+			mxcfb_drv_data.backlight_level = level;
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+			pmic_bklit_set_current(BACKLIGHT_LED1,
+					       mxcfb_drv_data.backlight_level);
+			pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 15);
+#endif
+			dev_dbg(fbi->device, "Set brightness to %d\n", level);
+			break;
+		}
+	default:
+		retval = -EINVAL;
+	}
+	return retval;
+}
+
+/*
+ * mxcfb_blank():
+ *      Blank the display.
+ */
+static int mxcfb_blank(int blank, struct fb_info *fbi)
+{
+	int retval = 0;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	dev_dbg(fbi->device, "blank = %d\n", blank);
+
+	if ((retval = wait_event_interruptible(mxcfb_drv_data.suspend_wq,
+					       (mxcfb_drv_data.suspended ==
+						false))) < 0) {
+		return retval;
+	}
+
+	mxc_fbi->blank = blank;
+
+	switch (blank) {
+	case FB_BLANK_POWERDOWN:
+	case FB_BLANK_VSYNC_SUSPEND:
+	case FB_BLANK_HSYNC_SUSPEND:
+	case FB_BLANK_NORMAL:
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_bklit_set_current(BACKLIGHT_LED1, 0);
+		pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 0);
+#endif
+		break;
+	case FB_BLANK_UNBLANK:
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_DEFAULT, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+		pmic_bklit_set_current(BACKLIGHT_LED1, 7);
+		pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 15);
+#endif
+		break;
+	}
+	return 0;
+}
+
+/*!
+ * This structure contains the pointers to the control functions that are
+ * invoked by the core framebuffer driver to perform operations like
+ * blitting, rectangle filling, copy regions and cursor definition.
+ */
+static struct fb_ops mxcfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_open = mxcfb_open,
+	.fb_release = mxcfb_release,
+	.fb_set_par = mxcfb_set_par,
+	.fb_check_var = mxcfb_check_var,
+	.fb_setcolreg = mxcfb_setcolreg,
+	.fb_fillrect = cfb_fillrect,
+	.fb_copyarea = cfb_copyarea,
+	.fb_imageblit = cfb_imageblit,
+	.fb_blank = mxcfb_blank,
+	.fb_ioctl = mxcfb_ioctl,
+};
+
+/*!
+ * Allocates the DRAM memory for the frame buffer.      This buffer is remapped
+ * into a non-cached, non-buffered, memory region to allow palette and pixel
+ * writes to occur without flushing the cache.  Once this area is remapped,
+ * all virtual memory access to the video memory should occur at the new region.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_map_video_memory(struct fb_info *fbi)
+{
+	u32 msb;
+	u32 offset;
+	struct mxcfb_info *mxcfbi = fbi->par;
+
+	fbi->fix.smem_len = fbi->var.xres_virtual * fbi->var.yres_virtual * 4;
+
+	// Set size to power of 2.
+	msb = fls(fbi->fix.smem_len);
+	if (!(fbi->fix.smem_len & ((1UL << msb) - 1)))
+		msb--;		// Already aligned to power 2
+	if (msb < 11)
+		msb = 11;
+	mxcfbi->alloc_size = (1UL << msb) * 2;
+
+	mxcfbi->alloc_start_vaddr = dma_alloc_coherent(fbi->device,
+						       mxcfbi->alloc_size,
+						       &mxcfbi->
+						       alloc_start_paddr,
+						       GFP_KERNEL | GFP_DMA);
+
+	if (mxcfbi->alloc_start_vaddr == 0) {
+		dev_err(fbi->device, "Unable to allocate framebuffer memory\n");
+		return -ENOMEM;
+	}
+	dev_dbg(fbi->device, "allocated fb memory @ paddr=0x%08X, size=%d.\n",
+		(uint32_t) mxcfbi->alloc_start_paddr, mxcfbi->alloc_size);
+
+	offset =
+	    ((mxcfbi->alloc_size / 2) - 1) & ~((mxcfbi->alloc_size / 2) - 1);
+	fbi->fix.smem_start = mxcfbi->alloc_start_paddr + offset;
+	dev_dbg(fbi->device, "aligned fb start @ paddr=0x%08lX, size=%u.\n",
+		fbi->fix.smem_start, fbi->fix.smem_len);
+
+	fbi->screen_base = mxcfbi->alloc_start_vaddr + offset;
+
+	/* Clear the screen */
+	memset(fbi->screen_base, 0, fbi->fix.smem_len);
+	return 0;
+}
+
+/*!
+ * De-allocates the DRAM memory for the frame buffer.
+ *
+ * @param       fbi     framebuffer information pointer
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_unmap_video_memory(struct fb_info *fbi)
+{
+	struct mxcfb_info *mxc_fbi = (struct mxcfb_info *)fbi->par;
+
+	dma_free_coherent(fbi->device, mxc_fbi->alloc_size,
+			  mxc_fbi->alloc_start_vaddr,
+			  mxc_fbi->alloc_start_paddr);
+	return 0;
+}
+
+/*!
+ * Initializes the framebuffer information pointer. After allocating
+ * sufficient memory for the framebuffer structure, the fields are
+ * filled with custom information passed in from the configurable
+ * structures.  This includes information such as bits per pixel,
+ * color maps, screen width/height and RGBA offsets.
+ *
+ * @return      Framebuffer structure initialized with our information
+ */
+static struct fb_info *mxcfb_init_fbinfo(struct device *dev, struct fb_ops *ops)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxcfbi;
+
+	/*
+	 * Allocate sufficient memory for the fb structure
+	 */
+	fbi = framebuffer_alloc(sizeof(struct mxcfb_info), dev);
+	if (!fbi)
+		return NULL;
+
+	mxcfbi = (struct mxcfb_info *)fbi->par;
+
+	/*
+	 * Fill in fb_info structure information
+	 */
+	fbi->var.xres = fbi->var.xres_virtual = MXCFB_SCREEN_WIDTH;
+	fbi->var.yres = fbi->var.yres_virtual = MXCFB_SCREEN_HEIGHT;
+	fbi->var.activate = FB_ACTIVATE_NOW;
+	mxcfb_check_var(&fbi->var, fbi);
+
+	mxcfb_set_fix(fbi);
+
+	fbi->fbops = ops;
+	fbi->flags = FBINFO_FLAG_DEFAULT;
+	fbi->pseudo_palette = mxcfbi->pseudo_palette;
+
+	/*
+	 * Allocate colormap
+	 */
+	fb_alloc_cmap(&fbi->cmap, 16, 0);
+
+	return fbi;
+}
+
+/*!
+ * Probe routine for the framebuffer driver. It is called during the
+ * driver binding process.      The following functions are performed in
+ * this routine: Framebuffer initialization, Memory allocation and
+ * mapping, Framebuffer registration, IPU initialization.
+ *
+ * @return      Appropriate error code to the kernel common code
+ */
+static int mxcfb_probe(struct platform_device *pdev)
+{
+	struct fb_info *fbi;
+	struct mxcfb_info *mxc_fbi;
+	int ret;
+
+	platform_set_drvdata(pdev, &mxcfb_drv_data);
+
+	/*
+	 * Initialize FB structures
+	 */
+	fbi = mxcfb_init_fbinfo(&pdev->dev, &mxcfb_ops);
+	if (!fbi) {
+		ret = -ENOMEM;
+		goto err0;
+	}
+	mxcfb_drv_data.fbi = fbi;
+	mxc_fbi = fbi->par;
+
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	mxcfb_drv_data.backlight_level = 7;
+#endif
+	mxcfb_drv_data.suspended = false;
+	init_waitqueue_head(&mxcfb_drv_data.suspend_wq);
+
+	/*
+	 * Allocate memory
+	 */
+	ret = mxcfb_map_video_memory(fbi);
+	if (ret < 0) {
+		goto err1;
+	}
+
+	mxcfb_init_panel(fbi);
+
+	/*
+	 * Register framebuffer
+	 */
+	ret = register_framebuffer(fbi);
+	if (ret < 0) {
+		goto err2;
+	}
+
+	dev_info(&pdev->dev, "%s registered\n", MXCFB_NAME);
+
+	return 0;
+
+      err2:
+	mxcfb_unmap_video_memory(fbi);
+      err1:
+	if (&fbi->cmap)
+		fb_dealloc_cmap(&fbi->cmap);
+	framebuffer_release(fbi);
+      err0:
+	return ret;
+}
+
+#ifdef CONFIG_PM
+/*!
+ * Power management hooks.      Note that we won't be called from IRQ context,
+ * unlike the blank functions above, so we may sleep.
+ */
+
+/*!
+ * Suspends the framebuffer and blanks the screen. Power management support
+ *
+ * @param	pdev	pointer to device structure.
+ * @param	state	state of the device.
+ *
+ * @return	success
+ */
+static int mxcfb_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	uint32_t cmd_param;
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct fb_info *fbi = drv_data->fbi;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	drv_data->suspended = true;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK)
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_OFF, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	pmic_bklit_set_current(BACKLIGHT_LED1, 0);
+	pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 0);
+#endif
+	/* Display OFF */
+	cmd_param = 0x08;
+	ipu_adc_write_cmd(mxc_fbi->disp_num, CMD, 0x0, &cmd_param, 1);
+
+	return 0;
+}
+
+/*!
+ * Resumes the framebuffer and unblanks the screen. Power management support
+ *
+ * @param       pdev     pointer to device structure.
+ *
+ * @return      success
+ */
+static int mxcfb_resume(struct platform_device *pdev)
+{
+	uint32_t cmd_param;
+	struct mxcfb_data *drv_data = platform_get_drvdata(pdev);
+	struct fb_info *fbi = drv_data->fbi;
+	struct mxcfb_info *mxc_fbi = fbi->par;
+
+	// Display ON
+	cmd_param = 0x00;
+	ipu_adc_write_cmd(mxc_fbi->disp_num, CMD, 0x0, &cmd_param, 1);
+	drv_data->suspended = false;
+
+	if (mxc_fbi->blank == FB_BLANK_UNBLANK)
+		mxcfb_set_refresh_mode(fbi, MXCFB_REFRESH_DEFAULT, NULL);
+#if defined(CONFIG_MXC_MC13783_LIGHT) && defined(CONFIG_MXC_MC13783_POWER)
+	pmic_bklit_set_current(BACKLIGHT_LED1, drv_data->backlight_level);
+	pmic_bklit_set_dutycycle(BACKLIGHT_LED1, 15);
+#endif
+	wake_up_interruptible(&drv_data->suspend_wq);
+
+	return 0;
+}
+#else
+#define mxcfb_suspend   NULL
+#define mxcfb_resume    NULL
+#endif
+
+/*!
+ * This structure contains pointers to the power management callback functions.
+ */
+static struct platform_driver mxcfb_driver = {
+	.driver = {
+		   .name = MXCFB_NAME,
+		   },
+	.probe = mxcfb_probe,
+	.suspend = mxcfb_suspend,
+	.resume = mxcfb_resume,
+};
+
+/*!
+ * Device definition for the Framebuffer
+ */
+static struct platform_device mxcfb_device = {
+	.name = MXCFB_NAME,
+	.id = 0,
+	.dev = {
+		.coherent_dma_mask = 0xFFFFFFFF,
+		}
+};
+
+/*!
+ * Main entry function for the framebuffer. The function registers the power
+ * management callback functions with the kernel and also registers the MXCFB
+ * callback functions with the core Linux framebuffer driver \b fbmem.c
+ *
+ * @return      Error code indicating success or failure
+ */
+static int mxcfb_init(void)
+{
+	int ret = 0;
+
+	ret = platform_driver_register(&mxcfb_driver);
+	if (ret == 0) {
+		ret = platform_device_register(&mxcfb_device);
+		if (ret != 0) {
+			platform_driver_unregister(&mxcfb_driver);
+		}
+	}
+	return ret;
+}
+
+static void mxcfb_exit(void)
+{
+	struct fb_info *fbi = dev_get_drvdata(&mxcfb_device.dev);
+
+	if (fbi) {
+		mxcfb_unmap_video_memory(fbi);
+
+		if (&fbi->cmap)
+			fb_dealloc_cmap(&fbi->cmap);
+
+		unregister_framebuffer(fbi);
+		framebuffer_release(fbi);
+	}
+
+	platform_device_unregister(&mxcfb_device);
+	platform_driver_unregister(&mxcfb_driver);
+}
+
+module_init(mxcfb_init);
+module_exit(mxcfb_exit);
+
+EXPORT_SYMBOL(mxcfb_set_refresh_mode);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MXC Toshiba QVGA framebuffer driver");
+MODULE_SUPPORTED_DEVICE("fb");
+MODULE_LICENSE("GPL");
