--- linux-2.6.19.2/include/asm-arm/arch-mxc/arc_otg.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/arc_otg.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,307 @@
+
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_ARC_OTG_H__
+#define __ASM_ARCH_MXC_ARC_OTG_H__
+
+struct arc_usb_config {
+	char *name;		/* pretty print */
+	int (*platform_init) (void);	/* platform-specific init routine */
+	void (*platform_uninit) (void);	/* platform-specific uninit routine */
+	void (*set_vbus_power) (int);	/* turn on/off Vbus power */
+	u32 xcvr_type;		/* PORTSC_PTS_* */
+	u32 usbmode;		/* address of usbmode register */
+	u32 does_otg;		/* set IFF it's an OTG port */
+	unsigned power_budget;	/* for hcd->power_budget */
+};
+
+struct arc_xcvr_config {
+	char *name;		/* pretty print */
+	int (*platform_init) (void);	/* platform-specific init routine */
+	void (*platform_uninit) (void);	/* platform-specific uninit routine */
+	void *regs;		/* register base */
+};
+
+#define USB_OTGREGS_BASE	(OTG_BASE_ADDR + 0x000)
+#define USB_H1REGS_BASE		(OTG_BASE_ADDR + 0x200)
+#define USB_H2REGS_BASE		(OTG_BASE_ADDR + 0x400)
+#define USB_OTHERREGS_BASE	(OTG_BASE_ADDR + 0x600)
+
+#define USBOTG_REG32(offset)	(*((volatile u32 *)(IO_ADDRESS(USB_OTGREGS_BASE + (offset)))))
+#define USBOTG_REG16(offset)	(*((volatile u16 *)(IO_ADDRESS(USB_OTGREGS_BASE + (offset)))))
+
+#define USBH1_REG32(offset)	(*((volatile u32 *)(IO_ADDRESS(USB_H1REGS_BASE + (offset)))))
+#define USBH1_REG16(offset)	(*((volatile u16 *)(IO_ADDRESS(USB_H1REGS_BASE + (offset)))))
+
+#define USBH2_REG32(offset)	(*((volatile u32 *)(IO_ADDRESS(USB_H2REGS_BASE + (offset)))))
+#define USBH2_REG16(offset)	(*((volatile u16 *)(IO_ADDRESS(USB_H2REGS_BASE + (offset)))))
+
+#define USBOTHER_REG(offset)	(*((volatile u32 *)(IO_ADDRESS(USB_OTHERREGS_BASE + (offset)))))
+
+/*
+ * OTG registers
+ */
+#define UOG_ID			USBOTG_REG32(0x00)	/* Host ID */
+#define UOG_HWGENERAL		USBOTG_REG32(0x04)	/* Host General */
+#define UOG_HWHOST		USBOTG_REG32(0x08)	/* Host h/w params */
+#define UOG_HWTXBUF		USBOTG_REG32(0x10)	/* TX buffer h/w params */
+#define UOG_HWRXBUF		USBOTG_REG32(0x14)	/* RX buffer h/w params */
+#define UOG_CAPLENGTH		USBOTG_REG16(0x100)	/* Capability register length */
+#define UOG_HCIVERSION		USBOTG_REG16(0x102)	/* Host Interface version */
+#define UOG_HCSPARAMS		USBOTG_REG32(0x104)	/* Host control structural params */
+#define UOG_HCCPARAMS		USBOTG_REG32(0x108)	/* control capability params */
+#define UOG_DCIVERSION		USBOTG_REG32(0x120)	/* device interface version */
+/* start EHCI registers: */
+#define UOG_USBCMD		USBOTG_REG32(0x140)	/* USB command register */
+#define UOG_USBSTS		USBOTG_REG32(0x144)	/* USB status register */
+#define UOG_USBINTR		USBOTG_REG32(0x148)	/* interrupt enable register */
+#define UOG_FRINDEX		USBOTG_REG32(0x14c)	/* USB frame index */
+/*      segment                             (0x150)	   addr bits 63:32 if needed */
+#define UOG_PERIODICLISTBASE	USBOTG_REG32(0x154)	/* host crtlr frame list base addr */
+#define UOG_DEVICEADDR		USBOTG_REG32(0x154)	/* device crtlr device address */
+#define UOG_ASYNCLISTADDR	USBOTG_REG32(0x158)	/* host ctrlr next async addr */
+#define UOG_EPLISTADDR		USBOTG_REG32(0x158)	/* device ctrlr endpoint list addr */
+#define UOG_BURSTSIZE		USBOTG_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UOG_TXFILLTUNING	USBOTG_REG32(0x164)	/* TX FIFO fill tuning */
+#define UOG_ULPIVIEW		USBOTG_REG32(0x170)	/* ULPI viewport */
+#define	UOG_CFGFLAG		USBOTG_REG32(0x180)	/* configflag (supports HS) */
+#define UOG_PORTSC1		USBOTG_REG32(0x184)	/* port status and control */
+/* end EHCI registers: */
+#define UOG_OTGSC		USBOTG_REG32(0x1a4)	/* OTG status and control */
+#define UOG_USBMODE		USBOTG_REG32(0x1a8)	/* USB device mode */
+#define UOG_ENDPTSETUPSTAT	USBOTG_REG32(0x1ac)	/* endpoint setup status */
+#define UOG_ENDPTPRIME		USBOTG_REG32(0x1b0)	/* endpoint initialization */
+#define UOG_ENDPTFLUSH		USBOTG_REG32(0x1b4)	/* endpoint de-initialize */
+#define UOG_ENDPTSTAT		USBOTG_REG32(0x1b8)	/* endpoint status */
+#define UOG_ENDPTCOMPLETE	USBOTG_REG32(0x1bc)	/* endpoint complete */
+#define UOG_EPCTRL0		USBOTG_REG32(0x1c0)	/* endpoint control0 */
+#define UOG_EPCTRL1		USBOTG_REG32(0x1c4)	/* endpoint control1 */
+#define UOG_EPCTRL2		USBOTG_REG32(0x1c8)	/* endpoint control2 */
+#define UOG_EPCTRL3		USBOTG_REG32(0x1cc)	/* endpoint control3 */
+#define UOG_EPCTRL4		USBOTG_REG32(0x1d0)	/* endpoint control4 */
+#define UOG_EPCTRL5		USBOTG_REG32(0x1d4)	/* endpoint control5 */
+#define UOG_EPCTRL6		USBOTG_REG32(0x1d8)	/* endpoint control6 */
+#define UOG_EPCTRL7		USBOTG_REG32(0x1dc)	/* endpoint control7 */
+
+/*
+ * Host 1 registers
+ */
+#define UH1_ID			USBH1_REG32(0x00)	/* Host ID */
+#define UH1_HWGENERAL		USBH1_REG32(0x04)	/* Host General */
+#define UH1_HWHOST		USBH1_REG32(0x08)	/* Host h/w params */
+#define UH1_HWTXBUF		USBH1_REG32(0x10)	/* TX buffer h/w params */
+#define UH1_HWRXBUF		USBH1_REG32(0x14)	/* RX buffer h/w params */
+#define UH1_CAPLENGTH		USBH1_REG16(0x100)	/* Capability register length */
+#define UH1_HCIVERSION		USBH1_REG16(0x102)	/* Host Interface version */
+#define UH1_HCSPARAMS		USBH1_REG32(0x104)	/* Host control structural params */
+#define UH1_HCCPARAMS		USBH1_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH1_USBCMD		USBH1_REG32(0x140)	/* USB command register */
+#define UH1_USBSTS		USBH1_REG32(0x144)	/* USB status register */
+#define UH1_USBINTR		USBH1_REG32(0x148)	/* interrupt enable register */
+#define UH1_FRINDEX		USBH1_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH1_PERIODICLISTBASE	USBH1_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH1_ASYNCLISTADDR	USBH1_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH1_BURSTSIZE		USBH1_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH1_TXFILLTUNING	USBH1_REG32(0x164)	/* TX FIFO fill tuning */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH1_PORTSC1		USBH1_REG32(0x184)	/* port status and control */
+/* end EHCI registers: */
+#define UH1_USBMODE		USBH1_REG32(0x1a8)	/* USB device mode */
+
+/*
+ * Host 2 registers
+ */
+#define UH2_ID			USBH2_REG32(0x00)	/* Host ID */
+#define UH2_HWGENERAL		USBH2_REG32(0x04)	/* Host General */
+#define UH2_HWHOST		USBH2_REG32(0x08)	/* Host h/w params */
+#define UH2_HWTXBUF		USBH2_REG32(0x10)	/* TX buffer h/w params */
+#define UH2_HWRXBUF		USBH2_REG32(0x14)	/* RX buffer h/w params */
+#define UH2_CAPLENGTH		USBH2_REG16(0x100)	/* Capability register length */
+#define UH2_HCIVERSION		USBH2_REG16(0x102)	/* Host Interface version */
+#define UH2_HCSPARAMS		USBH2_REG32(0x104)	/* Host control structural params */
+#define UH2_HCCPARAMS		USBH2_REG32(0x108)	/* control capability params */
+/* start EHCI registers: */
+#define UH2_USBCMD		USBH2_REG32(0x140)	/* USB command register */
+#define UH2_USBSTS		USBH2_REG32(0x144)	/* USB status register */
+#define UH2_USBINTR		USBH2_REG32(0x148)	/* interrupt enable register */
+#define UH2_FRINDEX		USBH2_REG32(0x14c)	/* USB frame index */
+/*      segment                            (0x150)	   addr bits 63:32 if needed */
+#define UH2_PERIODICLISTBASE	USBH2_REG32(0x154)	/* host crtlr frame list base addr */
+#define UH2_ASYNCLISTADDR	USBH2_REG32(0x158)	/* host ctrlr nest async addr */
+#define UH2_BURSTSIZE		USBH2_REG32(0x160)	/* host ctrlr embedded TT async buf status */
+#define UH2_TXFILLTUNING	USBH2_REG32(0x164)	/* TX FIFO fill tuning */
+#define UH2_ULPIVIEW		USBH2_REG32(0x170)	/* ULPI viewport */
+/*      configured_flag                    (0x180)	   configflag (supports HS) */
+#define UH2_PORTSC1		USBH2_REG32(0x184)	/* port status and control */
+/* end EHCI registers */
+#define UH2_USBMODE		USBH2_REG32(0x1a8)	/* USB device mode */
+
+/*
+ * other regs (not part of ARC core)
+ */
+#define USBCTRL			USBOTHER_REG(0x00)	/* USB Control register */
+#define USB_OTG_MIRROR		USBOTHER_REG(0x04)	/* USB OTG mirror register */
+
+/*
+ * register bits
+ */
+
+/* x_PORTSCx */
+#define PORTSC_PTS_MASK			(3 << 30)	/* parallel xcvr select mask */
+#define PORTSC_PTS_UTMI			(0 << 30)	/* UTMI/UTMI+ */
+#define PORTSC_PTS_PHILIPS		(1 << 30)	/* Philips classic */
+#define PORTSC_PTS_ULPI			(2 << 30)	/* ULPI */
+#define PORTSC_PTS_SERIAL		(3 << 30)	/* serial */
+#define PORTSC_STS			(1 << 29)	/* serial xcvr select */
+#define PORTSC_PORT_POWER		(1 << 12)	/* port power */
+#define PORTSC_LS_MASK			(3 << 10)	/* Line State mask */
+#define PORTSC_LS_SE0			(0 << 10)	/* SE0     */
+#define PORTSC_LS_K_STATE		(1 << 10)	/* K-state */
+#define PORTSC_LS_J_STATE		(2 << 10)	/* J-state */
+#define PORTSC_PORT_RESET		(1 <<  8)	/* Port reset */
+#define PORTSC_PORT_SUSPEND		(1 <<  7)	/* Suspend */
+#define PORTSC_PORT_FORCE_RESUME	(1 <<  6)	/* Force port resume */
+#define PORTSC_OVER_CURRENT_CHG		(1 <<  5)	/* over current change */
+#define PORTSC_OVER_CURRENT_ACT		(1 <<  4)	/* over currrent active */
+#define PORTSC_PORT_EN_DIS_CHANGE	(1 <<  3)	/* port {en,dis}able change */
+#define PORTSC_PORT_ENABLE		(1 <<  2)	/* port enabled */
+#define PORTSC_CONNECT_STATUS_CHANGE	(1 <<  1)	/* connect status change */
+#define PORTSC_CURRENT_CONNECT_STATUS	(1 <<  0)	/* current connect status */
+
+#define PORTSC_W1C_BITS                     \
+       ( PORTSC_CONNECT_STATUS_CHANGE |     \
+         PORTSC_PORT_EN_DIS_CHANGE    |     \
+         PORTSC_OVER_CURRENT_CHG )
+
+/* UOG_OTGSC Register Bits */
+/* control bits: */
+#define  OTGSC_CTRL_VBUS_DISCHARGE	(1 <<  0)
+#define  OTGSC_CTRL_VBUS_CHARGE		(1 <<  1)
+#define  OTGSC_CTRL_OTG_TERM		(1 <<  3)	/* controls DM pulldown */
+#define  OTGSC_CTRL_DATA_PULSING	(1 <<  4)
+#define  OTGSC_CTRL_USB_ID_PU		(1 <<  5)	/* enable ID pullup */
+/* current status: (R/O) */
+#define  OTGSC_STS_USB_ID		(1 <<  8)	/* 0=A-device  1=B-device */
+#define  OTGSC_STS_A_VBUS_VALID		(1 <<  9)
+#define  OTGSC_STS_A_SESSION_VALID	(1 << 10)
+#define  OTGSC_STS_B_SESSION_VALID	(1 << 11)
+#define  OTGSC_STS_B_SESSION_END	(1 << 12)
+#define  OTGSC_STS_1ms_TIMER		(1 << 13)
+#define  OTGSC_STS_DATA_PULSE		(1 << 14)
+/* interrupt status: (write to clear) */
+#define  OTGSC_IS_MASK			(0x7f << 16)
+#define  OTGSC_IS_USB_ID		(1 << 16)
+#define  OTGSC_IS_A_VBUS_VALID		(1 << 17)
+#define  OTGSC_IS_A_SESSION_VALID	(1 << 18)
+#define  OTGSC_IS_B_SESSION_VALID	(1 << 19)
+#define  OTGSC_IS_B_SESSION_END		(1 << 20)
+#define  OTGSC_IS_1ms_TIMER		(1 << 21)
+#define  OTGSC_IS_DATA_PULSE		(1 << 22)
+/* interrupt enables: */
+#define  OTGSC_IE_MASK			(0x7f << 24)
+#define  OTGSC_IE_USB_ID		(1 << 24)
+#define  OTGSC_IE_A_VBUS_VALID		(1 << 25)
+#define  OTGSC_IE_A_SESSION_VALID	(1 << 26)
+#define  OTGSC_IE_B_SESSION_VALID	(1 << 27)
+#define  OTGSC_IE_B_SESSION_END		(1 << 28)
+#define  OTGSC_IE_1ms_TIMER		(1 << 19)
+#define  OTGSC_IE_DATA_PULSE		(1 << 30)
+
+#if 1				/* FIXME these here for compatibility between my names and Leo's */
+/* OTG interrupt enable bit masks */
+#define  OTGSC_INTERRUPT_ENABLE_BITS_MASK	OTGSC_IE_MASK
+#define  OTGSC_INTSTS_MASK			OTGSC_IS_MASK
+
+/* OTG interrupt status bit masks */
+#define  OTGSC_INTERRUPT_STATUS_BITS_MASK	OTGSC_IS_MASK
+#endif
+
+/* x_USBMODE */
+#define USBMODE_SDIS		(1 << 4)	/* stream disable mode */
+#define USBMODE_SLOM		(1 << 3)	/* setup lockout mode */
+#define USBMODE_ES		(1 << 2)	/* (big) endian select */
+#define USBMODE_CM_MASK		(3 << 0)	/* controller mode mask */
+#define USBMODE_CM_HOST		(3 << 0)	/* host */
+#define USBMODE_CM_DEVICE	(2 << 0)	/* device */
+#define USBMODE_CM_reserved	(1 << 0)	/* reserved */
+#define USBMODE_CM_IDLE		(0 << 0)	/* idle */
+
+/* USBCTRL */
+#define UCTRL_OWIR		(1 << 31)	/* OTG wakeup intr request received */
+#define UCTRL_OSIC_MASK		(3 << 29)	/* OTG  Serial Interface Config: */
+#define UCTRL_OSIC_DU6		(0 << 29)	/* Differential/unidirectional 6 wire */
+#define UCTRL_OSIC_DB4		(1 << 29)	/* Differential/bidirectional  4 wire */
+#define UCTRL_OSIC_SU6		(2 << 29)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_OSIC_SB3		(3 << 29)	/* single-ended/bidirectional  3 wire */
+
+#define UCTRL_OUIE		(1 << 28)	/* OTG ULPI intr enable */
+#define UCTRL_OWIE		(1 << 27)	/* OTG wakeup intr enable */
+#define UCTRL_OBPVAL_RXDP	(1 << 26)	/* OTG RxDp status in bypass mode */
+#define UCTRL_OBPVAL_RXDM	(1 << 25)	/* OTG RxDm status in bypass mode */
+#define UCTRL_OPM		(1 << 24)	/* OTG power mask */
+#define UCTRL_H2WIR		(1 << 23)	/* HOST2 wakeup intr request received */
+#define UCTRL_H2SIC_MASK	(3 << 21)	/* HOST2 Serial Interface Config: */
+#define UCTRL_H2SIC_DU6		(0 << 21)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H2SIC_DB4		(1 << 21)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H2SIC_SU6		(2 << 21)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H2SIC_SB3		(3 << 21)	/* single-ended/bidirectional  3 wire */
+
+#define UCTRL_H2UIE		(1 << 20)	/* HOST2 ULPI intr enable */
+#define UCTRL_H2WIE		(1 << 19)	/* HOST2 wakeup intr enable */
+#define UCTRL_H2PM		(1 << 16)	/* HOST2 power mask */
+
+#define UCTRL_H1WIR		(1 << 15)	/* HOST1 wakeup intr request received */
+#define UCTRL_H1SIC_MASK	(3 << 13)	/* HOST1 Serial Interface Config: */
+#define UCTRL_H1SIC_DU6		(0 << 13)	/* Differential/unidirectional 6 wire */
+#define UCTRL_H1SIC_DB4		(1 << 13)	/* Differential/bidirectional  4 wire */
+#define UCTRL_H1SIC_SU6		(2 << 13)	/* single-ended/unidirectional 6 wire */
+#define UCTRL_H1SIC_SB3		(3 << 13)	/* single-ended/bidirectional  3 wire */
+
+#define UCTRL_H1WIE		(1 << 11)	/* HOST1 wakeup intr enable */
+#define UCTRL_H1BPVAL_RXDP	(1 << 10)	/* HOST1 RxDp status in bypass mode */
+#define UCTRL_H1BPVAL_RXDM	(1 <<  9)	/* HOST1 RxDm status in bypass mode */
+#define UCTRL_H1PM		(1 <<  8)	/* HOST1 power mask */
+
+#define UCTRL_H2DT		(1 <<  5)	/* HOST2 TLL disabled */
+#define UCTRL_H1DT		(1 <<  4)	/* HOST1 TLL disabled */
+#define UCTRL_BPE		(1 <<  0)	/* bypass mode enable */
+
+/* USBCMD */
+#define UCMD_RESET		(1 << 1)	/* controller reset */
+
+/* OTG_MIRROR */
+#define OTGM_SESEND		(1 << 4)	/* B device session end */
+#define OTGM_VBUSVAL		(1 << 3)	/* Vbus valid */
+#define OTGM_BSESVLD		(1 << 2)	/* B session Valid */
+#define OTGM_ASESVLD		(1 << 1)	/* A session Valid */
+#define OTGM_IDIDG		(1 << 0)	/* OTG ID pin status */
+						/* 1=high: Operate as B-device */
+						/* 0=low : Operate as A-device */
+
+/* ULPIVIEW register bits */
+#define ULPIVW_WU		(1 << 31)	/* Wakeup */
+#define ULPIVW_RUN		(1 << 30)	/* read/write run */
+#define ULPIVW_WRITE		(1 << 29)	/* 0=read  1=write */
+#define ULPIVW_SS		(1 << 27)	/* SyncState */
+#define ULPIVW_PORT_MASK	0x07	/* Port field */
+#define ULPIVW_PORT_SHIFT	24
+#define ULPIVW_ADDR_MASK	0xFF	/* data address field */
+#define ULPIVW_ADDR_SHIFT	16
+#define ULPIVW_RDATA_MASK	0xFF	/* read data field */
+#define ULPIVW_RDATA_SHIFT	8
+#define ULPIVW_WDATA_MASK	0xFF	/* write data field */
+#define ULPIVW_WDATA_SHIFT	0
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/board.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/board.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_H__
+#define __ASM_ARCH_MXC_BOARD_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+#ifndef __ASSEMBLY__
+
+struct mxc_ipu_config {
+	int rev;
+};
+
+struct mxc_ir_platform_data {
+	int uart_ir_mux;
+};
+#endif
+
+/*
+ * The modes of the UART ports
+ */
+#define MODE_DTE                0
+#define MODE_DCE                1
+/*
+ * Is the UART configured to be a IR port
+ */
+#define IRDA                    0
+#define NO_IRDA                 1
+
+#endif				/* __ASM_ARCH_MXC_BOARD_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/board-mx27ads.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/board-mx27ads.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,456 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX27ADS_H__
+#define __ASM_ARCH_MXC_BOARD_MX27ADS_H__
+
+/*!
+ * @defgroup BRDCFG Board Configuration Options
+ * @ingroup MSL
+ */
+
+/*!
+ * @file board-mx27ads.h
+ *
+ * @brief This file contains all the board level configuration options.
+ *
+ * It currently hold the options defined for MX27 ADS Platform.
+ *
+ * @ingroup BRDCFG
+ */
+
+/*
+ * Include Files
+ */
+#include <asm/arch/board.h>
+
+#define CKIH_CLK_FREQ           26000000	/* 26M reference clk */
+#define CKIH_CLK_FREQ_27MHZ     27000000
+#define CKIL_CLK_FREQ           (32768 * 1024)	/* 32.768k oscillator in */
+#define CKIH_27MHZ_BIT_SET      (1 << 3)
+
+/* Start of physical RAM */
+#define PHYS_OFFSET             UL(0xA0000000)
+
+/* Size of contiguous memory for DMA and other h/w blocks */
+#define CONSISTENT_DMA_SIZE	SZ_8M
+
+/* I2C configuration */
+/*!
+ * This defines the number of I2C modules in the MXC platform
+ */
+#define I2C_NR                 1
+/*!
+ * This define specifies the frequency divider value to be written into
+ * the I2C \b IFDR register.
+ */
+#define I2C1_FRQ_DIV            0x17
+
+/*!
+ * @name MXC UART EVB board level configurations
+ */
+/*! @{ */
+/*!
+ * Specify the max baudrate for the MXC UARTs for your board, do not specify a max
+ * baudrate greater than 1500000. This is used while specifying the UART Power
+ * management constraints.
+ */
+#define MAX_UART_BAUDRATE       1500000
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV         0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV         0
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                NO_IRDA
+#define UART2_ENABLED           1
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DCE
+#define UART3_IR                IRDA
+#define UART3_ENABLED           1
+/* UART 4 configuration */
+#define UART4_MODE              MODE_DTE
+#define UART4_IR                NO_IRDA
+#define UART4_ENABLED           0	/* Disable UART 4 as its pins are shared with ATA */
+/* UART 5 configuration */
+#define UART5_MODE              MODE_DTE
+#define UART5_IR                NO_IRDA
+#define UART5_ENABLED           1
+/* UART 6 configuration */
+#define UART6_MODE              MODE_DTE
+#define UART6_IR                NO_IRDA
+#define UART6_ENABLED           1
+
+#define MXC_LL_EXTUART_PADDR	(CS4_BASE_ADDR + 0x20000)
+#define MXC_LL_EXTUART_VADDR	(CS4_BASE_ADDR_VIRT + 0x20000)
+#define MXC_LL_EXTUART_16BIT_BUS
+
+#define MXC_LL_UART_PADDR       UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR       AIPI_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name Memory Size parameters
+ */
+/*! @{ */
+/*!
+ * Size of SDRAM memory
+ */
+#define SDRAM_MEM_SIZE          SZ_128M
+/*! @} */
+
+/*! @{ */
+/*!
+ * @name Keypad Configurations
+ */
+/*! @{ */
+/*!
+ * Maximum number of rows (0 to 7)
+ */
+#define MAXROW                          6
+/*!
+ * Maximum number of columns (0 to 7)
+ */
+#define MAXCOL                          6
+/*! @} */
+
+/*!
+ * @name PBC Controller parameters
+ */
+/*! @{ */
+/*!
+ * Base address of PBC controller, CS4
+ */
+#define PBC_BASE_ADDRESS        IO_ADDRESS(CS4_BASE_ADDR)
+#define PBC_REG_ADDR(offset)    (PBC_BASE_ADDRESS + (offset))
+
+/*!
+ * PBC Interupt name definitions
+ */
+#define PBC_GPIO1_0  0
+#define PBC_GPIO1_1  1
+#define PBC_GPIO1_2  2
+#define PBC_GPIO1_3  3
+#define PBC_GPIO1_4  4
+#define PBC_GPIO1_5  5
+
+#define PBC_INTR_MAX_NUM 6
+#define PBC_INTR_SHARED_MAX_NUM 8
+
+/* When the PBC address connection is fixed in h/w, defined as 1 */
+#define PBC_ADDR_SH             0
+
+/* Offsets for the PBC Controller register */
+/*!
+ * PBC Board version register offset
+ */
+#define PBC_VERSION_REG         PBC_REG_ADDR(0x00000 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 1 set address.
+ */
+#define PBC_BCTRL1_SET_REG      PBC_REG_ADDR(0x00008 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 1 clear address.
+ */
+#define PBC_BCTRL1_CLEAR_REG    PBC_REG_ADDR(0x0000C >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 2 set address.
+ */
+#define PBC_BCTRL2_SET_REG      PBC_REG_ADDR(0x00010 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 2 clear address.
+ */
+#define PBC_BCTRL2_CLEAR_REG    PBC_REG_ADDR(0x00014 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 3 set address.
+ */
+#define PBC_BCTRL3_SET_REG      PBC_REG_ADDR(0x00018 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 3 clear address.
+ */
+#define PBC_BCTRL3_CLEAR_REG    PBC_REG_ADDR(0x0001C >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 3 set address.
+ */
+#define PBC_BCTRL4_SET_REG      PBC_REG_ADDR(0x00020 >> PBC_ADDR_SH)
+/*!
+ * PBC Board control register 4 clear address.
+ */
+#define PBC_BCTRL4_CLEAR_REG    PBC_REG_ADDR(0x00024 >> PBC_ADDR_SH)
+/*!PBC_ADDR_SH
+ * PBC Board status register 1.
+ */
+#define PBC_BSTAT1_REG          PBC_REG_ADDR(0x00028 >> PBC_ADDR_SH)
+/*!
+ * PBC Board interrupt status register.
+ */
+#define PBC_INTSTATUS_REG       PBC_REG_ADDR(0x0002C >> PBC_ADDR_SH)
+/*!
+ * PBC Board interrupt current status register.
+ */
+#define PBC_INTCURR_STATUS_REG  PBC_REG_ADDR(0x00034 >> PBC_ADDR_SH)
+/*!
+ * PBC Interrupt mask register set address.
+ */
+#define PBC_INTMASK_SET_REG     PBC_REG_ADDR(0x00038 >> PBC_ADDR_SH)
+/*!
+ * PBC Interrupt mask register clear address.
+ */
+#define PBC_INTMASK_CLEAR_REG   PBC_REG_ADDR(0x0003C >> PBC_ADDR_SH)
+/*!
+ * External UART A.
+ */
+#define PBC_SC16C652_UARTA_REG  PBC_REG_ADDR(0x20000 >> PBC_ADDR_SH)
+/*!
+ * UART 4 Expanding Signal Status.
+ */
+#define PBC_UART_STATUS_REG     PBC_REG_ADDR(0x22000 >> PBC_ADDR_SH)
+/*!
+ * UART 4 Expanding Signal Control Set.
+ */
+#define PBC_UCTRL_SET_REG       PBC_REG_ADDR(0x24000 >> PBC_ADDR_SH)
+/*!
+ * UART 4 Expanding Signal Control Clear.
+ */
+#define PBC_UCTRL_CLR_REG       PBC_REG_ADDR(0x26000 >> PBC_ADDR_SH)
+/*!
+ * Ethernet Controller IO base address.
+ */
+#define PBC_CS8900A_IOBASE_REG  PBC_REG_ADDR(0x40000 >> PBC_ADDR_SH)
+/*!
+ * Ethernet Controller Memory base address.
+ */
+#define PBC_CS8900A_MEMBASE_REG PBC_REG_ADDR(0x42000 >> PBC_ADDR_SH)
+/*!
+ * Ethernet Controller DMA base address.
+ */
+#define PBC_CS8900A_DMABASE_REG PBC_REG_ADDR(0x44000 >> PBC_ADDR_SH)
+
+/* PBC Board Version Register bit definition */
+#define PBC_VERSION_ADS         0x8000	/* Bit15=1 means version for ads */
+#define PBC_VERSION_EVB_REVB    0x4000	/* BIT14=1 means version for evb revb */
+
+/* PBC Board Control Register 1 bit definitions */
+#define PBC_BCTRL1_ERST         0x0001	/* Ethernet Reset */
+#define PBC_BCTRL1_URST         0x0002	/* Reset External UART controller */
+#define PBC_BCTRL1_FRST         0x0004	/* FEC Reset */
+#define PBC_BCTRL1_ESLEEP       0x0010	/* Enable ethernet Sleep */
+#define PBC_BCTRL1_LCDON        0x0800	/* Enable the LCD */
+
+/* PBC Board Control Register 2 bit definitions */
+#define PBC_BCTRL2_VCC_EN       0x0004	/*   Enable VCC */
+#define PBC_BCTRL2_VPP_EN       0x0008	/*   Enable Vpp */
+#define PBC_BCTRL2_ATAFEC_EN    0X0010
+#define PBC_BCTRL2_ATAFEC_SEL   0X0020
+#define PBC_BCTRL2_ATA_EN       0X0040
+#define PBC_BCTRL2_IRDA_SD      0X0080
+#define PBC_BCTRL2_IRDA_EN      0X0100
+#define PBC_BCTRL2_CCTL10       0X0200
+#define PBC_BCTRL2_CCTL11       0X0400
+
+/* PBC Board Control Register 3 bit definitions */
+#define PBC_BCTRL3_HSH_EN       0X0020
+#define PBC_BCTRL3_FSH_MOD      0X0040
+#define PBC_BCTRL3_OTG_HS_EN    0X0080
+#define PBC_BCTRL3_OTG_VBUS_EN  0X0100
+#define PBC_BCTRL3_FSH_VBUS_EN  0X0200
+#define PBC_BCTRL3_USB_OTG_ON   0X0800
+#define PBC_BCTRL3_USB_FSH_ON   0X1000
+
+/* PBC Board Control Register 4 bit definitions */
+#define PBC_BCTRL4_REGEN_SEL    0X0001
+#define PBC_BCTRL4_USER_OFF     0X0002
+#define PBC_BCTRL4_VIB_EN       0X0004
+#define PBC_BCTRL4_PWRGT1_EN    0X0008
+#define PBC_BCTRL4_PWRGT2_EN    0X0010
+#define PBC_BCTRL4_STDBY_PRI    0X0020
+
+#ifndef __ASSEMBLY__
+/*!
+ * Enumerations for SD cards and memory stick card. This corresponds to
+ * the card EN bits in the IMR: SD1_EN | MS_EN | SD3_EN | SD2_EN.
+ */
+enum mxc_card_no {
+	MXC_CARD_SD2 = 0,
+	MXC_CARD_SD3,
+	MXC_CARD_MS,
+	MXC_CARD_SD1,
+	MXC_CARD_MIN = MXC_CARD_SD2,
+	MXC_CARD_MAX = MXC_CARD_SD1,
+};
+#endif
+
+#define MXC_CPLD_VER_1_50       0x01
+
+/*!
+ * PBC BSTAT Register bit definitions
+ */
+#define PBC_BSTAT_PRI_INT       0X0001
+#define PBC_BSTAT_USB_BYP       0X0002
+#define PBC_BSTAT_ATA_IOCS16    0X0004
+#define PBC_BSTAT_ATA_CBLID     0X0008
+#define PBC_BSTAT_ATA_DASP      0X0010
+#define PBC_BSTAT_PWR_RDY       0X0020
+#define PBC_BSTAT_SD3_WP        0X0100
+#define PBC_BSTAT_SD2_WP        0X0200
+#define PBC_BSTAT_SD1_WP        0X0400
+#define PBC_BSTAT_SD3_DET       0X0800
+#define PBC_BSTAT_SD2_DET       0X1000
+#define PBC_BSTAT_SD1_DET       0X2000
+#define PBC_BSTAT_MS_DET        0X4000
+#define PBC_BSTAT_SD3_DET_BIT   11
+#define PBC_BSTAT_SD2_DET_BIT   12
+#define PBC_BSTAT_SD1_DET_BIT   13
+#define PBC_BSTAT_MS_DET_BIT    14
+#define MXC_BSTAT_BIT(n)        ((n == MXC_CARD_SD2) ? PBC_BSTAT_SD2_DET : \
+				 ((n == MXC_CARD_SD3) ? PBC_BSTAT_SD3_DET : \
+				 ((n == MXC_CARD_SD1) ? PBC_BSTAT_SD1_DET : \
+				 ((n == MXC_CARD_MS) ? PBC_BSTAT_MS_DET : 0x0))))
+
+/*!
+ * PBC UART Control Register bit definitions
+ */
+#define PBC_UCTRL_DCE_DCD       0X0001
+#define PBC_UCTRL_DCE_DSR       0X0002
+#define PBC_UCTRL_DCE_RI        0X0004
+#define PBC_UCTRL_DTE_DTR       0X0100
+
+/*!
+ * PBC UART Status Register bit definitions
+ */
+#define PBC_USTAT_DTE_DCD       0X0001
+#define PBC_USTAT_DTE_DSR       0X0002
+#define PBC_USTAT_DTE_RI        0X0004
+#define PBC_USTAT_DCE_DTR       0X0100
+
+/*!
+ * PBC Interupt mask register bit definitions
+ */
+#define PBC_INTR_SD3_R_EN_BIT   4
+#define PBC_INTR_SD2_R_EN_BIT   0
+#define PBC_INTR_SD1_R_EN_BIT   6
+#define PBC_INTR_MS_R_EN_BIT    5
+#define PBC_INTR_SD3_EN_BIT     13
+#define PBC_INTR_SD2_EN_BIT     12
+#define PBC_INTR_MS_EN_BIT      14
+#define PBC_INTR_SD1_EN_BIT     15
+
+#define PBC_INTR_SD2_R_EN       0x0001
+#define PBC_INTR_LOW_BAT        0X0002
+#define PBC_INTR_OTG_FSOVER     0X0004
+#define PBC_INTR_FSH_OVER       0X0008
+#define PBC_INTR_SD3_R_EN       0x0010
+#define PBC_INTR_MS_R_EN        0x0020
+#define PBC_INTR_SD1_R_EN       0x0040
+#define PBC_INTR_FEC_INT        0X0080
+#define PBC_INTR_ENET_INT       0X0100
+#define PBC_INTR_OTGFS_INT      0X0200
+#define PBC_INTR_XUART_INT      0X0400
+#define PBC_INTR_CCTL12         0X0800
+#define PBC_INTR_SD2_EN         0x1000
+#define PBC_INTR_SD3_EN         0x2000
+#define PBC_INTR_MS_EN          0x4000
+#define PBC_INTR_SD1_EN         0x8000
+
+/*! @} */
+
+/* For interrupts like xuart, enet etc */
+#define EXPIO_PARENT_INT        IOMUX_TO_IRQ(MX27_PIN_TIN)
+#define MXC_MAX_EXP_IO_LINES    16
+
+/*
+ * This corresponds to PBC_INTMASK_SET_REG at offset 0x38.
+ *
+ */
+#define EXPIO_INT_LOW_BAT       (MXC_EXP_IO_BASE + 1)
+#define EXPIO_INT_OTG_FS_OVR    (MXC_EXP_IO_BASE + 2)
+#define EXPIO_INT_FSH_OVR       (MXC_EXP_IO_BASE + 3)
+#define EXPIO_INT_RES4          (MXC_EXP_IO_BASE + 4)
+#define EXPIO_INT_RES5          (MXC_EXP_IO_BASE + 5)
+#define EXPIO_INT_RES6          (MXC_EXP_IO_BASE + 6)
+#define EXPIO_INT_FEC           (MXC_EXP_IO_BASE + 7)
+#define EXPIO_INT_ENET_INT      (MXC_EXP_IO_BASE + 8)
+#define EXPIO_INT_OTG_FS_INT    (MXC_EXP_IO_BASE + 9)
+#define EXPIO_INT_XUART_INTA    (MXC_EXP_IO_BASE + 10)
+#define EXPIO_INT_CCTL12_INT    (MXC_EXP_IO_BASE + 11)
+#define EXPIO_INT_SD2_EN        (MXC_EXP_IO_BASE + 12)
+#define EXPIO_INT_SD3_EN        (MXC_EXP_IO_BASE + 13)
+#define EXPIO_INT_MS_EN         (MXC_EXP_IO_BASE + 14)
+#define EXPIO_INT_SD1_EN        (MXC_EXP_IO_BASE + 15)
+
+/*! This is System IRQ used by CS8900A for interrupt generation taken from platform.h */
+#define CS8900AIRQ              EXPIO_INT_ENET_INT
+/*! This is I/O Base address used to access registers of CS8900A on MXC ADS */
+#define CS8900A_BASE_ADDRESS    (PBC_CS8900A_IOBASE_REG + 0x300)
+
+#define MXC_PMIC_INT_LINE       IOMUX_TO_IRQ(MX27_PIN_TOUT)
+
+/*!
+* This is used to detect if the CPLD version is for mx27 evb board rev-a
+*/
+#define PBC_CPLD_VERSION_IS_REVA() \
+        ((__raw_readw(PBC_VERSION_REG) & \
+        (PBC_VERSION_ADS | PBC_VERSION_EVB_REVB))\
+        == 0)
+
+/*! This is used to active or inactive ata signal in CPLD .
+ *  It is dependent with hardware
+ */
+#define PBC_ATA_SIGNAL_ACTIVE() \
+        __raw_writew(           \
+                PBC_BCTRL2_ATAFEC_EN |PBC_BCTRL2_ATAFEC_SEL | PBC_BCTRL2_ATA_EN,                PBC_BCTRL2_CLEAR_REG)
+
+#define PBC_ATA_SIGNAL_INACTIVE() \
+         __raw_writew(  \
+                PBC_BCTRL2_ATAFEC_EN |PBC_BCTRL2_ATAFEC_SEL | PBC_BCTRL2_ATA_EN,                PBC_BCTRL2_SET_REG)
+
+#define MXC_SOUND_PLAYBACK_CHAIN_DMA_EN
+#define MXC_SOUND_CAPTURE_CHAIN_DMA_EN
+
+#ifdef MXC_SOUND_PLAYBACK_CHAIN_DMA_EN
+#define MXC_SOUND_PLAYBACK_CHAIN_DMA  1
+#else
+#define MXC_SOUND_PLAYBACK_CHAIN_DMA  0
+#endif
+
+#ifdef MXC_SOUND_CAPTURE_CHAIN_DMA_EN
+#define MXC_SOUND_CAPTURE_CHAIN_DMA  1
+#else
+#define MXC_SOUND_CAPTURE_CHAIN_DMA  0
+#endif
+
+#endif				/* __ASM_ARCH_MXC_BOARD_MX27ADS_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/board-mx31ads.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/board-mx31ads.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,367 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_BOARD_MX31ADS_H__
+#define __ASM_ARCH_MXC_BOARD_MX31ADS_H__
+
+/*
+ * Include Files
+ */
+#include <asm/arch/board.h>
+
+/* Start of physical RAM */
+#define PHYS_OFFSET	        UL(0x80000000)
+
+/* Size of contiguous memory for DMA and other h/w blocks */
+#define CONSISTENT_DMA_SIZE	SZ_8M
+
+/* I2C configuration */
+/*!
+ * This defines the number of I2C modules in the MXC platform
+ * Defined as 1, as MC13783 on ADS uses the other pins
+ */
+#define I2C_NR                  1
+/*!
+ * This define specifies the frequency divider value to be written into
+ * the I2C \b IFDR register.
+ */
+#define I2C1_FRQ_DIV            0x17
+
+/*!
+ * @name MXC UART EVB board level configurations
+ */
+/*! @{ */
+/*!
+ * Specify the max baudrate for the MXC UARTs for your board, do not specify a max
+ * baudrate greater than 1500000. This is used while specifying the UART Power
+ * management constraints.
+ */
+#define MAX_UART_BAUDRATE       1500000
+/*!
+ * Specifies if the Irda transmit path is inverting
+ */
+#define MXC_IRDA_TX_INV         0
+/*!
+ * Specifies if the Irda receive path is inverting
+ */
+#define MXC_IRDA_RX_INV         0
+/* UART 1 configuration */
+/*!
+ * This define specifies if the UART port is configured to be in DTE or
+ * DCE mode. There exists a define like this for each UART port. Valid
+ * values that can be used are \b MODE_DTE or \b MODE_DCE.
+ */
+#define UART1_MODE              MODE_DCE
+/*!
+ * This define specifies if the UART is to be used for IRDA. There exists a
+ * define like this for each UART port. Valid values that can be used are
+ * \b IRDA or \b NO_IRDA.
+ */
+#define UART1_IR                NO_IRDA
+/*!
+ * This define is used to enable or disable a particular UART port. If
+ * disabled, the UART will not be registered in the file system and the user
+ * will not be able to access it. There exists a define like this for each UART
+ * port. Specify a value of 1 to enable the UART and 0 to disable it.
+ */
+#define UART1_ENABLED           1
+/*! @} */
+/* UART 2 configuration */
+#define UART2_MODE              MODE_DCE
+#define UART2_IR                IRDA
+#ifdef CONFIG_MXC_FIR_MODULE
+#define UART2_ENABLED           0
+#else
+#define UART2_ENABLED           1
+#endif
+/* UART 3 configuration */
+#define UART3_MODE              MODE_DTE
+#define UART3_IR                NO_IRDA
+#define UART3_ENABLED           1
+/* UART 4 configuration */
+#define UART4_MODE              MODE_DTE
+#define UART4_IR                NO_IRDA
+#define UART4_ENABLED           0	/* Disable UART 4 as its pins are shared with ATA */
+/* UART 5 configuration */
+#define UART5_MODE              MODE_DTE
+#define UART5_IR                NO_IRDA
+#define UART5_ENABLED           1
+
+#define MXC_LL_EXTUART_PADDR	(CS4_BASE_ADDR + 0x10000)
+#define MXC_LL_EXTUART_VADDR	CS4_IO_ADDRESS(MXC_LL_EXTUART_PADDR)
+#undef  MXC_LL_EXTUART_16BIT_BUS
+
+#define MXC_LL_UART_PADDR	UART1_BASE_ADDR
+#define MXC_LL_UART_VADDR	AIPS1_IO_ADDRESS(UART1_BASE_ADDR)
+
+/*!
+ * @name Memory Size parameters
+ */
+/*! @{ */
+/*!
+ * Size of SDRAM memory
+ */
+#define SDRAM_MEM_SIZE          SZ_128M
+/*!
+ * Size of MBX buffer memory
+ */
+#define MXC_MBX_MEM_SIZE        SZ_16M
+/*!
+ * Size of memory available to kernel
+ */
+#define MEM_SIZE                (SDRAM_MEM_SIZE - MXC_MBX_MEM_SIZE)
+/*! @} */
+
+/*!
+ * @name Keypad Configurations FIXME
+ */
+/*! @{ */
+/*!
+ * Maximum number of rows (0 to 7)
+ */
+#define MAXROW                  8
+/*!
+ * Maximum number of columns (0 to 7)
+ */
+#define MAXCOL                  8
+/*! @} */
+
+/*!
+ * @name PBC Controller parameters
+ */
+/*! @{ */
+/*!
+ * Base address of PBC controller
+ */
+#define PBC_BASE_ADDRESS        IO_ADDRESS(CS4_BASE_ADDR)
+/* Offsets for the PBC Controller register */
+/*!
+ * PBC Board status register offset
+ */
+#define PBC_BSTAT               0x000002
+/*!
+ * PBC Board control register 1 set address.
+ */
+#define PBC_BCTRL1_SET          0x000004
+/*!
+ * PBC Board control register 1 clear address.
+ */
+#define PBC_BCTRL1_CLEAR        0x000006
+/*!
+ * PBC Board control register 2 set address.
+ */
+#define PBC_BCTRL2_SET          0x000008
+/*!
+ * PBC Board control register 2 clear address.
+ */
+#define PBC_BCTRL2_CLEAR        0x00000A
+/*!
+ * PBC Board control register 3 set address.
+ */
+#define PBC_BCTRL3_SET          0x00000C
+/*!
+ * PBC Board control register 3 clear address.
+ */
+#define PBC_BCTRL3_CLEAR        0x00000E
+/*!
+ * PBC Board control register 4 set address.
+ */
+#define PBC_BCTRL4_SET          0x000010
+/*!
+ * PBC Board control register 4 clear address.
+ */
+#define PBC_BCTRL4_CLEAR        0x000012
+/*!
+ * PBC Board status register 1.
+ */
+#define PBC_BSTAT1              0x000014
+/*!
+ * PBC Board interrupt status register.
+ */
+#define PBC_INTSTATUS           0x000016
+/*!
+ * PBC Board interrupt current status register.
+ */
+#define PBC_INTCURR_STATUS      0x000018
+/*!
+ * PBC Interrupt mask register set address.
+ */
+#define PBC_INTMASK_SET         0x00001A
+/*!
+ * PBC Interrupt mask register clear address.
+ */
+#define PBC_INTMASK_CLEAR       0x00001C
+
+/*!
+ * External UART A.
+ */
+#define PBC_SC16C652_UARTA      0x010000
+/*!
+ * External UART B.
+ */
+#define PBC_SC16C652_UARTB      0x010010
+/*!
+ * Ethernet Controller IO base address.
+ */
+#define PBC_CS8900A_IOBASE      0x020000
+/*!
+ * Ethernet Controller Memory base address.
+ */
+#define PBC_CS8900A_MEMBASE     0x021000
+/*!
+ * Ethernet Controller DMA base address.
+ */
+#define PBC_CS8900A_DMABASE     0x022000
+/*!
+ * External chip select 0.
+ */
+#define PBC_XCS0                0x040000
+/*!
+ * LCD Display enable.
+ */
+#define PBC_LCD_EN_B            0x060000
+/*!
+ * Code test debug enable.
+ */
+#define PBC_CODE_B              0x070000
+/*!
+ * PSRAM memory select.
+ */
+#define PBC_PSRAM_B             0x5000000
+
+/* PBC Board Status Register 1 bit definitions */
+#define PBC_BSTAT1_NF_DET       0x0001	/* NAND flash card. 0 = connected */
+#define PBC_BSTAT1_KP_ON        0x0002	/* KPP board. 0 = connected */
+#define PBC_BSTAT1_LS           0x0004	/* KPP:LightSense signal */
+#define PBC_BSTAT1_ATA_IOCS16   0x0008	/* ATA_IOCS16 signal */
+#define PBC_BSTAT1_ATA_CBLID    0x0010	/* ATA_CBLID signal */
+#define PBC_BSTAT1_ATA_DASP     0x0020	/* ATA_DASP signal */
+#define PBC_BSTAT1_PWR_RDY      0x0040	/* MC13783 power. 1 = ready */
+#define PBC_BSTAT1_SD1_WP       0x0080	/* 0 = SD1 card is write protected */
+#define PBC_BSTAT1_SD2_WP       0x0100	/* 0 = SD2 card is write protected */
+#define PBC_BSTAT1_FS1          0x0200	/* KPP:FlipSense1 signal */
+#define PBC_BSTAT1_FS2          0x0400	/* KPP:FlipSense2 signal */
+#define PBC_BSTAT1_PTT          0x0800	/* KPP:PTT signal */
+#define PBC_BSTAT1_MC13783_IN   0x1000	/* MC13783 board. 0 = connected. */
+
+/* PBC Board Control Register 1 bit definitions */
+#define PBC_BCTRL1_ERST         0x0001	/* Ethernet Reset */
+#define PBC_BCTRL1_URST         0x0002	/* Reset External UART controller */
+#define PBC_BCTRL1_UENA         0x0004	/* Enable UART A transceiver */
+#define PBC_BCTRL1_UENB         0x0008	/* Enable UART B transceiver */
+#define PBC_BCTRL1_UENCE        0x0010	/* Enable UART CE transceiver */
+#define PBC_BCTRL1_IREN         0x0020	/* Enable the IRDA transmitter */
+#define PBC_BCTRL1_LED0         0x0040	/* Used to control LED 0 (green) */
+#define PBC_BCTRL1_LED1         0x0080	/* Used to control LED 1 (yellow) */
+#define PBC_BCTRL1_SENSOR1_ON	0x0600	/* Enable Sensor 1 */
+#define PBC_BCTRL1_SENSOR2_ON	0x3000	/* Enable Sensor 2 */
+#define PBC_BCTRL1_BEND         0x4000	/* Big Endian Select */
+#define PBC_BCTRL1_LCDON        0x8000	/* Enable the LCD */
+
+/* PBC Board Control Register 2 bit definitions */
+#define PBC_BCTRL2_USELA	0x0001	/* UART A Select, 0 = UART1, 1 = UART5 */
+#define PBC_BCTRL2_USELB	0x0002	/* UART B Select, 0 = UART3, 1 = UART5 */
+#define PBC_BCTRL2_USELC	0x0004	/* UART C Select, 0 = UART2, 1 = UART1 */
+#define PBC_BCTRL2_UMODENA	0x0008	/* UART A Modem Signals Enable, 0 = enabled */
+#define PBC_BCTRL2_UMODENC	0x0008	/* UART C Modem Signals Enable, 0 = enabled */
+#define PBC_BCTRL2_CSI_EN	0x0020	/* Enable the CSI interface, 0 = enabled */
+#define PBC_BCTRL2_ATA_EN	0x0040	/* Enable the ATA interface, 0 = enabled */
+#define PBC_BCTRL2_ATA_SEL	0x0080	/* ATA Select, 0 = group A, 1 = group B */
+#define PBC_BCTRL2_IRDA_MOD	0x0100	/* IRDA Mode (see CPLD spec) */
+#define PBC_BCTRL2_LDC_RST0	0x0200	/* LCD 0 Reset, 1 = reset signal asserted */
+#define PBC_BCTRL2_LDC_RST1	0x0400	/* LCD 1 Reset, 1 = reset signal asserted */
+#define PBC_BCTRL2_LDC_RST2	0x0800	/* LCD 2 Reset, 1 = reset signal asserted */
+#define PBC_BCTRL2_LDCIO_EN	0x1000	/* LCD GPIO Enable, 0 = enabled */
+#define PBC_BCTRL2_CT_CS	0x2000	/* Code Test Chip Select, = Code Test selected */
+#define PBC_BCTRL2_VPP_EN	0x4000	/* PCMCIA VPP Enable, 1 = power on */
+#define PBC_BCTRL2_VCC_EN	0x8000	/* PCMCIA VCC Enable, 1 = power on */
+
+/* PBC Board Control Register 3 bit definitions */
+#define PBC_BCTRL3_OTG_FS_SEL	0x0001	/* USB OTG Full Speed Select, 0 = PMIC, 1 = CPU */
+#define PBC_BCTRL3_OTG_FS_EN	0x0002	/* USB OTG Full Speed Enable, 0 = enabled */
+#define PBC_BCTRL3_FSH_SEL	0x0004	/* USB Full Speed Host Select, 0 = Group A, 1 = Group B */
+#define PBC_BCTRL3_FSH_EN	0x0008	/* USB Full Speed Host Enable, 0 = enabled */
+#define PBC_BCTRL3_HSH_SEL	0x0010	/* USB High Speed Host Select, 0 = Group A, 1 = Group B */
+#define PBC_BCTRL3_HSH_EN	0x0020	/* USB High Speed Host Enable, 0 = enabled */
+#define PBC_BCTRL3_FSH_MOD	0x0040	/* USB Full Speed Host Mode, 0 = Differential, 1 = Single ended */
+#define PBC_BCTRL3_OTG_HS_EN	0x0080	/* USB OTG High Speed Enable, 0 = enabled */
+#define PBC_BCTRL3_OTG_VBUS_EN	0x0100	/* USB OTG VBUS Regulator Enable, 0 = enabled */
+#define PBC_BCTRL3_FSH_VBUS_EN	0x0200	/* USB Full Speed Host VBUS Regulator Enable, 0 = enabled */
+#define PBC_BCTRL3_CARD1_SEL	0x0400	/* Card1 Select, 0 = SD1, 1 = MS1 */
+#define PBC_BCTRL3_CARD2_SEL	0x0800	/* Card2 Select, 0 = PCMCIA & SD2, 1 = MS2 */
+#define PBC_BCTRL3_SYNTH_RST	0x1000	/* Audio Synthesizer Reset, 0 = reset asserted */
+#define PBC_BCTRL3_VSIM_EN	0x2000	/* VSIM Regulator Enable, 1 = enabled */
+#define PBC_BCTRL3_VESIM_EN	0x4000	/* VESIM Regulator Enable, 1 = enabled */
+#define PBC_BCTRL3_SPI3_RESET	0x8000	/* CSPI3 Connector Reset, 0 = reset asserted */
+
+/* PBC Board Control Register 4 bit definitions */
+#define PBC_BCTRL4_CSI_MSB_EN	0x0001	/* CSI MSB Enable, 0 = CSI_Data[3:0] enabled */
+#define PBC_BCTRL4_REGEN_SEL	0x0002	/* Regulator Enable Select, 0 = enabled */
+#define PBC_BCTRL4_USER_OFF	0x0004	/* User Off Indication, 1 = user off confirmation */
+#define PBC_BCTRL4_VIB_EN	0x0008	/* Vibrator Enable, 1 = enabled */
+#define PBC_BCTRL4_PCMCIA_EN	0x0010	/* PCMCIA Enable, 0 = buffer enabled */
+
+#define PBC_INT_CS8900A         4
+/*! @} */
+
+#define PBC_INTSTATUS_REG	(PBC_INTSTATUS + PBC_BASE_ADDRESS)
+#define PBC_INTCURR_STATUS_REG	(PBC_INTCURR_STATUS + PBC_BASE_ADDRESS)
+#define PBC_INTMASK_SET_REG	(PBC_INTMASK_SET + PBC_BASE_ADDRESS)
+#define PBC_INTMASK_CLEAR_REG	(PBC_INTMASK_CLEAR + PBC_BASE_ADDRESS)
+#define EXPIO_PARENT_INT	IOMUX_TO_IRQ(MX31_PIN_GPIO1_4)
+
+#define EXPIO_INT_LOW_BAT	(MXC_EXP_IO_BASE + 0)
+#define EXPIO_INT_PB_IRQ	(MXC_EXP_IO_BASE + 1)
+#define EXPIO_INT_OTG_FS_OVR	(MXC_EXP_IO_BASE + 2)
+#define EXPIO_INT_FSH_OVR	(MXC_EXP_IO_BASE + 3)
+#define EXPIO_INT_RES4		(MXC_EXP_IO_BASE + 4)
+#define EXPIO_INT_RES5		(MXC_EXP_IO_BASE + 5)
+#define EXPIO_INT_RES6		(MXC_EXP_IO_BASE + 6)
+#define EXPIO_INT_RES7		(MXC_EXP_IO_BASE + 7)
+#define EXPIO_INT_ENET_INT	(MXC_EXP_IO_BASE + 8)
+#define EXPIO_INT_OTG_FS_INT	(MXC_EXP_IO_BASE + 9)
+#define EXPIO_INT_XUART_INTA	(MXC_EXP_IO_BASE + 10)
+#define EXPIO_INT_XUART_INTB	(MXC_EXP_IO_BASE + 11)
+#define EXPIO_INT_SYNTH_IRQ	(MXC_EXP_IO_BASE + 12)
+#define EXPIO_INT_CE_INT1	(MXC_EXP_IO_BASE + 13)
+#define EXPIO_INT_CE_INT2	(MXC_EXP_IO_BASE + 14)
+#define EXPIO_INT_RES15		(MXC_EXP_IO_BASE + 15)
+
+#define MXC_MAX_EXP_IO_LINES	16
+
+/*!
+ * @name  Defines Base address and IRQ used for CS8900A Ethernet Controller on MXC Boards
+ */
+/*! @{*/
+/*! This is System IRQ used by CS8900A for interrupt generation taken from platform.h */
+#define CS8900AIRQ              EXPIO_INT_ENET_INT
+/*! This is I/O Base address used to access registers of CS8900A on MXC ADS */
+#define CS8900A_BASE_ADDRESS    (PBC_BASE_ADDRESS + PBC_CS8900A_IOBASE + 0x300)
+/*! @} */
+
+#define MXC_PMIC_INT_LINE	IOMUX_TO_IRQ(MX31_PIN_GPIO1_3)
+
+#define AHB_FREQ                133000000
+#define IPG_FREQ                66500000
+
+/*! This is used to active or inactive ata signal in CPLD .
+ *  It is dependent with hardware
+ */
+#define PBC_ATA_SIGNAL_ACTIVE() \
+        __raw_writew(PBC_BCTRL2_ATA_SEL, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);\
+        __raw_writew(PBC_BCTRL2_ATA_EN, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+#define PBC_ATA_SIGNAL_INACTIVE() \
+         __raw_writew(PBC_BCTRL2_ATA_EN, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+#endif				/* __ASM_ARCH_MXC_BOARD_MX31ADS_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/clock.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/clock.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,308 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_CLOCK_H__
+#define __ASM_ARCH_MXC_CLOCK_H__
+
+/*!
+ * @defgroup CLOCKS Clocking Setup and Retrieving
+ * @ingroup MSL
+ */
+
+/*!
+ * @file clock.h
+ *
+ * @brief API for setting up and retrieving clocks.
+ *
+ * This file contains API for setting up and retrieving clocks.
+ *
+ * @ingroup CLOCKS
+ */
+
+#ifndef __ASSEMBLY__
+/*!
+ * Enumerations of plls and available clock sources
+ */
+enum plls {
+	MCUPLL = 0,		/*!< MCU PLL */
+	USBPLL = 2,		/*!< USB PLL */
+	DSPPLL = 1,		/*!< DSP PLL */
+	CDPLL = 3,		/*!< Corrected Clock PLL */
+	CKIH = 4,		/*!< Main Network clock */
+	CKIH_X2 = 5,		/*!< Doubled version of CKIH */
+	DIGRF = 6,		/*!< DIGRF ref clock */
+	DIGRF_X2 = 7,		/*!< Doubled version of DIGRF */
+	USBCLK = 8,		/*!< USB Clock */
+	MRCG_2_CLK = 9,		/*!< MRCG CLock */
+	TURBOPLL,		/*!< Turbo PLL */
+	SERIALPLL,		/*!<  PLL */
+};
+
+enum mxc_clk_out {
+	CKOH,
+	CKO,
+	CKO2,
+	CKO1,
+};
+
+/*!
+ * Enumerations for MXC clocks
+ */
+enum mxc_clocks {
+	CLK_NONE,
+	CKIL_CLK,
+	CKIH_CLK,
+	CPU_CLK,
+	AHB_CLK,
+	IPG_CLK,
+	NFC_CLK,
+	USB_CLK,
+	UART1_BAUD,
+	UART2_BAUD,
+	UART3_BAUD,
+	UART4_BAUD,
+	UART5_BAUD,
+	UART6_BAUD,
+	SSI1_BAUD,
+	SSI2_BAUD,
+	CSI_BAUD,
+	FIRI_BAUD,
+	I2C_CLK,
+	I2C1_CLK = I2C_CLK,
+	I2C2_CLK,
+	I2C3_CLK,
+	CSPI1_CLK,
+	CSPI2_CLK,
+	CSPI3_CLK,
+	GPT_CLK,
+	GPT1_CLK = GPT_CLK,
+	GPT2_CLK,
+	GPT3_CLK,
+	GPT4_CLK,
+	GPT5_CLK,
+	GPT6_CLK,
+	RTC_CLK,
+	EPIT1_CLK,
+	EPIT2_CLK,
+	EDIO_CLK,
+	WDOG_CLK,
+	WDOG2_CLK,
+	PWM_CLK,
+	IPU_CLK,
+	SIM1_CLK,
+	SIM2_CLK,
+	HAC_CLK,
+	GEM_CLK,
+	SDHC1_CLK,
+	SDHC2_CLK,
+	SDMA_CLK,
+	RNG_CLK,
+	KPP_CLK,
+	MU_CLK,
+	RTIC_CLK,
+	SCC_CLK,
+	SPBA_CLK,
+	DSM_CLK,
+	SAHARA2_CLK,
+	MQSPI_IPG_CLK,
+	MQSPI_CKIH_CLK,
+	EL1T_IPG_CLK,
+	EL1T_NET_CLK,
+	LPMC_CLK,
+	MPEG4_CLK,
+	OWIRE_CLK,
+	MBX_CLK,
+	MSTICK1_BAUD,
+	MSTICK2_BAUD,
+	ATA_CLK,
+	PERCLK1,
+	PERCLK2,
+	PERCLK3,
+	PERCLK4,
+	DMA_CLK,
+	EMMA_PRP_CLK,
+	EMMA_PP_CLK,
+	FEC_CLK,
+	GPIO_CLK,
+	IIM_CLK,
+	LCDC_CLK,
+	SDHC3_CLK,
+	SLCDC_CLK,
+	BROM_CLK,
+	EMI_CLK,
+	VPU_BAUD,
+	BMI_AHB_CLK,
+};
+
+/*!
+ * This function is used to modify PLL registers to generate the required
+ * frequency.
+ *
+ * @param  pll      the PLL that you wish to modify
+ * @param  mfi      multiplication factor integer part
+ * @param  pdf      pre-division factor
+ * @param  mfd      multiplication factor denominator
+ * @param  mfn      multiplication factor numerator
+ */
+void mxc_pll_set(enum plls pll, unsigned int mfi, unsigned int pdf,
+		 unsigned int mfd, unsigned int mfn);
+
+/*!
+ * This function is used to get PLL registers values used generate the clock
+ * frequency.
+ *
+ * @param  pll      the PLL that you wish to access
+ * @param  mfi      pointer that holds multiplication factor integer part
+ * @param  pdf      pointer that holds pre-division factor
+ * @param  mfd      pointer that holds multiplication factor denominator
+ * @param  mfn      pointer that holds multiplication factor numerator
+ */
+void mxc_pll_get(enum plls pll, unsigned int *mfi, unsigned int *pdf,
+		 unsigned int *mfd, unsigned int *mfn);
+
+/*!
+ * This function returns the PLL output value in Hz based on pll.
+ *
+ * @param       pll     PLL as defined in enum plls
+ *
+ * @return      PLL value in Hz.
+ */
+unsigned long mxc_pll_clock(enum plls pll);
+
+/*!
+ * This function returns the clock value in Hz for various MXC modules.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks(enum mxc_clocks clk);
+
+/*!
+ * This function returns the parent clock value in Hz for various MXC modules.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks_parent(enum mxc_clocks clk);
+
+/*!
+ * This function sets the PLL source for a clock.
+ *
+ * @param clk     as defined in enum mxc_clocks
+ * @param pll_num the PLL that you wish to use as source for this clock
+ */
+void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num);
+
+/*!
+ * This function sets the division factor for a clock.
+ *
+ * @param clk as defined in enum mxc_clocks
+ * @param div the division factor to be used for the clock (For SSI, pass in
+ *            2 times the expected division value to account for FP vals)
+ */
+void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div);
+
+/*!
+ * This function returns the peripheral clock dividers.
+ * Note that for SSI divider, in order to maintain the accuracy, the returned
+ * divider is doubled.
+ *
+ * @param       clk     peripheral clock as defined in enum mxc_clocks
+ *
+ * @return      divider value
+ */
+unsigned long mxc_peri_clock_divider(enum mxc_clocks clk);
+
+/*!
+ * This function returns the main clock dividers.
+ *
+ * @param       clk     peripheral clock as defined in enum mxc_clocks
+ *
+ * @return      divider value
+ */
+unsigned long mxc_main_clock_divider(enum mxc_clocks clk);
+
+/*!
+ * This function sets the digital frequency multiplier clock.
+ *
+ * @param       freq    Desired DFM output frequency in Hz
+ *
+ * @return      Actual DFM frequency in Hz
+ */
+unsigned long mxc_set_dfm_clock(unsigned int freq);
+
+/*!
+ * This function returns the DFS block divider - LFDF value
+ *
+ * @return      Low Voltage frequency Divider Factor value
+ */
+unsigned int mxc_get_lfdf_value(void);
+
+/*!
+ * This function is called to gate off the individual module clocks
+ *
+ * @param clks     as defined in enum mxc_clocks
+ */
+void mxc_clks_disable(enum mxc_clocks clks);
+
+/*!
+ * This function is called to enable the individual module clocks
+ *
+ * @param clks     as defined in enum mxc_clocks
+ */
+void mxc_clks_enable(enum mxc_clocks clks);
+
+/*!
+ * This function is called to read the contents of a CCM register
+ *
+ * @param reg_offset the CCM register that will read
+ *
+ * @return the register contents
+ */
+unsigned long mxc_ccm_get_reg(unsigned int reg_offset);
+
+/*!
+ * This function is called to modify the contents of a CCM register
+ *
+ * @param reg_offset the CCM register that will read
+ * @param mask       the mask to be used to clear the bits that are to be modified
+ * @param data       the data that should be written to the register
+ */
+void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
+			unsigned int data);
+
+/*!
+ * Configure clock output on CKO1/CKO2 pins
+ *
+ * @param   output  The desired clock needed to measure. Possible
+ *                  values are, CKOH_AP_SEL, CKOH_AHB_SEL or CKOH_IP_SEL
+ * @param   clk     as defined in enum mxc_clocks
+ * @param   div     divider value
+ *
+ */
+void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk,
+			  int div);
+
+/*!
+ * This function returns the divider value for a clock.
+ *
+ * @param       clk as defined in enum mxc_clocks
+ *
+ * @return      divider value
+ */
+unsigned long mxc_get_clocks_div(enum mxc_clocks clk);
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_CLOCK_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/debug-macro.S	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/debug-macro.S	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,57 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <asm/arch/hardware.h>
+
+        .macro  addruart,rx
+                mrc     p15, 0, \rx, c1, c0
+                tst     \rx, #1                 /* MMU enabled? */
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+                ldreq   \rx, =MXC_LL_EXTUART_PADDR /* Physical Addr of EXT UART A */
+                ldrne   \rx, =MXC_LL_EXTUART_VADDR /* Virtual Addr */
+#else
+                ldreq   \rx, =MXC_LL_UART_PADDR /* Physical Addr of MXC UART */
+                ldrne   \rx, =MXC_LL_UART_VADDR /* Virtual Addr */
+#endif
+
+        .endm
+
+        .macro  senduart,rd,rx
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+#ifdef MXC_LL_EXTUART_16BIT_BUS
+                strh    \rd, [\rx]
+#else
+                strb    \rd, [\rx]
+#endif
+#else
+                strh    \rd, [\rx, #0x40]
+#endif
+        .endm
+
+        .macro  busyuart,rd,rx
+        .endm
+
+        .macro  waituart,rd,rx
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+#ifdef MXC_LL_EXTUART_16BIT_BUS
+1001:           ldrh    \rd, [\rx, #0xA]        /* LSR_TEMPT ? */
+#else
+1001:           ldrb    \rd, [\rx, #0x5]        /* LSR_TEMPT ? */
+#endif
+                tst     \rd, #0x40
+#else
+1001:           ldrh    \rd, [\rx, #0x98]       /* TXFE ? */
+                tst     \rd, #0x4000
+#endif
+                beq     1001b
+        .endm
--- linux-2.6.19.2/include/asm-arm/arch-mxc/dma.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/dma.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,255 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_DMA_H__
+#define __ASM_ARCH_MXC_DMA_H__
+
+/*!
+ * @file dma.h
+ * @brief This file contains Unified DMA API for all MXC platforms.
+ * The API is platform independent.
+ *
+ * @ingroup SDMA
+ */
+#define MXC_DMA_DYNAMIC_CHANNEL   255
+
+#define MXC_DMA_DONE		  0x0
+#define MXC_DMA_REQUEST_TIMEOUT   0x1
+#define MXC_DMA_TRANSFER_ERROR    0x2
+
+/*! This defines the list of device ID's for DMA */
+typedef enum mxc_dma_device {
+	MXC_DMA_UART1_RX,
+	MXC_DMA_UART1_TX,
+	MXC_DMA_UART2_RX,
+	MXC_DMA_UART2_TX,
+	MXC_DMA_UART3_RX,
+	MXC_DMA_UART3_TX,
+	MXC_DMA_UART4_RX,
+	MXC_DMA_UART4_TX,
+	MXC_DMA_UART5_RX,
+	MXC_DMA_UART5_TX,
+	MXC_DMA_UART6_RX,
+	MXC_DMA_UART6_TX,
+	MXC_DMA_MMC1_WIDTH_1,
+	MXC_DMA_MMC1_WIDTH_4,
+	MXC_DMA_MMC2_WIDTH_1,
+	MXC_DMA_MMC2_WIDTH_4,
+	MXC_DMA_SSI1_8BIT_RX0,
+	MXC_DMA_SSI1_8BIT_TX0,
+	MXC_DMA_SSI1_16BIT_RX0,
+	MXC_DMA_SSI1_16BIT_TX0,
+	MXC_DMA_SSI1_24BIT_RX0,
+	MXC_DMA_SSI1_24BIT_TX0,
+	MXC_DMA_SSI1_8BIT_RX1,
+	MXC_DMA_SSI1_8BIT_TX1,
+	MXC_DMA_SSI1_16BIT_RX1,
+	MXC_DMA_SSI1_16BIT_TX1,
+	MXC_DMA_SSI1_24BIT_RX1,
+	MXC_DMA_SSI1_24BIT_TX1,
+	MXC_DMA_SSI2_8BIT_RX0,
+	MXC_DMA_SSI2_8BIT_TX0,
+	MXC_DMA_SSI2_16BIT_RX0,
+	MXC_DMA_SSI2_16BIT_TX0,
+	MXC_DMA_SSI2_24BIT_RX0,
+	MXC_DMA_SSI2_24BIT_TX0,
+	MXC_DMA_SSI2_8BIT_RX1,
+	MXC_DMA_SSI2_8BIT_TX1,
+	MXC_DMA_SSI2_16BIT_RX1,
+	MXC_DMA_SSI2_16BIT_TX1,
+	MXC_DMA_SSI2_24BIT_RX1,
+	MXC_DMA_SSI2_24BIT_TX1,
+	MXC_DMA_FIR_RX,
+	MXC_DMA_FIR_TX,
+	MXC_DMA_CSPI1_RX,
+	MXC_DMA_CSPI1_TX,
+	MXC_DMA_CSPI2_RX,
+	MXC_DMA_CSPI2_TX,
+	MXC_DMA_ATA_RX,
+	MXC_DMA_ATA_TX,
+	MXC_DMA_MEMORY,
+	MXC_DMA_DSP_PACKET_DATA0_RD,
+	MXC_DMA_DSP_PACKET_DATA0_WR,
+	MXC_DMA_DSP_PACKET_DATA1_RD,
+	MXC_DMA_DSP_PACKET_DATA1_WR,
+	MXC_DMA_DSP_LOG0_CHNL,
+	MXC_DMA_DSP_LOG1_CHNL,
+	MXC_DMA_DSP_LOG2_CHNL,
+	MXC_DMA_DSP_LOG3_CHNL,
+	MXC_DMA_TEST_RAM2D2RAM,
+	MXC_DMA_TEST_RAM2RAM2D,
+	MXC_DMA_TEST_RAM2D2RAM2D,
+	MXC_DMA_TEST_RAM2RAM,
+	MXC_DMA_TEST_HW_CHAINING,
+	MXC_DMA_TEST_SW_CHAINING
+} mxc_dma_device_t;
+
+/*! This defines the prototype of callback funtion registered by the drivers */
+typedef void (*mxc_dma_callback_t) (void *arg, int error_status,
+				    unsigned int count);
+
+/*! This defines the type of DMA transfer requested */
+typedef enum mxc_dma_mode {
+	MXC_DMA_MODE_READ,
+	MXC_DMA_MODE_WRITE,
+} mxc_dma_mode_t;
+
+/*! This defines the DMA channel parameters */
+typedef struct mxc_dma_channel {
+	unsigned int active:1;	/*!< When there has a active tranfer, it is set to 1 */
+	unsigned int lock;	/*!< Defines the channel is allocated or not */
+	int curr_buf;		/*!< Current buffer */
+	mxc_dma_mode_t mode;	/*!< Read or Write */
+	unsigned int channel;	/*!< Channel info */
+	unsigned int dynamic:1;	/*!< Channel not statically allocated when 1 */
+	char *dev_name;		/*!< Device name */
+	void *private;		/*!< Private structure for platform */
+	mxc_dma_callback_t cb_fn;	/*!< The callback function */
+	void *cb_args;		/*!< The argument of callback function */
+} mxc_dma_channel_t;
+
+/*! This structure contains the information about a dma transfer */
+typedef struct mxc_dma_requestbuf {
+	dma_addr_t src_addr;	/*!< source address */
+	dma_addr_t dst_addr;	/*!< destination address */
+	int num_of_bytes;	/*!< the length of this transfer : bytes */
+} mxc_dma_requestbuf_t;
+
+#if defined(CONFIG_ARCH_MX27)
+#include <asm/arch/mx2_dma.h>
+#else
+#include <asm/arch/sdma.h>
+#endif
+
+/*!
+ * This function is generally called by the driver at open time.
+ * The DMA driver would do any initialization steps that is required
+ * to get the channel ready for data transfer.
+ *
+ * @param channel_id   a pre-defined id. The peripheral driver would specify
+ *                     the id associated with its peripheral. This would be
+ *                     used by the DMA driver to identify the peripheral
+ *                     requesting DMA and do the necessary setup on the
+ *                     channel associated with the particular peripheral.
+ *                     The DMA driver could use static or dynamic DMA channel
+ *                     allocation.
+ * @param dev_name     module name or device name
+ * @return returns a negative number on error if request for a DMA channel did not
+ *         succeed, returns the channel number to be used on success.
+ */
+extern int mxc_dma_request(mxc_dma_device_t channel_id, char *dev_name);
+
+/*!
+ * This function is generally called by the driver at close time. The DMA
+ * driver would do any cleanup associated with this channel.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_free(int channel_num);
+
+/*!
+ * This function would just configure the buffers specified by the user into
+ * dma channel. The caller must call mxc_dma_enable to start this transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param dma_buf      an array of physical addresses to the user defined
+ *                     buffers. The caller must guarantee the dma_buf is
+ *                     available until the transfer is completed.
+ * @param num_buf      number of buffers in the array
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not be
+ *         added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_config(int channel_num, mxc_dma_requestbuf_t * dma_buf,
+			  int num_buf, mxc_dma_mode_t mode);
+
+/*!
+ * This function would just configure the scatterlist specified by the
+ * user into dma channel. This is a slight variation of mxc_dma_config(),
+ * it is provided for the convenience of drivers that have a scatterlist
+ * passed into them. It is the calling driver's responsibility to have the
+ * correct physical address filled in the "dma_address" field of the
+ * scatterlist.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param sg           a scatterlist of buffers. The caller must guarantee
+ *                     the dma_buf is available until the transfer is
+ *                     completed.
+ * @param num_buf      number of buffers in the array
+ * @param num_of_bytes total number of bytes to transfer. If set to 0, this
+ *                     would imply to use the length field of the scatterlist
+ *                     for each DMA transfer. Else it would calculate the size
+ *                     for each DMA transfer.
+ * @param mode         specifies whether this is READ or WRITE operation
+ * @return This function returns a negative number on error if buffer could not
+ *         be added with DMA for transfer. On Success, it returns 0
+ */
+extern int mxc_dma_sg_config(int channel_num, struct scatterlist *sg,
+			     int num_buf, int num_of_bytes,
+			     mxc_dma_mode_t mode);
+
+/*!
+ * This function is provided if the driver would like to set/change its
+ * callback function.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @param callback     a callback function to provide notification on transfer
+ *                     completion, user could specify NULL if he does not wish
+ *                     to be notified
+ * @param arg          an argument that gets passed in to the callback
+ *                     function, used by the user to do any driver specific
+ *                     operations.
+ * @return this function returns a negative number on error if the callback
+ *         could not be set for the channel or 0 on success
+ */
+extern int mxc_dma_callback_set(int channel_num, mxc_dma_callback_t callback,
+				void *arg);
+
+/*!
+ * This stops the DMA channel and any ongoing transfers. Subsequent use of
+ * mxc_dma_enable() will restart the channel and restart the transfer.
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_disable(int channel_num);
+
+/*!
+ * This starts DMA transfer. Or it restarts DMA on a stopped channel
+ * previously stopped with mxc_dma_disable().
+ *
+ * @param channel_num  the channel number returned at request time. This
+ *                     would be used by the DMA driver to identify the calling
+ *                     driver and do the necessary cleanup on the channel
+ *                     associated with the particular peripheral
+ * @return returns a negative number on error or 0 on success
+ */
+extern int mxc_dma_enable(int channel_num);
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/dpm.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/dpm.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,151 @@
+/* REVISIT Doxygen fixups */
+/*
+ * DPM for Freescale MXC
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002-2004, MontaVista Software <source@mvista.com>
+ *
+ * Initially based on include/asm-arm/arch-omap/omap_dpm.h
+ */
+
+#ifndef __ASM_ARCH_MXC_DPM_H__
+#define __ASM_ARCH_MXC_DPM_H__
+
+#include <asm/io.h>
+#include <asm/timex.h>
+
+/*!
+ * @defgroup DPM Dynamic Power Management
+ * @ingroup MSL
+ */
+
+/*!
+ * @file dpm.h
+ *
+ * @brief This file provides DPM support hooks for the Freescale MXC
+ *
+ * @ingroup DPM
+ */
+
+/*!
+ * machine dependent operating state
+ *
+ * An operating state is a cpu execution state that has implications for power
+ * management. The DPM will select operating points based largely on the
+ * current operating state.
+ *
+ * DPM_STATES is the number of supported operating states. Valid operating
+ * states are from 0 to DPM_STATES-1 but when setting an operating state the
+ * kernel should only specify a state from the set of "base states" and should
+ * do so by name.  During the context switch the new operating state is simply
+ * extracted from current->dpm_state.
+ *
+ * task states:
+ *
+ * APIs that reference task states use the range -(DPM_TASK_STATE_LIMIT + 1)
+ * through +DPM_TASK_STATE_LIMIT.  This value is added to DPM_TASK_STATE to
+ * obtain the downward or upward adjusted task state value. The
+ * -(DPM_TASK_STATE_LIMIT + 1) value is interpreted specially, and equates to
+ * DPM_NO_STATE.
+ *
+ * Tasks inherit their task operating states across calls to
+ * fork(). DPM_TASK_STATE is the default operating state for all tasks, and is
+ * inherited from init.  Tasks can change (or have changed) their tasks states
+ * using the DPM_SET_TASK_STATE variant of the sys_dpm() system call.
+ */
+#define DPM_IDLE_TASK_STATE  0
+#define DPM_IDLE_STATE       1
+#define DPM_SLEEP_STATE      2
+#define DPM_BASE_STATES      3
+
+#define DPM_TASK_STATE_LIMIT 4
+#define DPM_TASK_STATE       (DPM_BASE_STATES + DPM_TASK_STATE_LIMIT)
+#define DPM_STATES           (DPM_TASK_STATE + DPM_TASK_STATE_LIMIT + 1)
+#define DPM_TASK_STATES      (DPM_STATES - DPM_BASE_STATES)
+
+#define DPM_STATE_NAMES                  \
+{ "idle-task", "idle", "sleep",          \
+  "task-4", "task-3", "task-2", "task-1",\
+  "task",                                \
+  "task+1", "task+2", "task+3", "task+4" \
+}
+
+#define DPM_PARAM_NAMES				\
+{ "core", "ahb",     \
+  "ip", "mode" }
+
+/*!
+ * MD operating point parameters
+ */
+#define DPM_CORE_FREQ         0
+#define DPM_AHB_FREQ          1
+#define DPM_IP_FREQ           2
+#define DPM_MODE              3
+
+#define DPM_PP_NBR 4
+
+#ifndef __ASSEMBLER__
+
+#include <linux/types.h>
+#include <linux/proc_fs.h>
+
+#define dpm_time()	get_cycles()
+
+extern unsigned long clock_to_usecs(unsigned long);
+#define dpm_time_to_usec(ticks) (clock_to_usecs(ticks))
+
+/*!
+ * The register values only include the bits manipulated by the DPM
+ * system - other bits that also happen to reside in these registers are
+ * not represented here.
+ */
+struct dpm_regs {
+};
+
+/*!
+ * Instances of this structure define valid MXC operating points for DPM.
+ * Voltages are represented in mV, and frequencies are represented in KHz.
+ */
+struct dpm_md_opt {
+	unsigned int cpu;	/* in KHz */
+	unsigned int ahb;	/* in KHz */
+	unsigned int ip;	/* in KHz */
+	unsigned int mode;
+	struct dpm_regs regs;	/* Register values */
+};
+
+#ifdef CONFIG_MACH_MX27ADS
+#define ARM_MAX 400000000
+#define ARM_MIN 33250000
+#define AHB_MAX 133000000
+#define AHB_MIN 33250000
+#define IPG_MAX 66500000
+#define IPG_MIN 16625000
+#else
+#define ARM_MAX 532000000
+#define ARM_MIN 133000000
+#define AHB_MAX AHB_FREQ
+#define AHB_MIN AHB_FREQ
+#define IPG_MAX IPG_FREQ
+#define IPG_MIN IPG_FREQ
+#endif
+
+#define DPM_MODE_SLEEP 0
+#define DPM_MODE_RUN 1
+#define DPM_MODE_WAIT 2
+#define DPM_MODE_STOP 3
+#endif				/* __ASSEMBLER__ */
+#endif				/* __ASM_ARCH_MXC_DPM_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/dptc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/dptc.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,189 @@
+
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dptc.h
+ *
+ * @brief MXC dptc header file.
+ *
+ * @ingroup PM
+ */
+#ifndef __ASM_ARCH_MXC_DPTC_H__
+#define __ASM_ARCH_MXC_DPTC_H__
+
+#include <asm/arch/dvfs_dptc_struct.h>
+
+#ifdef CONFIG_MXC_DVFS
+#include <asm/arch/dvfs.h>
+#endif
+
+/*!
+ * DPTC proc file system entry name
+ */
+#define PROC_NODE_NAME	"dptc"
+
+int __init init_dptc_controller(dvfs_dptc_params_s * params);
+
+/*!
+ * This function enables the DPTC module. this function updates the DPTC
+ * thresholds, updates the PMIC, unmasks the DPTC interrupt and enables
+ * the DPTC module
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DPTC module was enabled else returns -EINVAL.
+ */
+int start_dptc(dvfs_dptc_params_s * params);
+/*!
+ * This function disables the DPTC module.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DPTC module was disabled else returns -EINVAL.
+ */
+int stop_dptc(dvfs_dptc_params_s * params);
+/*!
+ * This function updates the drivers current working point index. This index is
+ * used for access the current DTPC table entry and it corresponds to the
+ * current CPU working point measured by the DPTC hardware.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    new_wp	New working point index value to be set.
+ *
+ */
+void set_dptc_wp(dvfs_dptc_params_s * params, int new_wp);
+/*!
+ * This function updates the DPTC threshold registers.
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table.
+ * @param    wp			current wp value.
+ * @param    freq_index		translation table index of the current CPU
+ *				frequency.
+ *
+ */
+void update_dptc_thresholds(dvfs_dptc_tables_s * dptc_tables_ptr,
+			    int wp, int freq_index);
+/*!
+ * This function adds a new entry to the DPTC log buffer.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    dptc_log		pointer to the DPTC log buffer structure.
+ * @param    wp			value of the working point index written
+ *				to the log buffer.
+ * @param    freq_index		value of the frequency index written to
+ *				the log buffer.
+ *
+ * @return   number of log buffer entries.
+ *
+ */
+
+void add_dptc_log_entry(dvfs_dptc_params_s * params,
+			dptc_log_s * dptc_log, int wp, int freq_index);
+
+/*!
+ * This function updates the CPU voltage, produced by PMIC, by calling PMIC
+ * driver functions.
+ *
+ * @param    dptc_tables_ptr    pointer to the DPTC translation table.
+ * @param    wp			current wp value.
+ */
+void set_pmic_voltage(dvfs_dptc_tables_s * dptc_tables_ptr, int wp);
+
+/*!
+ * This function enables the DPTC reference circuits.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    rc_state  each high bit specifies which
+ *                     reference circuite to enable.
+ * @return   0 on success, error code on failure
+ */
+int enable_ref_circuits(dvfs_dptc_params_s * params, unsigned char rc_state);
+
+/*!
+ * This function disables the DPTC reference circuits.
+  *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    rc_state  each high bit specifies which
+ *                     reference circuite to disable
+ * @return   0 on success, error code on failure
+ */
+int disable_ref_circuits(dvfs_dptc_params_s * params, unsigned char rc_state);
+
+/*!
+ * This function is the DPTC Interrupt handler.
+ * This function wakes-up the dptc_workqueue_handler function that handles the
+ * DPTC interrupt.
+ */
+void dptc_irq(void);
+
+/*!
+ * This function updates the drivers current frequency index.This index is
+ * used for access the current DTPC table entry and it corresponds to the
+ * current CPU frequency (each CPU frequency has a separate index number
+ * according to the loaded DPTC table).
+ *
+ * @param    params      pointer to the DVFS & DPTC driver parameters structure.
+ * @param    freq_index	 New frequency index value to be set.
+ *
+ * @return      0 if the frequency index was updated (the new index is a
+ *		valid index and the DPTC module isn't active) else returns
+ *              -EINVAL.
+ *
+ */
+int set_dptc_curr_freq(dvfs_dptc_params_s * params, unsigned int freq_index);
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*
+ * DPTC SDMA callback.
+ * Updates the PMIC voltage
+ *
+ * @param    params       pointer to the DVFS & DPTC driver parameters structure.
+ */
+void dptc_sdma_callback(dvfs_dptc_params_s * params);
+#endif
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which
+ *                device to suspend (not relevant for DPTC)
+ * @param   state the power state the device is entering
+ *
+ * @return  The function always returns 0.
+ */
+int mxc_dptc_suspend(struct platform_device *pdev, pm_message_t state);
+
+/*!
+ * This function is called to put the DPTC in a low power state.
+ *
+ */
+void dptc_suspend(void);
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ * @param   pdev  the device structure used to give information on which
+ *                device to suspend (not relevant for DPTC)
+ *
+ * @return  The function always returns 0.
+ */
+int mxc_dptc_resume(struct platform_device *dev);
+
+/*!
+ * This function is called to resume the DPTC from a low power state.
+ *
+ */
+void dptc_resume(void);
+
+#endif				/* __ASM_ARCH_MXC_DPTC_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/dvfs_dptc_struct.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/dvfs_dptc_struct.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,162 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs_dptc_struct.h
+ *
+ * @brief MXC dvfs & dptc structure definitions file.
+ *
+ * @ingroup PM
+ */
+#ifndef __ASM_ARCH_MXC_DVFS_DPTC_STRUCT_H__
+#define __ASM_ARCH_MXC_DVFS_DPTC_STRUCT_H__
+
+#include <asm/arch/pm_api.h>
+
+/*!
+ * Number of entries in the DPTC log buffer
+ */
+#define LOG_ENTRIES 1024
+
+/*!
+ * Log buffer Structure.\n
+ * This structure records the DPTC changes. \n
+ * This structure can be read by the user using the proc file system DPTC read entry.
+ */
+typedef struct {
+	/*!
+	 * Index to the head of the log buffer
+	 */
+	int head;
+
+	/*!
+	 * Index to the tail of the log buffer
+	 */
+	int tail;
+
+	/*!
+	 * Mutex to allow access to the log buffer
+	 */
+	struct semaphore mutex;
+
+	/*!
+	 * Array of log buffer entries
+	 */
+	dptc_log_entry_s entries[LOG_ENTRIES];
+} dptc_log_s;
+
+/*!
+ * DPTC driver data structure.\n
+ * Holds all driver parameters and data structures.
+ */
+typedef struct {
+	/*!
+	 * This variable holds the current frequency index
+	 */
+	int current_freq_index;
+
+	/*!
+	 * Boolean variable, if TRUE the DPTC module is enabled
+	 * if FALSE the DPTC module is disabled
+	 */
+	int dptc_is_active;
+
+	/*!
+	 * Boolean variable, if TRUE the DVFS module is enabled
+	 * if FALSE the DPTC module is disabled
+	 */
+	int dvfs_is_active;
+
+	/*!
+	 * Boolean variable, if TRUE the DPTC module is suspended
+	 */
+	int suspended;
+
+	unsigned char rc_state;
+
+	/*!
+	 * Pointer to the DVFS & DPTC translation table
+	 */
+	dvfs_dptc_tables_s *dvfs_dptc_tables_ptr;
+
+	/*!
+	 * The DPTC log buffer
+	 */
+	dptc_log_s dptc_log_buffer;
+
+	/*!
+	 * The DVFS log buffer
+	 */
+	unsigned char *dvfs_log_buffer;
+
+	/*!
+	 * The DVFS log buffer physical address (for SDMA)
+	 */
+	dma_addr_t dvfs_log_buffer_phys;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	/*!
+	 * SDMA channel number
+	 */
+	int sdma_channel;
+
+	/*!
+	 * This holds the previous working point
+	 */
+	int prev_wp;
+
+	/*!
+	 * Wait entry for predictive DVFS
+	 */
+	wait_queue_head_t dvfs_pred_wait;
+#endif
+
+	/*!
+	 * This holds the current DVFS mode
+	 */
+	unsigned int dvfs_mode;
+
+	/*!
+	 * Log buffer read pointer
+	 */
+	unsigned char *read_ptr;
+
+	/*
+	 * Number of characters in log buffer
+	 */
+	int chars_in_buffer;
+} dvfs_dptc_params_s;
+
+/*!
+ * This struct contains the array with values of supported frequencies in Hz
+ */
+typedef struct {
+	/*
+	 * Number of supported states
+	 */
+	unsigned int num_of_states;
+	/*!
+	 * Array of frequencies
+	 */
+	unsigned int *freqs;
+} dvfs_states_table;
+
+/*
+ * if not defined define TREU and FALSE values.
+ */
+#ifndef TRUE
+#define TRUE  1
+#define FALSE 0
+#endif				/* TRUE */
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/dvfs.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/dvfs.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs.h
+ *
+ * @brief MXC dvfs header file.
+ *
+ * @ingroup PM
+ */
+#ifndef __ASM_ARCH_MXC_DVFS_H__
+#define __ASM_ARCH_MXC_DVFS_H__
+
+#include "dvfs_dptc_struct.h"
+
+/*!
+ * If value equal to FSVAI bits indicates working point decrease
+ */
+#define DVFS_DECREASE		(unsigned long)0x2
+
+/*!
+ * If value equal to FSVAI bits indicates working point increase
+ */
+#define DVFS_INCREASE		(unsigned long)0x1
+
+/*!
+ * If value equal to FSVAI bits indicates working point increase to maximum
+ */
+#define DVFS_EMERG		(unsigned long)0x3
+
+/*!
+ * This function is called for module initialization.
+ * It initializes the driver data structures and sets up the DVFS hardware.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return   0 to indicate success else returns a negative number.
+ *
+ */
+int __init init_dvfs_controller(dvfs_dptc_params_s * params);
+
+/*!
+ * This function enables the DVFS module. this function updates the DVFS
+ * thresholds, updates the PMIC, unmasks the DVFS interrupt and enables
+ * the DVFS module
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DVFS module was enabled else returns -EINVAL.
+ */
+int start_dvfs(dvfs_dptc_params_s * params);
+
+/*!
+ * This function disables the DVFS module.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DVFS module was enabled else returns -EINVAL.
+ */
+int stop_dvfs(dvfs_dptc_params_s * params);
+
+/*!
+ * This function turns on/off SW general purpose bits.
+ * The argument's 4 LSBs represent the status of the bits.
+ *
+ * @param   arg  status of the SW general purpose bits
+ *
+ * @return 0 on success
+ */
+int set_sw_gp(unsigned char arg);
+
+/*!
+ * This function sets DVFS to monitor WFI signal
+ *
+ * @param   arg  0 - turn WFI off, 1 - turn WFI on
+ * @return  0 on success, error code on fail
+ */
+int set_wfi(unsigned char arg);
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * This function is the DVFS Interrupt handler.
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ */
+void dvfs_irq(dvfs_dptc_params_s * params);
+#endif
+
+/*!
+ * This function changes the frequency if DVFS HW is disabled.
+ * It gets id of the required state supported by DVFS table and
+ * updates CCM.
+ *
+ * @param    dvfs_state_id  id of the DVFS state.
+ * @return   0 on success, error code on fail
+ */
+int dvfs_set_state(int dvfs_state_id);
+
+/*
+ * Update tables of frequencies for DPM usage
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DVFS &
+ *                                   DPTC translation table.
+ */
+void dvfs_update_freqs_table(dvfs_dptc_tables_s * dvfs_dptc_tables_ptr);
+
+/*!
+ * Read the DVSUP bits from the CCM
+ */
+unsigned long dvfs_get_dvsup(void);
+
+/*!
+ * This contains the array with values of supported frequencies in Hz.
+ * The structure is used by DPM.
+ */
+extern dvfs_states_table *dvfs_states_tbl;
+
+/*!
+ * This define DVFS log buffer sample size (in bits)
+ */
+#define DVFS_LB_SAMPLE_SIZE 4
+
+/*!
+ * This define DVFS log buffer samples
+ */
+#define DVFS_LB_SIZE 1600
+
+/*!
+ * This define DVFS SDMA buffer descriptors number
+ */
+#define DVFS_LB_SDMA_BD 10
+
+/*!
+ * This defines default DVFS down threshold
+ */
+#define DVFS_DNTHR  18
+
+/*!
+ * This defines default DVFS up threshold
+ */
+#define DVFS_UPTHR  30
+
+/*!
+ * This defines default DVFS panic threshold
+ */
+#define DVFS_PNCTHR 63
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/entry-macro.S	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/entry-macro.S	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,41 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+ 
+	@ this macro disables fast irq (not implemented)
+	.macro	disable_fiq
+	.endm
+
+	@ this macro checks which interrupt occured
+	@ and returns its number in irqnr
+	@ and returns if an interrupt occured in irqstat
+	.macro	get_irqnr_and_base, irqnr, irqstat, base, tmp
+	@ Can't use IO_ADDRESS macro. Otherwise compilation error
+	ldr	\irqstat, =AVIC_IO_ADDRESS(AVIC_BASE_ADDR)
+	@ Load offset & priority of the highest priority
+	@ interrupt pending.
+	ldr	\irqnr, [\irqstat, #0x40]	@ this is AVIC_NIVECSR
+	@ Shift off the priority leaving the offset or
+	@ "interrupt number"
+	mov	\irqnr, \irqnr, lsr #16
+	ldr	\irqstat, =1	@ dummy compare
+	ldr	\base, =0xFFFF	// invalid interrupt
+	cmp	\irqnr, \base
+	bne	1001f
+	ldr	\irqstat, =0
+	1001:
+	tst	\irqstat, #1	@ to make the condition code = TRUE
+	.endm
+
+	@ irq priority table (not used)
+	.macro	irq_prio_table
+	.endm
--- linux-2.6.19.2/include/asm-arm/arch-mxc/gpio.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/gpio.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_GPIO_H__
+#define __ASM_ARCH_MXC_GPIO_H__
+
+/*!
+ * @defgroup GPIO General Purpose Input Output (GPIO)
+ * @ingroup MSL
+ */
+
+/*!
+ * @file gpio.h
+ * @brief This file contains the GPIO and IOMUX configuration details.
+ *
+ * @ingroup GPIO
+ */
+
+#include <asm/sizes.h>
+#include <linux/interrupt.h>
+#include <asm/hardware.h>
+
+/* gpio related defines */
+
+/*!
+ * There are two queues for registered GPIO ISRs. One is for high priority and
+ * the other is for low priority. The ISRs in the high priority queue will be
+ * called first before the low priority queue if more than one GPIO interrupt
+ * occurs at the same time.
+ */
+enum gpio_prio {
+	GPIO_HIGH_PRIO = 0,	/*!< high priority queue */
+	GPIO_LOW_PRIO		/*!< low priority queue */
+};
+
+/*!
+ * This enumeration data type defines various different ways for interrupting
+ * the ARM core from GPIO signals. The way to interrupt the core is dictated
+ * by the external hardware.
+ */
+typedef enum gpio_int_cfg {
+#if defined(CONFIG_ARCH_MX27)
+	GPIO_INT_LOW_LEV = 0x3,	/*!< low level sensitive */
+	GPIO_INT_HIGH_LEV = 0x2,	/*!< high level sensitive */
+	GPIO_INT_RISE_EDGE = 0x0,	/*!< rising edge sensitive */
+	GPIO_INT_FALL_EDGE = 0x1,	/*!< falling edge sensitive */
+	GPIO_INT_NONE = 0x4	/*!< No interrupt */
+#else
+	GPIO_INT_LOW_LEV = 0x0,	/*!< low level sensitive */
+	GPIO_INT_HIGH_LEV = 0x1,	/*!< high level sensitive */
+	GPIO_INT_RISE_EDGE = 0x2,	/*!< rising edge sensitive */
+	GPIO_INT_FALL_EDGE = 0x3,	/*!< falling edge sensitive */
+	GPIO_INT_NONE = 0x4	/*!< No interrupt */
+#endif
+} gpio_edge_t;
+
+typedef irqreturn_t(*gpio_irq_handler) (int, void *, struct pt_regs *);
+
+/*!
+ * This function configures the GPIO signal to be either input or output. For
+ * input signals used for generating interrupts for the ARM core, how the
+ * interrupts being triggered is also passed in via \a icr. For output signals,
+ * the \a icr value doesn't matter.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  out          #true for output, #false for input
+ * @param  icr          value defined in \b #gpio_int_cfg
+ */
+void gpio_config(__u32 port, __u32 sig_no, bool out, enum gpio_int_cfg icr);
+
+/*!
+ * This function sets a GPIO signal value.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  data         value to be set (only 0 or 1 is valid)
+ */
+void gpio_set_data(__u32 port, __u32 sig_no, __u32 data);
+
+/*!
+ * This function returns the value of the GPIO signal.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ *
+ * @return Value of the GPIO signal
+ */
+__u32 gpio_get_data(__u32 port, __u32 sig_no);
+
+/*!
+ * This function is responsible for registering a GPIO signal's ISR.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  prio         priority as defined in \b enum \b #gpio_prio
+ * @param  handler      GPIO ISR function pointer for the GPIO signal
+ * @param  irq_flags    irq flags (not used)
+ * @param  devname      device name associated with the interrupt
+ * @param  dev_id       some unique information for the ISR
+ *
+ * @return 0 if successful; non-zero otherwise.
+ */
+int gpio_request_irq(__u32 port, __u32 sig_no, enum gpio_prio prio,
+		     gpio_irq_handler handler, __u32 irq_flags,
+		     const char *devname, void *dev_id);
+
+/*!
+ * This function un-registers an ISR with the GPIO interrupt module.
+ *
+ * @param  port         specified port with 0-GPIO port 1; 1-GPIO port 2
+ * @param  sig_no       specified GPIO signal (0 based)
+ * @param  prio         priority as defined in \b enum \b #gpio_prio
+ */
+void gpio_free_irq(__u32 port, __u32 sig_no, enum gpio_prio prio);
+
+/*!
+ * Request ownership for a GPIO pin. The caller has to check the return value
+ * of this function to make sure it returns 0 before make use of that pin.
+ * @param pin		a name defined by \b iomux_pin_name_t
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_gpio(iomux_pin_name_t pin);
+
+/*!
+ * Exported function to set a GPIO pin's direction
+ * @param pin		a name defined by \b iomux_pin_name_t
+ * @param is_input	1 (or non-zero) for input; 0 for output
+ */
+void mxc_set_gpio_direction(iomux_pin_name_t pin, int is_input);
+
+/*!
+ * Exported function to set a GPIO pin's data output
+ * @param pin		a name defined by \b iomux_pin_name_t
+ * @param data		value to be set (only 0 or 1 is valid)
+ */
+void mxc_set_gpio_dataout(iomux_pin_name_t pin, u32 data);
+
+/*!
+ * Return the data value of a GPIO signal.
+ * @param pin	a name defined by \b iomux_pin_name_t
+ *
+ * @return 	value (0 or 1) of the GPIO signal; -1 if pass in invalid pin
+ */
+int mxc_get_gpio_datain(iomux_pin_name_t pin);
+
+/*!
+ * Release ownership for a GPIO pin
+ * @param pin		a name defined by \b iomux_pin_name_t
+ */
+void mxc_free_gpio(iomux_pin_name_t pin);
+
+/*!
+ * GPIO driver initialization
+ * @return    always 0
+ */
+int mxc_gpio_init(void);
+#endif				/* __ASM_ARCH_MXC_GPIO_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/hardware.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/hardware.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,165 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file hardware.h
+ * @brief This file contains the hardware definitions of the board.
+ *
+ * @ingroup System
+ */
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#define __ASM_ARCH_MXC_HARDWARE_H__
+
+#include <asm/sizes.h>
+
+/*!
+ * makes bool as int type
+ */
+#define bool int
+
+/*!
+ * defines false as 0
+ */
+#define false 		0
+
+/*!
+ * defines true as 1
+ */
+#define true		1
+
+/*!
+ * defines PCIO_BASE (not used but needed for compilation)
+ */
+#define PCIO_BASE		0
+
+/*!
+ * This macro is used to get certain bit field from a number
+ */
+#define MXC_GET_FIELD(val, len, sh)          ((val >> sh) & ((1 << len) - 1))
+
+/*!
+ * This macro is used to set certain bit field inside a number
+ */
+#define MXC_SET_FIELD(val, len, sh, nval)    ((val & ~(((1 << len) - 1) << sh)) | nval << sh)
+
+/* This is used to turn on/off debugging */
+#define MXC_TRACE
+#ifdef MXC_TRACE
+/*!
+ * This is used for error checking in debugging mode.
+ */
+#define MXC_ERR_CHK(a) \
+        do { \
+                if ((a)) { \
+                        printk("Error at line %d in function %s in file %s", \
+                                __LINE__, __FUNCTION__, __FILE__); \
+                        BUG(); \
+                } \
+        } \
+        while (0)
+#else
+#define MXC_ERR_CHK(a)
+#endif
+
+/*
+ * ---------------------------------------------------------------------------
+ * Processor specific defines
+ * ---------------------------------------------------------------------------
+ */
+#define CHIP_REV_1_0		0x10
+#define CHIP_REV_1_1		0x11
+#define CHIP_REV_1_2		0x12
+#define CHIP_REV_1_3		0x13
+#define CHIP_REV_2_0		0x20
+#define CHIP_REV_2_1		0x21
+#define CHIP_REV_2_2		0x22
+#define CHIP_REV_2_3		0x23
+#define CHIP_REV_3_0		0x30
+#define CHIP_REV_3_1		0x31
+#define CHIP_REV_3_2		0x32
+
+#ifdef CONFIG_ARCH_MX3
+#include <asm/arch/mx31.h>
+#define cpu_is_mx31()		(1)
+#else
+#define cpu_is_mx31()		(0)
+#endif
+
+#define cpu_is_mx21()		(0)
+
+#ifdef CONFIG_ARCH_MX27
+#include <asm/arch/mx27.h>
+#define cpu_is_mx27()		(1)
+#else
+#define cpu_is_mx27()		(0)
+#endif
+
+#if !defined(__ASSEMBLY__) && !defined(__MXC_BOOT_UNCOMPRESS)
+extern unsigned int system_rev;
+#define _is_rev(rev) ((system_rev == rev) ? 1 : ((system_rev < rev) ? -1 : 2))
+
+#define MXC_REV(type)				\
+static inline int type## _rev (int rev)		\
+{						\
+	return (type() ? _is_rev(rev) : 0);	\
+}
+
+/*
+ * Create inline functions to test for cpu revision
+ * Function name is cpu_is_<cpu name>_rev(rev)
+ *
+ * Returns:
+ *	 0 - not the cpu queried
+ *	 1 - cpu and revision match
+ *	 2 - cpu matches, but cpu revision is greater than queried rev
+ *	-1 - cpu matches, but cpu revision is less than queried rev
+ */
+MXC_REV(cpu_is_mx27);
+MXC_REV(cpu_is_mx31);
+#endif
+
+#include <asm/arch/mxc.h>
+
+#define MXC_MAX_GPIO_LINES      (GPIO_NUM_PIN * GPIO_PORT_NUM)
+
+/*
+ * ---------------------------------------------------------------------------
+ * Board specific defines
+ * ---------------------------------------------------------------------------
+ */
+#define MXC_EXP_IO_BASE         (MXC_GPIO_BASE + MXC_MAX_GPIO_LINES)
+
+#ifdef CONFIG_MACH_MX31ADS
+#include <asm/arch/board-mx31ads.h>
+#endif
+
+#ifdef CONFIG_MACH_MX27ADS
+#include <asm/arch/board-mx27ads.h>
+#endif
+
+#ifndef MXC_MAX_EXP_IO_LINES
+#define MXC_MAX_EXP_IO_LINES 0
+#endif
+
+#define MXC_MAX_VIRTUAL_INTS	16
+#define MXC_VIRTUAL_INTS_BASE	(MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES)
+#define MXC_SDIO1_CARD_IRQ	MXC_VIRTUAL_INTS_BASE
+#define MXC_SDIO2_CARD_IRQ	(MXC_VIRTUAL_INTS_BASE + 1)
+#define MXC_SDIO3_CARD_IRQ	(MXC_VIRTUAL_INTS_BASE + 2)
+
+#define MXC_MAX_INTS            (MXC_MAX_INT_LINES + \
+                                MXC_MAX_GPIO_LINES + \
+                                MXC_MAX_EXP_IO_LINES + \
+                                MXC_MAX_VIRTUAL_INTS)
+
+#endif				/* __ASM_ARCH_MXC_HARDWARE_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/ide.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/ide.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,55 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_IDE_H__
+#define __ASM_ARCH_MXC_IDE_H__
+
+#include <asm/irq.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+/*
+ * Set up a hw structure for a specified data port, control port and IRQ.
+ * This should follow whatever the default interface uses.
+ */
+static __inline__ void
+ide_init_hwif_ports(hw_regs_t * hw, int data_port, int ctrl_port, int *irq)
+{
+	ide_ioreg_t reg;
+	int i;
+	int regincr = 1;
+
+	memset(hw, 0, sizeof(*hw));
+
+	reg = (ide_ioreg_t) data_port;
+
+	for (i = IDE_DATA_OFFSET; i <= IDE_STATUS_OFFSET; i++) {
+		hw->io_ports[i] = reg;
+		reg += regincr;
+	}
+
+	hw->io_ports[IDE_CONTROL_OFFSET] = (ide_ioreg_t) ctrl_port;
+
+	if (irq)
+		*irq = 0;
+}
+
+/*
+ * This registers the standard ports for this architecture with the IDE
+ * driver.
+ */
+static __inline__ void ide_init_default_hwifs(void)
+{
+
+}
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/iim.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/iim.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,67 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_IIM_H__
+#define __ASM_ARCH_MXC_IIM_H__
+
+/* Register offsets */
+#define MXC_IIMSTAT             0x0000
+#define MXC_IIMSTATM            0x0004
+#define MXC_IIMERR              0x0008
+#define MXC_IIMEMASK            0x000C
+#define MXC_IIMFCTL             0x0010
+#define MXC_IIMUA               0x0014
+#define MXC_IIMLA               0x0018
+#define MXC_IIMSDAT             0x001C
+#define MXC_IIMPREV             0x0020
+#define MXC_IIMSREV             0x0024
+#define MXC_IIMPRG_P            0x0028
+#define MXC_IIMSCS0             0x002C
+#define MXC_IIMSCS1             0x0030
+#define MXC_IIMSCS2             0x0034
+#define MXC_IIMSCS3             0x0038
+#define MXC_IIMFBAC0            0x0800
+#define MXC_IIMJAC              0x0804
+#define MXC_IIMHWV1             0x0808
+#define MXC_IIMHWV2             0x080C
+#define MXC_IIMHAB0             0x0810
+#define MXC_IIMHAB1             0x0814
+#define MXC_IIMPREV_FUSE        0x0818
+#define MXC_IIMSREV_FUSE        0x081C
+#define MXC_IIMSJC_CHALL_0      0x0820
+#define MXC_IIMSJC_CHALL_7      0x083C
+#define MXC_IIMFB0UC17          0x0840
+#define MXC_IIMFB0UC255         0x0BFC
+#define MXC_IIMFBAC1            0x0C00
+#define MXC_IIMKEY0             0x0C04
+#define MXC_IIMKEY20            0x0C54
+#define MXC_IIMSJC_RESP_0       0x0C58
+#define MXC_IIMSJC_RESP_7       0x0C74
+#define MXC_IIMFB1UC30          0x0C78
+#define MXC_IIMFB1UC255         0x0FFC
+
+/* Bit definitions */
+
+#define MXC_IIMHWV1_WLOCK               (0x1 << 7)
+#define MXC_IIMHWV1_MCU_ENDIAN          (0x1 << 6)
+#define MXC_IIMHWV1_DSP_ENDIAN          (0x1 << 5)
+#define MXC_IIMHWV1_BOOT_INT            (0x1 << 4)
+#define MXC_IIMHWV1_SCC_DISABLE         (0x1 << 3)
+#define MXC_IIMHWV1_HANTRO_DISABLE      (0x1 << 2)
+#define MXC_IIMHWV1_MEMSTICK_DIS        (0x1 << 1)
+
+#define MXC_IIMHWV2_WLOCK               (0x1 << 7)
+#define MXC_IIMHWV2_BP_SDMA             (0x1 << 6)
+#define MXC_IIMHWV2_SCM_DCM             (0x1 << 5)
+
+#endif				/* __ASM_ARCH_MXC_IIM_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/io.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/io.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,49 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file io.h
+ * @brief This file contains some memory mapping macros.
+ * @note There is no real ISA or PCI buses. But have to define these macros
+ * for some drivers to compile.
+ *
+ * @ingroup System
+ */
+
+#ifndef __ASM_ARCH_MXC_IO_H__
+#define __ASM_ARCH_MXC_IO_H__
+
+//#include <asm/arch/hardware.h>
+
+/*! Allow IO space to be anywhere in the memory */
+#define IO_SPACE_LIMIT 0xffffffff
+
+/*!
+ * io address mapping macro
+ */
+#define __io(a)			((void __iomem *)(a))
+
+#define __mem_pci(a)		(a)
+#define __mem_isa(a)		(a)
+
+/*!
+ * Validate the pci memory address for ioremap.
+ */
+#define iomem_valid_addr(iomem,size)	(1)
+
+/*!
+ * Convert PCI memory space to a CPU physical address
+ */
+#define iomem_to_phys(iomem)	(iomem)
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/ipu.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/ipu.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,768 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup IPU MXC Image Processing Unit (IPU) Driver
+ */
+/*!
+ * @file ipu.h
+ *
+ * @brief This file contains the IPU driver API declarations.
+ *
+ * @ingroup IPU
+ */
+
+#ifndef __ASM_ARCH_IPU_H__
+#define __ASM_ARCH_IPU_H__
+
+#include <linux/types.h>
+#include <linux/interrupt.h>
+
+/*!
+ * Enumeration of IPU rotation modes
+ */
+typedef enum {
+	/* Note the enum values correspond to BAM value */
+	IPU_ROTATE_NONE = 0,
+	IPU_ROTATE_VERT_FLIP = 1,
+	IPU_ROTATE_HORIZ_FLIP = 2,
+	IPU_ROTATE_180 = 3,
+	IPU_ROTATE_90_RIGHT = 4,
+	IPU_ROTATE_90_RIGHT_VFLIP = 5,
+	IPU_ROTATE_90_RIGHT_HFLIP = 6,
+	IPU_ROTATE_90_LEFT = 7,
+} ipu_rotate_mode_t;
+
+/*!
+ * Enumeration of Post Filter modes
+ */
+typedef enum {
+	PF_DISABLE_ALL = 0,
+	PF_MPEG4_DEBLOCK = 1,
+	PF_MPEG4_DERING = 2,
+	PF_MPEG4_DEBLOCK_DERING = 3,
+	PF_H264_DEBLOCK = 4,
+} pf_operation_t;
+
+/*!
+ * Enumeration of Synchronous (Memory-less) panel types
+ */
+typedef enum {
+	IPU_PANEL_SHARP_TFT,
+	IPU_PANEL_TFT,
+} ipu_panel_t;
+
+/*  IPU Pixel format definitions */
+/*  Four-character-code (FOURCC) */
+#define ipu_fourcc(a,b,c,d)\
+        (((__u32)(a)<<0)|((__u32)(b)<<8)|((__u32)(c)<<16)|((__u32)(d)<<24))
+
+/*!
+ * @name IPU Pixel Formats
+ *
+ * Pixel formats are defined with ASCII FOURCC code. The pixel format codes are
+ * the same used by V4L2 API.
+ */
+
+/*! @{ */
+/*! @name Generic or Raw Data Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GENERIC ipu_fourcc('I','P','U','0')	/*!< IPU Generic Data */
+#define IPU_PIX_FMT_GENERIC_32 ipu_fourcc('I','P','U','1')	/*!< IPU Generic Data */
+/*! @} */
+/*! @name RGB Formats */
+/*! @{ */
+#define IPU_PIX_FMT_RGB332  ipu_fourcc('R','G','B','1')	/*!<  8  RGB-3-3-2     */
+#define IPU_PIX_FMT_RGB555  ipu_fourcc('R','G','B','O')	/*!< 16  RGB-5-5-5     */
+#define IPU_PIX_FMT_RGB565  ipu_fourcc('R','G','B','P')	/*!< 16  RGB-5-6-5     */
+#define IPU_PIX_FMT_RGB666  ipu_fourcc('R','G','B','6')	/*!< 18  RGB-6-6-6     */
+#define IPU_PIX_FMT_BGR666  ipu_fourcc('B','G','R','6')	/*!< 18  BGR-6-6-6     */
+#define IPU_PIX_FMT_BGR24   ipu_fourcc('B','G','R','3')	/*!< 24  BGR-8-8-8     */
+#define IPU_PIX_FMT_RGB24   ipu_fourcc('R','G','B','3')	/*!< 24  RGB-8-8-8     */
+#define IPU_PIX_FMT_BGR32   ipu_fourcc('B','G','R','4')	/*!< 32  BGR-8-8-8-8   */
+#define IPU_PIX_FMT_BGRA32  ipu_fourcc('B','G','R','A')	/*!< 32  BGR-8-8-8-8   */
+#define IPU_PIX_FMT_RGB32   ipu_fourcc('R','G','B','4')	/*!< 32  RGB-8-8-8-8   */
+#define IPU_PIX_FMT_RGBA32  ipu_fourcc('R','G','B','A')	/*!< 32  RGB-8-8-8-8   */
+#define IPU_PIX_FMT_ABGR32  ipu_fourcc('A','B','G','R')	/*!< 32  ABGR-8-8-8-8  */
+/*! @} */
+/*! @name YUV Interleaved Formats */
+/*! @{ */
+#define IPU_PIX_FMT_YUYV    ipu_fourcc('Y','U','Y','V')	/*!< 16  YUV 4:2:2     */
+#define IPU_PIX_FMT_UYVY    ipu_fourcc('U','Y','V','Y')	/*!< 16  YUV 4:2:2     */
+#define IPU_PIX_FMT_Y41P    ipu_fourcc('Y','4','1','P')	/*!< 12  YUV 4:1:1     */
+/*! @} */
+/*! @name YUV Planar Formats */
+/*! @{ */
+#define IPU_PIX_FMT_GREY    ipu_fourcc('G','R','E','Y')	/*!< 8  Greyscale     */
+#define IPU_PIX_FMT_YVU410P ipu_fourcc('Y','V','U','9')	/*!< 9  YVU 4:1:0     */
+#define IPU_PIX_FMT_YUV410P ipu_fourcc('Y','U','V','9')	/*!< 9  YUV 4:1:0     */
+#define IPU_PIX_FMT_YVU420P ipu_fourcc('Y','V','1','2')	/*!< 12  YVU 4:2:0     */
+#define IPU_PIX_FMT_YUV420P ipu_fourcc('I','4','2','0')	/*!< 12  YUV420 planar */
+#define IPU_PIX_FMT_YUV420P2 ipu_fourcc('Y','U','1','2')	/*!< 12  YUV 4:2:0 planar */
+#define IPU_PIX_FMT_YVU422P ipu_fourcc('Y','V','1','6')	/*!< 16  YVU422 planar */
+#define IPU_PIX_FMT_YUV422P ipu_fourcc('4','2','2','P')	/*!< 16  YUV422 planar */
+/*! @} */
+
+/*#define IPU_PIX_FMT_YUV411P ipu_fourcc('4','1','1','P')  16  YVU411 planar */
+/*#define IPU_PIX_FMT_YYUV    ipu_fourcc('Y','Y','U','V')  16  YUV 4:2:2     */
+
+/* IPU Driver channels definitions.	*/
+/* Note these are different from IDMA channels */
+#define _MAKE_CHAN(num, in, out, sec)    ((num << 24) | (sec << 16) | (out << 8) | in)
+#define IPU_CHAN_ID(ch)         (ch >> 24)
+#define IPU_CHAN_SEC_DMA(ch)    ((uint32_t) (ch >> 16) & 0xFF)
+#define IPU_CHAN_OUT_DMA(ch)    ((uint32_t) (ch >> 8) & 0xFF)
+#define IPU_CHAN_IN_DMA(ch)     ((uint32_t) (ch & 0xFF))
+
+/*!
+ * Enumeration of IPU logical channels. An IPU logical channel is defined as a
+ * combination of an input (memory to IPU), output (IPU to memory), and/or
+ * secondary input IDMA channels and in some cases an Image Converter task.
+ * Some channels consist of only an input or output.
+ */
+typedef enum {
+	CSI_MEM = _MAKE_CHAN(1, 0xFF, 7, 0xFF),	/*!< CSI raw sensor data to memory */
+
+	CSI_PRP_ENC_MEM = _MAKE_CHAN(2, 0xFF, 0, 0xFF),	/*!< CSI to IC Encoder PreProcessing to Memory */
+	MEM_PRP_ENC_MEM = _MAKE_CHAN(3, 6, 0, 0xFF),	/*!< Memory to IC Encoder PreProcessing to Memory */
+	MEM_ROT_ENC_MEM = _MAKE_CHAN(4, 10, 8, 0xFF),	/*!< Memory to IC Encoder Rotation to Memory */
+
+	CSI_PRP_VF_MEM = _MAKE_CHAN(5, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to Memory */
+	CSI_PRP_VF_ADC = _MAKE_CHAN(6, 0xFF, 1, 0xFF),	/*!< CSI to IC Viewfinder PreProcessing to ADC */
+	MEM_PRP_VF_MEM = _MAKE_CHAN(7, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to Memory */
+	MEM_PRP_VF_ADC = _MAKE_CHAN(8, 6, 1, 3),	/*!< Memory to IC Viewfinder PreProcessing to ADC */
+	MEM_ROT_VF_MEM = _MAKE_CHAN(9, 11, 9, 0xFF),	/*!< Memory to IC Viewfinder Rotation to Memory */
+
+	MEM_PP_MEM = _MAKE_CHAN(10, 5, 2, 4),	/*!< Memory to IC PostProcessing to Memory */
+	MEM_ROT_PP_MEM = _MAKE_CHAN(11, 13, 12, 0xFF),	/*!< Memory to IC PostProcessing Rotation to Memory */
+	MEM_PP_ADC = _MAKE_CHAN(12, 5, 2, 4),	/*!< Memory to IC PostProcessing to ADC */
+
+	MEM_SDC_BG = _MAKE_CHAN(14, 14, 0xFF, 0xFF),	/*!< Memory to SDC Background plane */
+	MEM_SDC_FG = _MAKE_CHAN(15, 15, 0xFF, 0xFF),	/*!< Memory to SDC Foreground plane */
+	MEM_SDC_MASK = _MAKE_CHAN(16, 16, 0xFF, 0xFF),	/*!< Memory to SDC Mask */
+
+	ADC_SYS1 = _MAKE_CHAN(17, 18, 22, 20),	/*!< Memory to ADC System Channel 1 */
+	ADC_SYS2 = _MAKE_CHAN(18, 19, 23, 21),	/*!< Memory to ADC System Channel 2 */
+
+	MEM_PF_Y_MEM = _MAKE_CHAN(19, 26, 29, 24),	/*!< Y and PF Memory to Post-filter to Y Memory */
+	MEM_PF_U_MEM = _MAKE_CHAN(20, 27, 30, 25),	/*!< U and PF Memory to Post-filter to U Memory */
+	MEM_PF_V_MEM = _MAKE_CHAN(21, 28, 31, 0xFF),	/*!< V Memory to Post-filter to V Memory */
+
+	CHAN_NONE = 0xFFFFFFFF,
+} ipu_channel_t;
+
+/*!
+ * Enumeration of types of buffers for a logical channel.
+ */
+typedef enum {
+	IPU_INPUT_BUFFER,	/*!< Buffer for input to IPU */
+	IPU_OUTPUT_BUFFER,	/*!< Buffer for output from IPU */
+	IPU_SEC_INPUT_BUFFER,	/*!< Buffer for second input to IPU */
+} ipu_buffer_t;
+
+/*!
+ * Enumeration of DI ports for ADC.
+ */
+typedef enum {
+	DISP0,
+	DISP1,
+	DISP2,
+	DISP3
+} display_port_t;
+
+/*!
+ * Enumeration of ADC channels.
+typedef enum
+{
+        PRPCHAN,
+        PPCHAN,
+        SYSCHAN1,
+        SYSCHAN2
+}sys_channel_t;
+ */
+
+/*!
+ * Enumeration of ADC channel operation mode.
+ */
+typedef enum {
+	Disable,
+	WriteTemplateNonSeq,
+	ReadTemplateNonSeq,
+	WriteTemplateUnCon,
+	ReadTemplateUnCon,
+	WriteDataWithRS,
+	WriteDataWoRS,
+	WriteCmd
+} mcu_mode_t;
+
+/*!
+ * Enumeration of ADC channel addressing mode.
+ */
+typedef enum {
+	FullWoBE,
+	FullWithBE,
+	XY
+} display_addressing_t;
+
+/*!
+ * Union of initialization parameters for a logical channel.
+ */
+typedef union {
+	struct {
+		uint32_t temp;
+	} csi_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} csi_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_prp_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+	} mem_rot_enc_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+	} csi_prp_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} csi_prp_vf_adc;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+	} mem_prp_vf_mem;
+	struct {
+		uint32_t temp;
+	} mem_prp_vf_adc;
+	struct {
+		uint32_t temp;
+	} mem_rot_vf_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+	} mem_pp_mem;
+	struct {
+		uint32_t temp;
+	} mem_rot_mem;
+	struct {
+		uint32_t in_width;
+		uint32_t in_height;
+		uint32_t in_pixel_fmt;
+		uint32_t out_width;
+		uint32_t out_height;
+		uint32_t out_pixel_fmt;
+		bool graphics_combine_en;
+		bool global_alpha_en;
+		bool key_color_en;
+		display_port_t disp;
+		uint32_t out_left;
+		uint32_t out_top;
+	} mem_pp_adc;
+
+	struct {
+		pf_operation_t operation;
+	} mem_pf_mem;
+
+	struct {
+		uint32_t temp;
+	} mem_sdc_fg;
+	struct {
+		uint32_t temp;
+	} mem_sdc_bg;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys1;
+	struct {
+		display_port_t disp;
+		mcu_mode_t ch_mode;
+		uint32_t out_left;
+		uint32_t out_top;
+	} adc_sys2;
+} ipu_channel_params_t;
+
+/*!
+ * Enumeration of IPU interrupt sources.
+ */
+enum ipu_irq_line {
+	IPU_IRQ_PRP_ENC_OUT_EOF = 0,
+	IPU_IRQ_PRP_VF_OUT_EOF = 1,
+	IPU_IRQ_PP_OUT_EOF = 2,
+	IPU_IRQ_PRP_GRAPH_IN_EOF = 3,
+	IPU_IRQ_PP_GRAPH_IN_EOF = 4,
+	IPU_IRQ_PP_IN_EOF = 5,
+	IPU_IRQ_PRP_IN_EOF = 6,
+	IPU_IRQ_SENSOR_OUT_EOF = 7,
+	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 8,
+	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 9,
+	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 10,
+	IPU_IRQ_PRP_VF_ROT_IN_EOF = 11,
+	IPU_IRQ_PP_ROT_OUT_EOF = 12,
+	IPU_IRQ_PP_ROT_IN_EOF = 13,
+	IPU_IRQ_SDC_BG_EOF = 14,
+	IPU_IRQ_SDC_FG_EOF = 15,
+	IPU_IRQ_SDC_MASK_EOF = 16,
+	IPU_IRQ_SDC_BG_PART_EOF = 17,
+	IPU_IRQ_ADC_SYS1_WR_EOF = 18,
+	IPU_IRQ_ADC_SYS2_WR_EOF = 19,
+	IPU_IRQ_ADC_SYS1_CMD_EOF = 20,
+	IPU_IRQ_ADC_SYS2_CMD_EOF = 21,
+	IPU_IRQ_ADC_SYS1_RD_EOF = 22,
+	IPU_IRQ_ADC_SYS2_RD_EOF = 23,
+	IPU_IRQ_PF_QP_IN_EOF = 24,
+	IPU_IRQ_PF_BSP_IN_EOF = 25,
+	IPU_IRQ_PF_Y_IN_EOF = 26,
+	IPU_IRQ_PF_U_IN_EOF = 27,
+	IPU_IRQ_PF_V_IN_EOF = 28,
+	IPU_IRQ_PF_Y_OUT_EOF = 29,
+	IPU_IRQ_PF_U_OUT_EOF = 30,
+	IPU_IRQ_PF_V_OUT_EOF = 31,
+
+	IPU_IRQ_PRP_ENC_OUT_NF = 32,
+	IPU_IRQ_PRP_VF_OUT_NF = 33,
+	IPU_IRQ_PP_OUT_NF = 34,
+	IPU_IRQ_PRP_GRAPH_IN_NF = 35,
+	IPU_IRQ_PP_GRAPH_IN_NF = 36,
+	IPU_IRQ_PP_IN_NF = 37,
+	IPU_IRQ_PRP_IN_NF = 38,
+	IPU_IRQ_SENSOR_OUT_NF = 39,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NF = 40,
+	IPU_IRQ_PRP_VF_ROT_OUT_NF = 41,
+	IPU_IRQ_PRP_ENC_ROT_IN_NF = 42,
+	IPU_IRQ_PRP_VF_ROT_IN_NF = 43,
+	IPU_IRQ_PP_ROT_OUT_NF = 44,
+	IPU_IRQ_PP_ROT_IN_NF = 45,
+	IPU_IRQ_SDC_FG_NF = 46,
+	IPU_IRQ_SDC_BG_NF = 47,
+	IPU_IRQ_SDC_MASK_NF = 48,
+	IPU_IRQ_SDC_BG_PART_NF = 49,
+	IPU_IRQ_ADC_SYS1_WR_NF = 50,
+	IPU_IRQ_ADC_SYS2_WR_NF = 51,
+	IPU_IRQ_ADC_SYS1_CMD_NF = 52,
+	IPU_IRQ_ADC_SYS2_CMD_NF = 53,
+	IPU_IRQ_ADC_SYS1_RD_NF = 54,
+	IPU_IRQ_ADC_SYS2_RD_NF = 55,
+	IPU_IRQ_PF_QP_IN_NF = 56,
+	IPU_IRQ_PF_BSP_IN_NF = 57,
+	IPU_IRQ_PF_Y_IN_NF = 58,
+	IPU_IRQ_PF_U_IN_NF = 59,
+	IPU_IRQ_PF_V_IN_NF = 60,
+	IPU_IRQ_PF_Y_OUT_NF = 61,
+	IPU_IRQ_PF_U_OUT_NF = 62,
+	IPU_IRQ_PF_V_OUT_NF = 63,
+
+	IPU_IRQ_BREAKRQ = 64,
+	IPU_IRQ_SDC_BG_OUT_EOF = 65,
+	IPU_IRQ_SDC_FG_OUT_EOF = 66,
+	IPU_IRQ_SDC_MASK_OUT_EOF = 67,
+	IPU_IRQ_ADC_SERIAL_DATA_OUT = 68,
+	IPU_IRQ_SENSOR_NF = 69,
+	IPU_IRQ_SENSOR_EOF = 70,
+	IPU_IRQ_SDC_DISP3_VSYNC = 80,
+	IPU_IRQ_ADC_DISP0_VSYNC = 81,
+	IPU_IRQ_ADC_DISP12_VSYNC = 82,
+	IPU_IRQ_ADC_PRP_EOF = 83,
+	IPU_IRQ_ADC_PP_EOF = 84,
+	IPU_IRQ_ADC_SYS1_EOF = 85,
+	IPU_IRQ_ADC_SYS2_EOF = 86,
+
+	IPU_IRQ_PRP_ENC_OUT_NFB4EOF_ERR = 96,
+	IPU_IRQ_PRP_VF_OUT_NFB4EOF_ERR = 97,
+	IPU_IRQ_PP_OUT_NFB4EOF_ERR = 98,
+	IPU_IRQ_PRP_GRAPH_IN_NFB4EOF_ERR = 99,
+	IPU_IRQ_PP_GRAPH_IN_NFB4EOF_ERR = 100,
+	IPU_IRQ_PP_IN_NFB4EOF_ERR = 101,
+	IPU_IRQ_PRP_IN_NFB4EOF_ERR = 102,
+	IPU_IRQ_SENSOR_OUT_NFB4EOF_ERR = 103,
+	IPU_IRQ_PRP_ENC_ROT_OUT_NFB4EOF_ERR = 104,
+	IPU_IRQ_PRP_VF_ROT_OUT_NFB4EOF_ERR = 105,
+	IPU_IRQ_PRP_ENC_ROT_IN_NFB4EOF_ERR = 106,
+	IPU_IRQ_PRP_VF_ROT_IN_NFB4EOF_ERR = 107,
+	IPU_IRQ_PP_ROT_OUT_NFB4EOF_ERR = 108,
+	IPU_IRQ_PP_ROT_IN_NFB4EOF_ERR = 109,
+	IPU_IRQ_SDC_FG_NFB4EOF_ERR = 110,
+	IPU_IRQ_SDC_BG_NFB4EOF_ERR = 111,
+	IPU_IRQ_SDC_MASK_NFB4EOF_ERR = 112,
+	IPU_IRQ_SDC_BG_PART_NFB4EOF_ERR = 113,
+	IPU_IRQ_ADC_SYS1_WR_NFB4EOF_ERR = 114,
+	IPU_IRQ_ADC_SYS2_WR_NFB4EOF_ERR = 115,
+	IPU_IRQ_ADC_SYS1_CMD_NFB4EOF_ERR = 116,
+	IPU_IRQ_ADC_SYS2_CMD_NFB4EOF_ERR = 117,
+	IPU_IRQ_ADC_SYS1_RD_NFB4EOF_ERR = 118,
+	IPU_IRQ_ADC_SYS2_RD_NFB4EOF_ERR = 119,
+	IPU_IRQ_PF_QP_IN_NFB4EOF_ERR = 120,
+	IPU_IRQ_PF_BSP_IN_NFB4EOF_ERR = 121,
+	IPU_IRQ_PF_Y_IN_NFB4EOF_ERR = 122,
+	IPU_IRQ_PF_U_IN_NFB4EOF_ERR = 123,
+	IPU_IRQ_PF_V_IN_NFB4EOF_ERR = 124,
+	IPU_IRQ_PF_Y_OUT_NFB4EOF_ERR = 125,
+	IPU_IRQ_PF_U_OUT_NFB4EOF_ERR = 126,
+	IPU_IRQ_PF_V_OUT_NFB4EOF_ERR = 127,
+
+	IPU_IRQ_BAYER_BUFOVF_ERR = 128,
+	IPU_IRQ_ENC_BUFOVF_ERR = 129,
+	IPU_IRQ_VF_BUFOVF_ERR = 130,
+	IPU_IRQ_ADC_PP_TEAR_ERR = 131,
+	IPU_IRQ_ADC_SYS1_TEAR_ERR = 132,
+	IPU_IRQ_ADC_SYS2_TEAR_ERR = 133,
+	IPU_IRQ_SDC_BGD_ERR = 134,
+	IPU_IRQ_SDC_FGD_ERR = 135,
+	IPU_IRQ_SDC_MASKD_ERR = 136,
+	IPU_IRQ_BAYER_FRM_LOST_ERR = 137,
+	IPU_IRQ_ENC_FRM_LOST_ERR = 138,
+	IPU_IRQ_VF_FRM_LOST_ERR = 139,
+	IPU_IRQ_ADC_LOCK_ERR = 140,
+	IPU_IRQ_DI_LLA_LOCK_ERR = 141,
+	IPU_IRQ_AHB_M1_ERR = 142,
+	IPU_IRQ_AHB_M12_ERR = 143,
+
+	IPU_IRQ_COUNT
+};
+
+/*!
+ * Bitfield of Display Interface signal polarities.
+ */
+typedef struct {
+	unsigned datamask_en:1;
+	unsigned clksel_en:1;
+	unsigned clkidle_en:1;
+	unsigned data_pol:1;	/* true = inverted */
+	unsigned clk_pol:1;	/* true = rising edge */
+	unsigned enable_pol:1;
+	unsigned Hsync_pol:1;	/* true = active high */
+	unsigned Vsync_pol:1;
+} ipu_di_signal_cfg_t;
+
+/*!
+ * Bitfield of CSI signal polarities and modes.
+ */
+typedef struct {
+	unsigned data_width:3;
+	unsigned clk_mode:2;
+	unsigned ext_vsync:1;
+	unsigned Vsync_pol:1;
+	unsigned Hsync_pol:1;
+	unsigned pixclk_pol:1;
+	unsigned data_pol:1;
+	unsigned sens_clksrc:1;
+} ipu_csi_signal_cfg_t;
+
+/*!
+ * Enumeration of CSI data bus widths.
+ */
+enum {
+	IPU_CSI_DATA_WIDTH_4,
+	IPU_CSI_DATA_WIDTH_8,
+	IPU_CSI_DATA_WIDTH_10,
+	IPU_CSI_DATA_WIDTH_16,
+};
+
+/*!
+ * Enumeration of CSI clock modes.
+ */
+enum {
+	IPU_CSI_CLK_MODE_GATED_CLK,
+	IPU_CSI_CLK_MODE_NONGATED_CLK,
+	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE,
+	IPU_CSI_CLK_MODE_CCIR656_INTERLACED,
+};
+
+typedef enum {
+	RGB,
+	YCbCr,
+	YUV
+} ipu_color_space_t;
+
+/*!
+ * Enumeration of ADC vertical sync mode.
+ */
+typedef enum {
+	VsyncNone,
+	VsyncInternal,
+	VsyncCSI,
+	VsyncExternal
+} vsync_t;
+
+typedef enum {
+	DAT,
+	CMD
+} cmddata_t;
+
+/*!
+ * Enumeration of ADC display update mode.
+ */
+typedef enum {
+	IPU_ADC_REFRESH_NONE,
+	IPU_ADC_AUTO_REFRESH,
+	IPU_ADC_AUTO_REFRESH_SNOOP,
+	IPU_ADC_SNOOPING,
+} ipu_adc_update_mode_t;
+
+/*!
+ * Enumeration of ADC display interface types (serial or parallel).
+ */
+enum {
+	IPU_ADC_IFC_MODE_SYS80_TYPE1,
+	IPU_ADC_IFC_MODE_SYS80_TYPE2,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE1,
+	IPU_ADC_IFC_MODE_SYS68K_TYPE2,
+	IPU_ADC_IFC_MODE_3WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_4WIRE_SERIAL,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CLK,
+	IPU_ADC_IFC_MODE_5WIRE_SERIAL_CS,
+};
+
+enum {
+	IPU_ADC_IFC_WIDTH_8,
+	IPU_ADC_IFC_WIDTH_16,
+};
+
+/*!
+ * Enumeration of ADC display interface burst mode.
+ */
+enum {
+	IPU_ADC_BURST_WCS,
+	IPU_ADC_BURST_WBLCK,
+	IPU_ADC_BURST_NONE,
+	IPU_ADC_BURST_SERIAL,
+};
+
+/*!
+ * Enumeration of ADC display interface RW signal timing modes.
+ */
+enum {
+	IPU_ADC_SER_NO_RW,
+	IPU_ADC_SER_RW_BEFORE_RS,
+	IPU_ADC_SER_RW_AFTER_RS,
+};
+
+/*!
+ * Bitfield of ADC signal polarities and modes.
+ */
+typedef struct {
+	unsigned data_pol:1;
+	unsigned clk_pol:1;
+	unsigned cs_pol:1;
+	unsigned addr_pol:1;
+	unsigned read_pol:1;
+	unsigned write_pol:1;
+	unsigned Vsync_pol:1;
+	unsigned burst_pol:1;
+	unsigned burst_mode:2;
+	unsigned ifc_mode:3;
+	unsigned ifc_width:5;
+	unsigned ser_preamble_len:4;
+	unsigned ser_preamble:8;
+	unsigned ser_rw_mode:2;
+} ipu_adc_sig_cfg_t;
+
+/*!
+ * Enumeration of ADC template commands.
+ */
+enum {
+	RD_DATA,
+	RD_ACK,
+	RD_WAIT,
+	WR_XADDR,
+	WR_YADDR,
+	WR_ADDR,
+	WR_CMND,
+	WR_DATA,
+};
+
+/*!
+ * Enumeration of ADC template command flow control.
+ */
+enum {
+	SINGLE_STEP,
+	PAUSE,
+	STOP,
+};
+
+/*Define template constants*/
+#define     ATM_ADDR_RANGE      0x20	/*offset address of DISP */
+#define     TEMPLATE_BUF_SIZE   0x20	/*size of template */
+
+/*!
+ * Define to create ADC template command entry.
+ */
+#define ipu_adc_template_gen(oc, rs, fc, dat) ( ((rs) << 29) | ((fc) << 27) | \
+                                                ((oc) << 24) | (dat) )
+
+typedef struct {
+	u32 reg;
+	u32 value;
+} ipu_lpmc_reg_t;
+
+#define IPU_LPMC_REG_READ       0x80000000L
+
+#define CSI_MCLK_VF  1
+#define CSI_MCLK_ENC 2
+#define CSI_MCLK_RAW 4
+#define CSI_MCLK_I2C 8
+
+/* Common IPU API */
+int32_t ipu_init_channel(ipu_channel_t channel, ipu_channel_params_t * params);
+void ipu_uninit_channel(ipu_channel_t channel);
+
+int32_t ipu_init_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				uint32_t pixel_fmt,
+				uint16_t width, uint16_t height,
+				uint32_t stride,
+				ipu_rotate_mode_t rot_mode,
+				dma_addr_t phyaddr_0, dma_addr_t phyaddr_1,
+				uint32_t u_offset, uint32_t v_offset);
+
+int32_t ipu_update_channel_buffer(ipu_channel_t channel, ipu_buffer_t type,
+				  uint32_t bufNum, dma_addr_t phyaddr);
+
+int32_t ipu_select_buffer(ipu_channel_t channel,
+			  ipu_buffer_t type, uint32_t bufNum);
+
+int32_t ipu_link_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+int32_t ipu_unlink_channels(ipu_channel_t src_ch, ipu_channel_t dest_ch);
+
+int32_t ipu_enable_channel(ipu_channel_t channel);
+int32_t ipu_disable_channel(ipu_channel_t channel, bool wait_for_stop);
+
+void ipu_enable_irq(uint32_t irq);
+void ipu_disable_irq(uint32_t irq);
+void ipu_clear_irq(uint32_t irq);
+int ipu_request_irq(uint32_t irq,
+		    irqreturn_t(*handler) (int, void *, struct pt_regs *),
+		    uint32_t irq_flags, const char *devname, void *dev_id);
+void ipu_free_irq(uint32_t irq, void *dev_id);
+bool ipu_get_irq_status(uint32_t irq);
+
+/* SDC API */
+int32_t ipu_sdc_init_panel(ipu_panel_t panel,
+			   uint32_t pixel_clk,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint16_t hStartWidth, uint16_t hSyncWidth,
+			   uint16_t hEndWidth, uint16_t vStartWidth,
+			   uint16_t vSyncWidth, uint16_t vEndWidth,
+			   ipu_di_signal_cfg_t sig);
+int32_t ipu_sdc_set_window_pos(ipu_channel_t channel, int16_t x_pos,
+			       int16_t y_pos);
+int32_t ipu_sdc_set_global_alpha(bool enable, uint8_t alpha);
+int32_t ipu_sdc_set_color_key(ipu_channel_t channel, bool enable,
+			      uint32_t colorKey);
+int32_t ipu_sdc_set_brightness(uint8_t value);
+
+/* ADC API */
+int32_t ipu_adc_write_template(display_port_t disp, uint32_t * pCmd,
+			       bool write);
+
+int32_t ipu_adc_set_update_mode(ipu_channel_t channel,
+				ipu_adc_update_mode_t mode,
+				uint32_t refresh_rate, unsigned long addr,
+				uint32_t * size);
+
+int32_t ipu_adc_get_snooping_status(uint32_t * statl, uint32_t * stath);
+
+int32_t ipu_adc_write_cmd(display_port_t disp, cmddata_t type,
+			  uint32_t cmd, const uint32_t * params,
+			  uint16_t numParams);
+
+int32_t ipu_adc_init_panel(display_port_t disp,
+			   uint16_t width, uint16_t height,
+			   uint32_t pixel_fmt,
+			   uint32_t stride,
+			   ipu_adc_sig_cfg_t sig,
+			   display_addressing_t addr,
+			   uint32_t vsync_width, vsync_t mode);
+
+int32_t ipu_adc_init_ifc_timing(display_port_t disp, bool read,
+				uint32_t cycle_time,
+				uint32_t up_time,
+				uint32_t down_time,
+				uint32_t read_latch_time, uint32_t pixel_clk);
+
+/* CMOS Sensor Interface API */
+int32_t ipu_csi_init_interface(uint16_t width, uint16_t height,
+			       uint32_t pixel_fmt, ipu_csi_signal_cfg_t sig);
+
+int32_t ipu_csi_enable_mclk(int src, bool flag, bool wait);
+
+int ipu_csi_read_mclk_flag(void);
+
+void ipu_csi_flash_strobe(bool flag);
+
+void ipu_csi_get_window_size(uint32_t * width, uint32_t * height);
+
+void ipu_csi_set_window_size(uint32_t width, uint32_t height);
+
+void ipu_csi_set_window_pos(uint32_t left, uint32_t top);
+
+/* Post Filter functions */
+int32_t ipu_pf_set_pause_row(uint32_t pause_row);
+
+/* LPMC module functions */
+int ipu_lpmc_init(u32 dfm_freq,
+		  ipu_lpmc_reg_t * save_list,
+		  u32 save_count, ipu_lpmc_reg_t * lpm_list, u32 lpm_count);
+void ipu_lpmc_uninit(void);
+
+uint32_t bytes_per_pixel(uint32_t fmt);
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/irqs.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/irqs.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,52 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_IRQS_H__
+#define __ASM_ARCH_MXC_IRQS_H__
+
+#include <asm/arch/hardware.h>
+
+/*!
+ * @defgroup Interrupt Interrupt Controller (AVIC)
+ * @ingroup MSL
+ */
+/*!
+ * @file irqs.h
+ * @brief This file defines the number of normal interrupts and fast interrupts
+ *
+ * @ingroup Interrupt
+ */
+
+#define MXC_IRQ_TO_EDIO(nr)     ((nr) - MXC_EXT_BASE)
+#define MXC_IRQ_IS_EDIO(nr)  	((nr) >= MXC_EXT_BASE)
+
+#define MXC_IRQ_TO_EXPIO(irq)	(irq - MXC_EXP_IO_BASE)
+
+#define MXC_IRQ_TO_GPIO(irq)	(irq - MXC_GPIO_BASE)
+#define MXC_GPIO_TO_IRQ(x)	(MXC_GPIO_BASE + x)
+
+/*!
+ * REVISIT: document me
+ */
+#define ARCH_TIMER_IRQ	INT_GPT
+
+/*!
+ * Number of normal interrupts
+ */
+#define NR_IRQS         (MXC_MAX_INTS)
+
+/*!
+ * Number of fast interrupts
+ */
+#define NR_FIQS		(MXC_MAX_INTS)
+
+#endif				/* __ASM_ARCH_MXC_IRQS_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/isp1301.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/isp1301.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,221 @@
+
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_ISP1301_H__
+#define __ASM_ARCH_MXC_ISP1301_H__
+
+#include <linux/i2c.h>
+#include <asm/arch/mxc_i2c.h>
+
+/* ISP1301 register addresses,all register of ISP1301 
+ * is one-byte length register 
+ */
+
+/* ISP1301: I2C device address */
+#define ISP1301_DEV_ADDR 		0x2D
+
+/* ISP 1301 register set*/
+#define ISP1301_MODE_REG1_SET		0x04
+#define ISP1301_MODE_REG1_CLR		0x05
+
+#define ISP1301_CTRL_REG1_SET		0x06
+#define ISP1301_CTRL_REG1_CLR		0x07
+
+#define ISP1301_INT_SRC_REG		0x08
+#define ISP1301_INT_LAT_REG_SET		0x0a
+#define ISP1301_INT_LAT_REG_CLR		0x0b
+#define ISP1301_INT_FALSE_REG_SET	0x0c
+#define ISP1301_INT_FALSE_REG_CLR	0x0d
+#define ISP1301_INT_TRUE_REG_SET	0x0e
+#define ISP1301_INT_TRUE_REG_CLR	0x0f
+
+#define ISP1301_CTRL_REG2_SET		0x10
+#define ISP1301_CTRL_REG2_CLR		0x11
+
+#define ISP1301_MODE_REG2_SET		0x12
+#define ISP1301_MODE_REG2_CLR		0x13
+
+#define ISP1301_BCD_DEV_REG0		0x14
+#define ISP1301_BCD_DEV_REG1		0x15
+
+/* OTG Control register bit description */
+#define DP_PULLUP			0x01
+#define DM_PULLUP			0x02
+#define DP_PULLDOWN			0x04
+#define DM_PULLDOWN			0x08
+#define ID_PULLDOWN			0x10
+#define VBUS_DRV			0x20
+#define VBUS_DISCHRG			0x40
+#define VBUS_CHRG			0x80
+
+/* Mode Control 1 register bit description */
+#define SPEED_REG  			0x01
+#define SUSPEND_REG			0x02
+#define DAT_SE0				0x04
+#define TRANSP_EN			0x08
+#define BDIS_ACON_EN			0x10
+#define OE_INT_EN			0x20
+#define UART_EN				0x40
+
+static int isp1301_attach(struct i2c_adapter *adapter);
+static int isp1301_detach(struct i2c_client *client);
+
+static struct i2c_driver isp1301_i2c_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "isp1301 Client",
+		   },
+	.attach_adapter = isp1301_attach,
+	.detach_client = isp1301_detach,
+};
+
+static struct i2c_client isp1301_i2c_client = {
+	.name = "isp1301 I2C dev",
+	.addr = ISP1301_DEV_ADDR,
+	.driver = &isp1301_i2c_driver,
+};
+
+/*!
+ * isp1301 I2C attach function
+ *
+ * @param adapter            struct i2c_adapter *
+ * @return  Error code indicating success or failure
+ */
+static int isp1301_attach(struct i2c_adapter *adapter)
+{
+	if (strcmp(adapter->name, MXC_ADAPTER_NAME) != 0) {
+		printk(KERN_ERR "isp1301_attach: %s\n", adapter->name);
+		return -1;
+	}
+
+	isp1301_i2c_client.adapter = adapter;
+	if (i2c_attach_client(&isp1301_i2c_client)) {
+		isp1301_i2c_client.adapter = NULL;
+		printk(KERN_ERR "isp1301_attach: i2c_attach_client failed\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*!
+ * isp1301 I2C detach function
+ *
+ * @param client            struct i2c_client *
+ * @return  Error code indicating success or failure
+ */
+static int isp1301_detach(struct i2c_client *client)
+{
+	int err;
+
+	if (!isp1301_i2c_client.adapter)
+		return -1;
+
+	err = i2c_detach_client(&isp1301_i2c_client);
+	isp1301_i2c_client.adapter = NULL;
+
+	return err;
+}
+
+static int isp1301_i2c_client_xfer(unsigned int addr, char *reg, int reg_len,
+				   char *buf, int num, int tran_flag)
+{
+	struct i2c_msg msg[2];
+	int ret;
+
+	msg[0].addr = addr;
+	msg[0].len = reg_len;
+	msg[0].buf = reg;
+	msg[0].flags = tran_flag;
+	msg[0].flags &= ~I2C_M_RD;
+
+	msg[1].addr = addr;
+	msg[1].len = num;
+	msg[1].buf = buf;
+	msg[1].flags = tran_flag;
+
+	if (tran_flag & 1) {
+		msg[1].flags |= I2C_M_RD;
+	} else {
+		msg[1].flags &= ~I2C_M_RD;
+	}
+
+	ret = i2c_transfer(isp1301_i2c_client.adapter, msg, 2);
+	if (ret >= 0)
+		return 0;
+
+	return ret;
+}
+
+static inline void isp1301_init(void)
+{
+	i2c_add_driver(&isp1301_i2c_driver);
+}
+
+static inline void isp1301_uninit(void)
+{
+	i2c_del_driver(&isp1301_i2c_driver);
+}
+
+/* Write ISP1301 register*/
+static inline void isp1301_write_reg(char reg, char data)
+{
+	isp1301_i2c_client_xfer(ISP1301_DEV_ADDR, &reg, 1, &data, 1, 0);
+}
+
+/* read ISP1301 register*/
+static inline char isp1301_read_reg(char reg)
+{
+	char data;
+	isp1301_i2c_client_xfer(ISP1301_DEV_ADDR, &reg, 1, &data, 1, 1);
+	return data;
+}
+
+/* set ISP1301 as USB host*/
+static inline void isp1301_set_serial_host(void)
+{
+	isp1301_write_reg(ISP1301_CTRL_REG1_CLR, 0xFF);
+	isp1301_write_reg(ISP1301_CTRL_REG1_SET,
+			  (VBUS_DRV | DP_PULLDOWN | DM_PULLDOWN));
+	isp1301_write_reg(ISP1301_MODE_REG1_SET, DAT_SE0);	/* SE0 state */
+}
+
+/* set ISP1301 as USB device*/
+static inline void isp1301_set_serial_dev(void)
+{
+	isp1301_write_reg(ISP1301_MODE_REG1_CLR, 0xFF);
+	/* FS mode, DP pull down, DM pull down */
+	isp1301_write_reg(ISP1301_CTRL_REG1_SET,
+			  (DP_PULLDOWN | DM_PULLDOWN | DP_PULLUP));
+}
+
+static inline void isp1301_set_vbus_power(int on)
+{
+	if (on) {
+		/* disable D+ pull-up */
+		isp1301_write_reg(ISP1301_CTRL_REG1_CLR, DP_PULLUP);
+		/* enable D+ pull-down */
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET, DP_PULLDOWN);
+		/* turn on Vbus */
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET, VBUS_DRV);
+	} else {
+		/* D+ pull up, D- pull down  */
+		isp1301_write_reg(ISP1301_CTRL_REG1_SET,
+				  (DP_PULLUP | DM_PULLDOWN));
+		/* disable D- pull up, disable D+ pull down */
+		isp1301_write_reg(ISP1301_CTRL_REG1_CLR,
+				  (DM_PULLUP | DP_PULLDOWN));
+	}
+}
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/isp1504.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/isp1504.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,38 @@
+
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_ISP1504_H__
+#define __ASM_ARCH_MXC_ISP1504_H__
+
+/* ISP 1504 register addresses */
+#define ISP1504_VID_LOW		0x00	/* Vendor ID low */
+#define ISP1504_VID_HIGH	0x01	/* Vendor ID high */
+#define ISP1504_PID_LOW		0x02	/* Product ID low */
+#define ISP1504_PID_HIGH	0x03	/* Product ID high */
+#define ISP1504_OTGCTL		0x0A	/* OTG Control */
+
+/* add to above register address to access Set/Clear functions */
+#define ISP1504_REG_SET		0x01
+#define ISP1504_REG_CLEAR	0x02
+
+/* 1504 OTG Control Register bits */
+#define USE_EXT_VBUS_IND	(1 << 7)	/* Use ext. Vbus indicator */
+#define DRV_VBUS_EXT		(1 << 6)	/* Drive Vbus external */
+#define DRV_VBUS		(1 << 5)	/* Drive Vbus */
+#define CHRG_VBUS		(1 << 4)	/* Charge Vbus */
+#define DISCHRG_VBUS		(1 << 3)	/* Discharge Vbus */
+#define DM_PULL_DOWN		(1 << 2)	/* enable DM Pull Down */
+#define DP_PULL_DOWN		(1 << 1)	/* enable DP Pull Down */
+#define ID_PULL_UP		(1 << 0)	/* enable ID Pull Up */
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/memory.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/memory.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MEMORY_H__
+#define __ASM_ARCH_MXC_MEMORY_H__
+
+#include <asm/arch/hardware.h>
+
+/*!
+ * @defgroup Memory Memory Map
+ * @ingroup MSL
+ */
+
+/*!
+ * @file memory.h
+ * @brief This file contains macros needed by the Linux kernel and drivers.
+ *
+ * @ingroup Memory
+ */
+
+/*!
+ * Physical start address of the first bank of RAM
+ */
+#if defined(PHYS_OFFSET)
+
+/*! This is needed for L2 Cache support */
+#define PHYS_OFFSET_ASM	        PHYS_OFFSET
+#define PAGE_OFFSET_ASM	        0xC0000000
+
+#else
+#error "Define PHYS_OFFSET to the base of the physical memory's PA"
+#endif
+
+/*!
+ * Virtual view <-> DMA view memory address translations
+ * This macro is used to translate the virtual address to an address
+ * suitable to be passed to set_dma_addr()
+ */
+#define __virt_to_bus(a)	__virt_to_phys(a)
+
+/*!
+ * Used to convert an address for DMA operations to an address that the
+ * kernel can use.
+ */
+#define __bus_to_virt(a)	__phys_to_virt(a)
+
+#ifdef CONFIG_DISCONTIGMEM
+
+/*!
+ * The MXC's memory is physically contiguous, but to
+ * support and test Memory Type Based Allocation, we need
+ * to artificially create some memory banks. Our goal
+ * it to have a minimum of 4 nodes of the same size
+ * and to try to have a Node size be 16MiB when  possible.
+ */
+#if (SDRAM_MEM_SIZE == SZ_128M)
+#define        NODES_SHIFT	2	/* 4 Nodes */
+#define NODE_MAX_MEM_SHIFT	25	/* 32 MiB */
+#elif (SDRAM_MEM_SIZE == SZ_64M)
+#define        NODES_SHIFT	2	/* 4 Nodes */
+#define NODE_MAX_MEM_SHIFT	24	/* 16 MiB */
+#elif (SDRAM_MEM_SIZE == SZ_32M)
+#define        NODES_SHIFT	2	/* 4 Nodes */
+#define NODE_MAX_MEM_SHIFT	23	/* 8 MiB */
+#else
+#error "Please, #Define SDRAM_MEM_SIZE "
+#endif
+
+#define MXC_NUMNODES	(1 << NODES_SHIFT)
+#define NODE_MAX_MEM_SIZE	(1 << NODE_MAX_MEM_SHIFT)
+
+#define SET_NODE(mi, nid) { \
+	(mi)->bank[(nid)].start = PHYS_OFFSET + (nid) * NODE_MAX_MEM_SIZE; \
+	(mi)->bank[(nid)].size =  NODE_MAX_MEM_SIZE; \
+	(mi)->bank[(nid)].node = (nid); \
+	node_set_online(nid); \
+}
+
+/*!
+ * Given a kernel address, find the home node of the underlying memory.
+ */
+#define KVADDR_TO_NID(addr) \
+	(((unsigned long)(addr) - PAGE_OFFSET) >> NODE_MAX_MEM_SHIFT)
+
+/*!
+ * Given a page frame number, convert it to a node id.
+ */
+#define PFN_TO_NID(pfn) \
+	(((pfn) - PHYS_PFN_OFFSET) >> (NODE_MAX_MEM_SHIFT - PAGE_SHIFT))
+
+/*!
+ * Given a kaddr, ADDR_TO_MAPBASE finds the owning node of the memory
+ * and returns the mem_map of that node.
+ */
+#define ADDR_TO_MAPBASE(kaddr) NODE_MEM_MAP(KVADDR_TO_NID(kaddr))
+
+/*!
+ * Given a page frame number, find the owning node of the memory
+ * and returns the mem_map of that node.
+ */
+#define PFN_TO_MAPBASE(pfn)    NODE_MEM_MAP(PFN_TO_NID(pfn))
+
+/*!
+ * Given a kaddr, LOCAL_MAR_NR finds the owning node of the memory
+ * and returns the index corresponding to the appropriate page in the
+ * node's mem_map.
+ */
+#define LOCAL_MAP_NR(addr) \
+	(((unsigned long)(addr) & (NODE_MAX_MEM_SIZE - 1)) >> PAGE_SHIFT)
+
+#endif				/* CONFIG_DISCONTIGMEM */
+
+#endif				/* __ASM_ARCH_MXC_MEMORY_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mmc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mmc.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,27 @@
+/*
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MMC_H__
+#define __ASM_ARCH_MXC_MMC_H__
+
+#include <linux/mmc/protocol.h>
+
+struct mxc_mmc_platform_data {
+	unsigned int ocr_mask;	/* available voltages */
+	unsigned int min_clk;
+	unsigned int max_clk;
+	unsigned int card_inserted_state;
+//      u32 (*translate_vdd)(struct device *, unsigned int);
+	unsigned int (*status) (struct device *);
+};
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mx27.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mx27.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,353 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup MSL Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @defgroup System System-wide Misc Files for MSL
+ * @ingroup MSL
+ */
+
+/*!
+ * @file mx27.h
+ * @brief This file contains register definitions.
+ *
+ * @ingroup System
+ */
+
+#ifndef __ASM_ARCH_MXC_MX27_H__
+#define __ASM_ARCH_MXC_MX27_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+#include <asm/arch/mx27_pins.h>
+
+/*!
+ * defines the OS clock tick rate
+ */
+#define CLOCK_TICK_RATE         13300000
+
+#define ATA_BASE_CLK            (AHB_CLK)
+
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*!
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+#define MXC_UART_NR 6
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/*
+ * IRAM
+ */
+#define IRAM_BASE_ADDR          0xFFFF4C00	/* internal ram */
+
+/*
+ *  Register offests.
+ */
+#define AIPI_BASE_ADDR          0x10000000
+#define AIPI_BASE_ADDR_VIRT     0xD4000000
+#define AIPI_SIZE               SZ_1M
+
+#define DMA_BASE_ADDR           (AIPI_BASE_ADDR + 0x01000)
+#define WDOG_BASE_ADDR          (AIPI_BASE_ADDR + 0x02000)
+#define GPT1_BASE_ADDR          (AIPI_BASE_ADDR + 0x03000)
+#define GPT2_BASE_ADDR          (AIPI_BASE_ADDR + 0x04000)
+#define GPT3_BASE_ADDR          (AIPI_BASE_ADDR + 0x05000)
+#define PWM_BASE_ADDR           (AIPI_BASE_ADDR + 0x06000)
+#define RTC_BASE_ADDR           (AIPI_BASE_ADDR + 0x07000)
+#define KPP_BASE_ADDR           (AIPI_BASE_ADDR + 0x08000)
+#define OWIRE_BASE_ADDR         (AIPI_BASE_ADDR + 0x09000)
+#define UART1_BASE_ADDR         (AIPI_BASE_ADDR + 0x0A000)
+#define UART2_BASE_ADDR         (AIPI_BASE_ADDR + 0x0B000)
+#define UART3_BASE_ADDR         (AIPI_BASE_ADDR + 0x0C000)
+#define UART4_BASE_ADDR         (AIPI_BASE_ADDR + 0x0D000)
+#define CSPI1_BASE_ADDR         (AIPI_BASE_ADDR + 0x0E000)
+#define CSPI2_BASE_ADDR         (AIPI_BASE_ADDR + 0x0F000)
+#define SSI1_BASE_ADDR          (AIPI_BASE_ADDR + 0x10000)
+#define SSI2_BASE_ADDR          (AIPI_BASE_ADDR + 0x11000)
+#define I2C_BASE_ADDR           (AIPI_BASE_ADDR + 0x12000)
+#define SDHC1_BASE_ADDR         (AIPI_BASE_ADDR + 0x13000)
+#define SDHC2_BASE_ADDR         (AIPI_BASE_ADDR + 0x14000)
+#define GPIO_BASE_ADDR          (AIPI_BASE_ADDR + 0x15000)
+#define AUDMUX_BASE_ADDR        (AIPI_BASE_ADDR + 0x16000)
+
+#define CSPI3_BASE_ADDR         (AIPI_BASE_ADDR + 0x17000)
+#define MSHC_BASE_ADDR          (AIPI_BASE_ADDR + 0x18000)
+#define GPT5_BASE_ADDR          (AIPI_BASE_ADDR + 0x19000)
+#define GPT4_BASE_ADDR          (AIPI_BASE_ADDR + 0x1A000)
+#define UART5_BASE_ADDR         (AIPI_BASE_ADDR + 0x1B000)
+#define UART6_BASE_ADDR         (AIPI_BASE_ADDR + 0x1C000)
+#define I2C2_BASE_ADDR          (AIPI_BASE_ADDR + 0x1D000)
+#define SDHC3_BASE_ADDR         (AIPI_BASE_ADDR + 0x1E000)
+#define GPT6_BASE_ADDR          (AIPI_BASE_ADDR + 0x1F000)
+
+#define LCDC_BASE_ADDR          (AIPI_BASE_ADDR + 0x21000)
+#define SLCDC_BASE_ADDR         (AIPI_BASE_ADDR + 0x22000)
+#define VPU_BASE_ADDR           (AIPI_BASE_ADDR + 0x23000)
+#define USBOTG_BASE_ADDR        (AIPI_BASE_ADDR + 0x24000)
+/* for mx27*/
+#define OTG_BASE_ADDR           USBOTG_BASE_ADDR
+#define SAHARA_BASE_ADDR        (AIPI_BASE_ADDR + 0x25000)
+#define EMMA_BASE_ADDR          (AIPI_BASE_ADDR + 0x26400)
+#define CCM_BASE_ADDR           (AIPI_BASE_ADDR + 0x27000)
+#define SYSCTRL_BASE_ADDR       (AIPI_BASE_ADDR + 0x27800)
+#define IIM_BASE_ADDR           (AIPI_BASE_ADDR + 0x28000)
+
+#define RTIC_BASE_ADDR          (AIPI_BASE_ADDR + 0x2A000)
+#define FEC_BASE_ADDR           (AIPI_BASE_ADDR + 0x2B000)
+#define SCC_BASE_ADDR           (AIPI_BASE_ADDR + 0x2C000)
+#define ETB_BASE_ADDR           (AIPI_BASE_ADDR + 0x3B000)
+#define ETB_RAM_BASE_ADDR       (AIPI_BASE_ADDR + 0x3C000)
+
+#define JAM_BASE_ADDR           (AIPI_BASE_ADDR + 0x3E000)
+#define MAX_BASE_ADDR           (AIPI_BASE_ADDR + 0x3F000)
+
+/*
+ * ROMP and AVIC
+ */
+#define ROMP_BASE_ADDR          0x10041000
+
+#define AVIC_BASE_ADDR          0x10040000
+
+#define SAHB1_BASE_ADDR         0x80000000
+#define SAHB1_BASE_ADDR_VIRT    0xD4100000
+#define SAHB1_SIZE              SZ_1M
+
+#define CSI_BASE_ADDR           (SAHB1_BASE_ADDR + 0x0000)
+#define ATA_BASE_ADDR           (SAHB1_BASE_ADDR + 0x1000)
+
+/*
+ * NAND, SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define X_MEMC_BASE_ADDR        0xD8000000
+#define X_MEMC_BASE_ADDR_VIRT   0xD4200000
+#define X_MEMC_SIZE             SZ_1M
+
+#define NFC_BASE_ADDR           (X_MEMC_BASE_ADDR)
+#define SDRAMC_BASE_ADDR        (X_MEMC_BASE_ADDR + 0x1000)
+#define WEIM_BASE_ADDR          (X_MEMC_BASE_ADDR + 0x2000)
+#define M3IF_BASE_ADDR          (X_MEMC_BASE_ADDR + 0x3000)
+#define PCMCIA_CTL_BASE_ADDR    (X_MEMC_BASE_ADDR + 0x4000)
+
+/*
+ * Memory regions and CS
+ */
+#define SDRAM_BASE_ADDR         0xA0000000
+#define CSD1_BASE_ADDR          0xB0000000
+
+#define CS0_BASE_ADDR           0xC0000000
+#define CS1_BASE_ADDR           0xC8000000
+#define CS2_BASE_ADDR           0xD0000000
+#define CS3_BASE_ADDR           0xD2000000
+#define CS4_BASE_ADDR           0xD4000000
+#define CS4_BASE_ADDR_VIRT      0xEB000000
+#define CS4_SIZE                SZ_1M
+#define CS5_BASE_ADDR           0xD6000000
+#define PCMCIA_MEM_BASE_ADDR    0xDC000000
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+        (((x >= AIPI_BASE_ADDR) && (x < (AIPI_BASE_ADDR + AIPI_SIZE))) ? AIPI_IO_ADDRESS(x):\
+        ((x >= SAHB1_BASE_ADDR) && (x < (SAHB1_BASE_ADDR + SAHB1_SIZE))) ? SAHB1_IO_ADDRESS(x):\
+        ((x >= CS4_BASE_ADDR) && (x < (CS4_BASE_ADDR + CS4_SIZE))) ? CS4_IO_ADDRESS(x):\
+        ((x >= X_MEMC_BASE_ADDR) && (x < (X_MEMC_BASE_ADDR + X_MEMC_SIZE))) ? X_MEMC_IO_ADDRESS(x):\
+        0xDEADBEEF)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+
+#define AIPI_IO_ADDRESS(x)  \
+        (((x) - AIPI_BASE_ADDR) + AIPI_BASE_ADDR_VIRT)
+
+#define AVIC_IO_ADDRESS(x)      AIPI_IO_ADDRESS(x)
+
+#define SAHB1_IO_ADDRESS(x)  \
+        (((x) - SAHB1_BASE_ADDR) + SAHB1_BASE_ADDR_VIRT)
+
+#define CS4_IO_ADDRESS(x)  \
+        (((x) - CS4_BASE_ADDR) + CS4_BASE_ADDR_VIRT)
+
+#define X_MEMC_IO_ADDRESS(x)  \
+        (((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+#define PCMCIA_IO_ADDRESS(x) \
+        (((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+/*
+ *  MX27 ADS Interrupt numbers
+ */
+#define INT_CCM                 63
+#define INT_IIM                 62
+#define INT_LCDC                61
+#define INT_SLCDC               60
+#define INT_SAHARA              59
+#define INT_SCC_SCM             58
+#define INT_SCC_SMN             57
+#define INT_USB3                56
+#define INT_USB2                55
+#define INT_USB1                54
+#define INT_VPU                53
+#define INT_EMMAPP              52
+#define INT_EMMAPRP             51
+#define INT_FEC                 50
+#define INT_UART5               49
+#define INT_UART6               48
+#define INT_DMACH15             47
+#define INT_DMACH14             46
+#define INT_DMACH13             45
+#define INT_DMACH12             44
+#define INT_DMACH11             43
+#define INT_DMACH10             42
+#define INT_DMACH9              41
+#define INT_DMACH8              40
+#define INT_DMACH7              39
+#define INT_DMACH6              38
+#define INT_DMACH5              37
+#define INT_DMACH4              36
+#define INT_DMACH3              35
+#define INT_DMACH2              34
+#define INT_DMACH1              33
+#define INT_DMACH0              32
+#define INT_CSI                 31
+#define INT_ATA                 30
+#define INT_NANDFC              29
+#define INT_PCMCIA              28
+#define INT_WDOG                27
+#define INT_GPT1                26
+#define INT_GPT2                25
+#define INT_GPT3                24
+#define INT_GPT                 INT_GPT1
+#define INT_PWM                 23
+#define INT_RTC                 22
+#define INT_KPP                 21
+#define INT_UART1               20
+#define INT_UART2               19
+#define INT_UART3               18
+#define INT_UART4               17
+#define INT_CSPI1               16
+#define INT_CSPI2               15
+#define INT_SSI1                14
+#define INT_SSI2                13
+#define INT_I2C                 12
+#define INT_SDHC1               11
+#define INT_SDHC2               10
+#define INT_SDHC3               9
+#define INT_GPIO                8
+#define INT_SDHC                7
+#define INT_CSPI3               6
+#define INT_RTIC                5
+#define INT_GPT4                4
+#define INT_GPT5                3
+#define INT_GPT6                2
+#define INT_I2C2                1
+
+#define MXC_MAX_INT_LINES       64
+#define MXC_MAX_EXT_LINES       0
+
+#define MXC_MUX_GPIO_INTERRUPTS 1
+#define MXC_GPIO_BASE           (MXC_MAX_INT_LINES)
+
+/*!
+ * Number of GPIO port as defined in the IC Spec
+ */
+#define GPIO_PORT_NUM           6
+/*!
+ * Number of GPIO pins per port
+ */
+#define GPIO_NUM_PIN            32
+
+#define DMA_REQ_NFC             37
+#define DMA_REQ_SDHC3           36
+#define DMA_REQ_UART6_RX        35
+#define DMA_REQ_UART6_TX        34
+#define DMA_REQ_UART5_RX        33
+#define DMA_REQ_UART5_TX        32
+#define DMA_REQ_CSI_RX          31
+#define DMA_REQ_CSI_STAT        30
+#define DMA_REQ_ATA_RCV         29
+#define DMA_REQ_ATA_TX          28
+#define DMA_REQ_UART1_TX        27
+#define DMA_REQ_UART1_RX        26
+#define DMA_REQ_UART2_TX        25
+#define DMA_REQ_UART2_RX        24
+#define DMA_REQ_UART3_TX        23
+#define DMA_REQ_UART3_RX        22
+#define DMA_REQ_UART4_TX        21
+#define DMA_REQ_UART4_RX        20
+#define DMA_REQ_CSPI1_TX        19
+#define DMA_REQ_CSPI1_RX        18
+#define DMA_REQ_CSPI2_TX        17
+#define DMA_REQ_CSPI2_RX        16
+#define DMA_REQ_SSI1_TX1        15
+#define DMA_REQ_SSI1_RX1        14
+#define DMA_REQ_SSI1_TX0        13
+#define DMA_REQ_SSI1_RX0        12
+#define DMA_REQ_SSI2_TX1        11
+#define DMA_REQ_SSI2_RX1        10
+#define DMA_REQ_SSI2_TX0        9
+#define DMA_REQ_SSI2_RX0        8
+#define DMA_REQ_SDHC1           7
+#define DMA_REQ_SDHC2           6
+#define DMA_REQ_MSHC            4
+#define DMA_REQ_EXT             3
+#define DMA_REQ_CSPI3_TX        2
+#define DMA_REQ_CSPI3_RX        1
+
+#define MXC_TIMER_GPT1          1
+#define MXC_TIMER_GPT2          2
+#define MXC_TIMER_GPT3          3
+#define MXC_TIMER_GPT4          4
+#define MXC_TIMER_GPT5          5
+#define MXC_TIMER_GPT6          6
+
+/*!
+ * NFMS bit in FMCR register for pagesize of nandflash
+ */
+#define NFMS (*((volatile u32 *)IO_ADDRESS(SYSCTRL_BASE_ADDR+0x14)))
+
+#define NFMS_BIT 5
+
+/*
+ * GPT clock source mask and offset bit definition
+ */
+#define GPT_CTRL_MASK           0xFFFFFFF1
+#define GPT_CTRL_OFFSET	    	1
+
+#endif				/* __ASM_ARCH_MXC_MX27_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mx27_pins.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mx27_pins.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,214 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_MX27_PINS_H__
+#define __ASM_ARCH_MXC_MX27_PINS_H__
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio port number (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 1's for error checking in the functions. (gpio port 7 is invalid)
+ */
+#define MUX_IO_P	29
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio offset bit (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 0's since they are don't cares. So for port 2 pin 21, bit 31-24
+ * will be (1 << MUX_IO_P) | (21 << MUX_IO_I).
+ */
+#define MUX_IO_I	24
+
+#define _MX27_BUILD_PIN(gp,gi) (((gp) << MUX_IO_P) | ((gi) << MUX_IO_I))
+
+typedef enum iomux_pins {
+	MX27_PIN_USBH2_CLK = _MX27_BUILD_PIN(0, 0),
+	MX27_PIN_USBH2_DIR = _MX27_BUILD_PIN(0, 1),
+	MX27_PIN_USBH2_DATA7 = _MX27_BUILD_PIN(0, 2),
+	MX27_PIN_USBH2_NXT = _MX27_BUILD_PIN(0, 3),
+	MX27_PIN_USBH2_STP = _MX27_BUILD_PIN(0, 4),
+	MX27_PIN_LSCLK = _MX27_BUILD_PIN(0, 5),
+	MX27_PIN_LD0 = _MX27_BUILD_PIN(0, 6),
+	MX27_PIN_LD1 = _MX27_BUILD_PIN(0, 7),
+	MX27_PIN_LD2 = _MX27_BUILD_PIN(0, 8),
+	MX27_PIN_LD3 = _MX27_BUILD_PIN(0, 9),
+	MX27_PIN_LD4 = _MX27_BUILD_PIN(0, 10),
+	MX27_PIN_LD5 = _MX27_BUILD_PIN(0, 11),
+	MX27_PIN_LD6 = _MX27_BUILD_PIN(0, 12),
+	MX27_PIN_LD7 = _MX27_BUILD_PIN(0, 13),
+	MX27_PIN_LD8 = _MX27_BUILD_PIN(0, 14),
+	MX27_PIN_LD9 = _MX27_BUILD_PIN(0, 15),
+	MX27_PIN_LD10 = _MX27_BUILD_PIN(0, 16),
+	MX27_PIN_LD11 = _MX27_BUILD_PIN(0, 17),
+	MX27_PIN_LD12 = _MX27_BUILD_PIN(0, 18),
+	MX27_PIN_LD13 = _MX27_BUILD_PIN(0, 19),
+	MX27_PIN_LD14 = _MX27_BUILD_PIN(0, 20),
+	MX27_PIN_LD15 = _MX27_BUILD_PIN(0, 21),
+	MX27_PIN_LD16 = _MX27_BUILD_PIN(0, 22),
+	MX27_PIN_LD17 = _MX27_BUILD_PIN(0, 23),
+	MX27_PIN_REV = _MX27_BUILD_PIN(0, 24),
+	MX27_PIN_CLS = _MX27_BUILD_PIN(0, 25),
+	MX27_PIN_PS = _MX27_BUILD_PIN(0, 26),
+	MX27_PIN_SPL_SPR = _MX27_BUILD_PIN(0, 27),
+	MX27_PIN_HSYNC = _MX27_BUILD_PIN(0, 28),
+	MX27_PIN_VSYNC = _MX27_BUILD_PIN(0, 29),
+	MX27_PIN_CONTRAST = _MX27_BUILD_PIN(0, 30),
+	MX27_PIN_OE_ACD = _MX27_BUILD_PIN(0, 31),
+
+	MX27_PIN_SD2_D0 = _MX27_BUILD_PIN(1, 4),
+	MX27_PIN_SD2_D1 = _MX27_BUILD_PIN(1, 5),
+	MX27_PIN_SD2_D2 = _MX27_BUILD_PIN(1, 6),
+	MX27_PIN_SD2_D3 = _MX27_BUILD_PIN(1, 7),
+	MX27_PIN_SD2_CMD = _MX27_BUILD_PIN(1, 8),
+	MX27_PIN_SD2_CLK = _MX27_BUILD_PIN(1, 9),
+	MX27_PIN_CSI_D0 = _MX27_BUILD_PIN(1, 10),
+	MX27_PIN_CSI_D1 = _MX27_BUILD_PIN(1, 11),
+	MX27_PIN_CSI_D2 = _MX27_BUILD_PIN(1, 12),
+	MX27_PIN_CSI_D3 = _MX27_BUILD_PIN(1, 13),
+	MX27_PIN_CSI_D4 = _MX27_BUILD_PIN(1, 14),
+	MX27_PIN_CSI_MCLK = _MX27_BUILD_PIN(1, 15),
+	MX27_PIN_CSI_PIXCLK = _MX27_BUILD_PIN(1, 16),
+	MX27_PIN_CSI_D5 = _MX27_BUILD_PIN(1, 17),
+	MX27_PIN_CSI_D6 = _MX27_BUILD_PIN(1, 18),
+	MX27_PIN_CSI_D7 = _MX27_BUILD_PIN(1, 19),
+	MX27_PIN_CSI_VSYNC = _MX27_BUILD_PIN(1, 20),
+	MX27_PIN_CSI_HSYNC = _MX27_BUILD_PIN(1, 21),
+	MX27_PIN_USBH1_SUSP = _MX27_BUILD_PIN(1, 22),
+	MX27_PIN_USB_PWR = _MX27_BUILD_PIN(1, 23),
+	MX27_PIN_USB_OC_B = _MX27_BUILD_PIN(1, 24),
+	MX27_PIN_USBH1_RCV = _MX27_BUILD_PIN(1, 25),
+	MX27_PIN_USBH1_FS = _MX27_BUILD_PIN(1, 26),
+	MX27_PIN_USBH1_OE_B = _MX27_BUILD_PIN(1, 27),
+	MX27_PIN_USBH1_TXDM = _MX27_BUILD_PIN(1, 28),
+	MX27_PIN_USBH1_TXDP = _MX27_BUILD_PIN(1, 29),
+	MX27_PIN_USBH1_RXDM = _MX27_BUILD_PIN(1, 30),
+	MX27_PIN_USBH1_RXDP = _MX27_BUILD_PIN(1, 31),
+
+	MX27_PIN_I2C2_SDA = _MX27_BUILD_PIN(2, 5),
+	MX27_PIN_I2C2_SCL = _MX27_BUILD_PIN(2, 6),
+	MX27_PIN_USBOTG_DATA5 = _MX27_BUILD_PIN(2, 7),
+	MX27_PIN_USBOTG_DATA6 = _MX27_BUILD_PIN(2, 8),
+	MX27_PIN_USBOTG_DATA0 = _MX27_BUILD_PIN(2, 9),
+	MX27_PIN_USBOTG_DATA2 = _MX27_BUILD_PIN(2, 10),
+	MX27_PIN_USBOTG_DATA1 = _MX27_BUILD_PIN(2, 11),
+	MX27_PIN_USBOTG_DATA4 = _MX27_BUILD_PIN(2, 12),
+	MX27_PIN_USBOTG_DATA3 = _MX27_BUILD_PIN(2, 13),
+	MX27_PIN_TOUT = _MX27_BUILD_PIN(2, 14),
+	MX27_PIN_TIN = _MX27_BUILD_PIN(2, 15),
+	MX27_PIN_SSI4_FS = _MX27_BUILD_PIN(2, 16),
+	MX27_PIN_SSI4_RXDAT = _MX27_BUILD_PIN(2, 17),
+	MX27_PIN_SSI4_TXDAT = _MX27_BUILD_PIN(2, 18),
+	MX27_PIN_SSI4_CLK = _MX27_BUILD_PIN(2, 19),
+	MX27_PIN_SSI1_FS = _MX27_BUILD_PIN(2, 20),
+	MX27_PIN_SSI1_RXDAT = _MX27_BUILD_PIN(2, 21),
+	MX27_PIN_SSI1_TXDAT = _MX27_BUILD_PIN(2, 22),
+	MX27_PIN_SSI1_CLK = _MX27_BUILD_PIN(2, 23),
+	MX27_PIN_SSI2_FS = _MX27_BUILD_PIN(2, 24),
+	MX27_PIN_SSI2_RXDAT = _MX27_BUILD_PIN(2, 25),
+	MX27_PIN_SSI2_TXDAT = _MX27_BUILD_PIN(2, 26),
+	MX27_PIN_SSI2_CLK = _MX27_BUILD_PIN(2, 27),
+	MX27_PIN_SSI3_FS = _MX27_BUILD_PIN(2, 28),
+	MX27_PIN_SSI3_RXDAT = _MX27_BUILD_PIN(2, 29),
+	MX27_PIN_SSI3_TXDAT = _MX27_BUILD_PIN(2, 30),
+	MX27_PIN_SSI3_CLK = _MX27_BUILD_PIN(2, 31),
+
+	MX27_PIN_SD3_CMD = _MX27_BUILD_PIN(3, 0),
+	MX27_PIN_SD3_CLK = _MX27_BUILD_PIN(3, 1),
+	MX27_PIN_ATA_DATA0 = _MX27_BUILD_PIN(3, 2),
+	MX27_PIN_ATA_DATA1 = _MX27_BUILD_PIN(3, 3),
+	MX27_PIN_ATA_DATA2 = _MX27_BUILD_PIN(3, 4),
+	MX27_PIN_ATA_DATA3 = _MX27_BUILD_PIN(3, 5),
+	MX27_PIN_ATA_DATA4 = _MX27_BUILD_PIN(3, 6),
+	MX27_PIN_ATA_DATA5 = _MX27_BUILD_PIN(3, 7),
+	MX27_PIN_ATA_DATA6 = _MX27_BUILD_PIN(3, 8),
+	MX27_PIN_ATA_DATA7 = _MX27_BUILD_PIN(3, 9),
+	MX27_PIN_ATA_DATA8 = _MX27_BUILD_PIN(3, 10),
+	MX27_PIN_ATA_DATA9 = _MX27_BUILD_PIN(3, 11),
+	MX27_PIN_ATA_DATA10 = _MX27_BUILD_PIN(3, 12),
+	MX27_PIN_ATA_DATA11 = _MX27_BUILD_PIN(3, 13),
+	MX27_PIN_ATA_DATA12 = _MX27_BUILD_PIN(3, 14),
+	MX27_PIN_ATA_DATA13 = _MX27_BUILD_PIN(3, 15),
+	MX27_PIN_ATA_DATA14 = _MX27_BUILD_PIN(3, 16),
+	MX27_PIN_I2C_DATA = _MX27_BUILD_PIN(3, 17),
+	MX27_PIN_I2C_CLK = _MX27_BUILD_PIN(3, 18),
+	MX27_PIN_CSPI2_SS2 = _MX27_BUILD_PIN(3, 19),
+	MX27_PIN_CSPI2_SS1 = _MX27_BUILD_PIN(3, 20),
+	MX27_PIN_CSPI2_SS0 = _MX27_BUILD_PIN(3, 21),
+	MX27_PIN_CSPI2_SCLK = _MX27_BUILD_PIN(3, 22),
+	MX27_PIN_CSPI2_MISO = _MX27_BUILD_PIN(3, 23),
+	MX27_PIN_CSPI2_MOSI = _MX27_BUILD_PIN(3, 24),
+	MX27_PIN_CSPI1_RDY = _MX27_BUILD_PIN(3, 25),
+	MX27_PIN_CSPI1_SS2 = _MX27_BUILD_PIN(3, 26),
+	MX27_PIN_CSPI1_SS1 = _MX27_BUILD_PIN(3, 27),
+	MX27_PIN_CSPI1_SS0 = _MX27_BUILD_PIN(3, 28),
+	MX27_PIN_CSPI1_SCLK = _MX27_BUILD_PIN(3, 29),
+	MX27_PIN_CSPI1_MISO = _MX27_BUILD_PIN(3, 30),
+	MX27_PIN_CSPI1_MOSI = _MX27_BUILD_PIN(3, 31),
+
+	MX27_PIN_USBOTG_NXT = _MX27_BUILD_PIN(4, 0),
+	MX27_PIN_USBOTG_STP = _MX27_BUILD_PIN(4, 1),
+	MX27_PIN_USBOTG_DIR = _MX27_BUILD_PIN(4, 2),
+	MX27_PIN_UART2_CTS = _MX27_BUILD_PIN(4, 3),
+	MX27_PIN_UART2_RTS = _MX27_BUILD_PIN(4, 4),
+	MX27_PIN_PWMO = _MX27_BUILD_PIN(4, 5),
+	MX27_PIN_UART2_TXD = _MX27_BUILD_PIN(4, 6),
+	MX27_PIN_UART2_RXD = _MX27_BUILD_PIN(4, 7),
+	MX27_PIN_UART3_TXD = _MX27_BUILD_PIN(4, 8),
+	MX27_PIN_UART3_RXD = _MX27_BUILD_PIN(4, 9),
+	MX27_PIN_UART3_CTS = _MX27_BUILD_PIN(4, 10),
+	MX27_PIN_UART3_RTS = _MX27_BUILD_PIN(4, 11),
+	MX27_PIN_UART1_TXD = _MX27_BUILD_PIN(4, 12),
+	MX27_PIN_UART1_RXD = _MX27_BUILD_PIN(4, 13),
+	MX27_PIN_UART1_CTS = _MX27_BUILD_PIN(4, 14),
+	MX27_PIN_UART1_RTS = _MX27_BUILD_PIN(4, 15),
+	MX27_PIN_RTCK = _MX27_BUILD_PIN(4, 16),
+	MX27_PIN_RESET_OUT_B = _MX27_BUILD_PIN(4, 17),
+	MX27_PIN_SD1_D0 = _MX27_BUILD_PIN(4, 18),
+	MX27_PIN_SD1_D1 = _MX27_BUILD_PIN(4, 19),
+	MX27_PIN_SD1_D2 = _MX27_BUILD_PIN(4, 20),
+	MX27_PIN_SD1_D3 = _MX27_BUILD_PIN(4, 21),
+	MX27_PIN_SD1_CMD = _MX27_BUILD_PIN(4, 22),
+	MX27_PIN_SD1_CLK = _MX27_BUILD_PIN(4, 23),
+	MX27_PIN_USBOTG_CLK = _MX27_BUILD_PIN(4, 24),
+	MX27_PIN_USBOTG_DATA7 = _MX27_BUILD_PIN(4, 25),
+
+	MX27_PIN_NFRB = _MX27_BUILD_PIN(5, 0),
+	MX27_PIN_NFCLE = _MX27_BUILD_PIN(5, 1),
+	MX27_PIN_NFWP_B = _MX27_BUILD_PIN(5, 2),
+	MX27_PIN_NFCE_B = _MX27_BUILD_PIN(5, 3),
+	MX27_PIN_NFALE = _MX27_BUILD_PIN(5, 4),
+	MX27_PIN_NFRE_B = _MX27_BUILD_PIN(5, 5),
+	MX27_PIN_NFWE_B = _MX27_BUILD_PIN(5, 6),
+	MX27_PIN_PC_POE = _MX27_BUILD_PIN(5, 7),
+	MX27_PIN_PC_RW_B = _MX27_BUILD_PIN(5, 8),
+	MX27_PIN_IOIS16 = _MX27_BUILD_PIN(5, 9),
+	MX27_PIN_PC_RST = _MX27_BUILD_PIN(5, 10),
+	MX27_PIN_PC_BVD2 = _MX27_BUILD_PIN(5, 11),
+	MX27_PIN_PC_BVD1 = _MX27_BUILD_PIN(5, 12),
+	MX27_PIN_PC_VS2 = _MX27_BUILD_PIN(5, 13),
+	MX27_PIN_PC_VS1 = _MX27_BUILD_PIN(5, 14),
+	MX27_PIN_CLKO = _MX27_BUILD_PIN(5, 15),
+	MX27_PIN_PC_PWRON = _MX27_BUILD_PIN(5, 16),
+	MX27_PIN_PC_READY = _MX27_BUILD_PIN(5, 17),
+	MX27_PIN_PC_WAIT_B = _MX27_BUILD_PIN(5, 18),
+	MX27_PIN_PC_CD2_B = _MX27_BUILD_PIN(5, 19),
+	MX27_PIN_PC_CD1_B = _MX27_BUILD_PIN(5, 20),
+	MX27_PIN_CS4_B = _MX27_BUILD_PIN(5, 21),
+	MX27_PIN_CS5_B = _MX27_BUILD_PIN(5, 22),
+	MX27_PIN_ATA_DATA15 = _MX27_BUILD_PIN(5, 23),
+} iomux_pin_name_t;
+
+#endif				/* __ASSEMBLY__ */
+#endif				/* __ASM_ARCH_MXC_MX27_PINS_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mx27_usb.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mx27_usb.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_USB2)
+
+static inline int fsl_platform_verify(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static inline void fsl_platform_usb_setup(struct usb_hcd *hcd)
+{
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mx2_dma.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mx2_dma.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,261 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_MX2_H__
+#define __ASM_ARCH_MXC_MX2_H__
+
+/*!
+*@defgroup DMA DMA driver
+*/
+
+/*!
+ *@file mx2_dma.h
+ *@brief DMA driver header file
+ *
+ * @ingroup DMA
+ *
+ */
+
+#include <asm/hardware.h>
+#include <asm/dma.h>
+#include <stdarg.h>
+
+#define MXC_DMA_INTR_0		32
+
+#define DMA_DCR		0x000	/*  32bit dma control reg */
+#define DMA_DISR	0x004	/*  32bit dma interrupt status reg */
+#define DMA_DIMR	0x008	/*  32bit dma interrupt mask reg */
+#define DMA_DBTOSR    0x00c	/*  32bit dma burst timeout stat reg */
+#define DMA_DRTOSR  0x010	/*  32bit dma req timeout status reg */
+#define DMA_DSESR    0x014	/*  32bit dma transfer err status reg */
+#define DMA_DBOSR    0x018	/*  32bit dma buffer overflow stat reg */
+#define DMA_DBTOCR    0x01c	/*  32bit dma burst timeout ctrl reg */
+
+#define DMA_WSRA		0x040	/*  32bit dma W-size A reg */
+#define DMA_XSRA		0x044	/*  32bit dma X-size A reg */
+#define DMA_YSRA		0x048	/*  32bit dma Y-size A reg */
+#define DMA_WSRB		0x04C	/*  32bit dma W-size B reg */
+#define DMA_XSRB		0x050	/*  32bit dma X-size B reg */
+#define DMA_YSRB		0x054	/*  32bit dma Y-size B reg */
+
+#define DMA_CH_BASE(x)	(0x080+0x040*(x))
+
+#define DMA_SAR(x)		(DMA_CH_BASE(x)+0x000)
+#define DMA_DAR(x)		(DMA_CH_BASE(x)+0x004)
+#define DMA_CNTR(x)		(DMA_CH_BASE(x)+0x008)
+#define DMA_CCR(x)		(DMA_CH_BASE(x)+0x00C)	/*  32bit dma ch0 control reg */
+#define DMA_RSSR(x)		(DMA_CH_BASE(x)+0x010)	/*  32bit dma ch0 req source sel reg */
+#define DMA_BLR(x)		(DMA_CH_BASE(x)+0x014)	/*  32bit dma ch0 burst lenght reg */
+#define DMA_RTOR(x)		(DMA_CH_BASE(x)+0x018)	/*  32bit dma ch0 req time out reg */
+#define DMA_BUCR(x)		(DMA_CH_BASE(x)+0x018)	/*  32bit dma ch0 bus utilization reg */
+#define DMA_CCNR(x)		(DMA_CH_BASE(x)+0x01C)	/*  32bit dma ch0 */
+
+#define DMA_TCR			0x480	/*32bit dma test control reg */
+#define DMA_TFIFOA		0x484	/*  32bit dma test fifo A reg */
+#define DMA_TDRR		0x488	/*  32bit dma test request reg */
+#define DMA_TDIPR		0x48c	/*  32bit dma test in progress reg */
+#define DMA_TFIFOB		0x490	/*  32bit dma test fifo B reg */
+
+/*!
+ * This defines maximum DMA address
+ */
+#define MAX_DMA_ADDRESS 0xffffffff
+
+#define MXC_DMA_CHANNELS 16
+#define MAX_DMA_CHANNELS MXC_DMA_CHANNELS
+
+#define MX_DMA_CHANNELS		MXC_DMA_CHANNELS
+
+/*!@def DMA_MEM_SIZE_8 DMA access port size, 8 bit*/
+/*!@def DMA_MEM_SIZE_16 DMA access port size, 16 bit*/
+/*!@def DMA_MEM_SIZE_32 DMA access port size, 32 bit*/
+#define DMA_MEM_SIZE_8		0x1
+#define DMA_MEM_SIZE_16	0x2
+#define DMA_MEM_SIZE_32	0x0
+
+/*!@def DMA_TYPE_LINEAR DMA transfer type, linear*/
+/*!@def DMA_TYPE_2D DMA transfer type, 2D*/
+/*!@def DMA_TYPE_FIFO DMA transfer type, FIFO*/
+/*!@def DMA_TYPE_EBE DMA transfer type, end-of-burst enable FIFO*/
+#define DMA_TYPE_LINEAR	0x0
+#define DMA_TYPE_2D		0x01
+#define DMA_TYPE_FIFO		0x2
+#define DMA_TYPE_EBE		0x3
+
+/*!@def DMA_DONE DMA transfer done*/
+/*!@def DMA_BURST_TIMEOUT DMA transfer timeout error*/
+/*!@def DMA_REQUEST_TIMEOUT DMA transfer request timeout error*/
+/*!@def DMA_TRANSFER_ERROR DMA transfer error*/
+/*!@def DMA_BUFFER_OVERFLOW DMA transfer buffer overflow error*/
+#define DMA_DONE		0x1000
+#define DMA_BURST_TIMEOUT 	0x1
+#define DMA_REQUEST_TIMEOUT 	0x2
+#define DMA_TRANSFER_ERROR	0x4
+#define DMA_BUFFER_OVERFLOW	0x8
+
+/*!@brief DMA control register*/
+typedef struct {
+	volatile u32 CEN:1;	/*!< Dma channel enable              */
+	volatile u32 FRC:1;	/*!<  Force a dma cycle bit           */
+	volatile u32 RPT:1;	/*!<  Repeat bit              */
+	volatile u32 REN:1;	/*!<   Request enable bit      */
+	volatile u32 SSIZ:2;	/*!<   Source port size, 2 bit in length               */
+	volatile u32 DSIZ:2;	/*!<  Dest port size, 2 bit in length         */
+	volatile u32 MSEL:1;	/*!<  2D memory register set  bit             */
+	volatile u32 MDIR:1;	/*!< Transfer direction, inversed or normal          */
+	volatile u32 SMOD:2;	/*!<  Source mode, 2 bit in length            */
+	volatile u32 DMOD:2;	/*!<  Dest mode, 2 bit in length              */
+	volatile u32 ACRPT:1;	/*!<  Auto clear repeat bit           */
+	volatile u32 Reserver:17;	/*!<  Reserved bits           */
+
+} dma_regs_control;
+
+#define DMA_CTL_CEN 0x1
+#define DMA_CTL_FRC 0x2
+#define DMA_CTL_RPT 0x4
+#define DMA_CTL_REN 0x8
+
+#define DMA_CTL_MSEL 0x100
+#define DMA_CTL_MDIR 0x200
+#define DMA_CTL_ACRPT 0x4000
+
+#define DMA_CTL_GET_SSIZ(x) (((x)>>4)&0x3)
+#define DMA_CTL_GET_DSIZ(x) (((x)>>6)&0x3)
+#define DMA_CTL_GET_SMOD(x)  (((x)>>10)&0x3)
+#define DMA_CTL_GET_DMOD(x)  (((x)>>12)&0x3)
+
+#define DMA_CTL_SET_SSIZ(x,value) 	do{ \
+									(x)&=~(0x3<<4); \
+									(x)|=(value)<<4; 		\
+								}while(0)
+
+#define DMA_CTL_SET_DSIZ(x,value) 	do{ \
+									(x)&=~(0x3<<6); \
+									(x)|=(value)<<6; 		\
+								}while(0)
+
+#define DMA_CTL_SET_SMOD(x,value) 	do{ \
+									(x)&=~(0x3<<10); \
+									(x)|=(value)<<10; 		\
+								}while(0)
+
+#define DMA_CTL_SET_DMOD(x,value) 	do{ \
+									(x)&=~(0x3<<12); \
+									(x)|=(value)<<12; 		\
+								}while(0)
+
+typedef struct {
+	volatile u32 SourceAddr;
+	volatile u32 DestAddr;
+	volatile u32 Count;
+	volatile u32 Ctl;
+	volatile u32 RequestSource;
+	volatile u32 BurstLength;
+	union {
+		volatile u32 ReqTimeout;
+		volatile u32 BusUtilt;
+	};
+	volatile u32 transferd;
+} dma_regs_t;
+
+#ifndef TRANSFER_32BIT
+/*!
+ * This defines DMA access data size
+ */
+
+#define TRANSFER_8BIT       DMA_MEM_SIZE_8
+#define TRANSFER_16BIT      DMA_MEM_SIZE_16
+#define TRANSFER_32BIT      DMA_MEM_SIZE_32
+
+#endif
+
+/*!
+ * This defines maximum device name length passed during mxc_request_dma().
+ */
+#define MAX_DEVNAME_LENGTH 32
+#define MAX_BD_SIZE	32
+
+/*!
+ * Structure containing dma channel parameters.
+ */
+typedef struct {
+	unsigned long dma_chan;	/*!< the dma channel information: dynamic or channel number */
+	u32 mode:1;		/*!< the initialized dma mode, 0 for dma read, 1 for dma write */
+	u32 rto_en:1;		/*!< enable request-timeout. It is valid when REN=1 */
+	u32 dir:1;		/*!< Transfer direction, 0 for increment, 1 for decrement */
+	u32 dma_chaining:1;	/*!< Autoclear bit for chainbuffer */
+	u32 ren:1;		/*!< enable transfer based request signal */
+	u32 M2D_Valid:1;	/*!< enable 2D address module. 0 for disable it. 1 for enabled it */
+	u32 msel:1;		/*!<2D memory selection, 0 for set A, 1 for set B */
+	u32 burstLength;	/*!<    Channel burst length    */
+	u32 request;		/*!<   Request source. */
+	u32 busuntils;		/*!<   when REN=0, Bus utilization, otherwise it it request timeout */
+	u32 sourceType;		/*!<    Source type, see DMA_TYPE_* */
+	u32 sourcePort;		/*!<    Source port size, see DMA_MEM_SIZE_*  */
+	u32 destType;		/*!<    Destination type, see DMA_TYPE_*    */
+	u32 destPort;		/*!<    Destination port size, see DMA_MEM_SIZE_*       */
+	__u32 per_address;	/*< Peripheral source/destination 
+				 *   physical address
+				 */
+	u32 W;			/*!<    2D Wide-size            */
+	u32 X;			/*!<    2D X-size               */
+	u32 Y;			/*!<    2D Y-size               */
+} mx2_dma_info_t;
+
+/*!
+ * Structure of dma buffer descriptor 
+ */
+typedef struct {
+	unsigned long state;	/*!< dma bd state */
+	int mode;		/*!< the dma mode of this bd */
+	unsigned long count;	/*!< the length of the dma transfer */
+	unsigned long src_addr;	/*!< the source address of the dma transfer */
+	unsigned long dst_addr;	/*!< the destination address of the dma transfer */
+} mx2_dma_bd_t;
+
+/*!
+ * the states of dma buffer descriptor
+ */
+#define DMA_BD_ST_BUSY	0x20000000	/*!< dma bd is transfering or has be configured into controller */
+#define DMA_BD_ST_PEND	0x10000000	/*!< dma bd is waiting to be configured into controller */
+#define DMA_BD_ST_LAST	0x08000000	/*!< dma bd is the last dma bd which is built in one dma transfer request
+					 *          When completed this bd, the callback function must be called.
+					 */
+
+/*!
+ *  This structure containing the private information for MX2
+ */
+typedef struct mx2_dma_priv_s {
+	unsigned int dma_chaining:1;	/* 1: using headware dma chaining feature */
+	unsigned int ren:1;	/* 1: dma start besed on request signal */
+	unsigned long trans_bytes;	/* To store the transfered data bytes in this transfer */
+	mx2_dma_info_t *dma_info;	/* To store the pointer for dma parameter for reading and wirting */
+	int bd_rd;		/* the read index of bd ring */
+	int bd_wr;		/* the write index of bd ring */
+	atomic_t bd_used;	/* the valid bd number in bd ring */
+	mx2_dma_bd_t *bd_ring;	/* the pointer of bd ring */
+	unsigned long dma_base;	/* register base address of this channel */
+	int dma_irq;		/* irq number of this channel */
+} mx2_dma_priv_t;
+
+/*!
+ * @brief get the dma info by channel_id
+ */
+extern mx2_dma_info_t *mxc_dma_get_info(mxc_dma_device_t channel_id);
+
+/*!
+ * @brief: scan dma parameter list . And collect information about which channels are dynamic .
+ */
+extern void mxc_dma_load_info(mxc_dma_channel_t * dma);
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mx31.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mx31.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,432 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX31_H__
+#define __ASM_ARCH_MXC_MX31_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+#include <asm/arch/mx31_pins.h>
+
+/*!
+ * defines the OS clock tick rate
+ */
+#define CLOCK_TICK_RATE         16625000
+
+#define ATA_BASE_CLK            (IPG_CLK)
+/*!
+ * Register an interrupt handler for the SMN as well as the SCC.  In some
+ * implementations, the SMN is not connected at all, and in others, it is
+ * on the same interrupt line as the SCM. Comment this line out accordingly
+ */
+#define USE_SMN_INTERRUPT
+
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+#define MXC_UART_NR 5
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive Irda data.
+ */
+#define MXC_UART_IR_RXDMUX      0x0004
+/*!
+ * This option is used to set or clear the RXDMUXSEL bit in control reg 3.
+ * Certain platforms need this bit to be set in order to receive UART data.
+ */
+#define MXC_UART_RXDMUX         0x0004
+
+/*
+ * IRAM
+ */
+#define IRAM_BASE_ADDR		0x1FFC0000	/* internal ram */
+#define IRAM_BASE_ADDR_VIRT	0xD0000000
+#define IRAM_SIZE		SZ_16K
+
+/*
+ * L2CC
+ */
+#define L2CC_BASE_ADDR		0x30000000
+#define L2CC_BASE_ADDR_VIRT	0xD1000000
+#define L2CC_SIZE		SZ_1M
+
+/*
+ * AIPS 1
+ */
+#define AIPS1_BASE_ADDR 	0x43F00000
+#define AIPS1_BASE_ADDR_VIRT	0xD4000000
+#define AIPS1_SIZE		SZ_1M
+
+#define MAX_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00004000)
+#define EVTMON_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00008000)
+#define CLKCTL_BASE_ADDR	(AIPS1_BASE_ADDR + 0x0000C000)
+#define ETB_SLOT4_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00010000)
+#define ETB_SLOT5_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00014000)
+#define ECT_CTIO_BASE_ADDR	(AIPS1_BASE_ADDR + 0x00018000)
+#define I2C_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00080000)
+#define I2C3_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00084000)
+#define OTG_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00088000)
+#define ATA_BASE_ADDR		(AIPS1_BASE_ADDR + 0x0008C000)
+#define UART1_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x00090000)
+#define UART2_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x00094000)
+#define I2C2_BASE_ADDR		(AIPS1_BASE_ADDR + 0x00098000)
+#define OWIRE_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x0009C000)
+#define SSI1_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A0000)
+#define CSPI1_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x000A4000)
+#define KPP_BASE_ADDR		(AIPS1_BASE_ADDR + 0x000A8000)
+#define IOMUXC_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000AC000)
+#define UART4_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x000B0000)
+#define UART5_BASE_ADDR 	(AIPS1_BASE_ADDR + 0x000B4000)
+#define ECT_IP1_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000B8000)
+#define ECT_IP2_BASE_ADDR	(AIPS1_BASE_ADDR + 0x000BC000)
+
+/*
+ * SPBA global module enabled #0
+ */
+#define SPBA0_BASE_ADDR 	0x50000000
+#define SPBA0_BASE_ADDR_VIRT	0xD4100000
+#define SPBA0_SIZE		SZ_1M
+
+#define MMC_SDHC1_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00004000)
+#define MMC_SDHC2_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00008000)
+#define UART3_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x0000C000)
+#define CSPI2_BASE_ADDR 	(SPBA0_BASE_ADDR + 0x00010000)
+#define SSI2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00014000)
+#define SIM1_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00018000)
+#define IIM_BASE_ADDR		(SPBA0_BASE_ADDR + 0x0001C000)
+#define ATA_DMA_BASE_ADDR	(SPBA0_BASE_ADDR + 0x00020000)
+#define MSHC1_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00024000)
+#define MSHC2_BASE_ADDR		(SPBA0_BASE_ADDR + 0x00024000)
+#define SPBA_CTRL_BASE_ADDR	(SPBA0_BASE_ADDR + 0x0003C000)
+
+/*!
+ * defines for SPBA modules
+ */
+#define SPBA_SDHC1	0x04
+#define SPBA_SDHC2	0x08
+#define SPBA_UART3	0x0C
+#define SPBA_CSPI2	0x10
+#define SPBA_SSI2	0x14
+#define SPBA_SIM	0x18
+#define SPBA_IIM	0x1C
+#define SPBA_ATA	0x20
+
+/*!
+ * Defines for modules using static and dynamic DMA channels
+ */
+#define MXC_DMA_CHANNEL_UART1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART3_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART4_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_UART5_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC1  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MMC2  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_SSI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_FIR_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_FIR_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI1_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_CSPI2_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_RX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_ATA_TX  MXC_DMA_DYNAMIC_CHANNEL
+#define MXC_DMA_CHANNEL_MEMORY  MXC_DMA_DYNAMIC_CHANNEL
+
+/*
+ * AIPS 2
+ */
+#define AIPS2_BASE_ADDR		0x53F00000
+#define AIPS2_BASE_ADDR_VIRT	0xD4200000
+#define AIPS2_SIZE		SZ_1M
+#define CCM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00080000)
+#define CSPI3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00084000)
+#define FIRI_BASE_ADDR		(AIPS2_BASE_ADDR + 0x0008C000)
+#define GPT1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00090000)
+#define EPIT1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00094000)
+#define EPIT2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x00098000)
+#define GPIO3_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000A4000)
+#define SCC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000AC000)
+#define SCM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000AE000)
+#define SMN_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000AF000)
+#define RNGA_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000B0000)
+#define IPU_CTRL_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C0000)
+#define AUDMUX_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C4000)
+#define MPEG4_ENC_BASE_ADDR	(AIPS2_BASE_ADDR + 0x000C8000)
+#define GPIO1_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000CC000)
+#define GPIO2_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D0000)
+#define SDMA_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D4000)
+#define RTC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000D8000)
+#define WDOG_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000DC000)
+#define PWM_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000E0000)
+#define RTIC_BASE_ADDR		(AIPS2_BASE_ADDR + 0x000EC000)
+
+/*
+ * ROMP and AVIC
+ */
+#define ROMP_BASE_ADDR		0x60000000
+#define ROMP_BASE_ADDR_VIRT	0xD4500000
+#define ROMP_SIZE		SZ_1M
+
+#define AVIC_BASE_ADDR		0x68000000
+#define AVIC_BASE_ADDR_VIRT	0xD4400000
+#define AVIC_SIZE		SZ_1M
+
+/*
+ * NAND, SDRAM, WEIM, M3IF, EMI controllers
+ */
+#define X_MEMC_BASE_ADDR	0xB8000000
+#define X_MEMC_BASE_ADDR_VIRT	0xD4320000
+#define X_MEMC_SIZE		SZ_64K
+
+#define NFC_BASE_ADDR		(X_MEMC_BASE_ADDR + 0x0000)
+#define ESDCTL_BASE_ADDR	(X_MEMC_BASE_ADDR + 0x1000)
+#define WEIM_BASE_ADDR		(X_MEMC_BASE_ADDR + 0x2000)
+#define M3IF_BASE_ADDR		(X_MEMC_BASE_ADDR + 0x3000)
+#define EMI_CTL_BASE_ADDR	(X_MEMC_BASE_ADDR + 0x4000)
+#define PCMCIA_CTL_BASE_ADDR	EMI_CTL_BASE_ADDR
+
+/*
+ * Memory regions and CS
+ */
+/* MX31 ADS SDRAM is from 0x80000000, 64M */
+#define SDRAM_BASE_ADDR         0x80000000
+#define IPU_MEM_BASE_ADDR       0x70000000
+#define CSD1_BASE_ADDR          0x90000000
+#define CS0_BASE_ADDR           0xA0000000
+#define CS1_BASE_ADDR           0xA8000000
+#define CS2_BASE_ADDR           0xB0000000
+#define CS3_BASE_ADDR           0xB2000000
+
+#define CS4_BASE_ADDR           0xB4000000
+#define CS4_BASE_ADDR_VIRT      0xEB000000
+#define CS4_SIZE                SZ_16M
+
+#define CS5_BASE_ADDR           0xB6000000
+#define PCMCIA_MEM_BASE_ADDR    0xBC000000
+
+/*!
+ * This macro defines the physical to virtual address mapping for all the
+ * peripheral modules. It is used by passing in the physical address as x
+ * and returning the virtual address. If the physical address is not mapped,
+ * it returns 0xDEADBEEF
+ */
+#define IO_ADDRESS(x)   \
+        (((x >= IRAM_BASE_ADDR) && (x < (IRAM_BASE_ADDR + IRAM_SIZE))) ? IRAM_IO_ADDRESS(x):\
+        ((x >= L2CC_BASE_ADDR) && (x < (L2CC_BASE_ADDR + L2CC_SIZE))) ? L2CC_IO_ADDRESS(x):\
+        ((x >= AIPS1_BASE_ADDR) && (x < (AIPS1_BASE_ADDR + AIPS1_SIZE))) ? AIPS1_IO_ADDRESS(x):\
+        ((x >= SPBA0_BASE_ADDR) && (x < (SPBA0_BASE_ADDR + SPBA0_SIZE))) ? SPBA0_IO_ADDRESS(x):\
+        ((x >= AIPS2_BASE_ADDR) && (x < (AIPS2_BASE_ADDR + AIPS2_SIZE))) ? AIPS2_IO_ADDRESS(x):\
+        ((x >= ROMP_BASE_ADDR) && (x < (ROMP_BASE_ADDR + ROMP_SIZE))) ? ROMP_IO_ADDRESS(x):\
+        ((x >= AVIC_BASE_ADDR) && (x < (AVIC_BASE_ADDR + AVIC_SIZE))) ? AVIC_IO_ADDRESS(x):\
+        ((x >= CS4_BASE_ADDR) && (x < (CS4_BASE_ADDR + CS4_SIZE))) ? CS4_IO_ADDRESS(x):\
+        ((x >= X_MEMC_BASE_ADDR) && (x < (X_MEMC_BASE_ADDR + X_MEMC_SIZE))) ? X_MEMC_IO_ADDRESS(x):\
+        0xDEADBEEF)
+
+/*
+ * define the address mapping macros: in physical address order
+ */
+
+#define IRAM_IO_ADDRESS(x)  \
+        (((x) - IRAM_BASE_ADDR) + IRAM_BASE_ADDR_VIRT)
+
+#define L2CC_IO_ADDRESS(x)  \
+        (((x) - L2CC_BASE_ADDR) + L2CC_BASE_ADDR_VIRT)
+
+#define AIPS1_IO_ADDRESS(x)  \
+        (((x) - AIPS1_BASE_ADDR) + AIPS1_BASE_ADDR_VIRT)
+
+#define SPBA0_IO_ADDRESS(x)  \
+        (((x) - SPBA0_BASE_ADDR) + SPBA0_BASE_ADDR_VIRT)
+
+#define AIPS2_IO_ADDRESS(x)  \
+        (((x) - AIPS2_BASE_ADDR) + AIPS2_BASE_ADDR_VIRT)
+
+#define ROMP_IO_ADDRESS(x)  \
+        (((x) - ROMP_BASE_ADDR) + ROMP_BASE_ADDR_VIRT)
+
+#define AVIC_IO_ADDRESS(x)  \
+        (((x) - AVIC_BASE_ADDR) + AVIC_BASE_ADDR_VIRT)
+
+#define CS4_IO_ADDRESS(x)  \
+        (((x) - CS4_BASE_ADDR) + CS4_BASE_ADDR_VIRT)
+
+#define X_MEMC_IO_ADDRESS(x)  \
+        (((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+#define PCMCIA_IO_ADDRESS(x) \
+	(((x) - X_MEMC_BASE_ADDR) + X_MEMC_BASE_ADDR_VIRT)
+
+/*
+ * DMA request assignments
+ */
+#define DMA_REQ_GPIO1_0    31
+#define DMA_REQ_NFC        30
+#define DMA_REQ_SSI1_TX1   29
+#define DMA_REQ_SSI1_RX1   28
+#define DMA_REQ_SSI1_TX2   27
+#define DMA_REQ_SSI1_RX2   26
+#define DMA_REQ_SSI2_TX1   25
+#define DMA_REQ_SSI2_RX1   24
+#define DMA_REQ_SSI2_TX2   23
+#define DMA_REQ_SSI2_RX2   22
+#define DMA_REQ_SDHC2      21
+#define DMA_REQ_SDHC1      20
+#define DMA_REQ_UART1_TX   19
+#define DMA_REQ_UART1_RX   18
+#define DMA_REQ_FIRI_TX    17
+#define DMA_REQ_FIRI_RX    16
+#define DMA_REQ_UART2_TX   17
+#define DMA_REQ_UART2_RX   16
+#define DMA_REQ_GPIO1_1    15
+#define DMA_REQ_GPIO1_2    14
+#define DMA_REQ_UART4_TX   13
+#define DMA_REQ_UART4_RX   12
+#define DMA_REQ_UART5_TX   11
+#define DMA_REQ_UART5_RX   10
+#define DMA_REQ_CSPI1_TX   9
+#define DMA_REQ_CSPI1_RX   8
+#define DMA_REQ_UART3_TX   9
+#define DMA_REQ_UART3_RX   8
+#define DMA_REQ_CSPI2_TX   7
+#define DMA_REQ_CSPI2_RX   6
+#define DMA_REQ_SIM        5
+#define DMA_REQ_ATA_RX     4
+#define DMA_REQ_ATA_TX     3
+#define DMA_REQ_ATA_TX_END 2
+#define DMA_REQ_CCM        1
+#define DMA_REQ_reserved   0
+
+/*
+ * Interrupt numbers
+ */
+#define MXC_INT_BASE		0
+#define INT_PEN_ADS7843         0
+#define INT_RESV1               1
+#define INT_CS8900A             2
+#define INT_I2C3                3
+#define INT_I2C2                4
+#define INT_MPEG4_ENCODER       5
+#define INT_RTIC                6
+#define INT_FIRI                7
+#define INT_MMC_SDHC2           8
+#define INT_MMC_SDHC1           9
+#define INT_I2C                 10
+#define INT_SSI2                11
+#define INT_SSI1                12
+#define INT_CSPI2               13
+#define INT_CSPI1               14
+#define INT_ATA                 15
+#define INT_MBX                 16
+#define INT_CSPI3               17
+#define INT_UART3               18
+#define INT_IIM                 19
+#define INT_SIM2                20
+#define INT_SIM1                21
+#define INT_RNGA                22
+#define INT_EVTMON              23
+#define INT_KPP                 24
+#define INT_RTC                 25
+#define INT_PWM                 26
+#define INT_EPIT2               27
+#define INT_EPIT1               28
+#define INT_GPT                 29
+#define INT_RESV30              30
+#define INT_RESV31              31
+#define INT_UART2               32
+#define INT_NANDFC              33
+#define INT_SDMA                34
+#define INT_USB1                35
+#define INT_USB2                36
+#define INT_USB3                37
+#define INT_USB4                38
+#define INT_MSHC1               39
+#define INT_MSHC2               40
+#define INT_IPU_ERR             41
+#define INT_IPU_SYN             42
+#define INT_RESV43              43
+#define INT_RESV44              44
+#define INT_UART1               45
+#define INT_UART4               46
+#define INT_UART5               47
+#define INT_ECT                 48
+#define INT_SCC_SCM             49
+#define INT_SCC_SMN             50
+#define INT_GPIO2               51
+#define INT_GPIO1               52
+#define INT_CCM                 53
+#define INT_PCMCIA              54
+#define INT_WDOG                55
+#define INT_GPIO3               56
+#define INT_RESV57              57
+#define INT_EXT_POWER           58
+#define INT_EXT_TEMPER          59
+#define INT_EXT_SENSOR60        60
+#define INT_EXT_SENSOR61        61
+#define INT_EXT_WDOG            62
+#define INT_EXT_TV              63
+
+#define MXC_MAX_INT_LINES       64
+
+/*!
+ * Interrupt Number for ARM11 PMU
+ */
+#define ARM11_PMU_IRQ		INT_EVTMON
+
+#define	MXC_GPIO_BASE		(MXC_MAX_INT_LINES)
+
+/*!
+ * Number of GPIO port as defined in the IC Spec
+ */
+#define GPIO_PORT_NUM           3
+/*!
+ * Number of GPIO pins per port
+ */
+#define GPIO_NUM_PIN            32
+
+#define PROD_SIGNATURE        0x1	/* For MX31 */
+
+#define SYSTEM_REV_MIN          CHIP_REV_1_0
+#define SYSTEM_REV_NUM          3
+
+/*
+ * Used for 1-Wire
+ */
+#define owire_read(a) (__raw_readw(a))
+#define owire_write(v,a) (__raw_writew(v,a))
+
+/*!
+ * NFMS bit in RCSR register for pagesize of nandflash
+ */
+#define NFMS (*((volatile u32 *)IO_ADDRESS(CCM_BASE_ADDR+0xc)))
+#define NFMS_BIT 30
+
+/*
+ * PWM control register used in clock API for
+ * finding clock source for the module
+ */
+#define MXC_PWM_PWMCTRL		IO_ADDRESS(PWM_BASE_ADDR)
+#define PWM_CTRL_MASK           0xFFFCFFFF
+#define PWM_CTRL_OFFSET	    	16
+
+#endif				/*  __ASM_ARCH_MXC_MX31_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mx31_pins.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mx31_pins.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,438 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_MX31_PINS_H__
+#define __ASM_ARCH_MXC_MX31_PINS_H__
+
+#ifndef __ASSEMBLY__
+
+/*!
+ * @name IOMUX/PAD Bit field definitions
+ */
+
+/*! @{ */
+
+/*!
+ * In order to identify pins more effectively, each mux-controlled pin's
+ * enumerated value is constructed in the following way:
+ *
+ * -------------------------------------------------------------------
+ * 31-29 | 28 - 24 |23 - 21| 20  | 19 - 18 | 17 - 10| 9 - 8 | 7 - 0
+ * -------------------------------------------------------------------
+ * IO_P  |  IO_I   |     RSVD    |  PAD_F  |  PAD_I | MUX_F | MUX_I
+ * -------------------------------------------------------------------
+ *
+ * Bit 0 to 7 contains MUX_I used to identify the register
+ * offset (0-based. base is IOMUX_module_base + 0xC) defined in the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the IC Spec. Bit 8 to 9 is MUX_F which
+ * contains the offset value defined WITHIN the same register (each IOMUX
+ * control register contains four 8-bit fields for four different pins). The
+ * similar field definitions are used for the pad control register.
+ * For example, the MX31_PIN_A0 is defined in the enumeration:
+ *    ( 73 << MUX_I) | (0 << MUX_F)|( 98 << PAD_I) | (0 << PAD_F)
+ * It means the mux control register is at register offset 73. So the absolute
+ * address is: 0xC+73*4=0x130   0 << MUX_F means the control bits are at the
+ * least significant bits within the register. The pad control register offset
+ * is: 0x154+98*4=0x2DC and also occupy the least significant bits within the
+ * register.
+ */
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio port number (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 1's for error checking in the functions. (gpio port 7 is invalid)
+ */
+#define MUX_IO_P	29
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * gpio offset bit (0-based) for that pin. For non-gpio pins, the bits will
+ * be all 0's since they are don't cares. So for port 2 pin 21, bit 31-24
+ * will be (1 << MUX_IO_P) | (21 << MUX_IO_I).
+ */
+#define MUX_IO_I	24
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * MUX control register index (0-based)
+ */
+#define MUX_I		0
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * field within IOMUX control register for control bits
+ * (legal values are 0, 1, 2, 3)
+ */
+#define MUX_F		8
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * PAD control register index (0-based)
+ */
+#define PAD_I		10
+
+/*!
+ * Starting bit position within each entry of \b iomux_pins to represent the
+ * field within PAD control register for control bits
+ * (legal values are 0, 1, 2)
+ */
+#define PAD_F		18
+
+#define _MXC_BUILD_PIN(gp,gi,mi,mf,pi,pf) \
+	((gp) << MUX_IO_P) | ((gi) << MUX_IO_I) | ((mi) << MUX_I) | \
+	((mf) << MUX_F) | ((pi) << PAD_I) | ((pf) << PAD_F)
+
+#define _MXC_BUILD_GPIO_PIN(gp,gi,mi,mf,pi,pf) \
+		_MXC_BUILD_PIN(gp,gi,mi,mf,pi,pf)
+#define _MXC_BUILD_NON_GPIO_PIN(mi,mf,pi,pf) \
+		_MXC_BUILD_PIN(7,0,mi,mf,pi,pf)
+
+/*! @} End IOMUX/PAD Bit field definitions */
+
+/*!
+ * This enumeration is constructed based on the Section
+ * "sw_pad_ctl & sw_mux_ctl details" of the MX31 IC Spec. Each enumerated
+ * value is constructed based on the rules described above.
+ */
+typedef enum iomux_pins {
+	MX31_PIN_CSPI3_MISO = _MXC_BUILD_NON_GPIO_PIN(0, 3, 1, 2),
+	MX31_PIN_CSPI3_SCLK = _MXC_BUILD_NON_GPIO_PIN(0, 2, 1, 1),
+	MX31_PIN_CSPI3_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(0, 1, 1, 0),
+	MX31_PIN_TTM_PAD = _MXC_BUILD_NON_GPIO_PIN(0, 0, 0, 2),
+	MX31_PIN_ATA_RESET_B = _MXC_BUILD_GPIO_PIN(2, 31, 1, 3, 3, 0),
+	MX31_PIN_CE_CONTROL = _MXC_BUILD_NON_GPIO_PIN(1, 2, 2, 2),
+	MX31_PIN_CLKSS = _MXC_BUILD_NON_GPIO_PIN(1, 1, 2, 1),
+	MX31_PIN_CSPI3_MOSI = _MXC_BUILD_NON_GPIO_PIN(1, 0, 2, 0),
+	MX31_PIN_ATA_CS1 = _MXC_BUILD_GPIO_PIN(2, 27, 2, 3, 4, 1),
+	MX31_PIN_ATA_DIOR = _MXC_BUILD_GPIO_PIN(2, 28, 2, 2, 4, 0),
+	MX31_PIN_ATA_DIOW = _MXC_BUILD_GPIO_PIN(2, 29, 2, 1, 3, 2),
+	MX31_PIN_ATA_DMACK = _MXC_BUILD_GPIO_PIN(2, 30, 2, 0, 3, 1),
+	MX31_PIN_SD1_DATA1 = _MXC_BUILD_GPIO_PIN(1, 29, 3, 3, 5, 2),
+	MX31_PIN_SD1_DATA2 = _MXC_BUILD_GPIO_PIN(1, 30, 3, 2, 5, 1),
+	MX31_PIN_SD1_DATA3 = _MXC_BUILD_GPIO_PIN(1, 31, 3, 1, 5, 0),
+	MX31_PIN_ATA_CS0 = _MXC_BUILD_GPIO_PIN(2, 26, 3, 0, 4, 2),
+	MX31_PIN_D3_SPL = _MXC_BUILD_NON_GPIO_PIN(4, 3, 7, 0),
+	MX31_PIN_SD1_CMD = _MXC_BUILD_GPIO_PIN(1, 26, 4, 2, 6, 2),
+	MX31_PIN_SD1_CLK = _MXC_BUILD_GPIO_PIN(1, 27, 4, 1, 6, 1),
+	MX31_PIN_SD1_DATA0 = _MXC_BUILD_GPIO_PIN(1, 28, 4, 0, 6, 0),
+	MX31_PIN_VSYNC3 = _MXC_BUILD_NON_GPIO_PIN(5, 3, 8, 1),
+	MX31_PIN_CONTRAST = _MXC_BUILD_NON_GPIO_PIN(5, 2, 8, 0),
+	MX31_PIN_D3_REV = _MXC_BUILD_NON_GPIO_PIN(5, 1, 7, 2),
+	MX31_PIN_D3_CLS = _MXC_BUILD_NON_GPIO_PIN(5, 0, 7, 1),
+	MX31_PIN_SER_RS = _MXC_BUILD_GPIO_PIN(2, 25, 6, 3, 9, 2),
+	MX31_PIN_PAR_RS = _MXC_BUILD_NON_GPIO_PIN(6, 2, 9, 1),
+	MX31_PIN_WRITE = _MXC_BUILD_NON_GPIO_PIN(6, 1, 9, 0),
+	MX31_PIN_READ = _MXC_BUILD_NON_GPIO_PIN(6, 0, 8, 2),
+	MX31_PIN_SD_D_IO = _MXC_BUILD_GPIO_PIN(2, 21, 7, 3, 11, 0),
+	MX31_PIN_SD_D_CLK = _MXC_BUILD_GPIO_PIN(2, 22, 7, 2, 10, 2),
+	MX31_PIN_LCS0 = _MXC_BUILD_GPIO_PIN(2, 23, 7, 1, 10, 1),
+	MX31_PIN_LCS1 = _MXC_BUILD_GPIO_PIN(2, 24, 7, 0, 10, 0),
+	MX31_PIN_HSYNC = _MXC_BUILD_NON_GPIO_PIN(8, 3, 12, 1),
+	MX31_PIN_FPSHIFT = _MXC_BUILD_NON_GPIO_PIN(8, 2, 12, 0),
+	MX31_PIN_DRDY0 = _MXC_BUILD_NON_GPIO_PIN(8, 1, 11, 2),
+	MX31_PIN_SD_D_I = _MXC_BUILD_GPIO_PIN(2, 20, 8, 0, 11, 1),
+	MX31_PIN_LD15 = _MXC_BUILD_NON_GPIO_PIN(9, 3, 13, 2),
+	MX31_PIN_LD16 = _MXC_BUILD_NON_GPIO_PIN(9, 2, 13, 1),
+	MX31_PIN_LD17 = _MXC_BUILD_NON_GPIO_PIN(9, 1, 13, 0),
+	MX31_PIN_VSYNC0 = _MXC_BUILD_NON_GPIO_PIN(9, 0, 12, 2),
+	MX31_PIN_LD11 = _MXC_BUILD_NON_GPIO_PIN(10, 3, 15, 0),
+	MX31_PIN_LD12 = _MXC_BUILD_NON_GPIO_PIN(10, 2, 14, 2),
+	MX31_PIN_LD13 = _MXC_BUILD_NON_GPIO_PIN(10, 1, 14, 1),
+	MX31_PIN_LD14 = _MXC_BUILD_NON_GPIO_PIN(10, 0, 14, 0),
+	MX31_PIN_LD7 = _MXC_BUILD_NON_GPIO_PIN(11, 3, 16, 1),
+	MX31_PIN_LD8 = _MXC_BUILD_NON_GPIO_PIN(11, 2, 16, 0),
+	MX31_PIN_LD9 = _MXC_BUILD_NON_GPIO_PIN(11, 1, 15, 2),
+	MX31_PIN_LD10 = _MXC_BUILD_NON_GPIO_PIN(11, 0, 15, 1),
+	MX31_PIN_LD3 = _MXC_BUILD_NON_GPIO_PIN(12, 3, 17, 2),
+	MX31_PIN_LD4 = _MXC_BUILD_NON_GPIO_PIN(12, 2, 17, 1),
+	MX31_PIN_LD5 = _MXC_BUILD_NON_GPIO_PIN(12, 1, 17, 0),
+	MX31_PIN_LD6 = _MXC_BUILD_NON_GPIO_PIN(12, 0, 16, 2),
+	MX31_PIN_USBH2_DATA1 = _MXC_BUILD_NON_GPIO_PIN(13, 3, 19, 0),
+	MX31_PIN_LD0 = _MXC_BUILD_NON_GPIO_PIN(13, 2, 18, 2),
+	MX31_PIN_LD1 = _MXC_BUILD_NON_GPIO_PIN(13, 1, 18, 1),
+	MX31_PIN_LD2 = _MXC_BUILD_NON_GPIO_PIN(13, 0, 18, 0),
+	MX31_PIN_USBH2_DIR = _MXC_BUILD_NON_GPIO_PIN(14, 3, 20, 1),
+	MX31_PIN_USBH2_STP = _MXC_BUILD_NON_GPIO_PIN(14, 2, 20, 0),
+	MX31_PIN_USBH2_NXT = _MXC_BUILD_NON_GPIO_PIN(14, 1, 19, 2),
+	MX31_PIN_USBH2_DATA0 = _MXC_BUILD_NON_GPIO_PIN(14, 0, 19, 1),
+	MX31_PIN_USBOTG_DATA5 = _MXC_BUILD_NON_GPIO_PIN(15, 3, 21, 2),
+	MX31_PIN_USBOTG_DATA6 = _MXC_BUILD_NON_GPIO_PIN(15, 2, 21, 1),
+	MX31_PIN_USBOTG_DATA7 = _MXC_BUILD_NON_GPIO_PIN(15, 1, 21, 0),
+	MX31_PIN_USBH2_CLK = _MXC_BUILD_NON_GPIO_PIN(15, 0, 20, 2),
+	MX31_PIN_USBOTG_DATA1 = _MXC_BUILD_NON_GPIO_PIN(16, 3, 23, 0),
+	MX31_PIN_USBOTG_DATA2 = _MXC_BUILD_NON_GPIO_PIN(16, 2, 22, 2),
+	MX31_PIN_USBOTG_DATA3 = _MXC_BUILD_NON_GPIO_PIN(16, 1, 22, 1),
+	MX31_PIN_USBOTG_DATA4 = _MXC_BUILD_NON_GPIO_PIN(16, 0, 22, 0),
+	MX31_PIN_USBOTG_DIR = _MXC_BUILD_NON_GPIO_PIN(17, 3, 24, 1),
+	MX31_PIN_USBOTG_STP = _MXC_BUILD_NON_GPIO_PIN(17, 2, 24, 0),
+	MX31_PIN_USBOTG_NXT = _MXC_BUILD_NON_GPIO_PIN(17, 1, 23, 2),
+	MX31_PIN_USBOTG_DATA0 = _MXC_BUILD_NON_GPIO_PIN(17, 0, 23, 1),
+	MX31_PIN_USB_PWR = _MXC_BUILD_GPIO_PIN(0, 29, 18, 3, 25, 2),
+	MX31_PIN_USB_OC = _MXC_BUILD_GPIO_PIN(0, 30, 18, 2, 25, 1),
+	MX31_PIN_USB_BYP = _MXC_BUILD_GPIO_PIN(0, 31, 18, 1, 25, 0),
+	MX31_PIN_USBOTG_CLK = _MXC_BUILD_NON_GPIO_PIN(18, 0, 24, 2),
+	MX31_PIN_TDO = _MXC_BUILD_NON_GPIO_PIN(19, 3, 27, 0),
+	MX31_PIN_TRSTB = _MXC_BUILD_NON_GPIO_PIN(19, 2, 26, 2),
+	MX31_PIN_DE_B = _MXC_BUILD_NON_GPIO_PIN(19, 1, 26, 1),
+	MX31_PIN_SJC_MOD = _MXC_BUILD_NON_GPIO_PIN(19, 0, 26, 0),
+	MX31_PIN_RTCK = _MXC_BUILD_NON_GPIO_PIN(20, 3, 28, 1),
+	MX31_PIN_TCK = _MXC_BUILD_NON_GPIO_PIN(20, 2, 28, 0),
+	MX31_PIN_TMS = _MXC_BUILD_NON_GPIO_PIN(20, 1, 27, 2),
+	MX31_PIN_TDI = _MXC_BUILD_NON_GPIO_PIN(20, 0, 27, 1),
+	MX31_PIN_KEY_COL4 = _MXC_BUILD_GPIO_PIN(1, 22, 21, 3, 29, 2),
+	MX31_PIN_KEY_COL5 = _MXC_BUILD_GPIO_PIN(1, 23, 21, 2, 29, 1),
+	MX31_PIN_KEY_COL6 = _MXC_BUILD_GPIO_PIN(1, 24, 21, 1, 29, 0),
+	MX31_PIN_KEY_COL7 = _MXC_BUILD_GPIO_PIN(1, 25, 21, 0, 28, 2),
+	MX31_PIN_KEY_COL0 = _MXC_BUILD_NON_GPIO_PIN(22, 3, 31, 0),
+	MX31_PIN_KEY_COL1 = _MXC_BUILD_NON_GPIO_PIN(22, 2, 30, 2),
+	MX31_PIN_KEY_COL2 = _MXC_BUILD_NON_GPIO_PIN(22, 1, 30, 1),
+	MX31_PIN_KEY_COL3 = _MXC_BUILD_NON_GPIO_PIN(22, 0, 30, 0),
+	MX31_PIN_KEY_ROW4 = _MXC_BUILD_GPIO_PIN(1, 18, 23, 3, 32, 1),
+	MX31_PIN_KEY_ROW5 = _MXC_BUILD_GPIO_PIN(1, 19, 23, 2, 32, 0),
+	MX31_PIN_KEY_ROW6 = _MXC_BUILD_GPIO_PIN(1, 20, 23, 1, 31, 2),
+	MX31_PIN_KEY_ROW7 = _MXC_BUILD_GPIO_PIN(1, 21, 23, 0, 31, 1),
+	MX31_PIN_KEY_ROW0 = _MXC_BUILD_NON_GPIO_PIN(24, 3, 33, 2),
+	MX31_PIN_KEY_ROW1 = _MXC_BUILD_NON_GPIO_PIN(24, 2, 33, 1),
+	MX31_PIN_KEY_ROW2 = _MXC_BUILD_NON_GPIO_PIN(24, 1, 33, 0),
+	MX31_PIN_KEY_ROW3 = _MXC_BUILD_NON_GPIO_PIN(24, 0, 32, 2),
+	MX31_PIN_TXD2 = _MXC_BUILD_GPIO_PIN(0, 28, 25, 3, 35, 0),
+	MX31_PIN_RTS2 = _MXC_BUILD_NON_GPIO_PIN(25, 2, 34, 2),
+	MX31_PIN_CTS2 = _MXC_BUILD_NON_GPIO_PIN(25, 1, 34, 1),
+	MX31_PIN_BATT_LINE = _MXC_BUILD_GPIO_PIN(1, 17, 25, 0, 34, 0),
+	MX31_PIN_RI_DTE1 = _MXC_BUILD_GPIO_PIN(1, 14, 26, 3, 36, 1),
+	MX31_PIN_DCD_DTE1 = _MXC_BUILD_GPIO_PIN(1, 15, 26, 2, 36, 0),
+	MX31_PIN_DTR_DCE2 = _MXC_BUILD_GPIO_PIN(1, 16, 26, 1, 35, 2),
+	MX31_PIN_RXD2 = _MXC_BUILD_GPIO_PIN(0, 27, 26, 0, 35, 1),
+	MX31_PIN_RI_DCE1 = _MXC_BUILD_GPIO_PIN(1, 10, 27, 3, 37, 2),
+	MX31_PIN_DCD_DCE1 = _MXC_BUILD_GPIO_PIN(1, 11, 27, 2, 37, 1),
+	MX31_PIN_DTR_DTE1 = _MXC_BUILD_GPIO_PIN(1, 12, 27, 1, 37, 0),
+	MX31_PIN_DSR_DTE1 = _MXC_BUILD_GPIO_PIN(1, 13, 27, 0, 36, 2),
+	MX31_PIN_RTS1 = _MXC_BUILD_GPIO_PIN(1, 6, 28, 3, 39, 0),
+	MX31_PIN_CTS1 = _MXC_BUILD_GPIO_PIN(1, 7, 28, 2, 38, 2),
+	MX31_PIN_DTR_DCE1 = _MXC_BUILD_GPIO_PIN(1, 8, 28, 1, 38, 1),
+	MX31_PIN_DSR_DCE1 = _MXC_BUILD_GPIO_PIN(1, 9, 28, 0, 38, 0),
+	MX31_PIN_CSPI2_SCLK = _MXC_BUILD_NON_GPIO_PIN(29, 3, 40, 1),
+	MX31_PIN_CSPI2_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(29, 2, 40, 0),
+	MX31_PIN_RXD1 = _MXC_BUILD_GPIO_PIN(1, 4, 29, 1, 39, 2),
+	MX31_PIN_TXD1 = _MXC_BUILD_GPIO_PIN(1, 5, 29, 0, 39, 1),
+	MX31_PIN_CSPI2_MISO = _MXC_BUILD_NON_GPIO_PIN(30, 3, 41, 2),
+	MX31_PIN_CSPI2_SS0 = _MXC_BUILD_NON_GPIO_PIN(30, 2, 41, 1),
+	MX31_PIN_CSPI2_SS1 = _MXC_BUILD_NON_GPIO_PIN(30, 1, 41, 0),
+	MX31_PIN_CSPI2_SS2 = _MXC_BUILD_NON_GPIO_PIN(30, 0, 40, 2),
+	MX31_PIN_CSPI1_SS2 = _MXC_BUILD_NON_GPIO_PIN(31, 3, 43, 0),
+	MX31_PIN_CSPI1_SCLK = _MXC_BUILD_NON_GPIO_PIN(31, 2, 42, 2),
+	MX31_PIN_CSPI1_SPI_RDY = _MXC_BUILD_NON_GPIO_PIN(31, 1, 42, 1),
+	MX31_PIN_CSPI2_MOSI = _MXC_BUILD_NON_GPIO_PIN(31, 0, 42, 0),
+	MX31_PIN_CSPI1_MOSI = _MXC_BUILD_NON_GPIO_PIN(32, 3, 44, 1),
+	MX31_PIN_CSPI1_MISO = _MXC_BUILD_NON_GPIO_PIN(32, 2, 44, 0),
+	MX31_PIN_CSPI1_SS0 = _MXC_BUILD_NON_GPIO_PIN(32, 1, 43, 2),
+	MX31_PIN_CSPI1_SS1 = _MXC_BUILD_NON_GPIO_PIN(32, 0, 43, 1),
+	MX31_PIN_STXD6 = _MXC_BUILD_GPIO_PIN(0, 23, 33, 3, 45, 2),
+	MX31_PIN_SRXD6 = _MXC_BUILD_GPIO_PIN(0, 24, 33, 2, 45, 1),
+	MX31_PIN_SCK6 = _MXC_BUILD_GPIO_PIN(0, 25, 33, 1, 45, 0),
+	MX31_PIN_SFS6 = _MXC_BUILD_GPIO_PIN(0, 26, 33, 0, 44, 2),
+	MX31_PIN_STXD5 = _MXC_BUILD_GPIO_PIN(0, 21, 34, 3, 47, 0),
+	MX31_PIN_SRXD5 = _MXC_BUILD_GPIO_PIN(0, 22, 34, 2, 46, 2),
+	MX31_PIN_SCK5 = _MXC_BUILD_NON_GPIO_PIN(34, 1, 46, 1),
+	MX31_PIN_SFS5 = _MXC_BUILD_NON_GPIO_PIN(34, 0, 46, 0),
+	MX31_PIN_STXD4 = _MXC_BUILD_GPIO_PIN(0, 19, 35, 3, 48, 1),
+	MX31_PIN_SRXD4 = _MXC_BUILD_GPIO_PIN(0, 20, 35, 2, 48, 0),
+	MX31_PIN_SCK4 = _MXC_BUILD_NON_GPIO_PIN(35, 1, 47, 2),
+	MX31_PIN_SFS4 = _MXC_BUILD_NON_GPIO_PIN(35, 0, 47, 1),
+	MX31_PIN_STXD3 = _MXC_BUILD_GPIO_PIN(0, 17, 36, 3, 49, 2),
+	MX31_PIN_SRXD3 = _MXC_BUILD_GPIO_PIN(0, 18, 36, 2, 49, 1),
+	MX31_PIN_SCK3 = _MXC_BUILD_NON_GPIO_PIN(36, 1, 49, 0),
+	MX31_PIN_SFS3 = _MXC_BUILD_NON_GPIO_PIN(36, 0, 48, 2),
+	MX31_PIN_CSI_HSYNC = _MXC_BUILD_GPIO_PIN(2, 18, 37, 3, 51, 0),
+	MX31_PIN_CSI_PIXCLK = _MXC_BUILD_GPIO_PIN(2, 19, 37, 2, 50, 2),
+	MX31_PIN_I2C_CLK = _MXC_BUILD_NON_GPIO_PIN(37, 1, 50, 1),
+	MX31_PIN_I2C_DAT = _MXC_BUILD_NON_GPIO_PIN(37, 0, 50, 0),
+	MX31_PIN_CSI_D14 = _MXC_BUILD_GPIO_PIN(2, 14, 38, 3, 52, 1),
+	MX31_PIN_CSI_D15 = _MXC_BUILD_GPIO_PIN(2, 15, 38, 2, 52, 0),
+	MX31_PIN_CSI_MCLK = _MXC_BUILD_GPIO_PIN(2, 16, 38, 1, 51, 2),
+	MX31_PIN_CSI_VSYNC = _MXC_BUILD_GPIO_PIN(2, 17, 38, 0, 51, 1),
+	MX31_PIN_CSI_D10 = _MXC_BUILD_GPIO_PIN(2, 10, 39, 3, 53, 2),
+	MX31_PIN_CSI_D11 = _MXC_BUILD_GPIO_PIN(2, 11, 39, 2, 53, 1),
+	MX31_PIN_CSI_D12 = _MXC_BUILD_GPIO_PIN(2, 12, 39, 1, 53, 0),
+	MX31_PIN_CSI_D13 = _MXC_BUILD_GPIO_PIN(2, 13, 39, 0, 52, 2),
+	MX31_PIN_CSI_D6 = _MXC_BUILD_GPIO_PIN(2, 6, 40, 3, 55, 0),
+	MX31_PIN_CSI_D7 = _MXC_BUILD_GPIO_PIN(2, 7, 40, 2, 54, 2),
+	MX31_PIN_CSI_D8 = _MXC_BUILD_GPIO_PIN(2, 8, 40, 1, 54, 1),
+	MX31_PIN_CSI_D9 = _MXC_BUILD_GPIO_PIN(2, 9, 40, 0, 54, 0),
+	MX31_PIN_M_REQUEST = _MXC_BUILD_NON_GPIO_PIN(41, 3, 56, 1),
+	MX31_PIN_M_GRANT = _MXC_BUILD_NON_GPIO_PIN(41, 2, 56, 0),
+	MX31_PIN_CSI_D4 = _MXC_BUILD_GPIO_PIN(2, 4, 41, 1, 55, 2),
+	MX31_PIN_CSI_D5 = _MXC_BUILD_GPIO_PIN(2, 5, 41, 0, 55, 1),
+	MX31_PIN_PC_RST = _MXC_BUILD_NON_GPIO_PIN(42, 3, 57, 2),
+	MX31_PIN_IOIS16 = _MXC_BUILD_NON_GPIO_PIN(42, 2, 57, 1),
+	MX31_PIN_PC_RW_B = _MXC_BUILD_NON_GPIO_PIN(42, 1, 57, 0),
+	MX31_PIN_PC_POE = _MXC_BUILD_NON_GPIO_PIN(42, 0, 56, 2),
+	MX31_PIN_PC_VS1 = _MXC_BUILD_NON_GPIO_PIN(43, 3, 59, 0),
+	MX31_PIN_PC_VS2 = _MXC_BUILD_NON_GPIO_PIN(43, 2, 58, 2),
+	MX31_PIN_PC_BVD1 = _MXC_BUILD_NON_GPIO_PIN(43, 1, 58, 1),
+	MX31_PIN_PC_BVD2 = _MXC_BUILD_NON_GPIO_PIN(43, 0, 58, 0),
+	MX31_PIN_PC_CD2_B = _MXC_BUILD_NON_GPIO_PIN(44, 3, 60, 1),
+	MX31_PIN_PC_WAIT_B = _MXC_BUILD_NON_GPIO_PIN(44, 2, 60, 0),
+	MX31_PIN_PC_READY = _MXC_BUILD_NON_GPIO_PIN(44, 1, 59, 2),
+	MX31_PIN_PC_PWRON = _MXC_BUILD_NON_GPIO_PIN(44, 0, 59, 1),
+	MX31_PIN_D2 = _MXC_BUILD_NON_GPIO_PIN(45, 3, 61, 2),
+	MX31_PIN_D1 = _MXC_BUILD_NON_GPIO_PIN(45, 2, 61, 1),
+	MX31_PIN_D0 = _MXC_BUILD_NON_GPIO_PIN(45, 1, 61, 0),
+	MX31_PIN_PC_CD1_B = _MXC_BUILD_NON_GPIO_PIN(45, 0, 60, 2),
+	MX31_PIN_D6 = _MXC_BUILD_NON_GPIO_PIN(46, 3, 63, 0),
+	MX31_PIN_D5 = _MXC_BUILD_NON_GPIO_PIN(46, 2, 62, 2),
+	MX31_PIN_D4 = _MXC_BUILD_NON_GPIO_PIN(46, 1, 62, 1),
+	MX31_PIN_D3 = _MXC_BUILD_NON_GPIO_PIN(46, 0, 62, 0),
+	MX31_PIN_D10 = _MXC_BUILD_NON_GPIO_PIN(47, 3, 64, 1),
+	MX31_PIN_D9 = _MXC_BUILD_NON_GPIO_PIN(47, 2, 64, 0),
+	MX31_PIN_D8 = _MXC_BUILD_NON_GPIO_PIN(47, 1, 63, 2),
+	MX31_PIN_D7 = _MXC_BUILD_NON_GPIO_PIN(47, 0, 63, 1),
+	MX31_PIN_D14 = _MXC_BUILD_NON_GPIO_PIN(48, 3, 65, 2),
+	MX31_PIN_D13 = _MXC_BUILD_NON_GPIO_PIN(48, 2, 65, 1),
+	MX31_PIN_D12 = _MXC_BUILD_NON_GPIO_PIN(48, 1, 65, 0),
+	MX31_PIN_D11 = _MXC_BUILD_NON_GPIO_PIN(48, 0, 64, 2),
+	MX31_PIN_NFWP_B = _MXC_BUILD_GPIO_PIN(0, 14, 49, 3, 67, 0),
+	MX31_PIN_NFCE_B = _MXC_BUILD_GPIO_PIN(0, 15, 49, 2, 66, 2),
+	MX31_PIN_NFRB = _MXC_BUILD_GPIO_PIN(0, 16, 49, 1, 66, 1),
+	MX31_PIN_D15 = _MXC_BUILD_NON_GPIO_PIN(49, 0, 66, 0),
+	MX31_PIN_NFWE_B = _MXC_BUILD_GPIO_PIN(0, 10, 50, 3, 68, 1),
+	MX31_PIN_NFRE_B = _MXC_BUILD_GPIO_PIN(0, 11, 50, 2, 68, 0),
+	MX31_PIN_NFALE = _MXC_BUILD_GPIO_PIN(0, 12, 50, 1, 67, 2),
+	MX31_PIN_NFCLE = _MXC_BUILD_GPIO_PIN(0, 13, 50, 0, 67, 1),
+	MX31_PIN_SDQS0 = _MXC_BUILD_NON_GPIO_PIN(51, 3, 69, 2),
+	MX31_PIN_SDQS1 = _MXC_BUILD_NON_GPIO_PIN(51, 2, 69, 1),
+	MX31_PIN_SDQS2 = _MXC_BUILD_NON_GPIO_PIN(51, 1, 69, 0),
+	MX31_PIN_SDQS3 = _MXC_BUILD_NON_GPIO_PIN(51, 0, 68, 2),
+	MX31_PIN_SDCKE0 = _MXC_BUILD_NON_GPIO_PIN(52, 3, 71, 0),
+	MX31_PIN_SDCKE1 = _MXC_BUILD_NON_GPIO_PIN(52, 2, 70, 2),
+	MX31_PIN_SDCLK = _MXC_BUILD_NON_GPIO_PIN(52, 1, 70, 1),
+	MX31_PIN_SDCLK_B = _MXC_BUILD_NON_GPIO_PIN(52, 0, 70, 0),
+	MX31_PIN_RW = _MXC_BUILD_NON_GPIO_PIN(53, 3, 72, 1),
+	MX31_PIN_RAS = _MXC_BUILD_NON_GPIO_PIN(53, 2, 72, 0),
+	MX31_PIN_CAS = _MXC_BUILD_NON_GPIO_PIN(53, 1, 71, 2),
+	MX31_PIN_SDWE = _MXC_BUILD_NON_GPIO_PIN(53, 0, 71, 1),
+	MX31_PIN_CS5 = _MXC_BUILD_NON_GPIO_PIN(54, 3, 73, 2),
+	MX31_PIN_ECB = _MXC_BUILD_NON_GPIO_PIN(54, 2, 73, 1),
+	MX31_PIN_LBA = _MXC_BUILD_NON_GPIO_PIN(54, 1, 73, 0),
+	MX31_PIN_BCLK = _MXC_BUILD_NON_GPIO_PIN(54, 0, 72, 2),
+	MX31_PIN_CS1 = _MXC_BUILD_NON_GPIO_PIN(55, 3, 75, 0),
+	MX31_PIN_CS2 = _MXC_BUILD_NON_GPIO_PIN(55, 2, 74, 2),
+	MX31_PIN_CS3 = _MXC_BUILD_NON_GPIO_PIN(55, 1, 74, 1),
+	MX31_PIN_CS4 = _MXC_BUILD_NON_GPIO_PIN(55, 0, 74, 0),
+	MX31_PIN_EB0 = _MXC_BUILD_NON_GPIO_PIN(56, 3, 76, 1),
+	MX31_PIN_EB1 = _MXC_BUILD_NON_GPIO_PIN(56, 2, 76, 0),
+	MX31_PIN_OE = _MXC_BUILD_NON_GPIO_PIN(56, 1, 75, 2),
+	MX31_PIN_CS0 = _MXC_BUILD_NON_GPIO_PIN(56, 0, 75, 1),
+	MX31_PIN_DQM0 = _MXC_BUILD_NON_GPIO_PIN(57, 3, 77, 2),
+	MX31_PIN_DQM1 = _MXC_BUILD_NON_GPIO_PIN(57, 2, 77, 1),
+	MX31_PIN_DQM2 = _MXC_BUILD_NON_GPIO_PIN(57, 1, 77, 0),
+	MX31_PIN_DQM3 = _MXC_BUILD_NON_GPIO_PIN(57, 0, 76, 2),
+	MX31_PIN_SD28 = _MXC_BUILD_NON_GPIO_PIN(58, 3, 79, 0),
+	MX31_PIN_SD29 = _MXC_BUILD_NON_GPIO_PIN(58, 2, 78, 2),
+	MX31_PIN_SD30 = _MXC_BUILD_NON_GPIO_PIN(58, 1, 78, 1),
+	MX31_PIN_SD31 = _MXC_BUILD_NON_GPIO_PIN(58, 0, 78, 0),
+	MX31_PIN_SD24 = _MXC_BUILD_NON_GPIO_PIN(59, 3, 80, 1),
+	MX31_PIN_SD25 = _MXC_BUILD_NON_GPIO_PIN(59, 2, 80, 0),
+	MX31_PIN_SD26 = _MXC_BUILD_NON_GPIO_PIN(59, 1, 79, 2),
+	MX31_PIN_SD27 = _MXC_BUILD_NON_GPIO_PIN(59, 0, 79, 1),
+	MX31_PIN_SD20 = _MXC_BUILD_NON_GPIO_PIN(60, 3, 81, 2),
+	MX31_PIN_SD21 = _MXC_BUILD_NON_GPIO_PIN(60, 2, 81, 1),
+	MX31_PIN_SD22 = _MXC_BUILD_NON_GPIO_PIN(60, 1, 81, 0),
+	MX31_PIN_SD23 = _MXC_BUILD_NON_GPIO_PIN(60, 0, 80, 2),
+	MX31_PIN_SD16 = _MXC_BUILD_NON_GPIO_PIN(61, 3, 83, 0),
+	MX31_PIN_SD17 = _MXC_BUILD_NON_GPIO_PIN(61, 2, 82, 2),
+	MX31_PIN_SD18 = _MXC_BUILD_NON_GPIO_PIN(61, 1, 82, 1),
+	MX31_PIN_SD19 = _MXC_BUILD_NON_GPIO_PIN(61, 0, 82, 0),
+	MX31_PIN_SD12 = _MXC_BUILD_NON_GPIO_PIN(62, 3, 84, 1),
+	MX31_PIN_SD13 = _MXC_BUILD_NON_GPIO_PIN(62, 2, 84, 0),
+	MX31_PIN_SD14 = _MXC_BUILD_NON_GPIO_PIN(62, 1, 83, 2),
+	MX31_PIN_SD15 = _MXC_BUILD_NON_GPIO_PIN(62, 0, 83, 1),
+	MX31_PIN_SD8 = _MXC_BUILD_NON_GPIO_PIN(63, 3, 85, 2),
+	MX31_PIN_SD9 = _MXC_BUILD_NON_GPIO_PIN(63, 2, 85, 1),
+	MX31_PIN_SD10 = _MXC_BUILD_NON_GPIO_PIN(63, 1, 85, 0),
+	MX31_PIN_SD11 = _MXC_BUILD_NON_GPIO_PIN(63, 0, 84, 2),
+	MX31_PIN_SD4 = _MXC_BUILD_NON_GPIO_PIN(64, 3, 87, 0),
+	MX31_PIN_SD5 = _MXC_BUILD_NON_GPIO_PIN(64, 2, 86, 2),
+	MX31_PIN_SD6 = _MXC_BUILD_NON_GPIO_PIN(64, 1, 86, 1),
+	MX31_PIN_SD7 = _MXC_BUILD_NON_GPIO_PIN(64, 0, 86, 0),
+	MX31_PIN_SD0 = _MXC_BUILD_NON_GPIO_PIN(65, 3, 88, 1),
+	MX31_PIN_SD1 = _MXC_BUILD_NON_GPIO_PIN(65, 2, 88, 0),
+	MX31_PIN_SD2 = _MXC_BUILD_NON_GPIO_PIN(65, 1, 87, 2),
+	MX31_PIN_SD3 = _MXC_BUILD_NON_GPIO_PIN(65, 0, 87, 1),
+	MX31_PIN_A24 = _MXC_BUILD_NON_GPIO_PIN(66, 3, 89, 2),
+	MX31_PIN_A25 = _MXC_BUILD_NON_GPIO_PIN(66, 2, 89, 1),
+	MX31_PIN_SDBA1 = _MXC_BUILD_NON_GPIO_PIN(66, 1, 89, 0),
+	MX31_PIN_SDBA0 = _MXC_BUILD_NON_GPIO_PIN(66, 0, 88, 2),
+	MX31_PIN_A20 = _MXC_BUILD_NON_GPIO_PIN(67, 3, 91, 0),
+	MX31_PIN_A21 = _MXC_BUILD_NON_GPIO_PIN(67, 2, 90, 2),
+	MX31_PIN_A22 = _MXC_BUILD_NON_GPIO_PIN(67, 1, 90, 1),
+	MX31_PIN_A23 = _MXC_BUILD_NON_GPIO_PIN(67, 0, 90, 0),
+	MX31_PIN_A16 = _MXC_BUILD_NON_GPIO_PIN(68, 3, 92, 1),
+	MX31_PIN_A17 = _MXC_BUILD_NON_GPIO_PIN(68, 2, 92, 0),
+	MX31_PIN_A18 = _MXC_BUILD_NON_GPIO_PIN(68, 1, 91, 2),
+	MX31_PIN_A19 = _MXC_BUILD_NON_GPIO_PIN(68, 0, 91, 1),
+	MX31_PIN_A12 = _MXC_BUILD_NON_GPIO_PIN(69, 3, 93, 2),
+	MX31_PIN_A13 = _MXC_BUILD_NON_GPIO_PIN(69, 2, 93, 1),
+	MX31_PIN_A14 = _MXC_BUILD_NON_GPIO_PIN(69, 1, 93, 0),
+	MX31_PIN_A15 = _MXC_BUILD_NON_GPIO_PIN(69, 0, 92, 2),
+	MX31_PIN_A9 = _MXC_BUILD_NON_GPIO_PIN(70, 3, 95, 0),
+	MX31_PIN_A10 = _MXC_BUILD_NON_GPIO_PIN(70, 2, 94, 2),
+	MX31_PIN_MA10 = _MXC_BUILD_NON_GPIO_PIN(70, 1, 94, 1),
+	MX31_PIN_A11 = _MXC_BUILD_NON_GPIO_PIN(70, 0, 94, 0),
+	MX31_PIN_A5 = _MXC_BUILD_NON_GPIO_PIN(71, 3, 96, 1),
+	MX31_PIN_A6 = _MXC_BUILD_NON_GPIO_PIN(71, 2, 96, 0),
+	MX31_PIN_A7 = _MXC_BUILD_NON_GPIO_PIN(71, 1, 95, 2),
+	MX31_PIN_A8 = _MXC_BUILD_NON_GPIO_PIN(71, 0, 95, 1),
+	MX31_PIN_A1 = _MXC_BUILD_NON_GPIO_PIN(72, 3, 97, 2),
+	MX31_PIN_A2 = _MXC_BUILD_NON_GPIO_PIN(72, 2, 97, 1),
+	MX31_PIN_A3 = _MXC_BUILD_NON_GPIO_PIN(72, 1, 97, 0),
+	MX31_PIN_A4 = _MXC_BUILD_NON_GPIO_PIN(72, 0, 96, 2),
+	MX31_PIN_DVFS1 = _MXC_BUILD_NON_GPIO_PIN(73, 3, 99, 0),
+	MX31_PIN_VPG0 = _MXC_BUILD_NON_GPIO_PIN(73, 2, 98, 2),
+	MX31_PIN_VPG1 = _MXC_BUILD_NON_GPIO_PIN(73, 1, 98, 1),
+	MX31_PIN_A0 = _MXC_BUILD_NON_GPIO_PIN(73, 0, 98, 0),
+	MX31_PIN_CKIL = _MXC_BUILD_NON_GPIO_PIN(74, 3, 100, 1),
+	MX31_PIN_POWER_FAIL = _MXC_BUILD_NON_GPIO_PIN(74, 2, 100, 0),
+	MX31_PIN_VSTBY = _MXC_BUILD_NON_GPIO_PIN(74, 1, 99, 2),
+	MX31_PIN_DVFS0 = _MXC_BUILD_NON_GPIO_PIN(74, 0, 99, 1),
+	MX31_PIN_BOOT_MODE1 = _MXC_BUILD_NON_GPIO_PIN(75, 3, 101, 2),
+	MX31_PIN_BOOT_MODE2 = _MXC_BUILD_NON_GPIO_PIN(75, 2, 101, 1),
+	MX31_PIN_BOOT_MODE3 = _MXC_BUILD_NON_GPIO_PIN(75, 1, 101, 0),
+	MX31_PIN_BOOT_MODE4 = _MXC_BUILD_NON_GPIO_PIN(75, 0, 100, 2),
+	MX31_PIN_RESET_IN_B = _MXC_BUILD_NON_GPIO_PIN(76, 3, 103, 0),
+	MX31_PIN_POR_B = _MXC_BUILD_NON_GPIO_PIN(76, 2, 102, 2),
+	MX31_PIN_CLKO = _MXC_BUILD_NON_GPIO_PIN(76, 1, 102, 1),
+	MX31_PIN_BOOT_MODE0 = _MXC_BUILD_NON_GPIO_PIN(76, 0, 102, 0),
+	MX31_PIN_STX0 = _MXC_BUILD_GPIO_PIN(1, 1, 77, 3, 104, 1),
+	MX31_PIN_SRX0 = _MXC_BUILD_GPIO_PIN(1, 2, 77, 2, 104, 0),
+	MX31_PIN_SIMPD0 = _MXC_BUILD_GPIO_PIN(1, 3, 77, 1, 103, 2),
+	MX31_PIN_CKIH = _MXC_BUILD_NON_GPIO_PIN(77, 0, 103, 1),
+	MX31_PIN_GPIO3_1 = _MXC_BUILD_GPIO_PIN(2, 1, 78, 3, 105, 2),
+	MX31_PIN_SCLK0 = _MXC_BUILD_GPIO_PIN(2, 2, 78, 2, 105, 1),
+	MX31_PIN_SRST0 = _MXC_BUILD_GPIO_PIN(2, 3, 78, 1, 105, 0),
+	MX31_PIN_SVEN0 = _MXC_BUILD_GPIO_PIN(1, 0, 78, 0, 104, 2),
+	MX31_PIN_GPIO1_4 = _MXC_BUILD_GPIO_PIN(0, 4, 79, 3, 107, 0),
+	MX31_PIN_GPIO1_5 = _MXC_BUILD_GPIO_PIN(0, 5, 79, 2, 106, 2),
+	MX31_PIN_GPIO1_6 = _MXC_BUILD_GPIO_PIN(0, 6, 79, 1, 106, 1),
+	MX31_PIN_GPIO3_0 = _MXC_BUILD_GPIO_PIN(2, 0, 79, 0, 106, 0),
+	MX31_PIN_GPIO1_0 = _MXC_BUILD_GPIO_PIN(0, 0, 80, 3, 108, 1),
+	MX31_PIN_GPIO1_1 = _MXC_BUILD_GPIO_PIN(0, 1, 80, 2, 108, 0),
+	MX31_PIN_GPIO1_2 = _MXC_BUILD_GPIO_PIN(0, 2, 80, 1, 107, 2),
+	MX31_PIN_GPIO1_3 = _MXC_BUILD_GPIO_PIN(0, 3, 80, 0, 107, 1),
+	MX31_PIN_CAPTURE = _MXC_BUILD_GPIO_PIN(0, 7, 81, 3, 109, 2),
+	MX31_PIN_COMPARE = _MXC_BUILD_GPIO_PIN(0, 8, 81, 2, 109, 1),
+	MX31_PIN_WATCHDOG_RST = _MXC_BUILD_NON_GPIO_PIN(81, 1, 109, 0),
+	MX31_PIN_PWMO = _MXC_BUILD_GPIO_PIN(0, 9, 81, 0, 108, 2),
+} iomux_pin_name_t;
+
+#endif
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mx31_usb.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mx31_usb.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,33 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* ehci_arc_hc_driver.flags value */
+#define FSL_PLATFORM_HC_FLAGS (HCD_USB2 | HCD_USB2)
+
+static inline int fsl_platform_verify(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static inline void fsl_platform_usb_setup(struct usb_hcd *hcd)
+{
+}
+
+static inline void fsl_platform_set_host_mode(struct usb_hcd *hcd)
+{
+	unsigned int temp;
+
+	/* set host mode */
+	temp = readl(hcd->regs + 0x1a8);
+	writel(temp | USBMODE_CM_HOST, hcd->regs + 0x1a8);
+}
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxcfb.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxcfb.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,70 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*
+ * @file    mxcfb.h
+ *
+ * @brief Global header file for the MXC Frame buffer
+ *
+ * @ingroup Framebuffer
+ */
+#ifndef __ASM_ARCH_MXCFB_H__
+#define __ASM_ARCH_MXCFB_H__
+
+#include <linux/fb.h>
+
+#define FB_SYNC_OE_ACT_HIGH	0x80000000
+#define FB_SYNC_CLK_INVERT	0x40000000
+#define FB_SYNC_DATA_INVERT	0x20000000
+#define FB_SYNC_CLK_IDLE_EN	0x10000000
+#define FB_SYNC_SHARP_MODE	0x08000000
+#define FB_SYNC_SWAP_RGB	0x04000000
+
+struct mxcfb_gbl_alpha {
+	int enable;
+	int alpha;
+};
+
+struct mxcfb_color_key {
+	int enable;
+	__u32 color_key;
+};
+
+#define MXCFB_WAIT_FOR_VSYNC	_IOW('F', 0x20, u_int32_t)
+#define MXCFB_SET_GBL_ALPHA     _IOW('F', 0x21, struct mxcfb_gbl_alpha)
+#define MXCFB_SET_CLR_KEY       _IOW('F', 0x22, struct mxcfb_color_key)
+#define MXCFB_SET_BRIGHTNESS    _IOW('F', 0x23, __u8)
+
+#ifdef __KERNEL__
+
+extern const struct fb_videomode mxcfb_modedb[];
+extern int mxcfb_modedb_sz;
+
+enum {
+	MXCFB_REFRESH_OFF,
+	MXCFB_REFRESH_AUTO,
+	MXCFB_REFRESH_PARTIAL,
+};
+
+struct mxcfb_rect {
+	u32 top;
+	u32 left;
+	u32 width;
+	u32 height;
+};
+
+int mxcfb_set_refresh_mode(struct fb_info *fbi, int mode,
+			   struct mxcfb_rect *update_region);
+
+#endif				/* __KERNEL__ */
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,177 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_H__
+#define __ASM_ARCH_MXC_H__
+
+#ifndef __ASM_ARCH_MXC_HARDWARE_H__
+#error "Do not include directly."
+#endif
+
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+/*!
+ * gpio port structure
+ */
+struct mxc_gpio_port {
+	u32 num;		/*!< gpio port number */
+	u32 base;		/*!< gpio port base VA */
+	u16 irq;		/*!< irq number to the core */
+	u16 virtual_irq_start;	/*!< virtual irq start number */
+};
+
+/*!
+ * This structure is used to define the SPI master controller's platform
+ * data. It includes the SPI  bus number and the maximum number of
+ * slaves/chips it supports.
+ */
+struct mxc_spi_master {
+	/*!
+	 * SPI Master's bus number.
+	 */
+	unsigned int bus_num;
+	/*!
+	 * SPI Master's maximum number of chip selects.
+	 */
+	unsigned int maxchipselect;
+	/*!
+	 * CSPI Hardware Version.
+	 */
+	unsigned int spi_version;
+	/*!
+	 * CSPI Clock.
+	 */
+	unsigned int clock;
+};
+#endif
+
+#define IOMUX_TO_GPIO(pin) 	((((unsigned int)pin >> MUX_IO_P) * GPIO_NUM_PIN) + ((pin >> MUX_IO_I) & ((1 << (MUX_IO_P - MUX_IO_I)) -1)))
+#define IOMUX_TO_IRQ(pin)	(MXC_GPIO_BASE + IOMUX_TO_GPIO(pin))
+#define GPIO_TO_PORT(n)		(n / GPIO_NUM_PIN)
+#define GPIO_TO_INDEX(n)	(n % GPIO_NUM_PIN)
+
+/*
+ *****************************************
+ * EPIT  Register definitions            *
+ *****************************************
+ */
+#ifndef EPIT1_AP_BASE_ADDR
+#define EPIT1_AP_BASE_ADDR 	EPIT1_BASE_ADDR
+#endif
+
+#define MXC_EPIT_EPITCR		(IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x00))
+#define MXC_EPIT_EPITSR		(IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x04))
+#define MXC_EPIT_EPITLR		(IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x08))
+#define MXC_EPIT_EPITCMPR	(IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x0C))
+#define MXC_EPIT_EPITCNR	(IO_ADDRESS(EPIT1_AP_BASE_ADDR + 0x10))
+
+/*
+ *****************************************
+ * GPT  Register definitions             *
+ *****************************************
+ */
+#if defined(CONFIG_ARCH_MX27)
+#define GPT_BASE_ADDR(x)	(GPT ##x## _BASE_ADDR)
+#define MXC_GPT_TCTL(x)		(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x00))
+#define MXC_GPT_TPRER(x)	(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x04))
+#define MXC_GPT_TCMP(x)		(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x08))
+#define MXC_GPT_TCR(x)		(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x0C))
+#define MXC_GPT_TCN(x)		(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x10))
+#define MXC_GPT_TSTAT(x)	(IO_ADDRESS(GPT_BASE_ADDR(x) + 0x14))
+#define MXC_GPT_GPTCNT		MXC_GPT_TCN(MXC_TIMER_GPT1)
+#define GPT_TSTAT_COMP		(1 << 0)
+#define GPT_TSTAT_CAPT		(1 << 1)
+#define GPT_TCTL_TEN		(1 << 0)
+#define GPT_TCTL_SRC_PER1	(1 << 1)
+#define GPT_TCTL_SRC_PER1_DIV4	(2 << 1)
+#define GPT_TCTL_SRC_TIN	(3 << 1)
+#define GPT_TCTL_SRC_32K	(4 << 1)
+#define GPT_TCTL_COMPEN		(1 << 4)
+#define GPT_TCTL_CAPTEN		(1 << 5)
+#define GPT_TCTL_FRR		(1 << 8)
+#define GPT_TCTL_OM		(1 << 9)
+#define GPT_TCTL_CC		(1 << 10)
+#define GPT_TCTL_SWR		(1 << 15)
+#else
+#define MXC_GPT_GPTCR		(IO_ADDRESS(GPT1_BASE_ADDR + 0x00))
+#define MXC_GPT_GPTPR		(IO_ADDRESS(GPT1_BASE_ADDR + 0x04))
+#define MXC_GPT_GPTSR		(IO_ADDRESS(GPT1_BASE_ADDR + 0x08))
+#define MXC_GPT_GPTIR		(IO_ADDRESS(GPT1_BASE_ADDR + 0x0C))
+#define MXC_GPT_GPTOCR1		(IO_ADDRESS(GPT1_BASE_ADDR + 0x10))
+#define MXC_GPT_GPTOCR2		(IO_ADDRESS(GPT1_BASE_ADDR + 0x14))
+#define MXC_GPT_GPTOCR3		(IO_ADDRESS(GPT1_BASE_ADDR + 0x18))
+#define MXC_GPT_GPTICR1		(IO_ADDRESS(GPT1_BASE_ADDR + 0x1C))
+#define MXC_GPT_GPTICR2		(IO_ADDRESS(GPT1_BASE_ADDR + 0x20))
+#define MXC_GPT_GPTCNT		(IO_ADDRESS(GPT1_BASE_ADDR + 0x24))
+#endif				/* #if defined(CONFIG_ARCH_MX27) */
+
+/*
+ *****************************************
+ * AVIC Registers                        *
+ *****************************************
+ */
+#define AVIC_BASE		IO_ADDRESS(AVIC_BASE_ADDR)
+#define AVIC_INTCNTL		(AVIC_BASE + 0x00)	/* int control reg */
+#define AVIC_NIMASK		(AVIC_BASE + 0x04)	/* int mask reg */
+#define AVIC_INTENNUM		(AVIC_BASE + 0x08)	/* int enable number reg */
+#define AVIC_INTDISNUM		(AVIC_BASE + 0x0C)	/* int disable number reg */
+#define AVIC_INTENABLEH		(AVIC_BASE + 0x10)	/* int enable reg high */
+#define AVIC_INTENABLEL		(AVIC_BASE + 0x14)	/* int enable reg low */
+#define AVIC_INTTYPEH		(AVIC_BASE + 0x18)	/* int type reg high */
+#define AVIC_INTTYPEL		(AVIC_BASE + 0x1C)	/* int type reg low */
+#define AVIC_NIPRIORITY7	(AVIC_BASE + 0x20)	/* norm int priority lvl7 */
+#define AVIC_NIPRIORITY6	(AVIC_BASE + 0x24)	/* norm int priority lvl6 */
+#define AVIC_NIPRIORITY5	(AVIC_BASE + 0x28)	/* norm int priority lvl5 */
+#define AVIC_NIPRIORITY4	(AVIC_BASE + 0x2C)	/* norm int priority lvl4 */
+#define AVIC_NIPRIORITY3	(AVIC_BASE + 0x30)	/* norm int priority lvl3 */
+#define AVIC_NIPRIORITY2	(AVIC_BASE + 0x34)	/* norm int priority lvl2 */
+#define AVIC_NIPRIORITY1	(AVIC_BASE + 0x38)	/* norm int priority lvl1 */
+#define AVIC_NIPRIORITY0	(AVIC_BASE + 0x3C)	/* norm int priority lvl0 */
+#define AVIC_NIVECSR		(AVIC_BASE + 0x40)	/* norm int vector/status */
+#define AVIC_FIVECSR		(AVIC_BASE + 0x44)	/* fast int vector/status */
+#define AVIC_INTSRCH		(AVIC_BASE + 0x48)	/* int source reg high */
+#define AVIC_INTSRCL		(AVIC_BASE + 0x4C)	/* int source reg low */
+#define AVIC_INTFRCH		(AVIC_BASE + 0x50)	/* int force reg high */
+#define AVIC_INTFRCL		(AVIC_BASE + 0x54)	/* int force reg low */
+#define AVIC_NIPNDH		(AVIC_BASE + 0x58)	/* norm int pending high */
+#define AVIC_NIPNDL		(AVIC_BASE + 0x5C)	/* norm int pending low */
+#define AVIC_FIPNDH		(AVIC_BASE + 0x60)	/* fast int pending high */
+#define AVIC_FIPNDL		(AVIC_BASE + 0x64)	/* fast int pending low */
+
+/*
+ *****************************************
+ * EDIO Registers                        *
+ *****************************************
+ */
+#ifdef EDIO_BASE_ADDR
+#define EDIO_EPPAR		(IO_ADDRESS(EDIO_BASE_ADDR) + 0x00)
+#define EDIO_EPDDR		(IO_ADDRESS(EDIO_BASE_ADDR) + 0x02)
+#define EDIO_EPDR		(IO_ADDRESS(EDIO_BASE_ADDR) + 0x04)
+#define EDIO_EPFR		(IO_ADDRESS(EDIO_BASE_ADDR) + 0x06)
+#endif
+
+#define SYSTEM_PREV_REG		IO_ADDRESS(IIM_BASE_ADDR + 0x20)
+#define SYSTEM_SREV_REG		IO_ADDRESS(IIM_BASE_ADDR + 0x24)
+#define IIM_PROD_REV_SH		3
+#define IIM_PROD_REV_LEN	5
+
+/* Since AVIC vector registers are NOT used, we reserve some for various
+ * purposes. */
+#define AVIC_VEC_0		0x100	/* For WFI workaround. */
+#define AVIC_VECTOR		IO_ADDRESS(AVIC_BASE_ADDR + AVIC_VEC_0)
+#define MXC_WFI_ENABLE		0x00000008
+
+/* DMA driver defines */
+#define MXC_IDE_DMA_WATERMARK	32	/* DMA watermark level in bytes */
+#define MXC_IDE_DMA_BD_NR	(512/3/4)	/* Number of BDs per channel */
+
+#endif				/*  __ASM_ARCH_MXC_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_i2c.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc_i2c.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_I2C_H__
+#define __ASM_ARCH_MXC_I2C_H__
+
+/*!
+ * @defgroup MXCI2C Inter-IC (I2C) Driver
+ */
+
+/*!
+ * @file mxc_i2c.h
+ *
+ * @brief This file contains the I2C chip level configuration details.
+ *
+ * It also contains the API function that other drivers can use to read/write
+ * to the I2C device registers.
+ *
+ * @ingroup MXCI2C
+ */
+
+/*!
+ * This defines the string used to identify MXC I2C Bus drivers
+ */
+#define MXC_ADAPTER_NAME        "MXC I2C Adapter"
+
+#define MXC_I2C_FLAG_READ	0x01	/* if set, is read; else is write */
+#define MXC_I2C_FLAG_POLLING	0x02	/* if set, is polling mode; else is interrupt mode */
+
+/*!
+ * Function used to read the register of the i2c slave device. This function
+ * is a kernel level API that can be called by other device drivers.
+ *
+ * @param   bus_id       the MXC I2C bus that the slave device is connected to
+ *                       (0 based)
+ * @param   addr         slave address of the device we wish to read data from
+ * @param   *reg         register in the device we wish to access
+ * @param   reg_len      number of bytes in the register address
+ * @param   *buf         data buffer
+ * @param   num          number of data bytes to transfer
+ *
+ * @return  Function returns the number of messages transferred to/from the device
+ *          or a negative number on failure
+ */
+int mxc_i2c_read(int bus_id, unsigned int addr, char *reg, int reg_len,
+		 char *buf, int num);
+
+/*!
+ * Function used to write to the register of the i2c slave device. This function
+ * is a kernel level API that can be called by other device drivers.
+ *
+ * @param   bus_id       the MXC I2C bus that the slave device is connected to
+ *                       (0 based)
+ * @param   addr         slave address of the device we wish to write data to
+ * @param   *reg         register in the device we wish to access
+ * @param   reg_len      number of bytes in the register address
+ * @param   *buf         data buffer
+ * @param   num          number of data bytes to transfer
+ *
+ * @return  Function returns the number of messages transferred to/from the device
+ *          or a negative number on failure
+ */
+int mxc_i2c_write(int bus_id, unsigned int addr, char *reg, int reg_len,
+		  char *buf, int num);
+
+/*!
+ * Function used to read the register of the i2c slave device. This function
+ * is a kernel level API that can be called by other device drivers.
+ *
+ * @param   bus_id       the MXC I2C bus that the slave device is connected to
+ *                       (0 based)
+ * @param   addr         slave address of the device we wish to read data from
+ * @param   *reg         register in the device we wish to access
+ * @param   reg_len      number of bytes in the register address
+ * @param   *buf         data buffer
+ * @param   num          number of data bytes to transfer
+ *
+ * @return  Function returns the number of messages transferred to/from the
+ *          device or a negative number on failure *
+ */
+int mxc_i2c_polling_read(int bus_id, unsigned int addr, char *reg, int reg_len,
+			 char *buf, int num);
+
+/*!
+ * Function used to write to the register of the i2c slave device. This function
+ * is a kernel level API that can be called by other device drivers.
+ *
+ * @param   bus_id       the MXC I2C bus that the slave device is connected to
+ *                       (0 based)
+ * @param   addr         slave address of the device we wish to write data to
+ * @param   *reg         register in the device we wish to access
+ * @param   reg_len      number of bytes in the register address
+ * @param   *buf         data buffer
+ * @param   num          number of data bytes to transfer
+ *
+ * @return  Function returns the number of messages transferred to/from the
+ *          device or a negative number on failure
+ */
+int mxc_i2c_polling_write(int bus_id, unsigned int addr, char *reg, int reg_len,
+			  char *buf, int num);
+
+#endif				/* __ASM_ARCH_MXC_I2C_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_pf.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc_pf.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup MXC_PF MPEG4/H.264 Post Filter Driver
+ */
+/*!
+ * @file mxc_pf.h
+ *
+ * @brief MXC IPU MPEG4/H.264 Post-filtering driver
+ *
+ * User-level API for IPU Hardware MPEG4/H.264 Post-filtering.
+ *
+ * @ingroup MXC_PF
+ */
+#ifndef __INCLUDED_MXC_PF_H__
+#define __INCLUDED_MXC_PF_H__
+
+#define PF_MAX_BUFFER_CNT       17
+
+/*!
+ * Structure for Post Filter initialization parameters.
+ */
+typedef struct {
+	uint16_t pf_mode;	/*!< Post filter operation mode */
+	uint16_t width;		/*!< Width of frame in pixels */
+	uint16_t height;	/*!< Height of frame in pixels */
+	uint16_t stride;	/*!< Stride of Y plane in pixels. Stride for U and V planes is half Y stride */
+	uint32_t qp_size;
+	unsigned long qp_paddr;
+} pf_init_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int count;		/*!< Number of buffers requested */
+	__u32 req_size;
+} pf_reqbufs_params;
+
+/*!
+ * Structure for Post Filter buffer request parameters.
+ */
+typedef struct {
+	int index;
+	int size;		/*!< Size of buffer allocated */
+	__u32 offset;		/*!< Buffer offset in driver memory. Set by QUERYBUF */
+	__u32 y_offset;		/*!< Optional starting relative offset of Y data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+	__u32 u_offset;		/*!< Optional starting relative offset of U data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+	__u32 v_offset;		/*!< Optional starting relative offset of V data
+				   from beginning of buffer. Set to 0 to use default
+				   calculated based on height and stride */
+} pf_buf;
+
+/*!
+ * Structure for Post Filter start parameters.
+ */
+typedef struct {
+	pf_buf in;		/*!< Input buffer address and offsets */
+	pf_buf out;		/*!< Output buffer address and offsets */
+	int wait;
+	uint32_t h264_pause_row;	/*!< Row to pause at for H.264 mode. 0 to disable pause */
+} pf_start_params;
+
+/*! @name User Client Ioctl Interface */
+/*! @{ */
+
+/*!
+ * IOCTL to Initialize the Post Filter.
+ */
+#define PF_IOCTL_INIT           _IOW('F',0x0, pf_init_params)
+
+/*!
+ * IOCTL to Uninitialize the Post Filter.
+ */
+#define PF_IOCTL_UNINIT         _IO('F',0x1)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_REQBUFS        _IOWR('F',0x2, pf_reqbufs_params)
+
+/*!
+ * IOCTL to set the buffer mode and allocate buffers if driver allocated.
+ */
+#define PF_IOCTL_QUERYBUF       _IOR('F',0x2, pf_buf)
+
+/*!
+ * IOCTL to start post filtering on a frame of data. This ioctl may block until
+ * processing is done or return immediately.
+ */
+#define PF_IOCTL_START          _IOWR('F',0x3, pf_start_params)
+
+/*!
+ * IOCTL to resume post-filtering after an intra frame pause in H.264 mode.
+ */
+#define PF_IOCTL_RESUME         _IOW('F',0x4, int)
+
+/*!
+ * IOCTL to wait for post-filtering to complete.
+ */
+#define PF_IOCTL_WAIT           _IO('F',0x5)
+/*! @} */
+
+#endif				/* __INCLUDED_MXC_PF_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_pm.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc_pm.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,229 @@
+
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup LPMD Low-Level Power Management Driver
+ */
+
+/*!
+ * @file mxc_pm.h
+ *
+ * @brief This file contains the  chip level configuration details and
+ * public API declarations for CRM_AP module
+ *
+ * @ingroup LPMD
+ */
+
+#ifndef __ASM_ARCH_MXC_PM_H__
+#define __ASM_ARCH_MXC_PM_H__
+
+#define WAIT_MODE               111
+#define DOZE_MODE               112
+#define STOP_MODE               113
+#define DSM_MODE                114
+
+#define GATE_STOP_WAIT          9
+#define GATE_STOP               10
+
+/*
+ * Used for MHz conversion
+ */
+#define MEGA_HERTZ              1000000
+
+/*
+ * If invalid frequency value other than the following
+ * CORE_133 - ARM desired to run @133MHz, LoV (1.2V)
+ * CORE_266 - ARM desired to run @266MHz, LoV (1.2V)
+ * CORE_399 - ARM desired to run @399MHz, LoV (1.2V)
+ * CORE_532 - ARM desired to run @133MHz, HiV (1.6V)
+ * are passed then this error is returned,
+ */
+#define ERR_FREQ_INVALID          1
+
+/*
+ * If PLL freq is less than desired ARM frequency during Integer
+ * DVFS, then return this error
+ */
+#define PLL_LESS_ARM_ERR        2
+
+/*
+ * Frequency change within the same-lo voltage is not approved.
+ * Inorder to do Integer DFS, move to the high voltage range and
+ * then set LFDF and move to the low voltage range
+ */
+#define INT_DFS_LOW_NOT_ALLOW   3
+
+/*
+ * If the desired AHB or IPG exceeds 133MHz or 66.5MHz respectively,
+ * then return this error
+ */
+#define AHB_IPG_EXCEED_LIMIT    4
+
+/*
+ * If the desired ARM frequency is too low to get by PLL scaling
+ * and the mxc_pm_pllscale API is called, return this error:
+ */
+#define PLL_DVFS_FREQ_TOO_LOW   5
+
+/*
+ * Invalid frequencies requested
+ */
+#define MXC_PM_INVALID_PARAM    6
+
+/*
+ * If AHB and/or IPG frequencies are greater than maximum allowed
+ */
+#define FREQ_OUT_OF_RANGE       2
+
+/*
+ * If AHB and/or IPG frequencies are other than 100 or 50Mhz
+ */
+#define BUS_FREQ_INVALID        2
+
+/*
+ * If MAX_PDF is greater than max value (8) then return this error
+ */
+#define AHB_MAX_DIV_ERR         3
+
+/*
+ * If IPG_PDF is greater than max value (2) then return this error
+ */
+#define IPG_MAX_DIV_ERR         4
+
+/*
+ * If ARM freq is out of range i.e., less than 133 or greater than
+ * 399 then return this error
+ */
+#define INVALID_ARM_FREQ        5
+
+/*
+ * This file includes all platform APIs. Some of the APIs are not
+ * appicable to some platforms. So, this error is used to indicate
+ * that a particular API is not available
+ */
+#define MXC_PM_API_NOT_SUPPORTED	6
+
+/*!
+ * Additional define for stop mode
+ */
+#define PM_SUSPEND_STOP         ((__force suspend_state_t) 2)
+
+/*!
+ * CKOH pins configuration
+ */
+#define CKOH_AP_SEL             1
+#define CKOH_AHB_SEL            2
+#define CKOH_IP_SEL             3
+
+/*!
+ * Defines for Stop and DSM mode acknowledgements
+ */
+#define MXC_PM_LOWPWR_ACK_SDMA  0x01
+#define MXC_PM_LOWPWR_ACK_IPU   0x02
+#define MXC_PM_LOWPWR_ACK_MAX   0x04
+#define MXC_PM_LOWPWR_ACK_MQSPI 0x08
+#define MXC_PM_LOWPWR_ACK_USB   0x10
+#define MXC_PM_LOWPWR_ACK_RTIC  0x20
+
+/*
+ * PMIC configuration
+ */
+#define MXC_PMIC_1_2_VOLT                      0xC
+#define MXC_PMIC_1_6_VOLT                      0x1C
+#define MXC_PMIC_1_0_VOLT                      0x4
+#define MXC_PMIC_DVS_SPEED                     0x3
+
+/*!
+ * Implementing Level 1 CRM Gate Control. Level 2 gate control
+ * is provided at module level using LPMD registers
+ *
+ * @param   group   The desired clock gate control register bits.
+ *                  Possible values are 0 through 6
+ * @param   opt     The desired option requesting clock to run during stop
+ *                  and wait modes or just during the stop mode. Possible
+ *                  values are GATE_STOP_WAIT and GATE_STOP.
+ *
+ */
+void mxc_pm_clockgate(int group, int opt);
+
+/*!
+ * Implementing steps required to transition to low-power modes
+ *
+ * @param   mode    The desired low-power mode. Possible values are,
+ *                  WAIT_MODE, STOP_MODE or DSM_MODE
+ *
+ */
+void mxc_pm_lowpower(int mode);
+
+/*!
+ * Enables acknowledgement from module when entering stop or DSM mode.
+ *
+ * @param   ack     The desired module acknowledgement to enable.
+ *
+ */
+void mxc_pm_lp_ack_enable(int ack);
+
+/*!
+ * Disables acknowledgement from module when entering stop or DSM mode.
+ *
+ * @param   ack     The desired module acknowledgement to disable.
+ *
+ */
+void mxc_pm_lp_ack_disable(int ack);
+
+/*!
+ * Implementing steps required to set Integer Scaling
+ *
+ * @param   armfreq    The desired ARM frequency. AHB and IP
+ *                     frequency are changed depending on ARM
+ *                     frequency and the divider values.
+ * @param   ahbfreq    The desired AHB frequency
+ * @param   ipfreq     The desired IP frequency
+ *
+ * @return             Returns 0 on success or
+ *                     Returns -PLL_LESS_ARM_ERR if pllfreq is less than
+ *                     desired core freq
+ */
+int mxc_pm_intscale(long armfreq, long ahbfreq, long ipfreq);
+
+/*!
+ * To calculate MFI, MFN, MFD values. Using this the output frequency
+ * whose value is calculated using,
+ * 2 * REF_FREQ * (MF / PDF), where
+ * REF_FREQ is 26 Mhz
+ * MF = MFI + (MFN + MFD)
+ * PDF is assumed to be 1
+ *
+ * @param   armfreq    The desired ARM frequency
+ * @param   ahbfreq    The desired AHB frequency
+ * @param   ipfreq     The desired IP frequency
+ *
+ * @return             Returns 0 on success or
+ *                     Returns -1 on error
+ */
+int mxc_pm_pllscale(long armfreq, long ahbfreq, long ipfreq);
+
+/*!
+ * To change AP core frequency and/or voltage suitably
+ *
+ * @param   armfreq    The desired ARM frequency
+ * @param   ahbfreq    The desired AHB frequency
+ * @param   ipfreq     The desired IP frequency
+ *
+ * @return             Returns -ERR_FREQ_INVALID on failure
+ *                     Returns 0 on success
+ */
+int mxc_pm_dvfs(unsigned long armfreq, long ahbfreq, long ipfreq);
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_scc_driver.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc_scc_driver.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,960 @@
+
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_SCC_DRIVER_H__
+#define __ASM_ARCH_MXC_SCC_DRIVER_H__
+
+/* Start marker for C++ compilers */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * NAMING CONVENTIONS
+ * ==================
+ * (A note to maintainers and other interested parties)
+ *
+ * Use scc_ or SCC_ prefix for 'high-level' interface routines and the types
+ * passed to those routines.  Try to avoid #defines in these interfaces.
+ *
+ * Use SMN_ or SCM_ prefix for the #defines used with scc_read_register() and
+ * scc_write_register, or values passed/retrieved from those routines.
+ */
+
+/*!
+ * @defgroup MXCSCC SCC Driver
+ *
+ * @ingroup MXCSECDRVRS
+ */
+
+/*!
+ * @file mxc_scc_driver.h
+ *
+ * @brief Header file to use the SCC driver.
+ *
+ * The SCC driver will only be available to other kernel modules.  That is,
+ * there will be no node file in /dev, no way for a user-mode program to access
+ * the driver, no way for a user program to access the device directly.
+ *
+ * With the exception of #scc_monitor_security_failure(), all routines are
+ * 'synchronous', i.e. they will not return to their caller until the requested
+ * action is complete, or fails to complete.  Some of these functions could
+ * take quite a while to perform, depending upon the request.
+ *
+ * Routines are provided to:
+ * @li encrypt or decrypt secrets - #scc_crypt()
+ * @li trigger a security-violation alarm - #scc_set_sw_alarm()
+ * @li get configuration and version information - #scc_get_configuration()
+ * @li zeroize memory - #scc_zeroize_memories()
+ * @li Work on wrapped and stored secret values: #scc_alloc_slot(),
+ *     #scc_dealloc_slot(), scc_load_slot(), #scc_decrypt_slot(),
+ *     #scc_encrypt_slot(), #scc_get_slot_info()
+
+ * @li monitor the Security Failure alarm - #scc_monitor_security_failure()
+ * @li stop monitoring Security Failure alarm -
+ *     #scc_stop_monitoring_security_failure()
+ * @li write registers of the SCC - #scc_write_register()
+ * @li read registers of the SCC - #scc_read_register()
+ *
+ * The driver does not allow "storage" of data in either the Red or Black
+ * memories.  Any decrypted secret is returned to the user, and if the user
+ * wants to use it at a later point, the encrypted form must again be passed
+ * to the driver, and it must be decrypted again.
+ *
+ * The SCC encrypts and decrypts using Triple DES with an internally stored
+ * key.  When the SCC is in Secure mode, it uses its secret, unique-per-chip
+ * key.  When it is in Non-Secure mode, it uses a default key.  This ensures
+ * that secrets stay secret if the SCC is not in Secure mode.
+ *
+ * Not all functions that could be provided in a 'high level' manner have been
+ * implemented.  Among the missing are interfaces to the ASC/AIC components and
+ * the timer functions.  These and other features must be accessed through
+ * #scc_read_register() and #scc_write_register(), using the @c \#define values
+ * provided.
+ *
+ * Here is a glossary of acronyms used in the SCC driver documentation:
+ * - CBC - Cipher Block Chaining.  A method of performing a block cipher.
+ *    Each block is encrypted using some part of the result of the previous
+ *    block's encryption.  It needs an 'initialization vector' to seed the
+ *    operation.
+ * - ECB - Electronic Code Book.  A method of performing a block cipher.
+ *    With a given key, a given block will always encrypt to the same value.
+ * - DES - Data Encryption Standard.  (8-byte) Block cipher algorithm which
+ *    uses 56-bit keys.  In SCC, this key is constant and unique to the device.
+ *    SCC uses the "triple DES" form of this algorithm.
+ * - AIC - Algorithm Integrity Checker.
+ * - ASC - Algorithm Sequence Checker.
+ * - SMN - Security Monitor.  The part of the SCC responsible for monitoring
+ *    for security problems and notifying the CPU and other PISA components.
+ * - SCM - Secure Memory.  The part of the SCC which handles the cryptography.
+ * - SCC - Security Controller.  Central security mechanism for PISA.
+ * - PISA - Platform-Independent Security Architecture.
+ *
+ * @ingroup MXCSCC
+ */
+
+/*! Major Version of the driver.  Used for
+    scc_configuration->driver_major_version */
+#define SCC_DRIVER_MAJOR_VERSION_1 1
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_0 0
+/*! Old Minor Version of the driver. */
+#define SCC_DRIVER_MINOR_VERSION_4 4
+/*! Minor Version of the driver.  Used for
+    scc_configuration->driver_minor_version */
+#define SCC_DRIVER_MINOR_VERSION_5 5
+
+/*!
+ * @typedef scc_return_t (enum scc_return)
+ */
+/*! Common status return values from SCC driver functions. */
+	typedef enum scc_return {
+		SCC_RET_OK = 0,	/*!< Function succeeded  */
+		SCC_RET_FAIL = -1,	/*!< Non-specific failure */
+		SCC_RET_VERIFICATION_FAILED = -2,	/*!< Decrypt validation failed */
+		SCC_RET_TOO_MANY_FUNCTIONS = -3,	/*!< At maximum registered functions */
+		SCC_RET_BUSY = -4,	/*!< SCC is busy and cannot handle request */
+		SCC_RET_INSUFFICIENT_SPACE = -5,	/*!< Encryption or decryption failed because
+							   @c count_out_bytes says that @c data_out is
+							   too small to hold the value. */
+	} scc_return_t;
+
+/*!
+ * @typedef scc_config_t (struct scc_config)
+ **/
+/*!
+ * @brief Configuration information about SCC and the driver.
+ *
+ * This struct/typedef contains information from the SCC and the driver to
+ * allow the user of the driver to determine the size of the SCC's memories and
+ * the version of the SCC and the driver.
+ */
+	typedef struct scc_config {
+		int driver_major_version;	/*!< Major version of the SCC driver code  */
+		int driver_minor_version;	/*!< Minor version of the SCC driver code  */
+		int scm_version;	/*!< Version from SCM Configuration register */
+		int smn_version;	/*!< Version from SMN Status register */
+		int block_size_bytes;	/*!< Number of bytes per block of RAM; also
+					   block size of the crypto algorithm. */
+		int black_ram_size_blocks;	/*!< Number of blocks of Black RAM */
+		int red_ram_size_blocks;	/*!< Number of blocks of Red RAM */
+	} scc_config_t;
+
+/*!
+ * @typedef scc_enc_dec_t (enum scc_enc_dec)
+ */
+/*!
+ * Determine whether SCC will run its cryptographic
+ * function as an encryption or decryption.  Used as an argument to
+ * #scc_crypt().
+ */
+	typedef enum scc_enc_dec {
+		SCC_ENCRYPT,	/*!< Encrypt (from Red to Black) */
+		SCC_DECRYPT	/*!< Decrypt (from Black to Red) */
+	} scc_enc_dec_t;
+
+/*!
+ * @typedef scc_crypto_mode_t (enum scc_crypto_mode)
+ */
+/*!
+ * Determine whether SCC will run its cryptographic function in ECB (electronic
+ * codebook) or CBC (cipher-block chaining) mode.  Used as an argument to
+ * #scc_crypt().
+ */
+	typedef enum scc_crypto_mode {
+		SCC_ECB_MODE,	/*!< Electronic Codebook Mode */
+		SCC_CBC_MODE	/*!< Cipher Block Chaining Mode  */
+	} scc_crypto_mode_t;
+
+/*!
+ * @typedef scc_verify_t (enum scc_verify)
+ */
+/*!
+ * Tell the driver whether it is responsible for verifying the integrity of a
+ * secret.  During an encryption, using other than #SCC_VERIFY_MODE_NONE will
+ * cause a check value to be generated and appended to the plaintext before
+ * encryption.  During decryption, the check value will be verified after
+ * decryption, and then stripped from the message.
+ */
+	typedef enum scc_verify {
+		/*! No verification value added or checked.  Input plaintext data must be
+		 *  be a multiple of the blocksize (#scc_get_configuration()).  */
+		SCC_VERIFY_MODE_NONE,
+		/*! Driver will generate/validate a 2-byte CCITT CRC.  Input plaintext will
+		   be padded to a multiple of the blocksize, adding 3-10 bytes to the
+		   resulting output ciphertext.  Upon decryption, this padding will be
+		   stripped, and the CRC will be verified. */
+		SCC_VERIFY_MODE_CCITT_CRC
+	} scc_verify_t;
+
+/*!
+ * Retrieve configuration information from the SCC.
+ *
+ * This function always succeeds.
+ *
+ * @return   A pointer to the configuration information.  This is a pointer to
+ *           static memory and must not be freed.  The values never change, and
+ *           the return value will never be null.
+ */
+	extern scc_config_t *scc_get_configuration(void);
+
+/*!
+ * Zeroize Red and Black memories of the SCC.  This will start the Zeroizing
+ * process.  The routine will return when the memories have zeroized or failed
+ * to do so.  The driver will poll waiting for this to occur, so this
+ * routine must not be called from interrupt level.  Some future version of
+ * driver may elect instead to sleep.
+ *
+ * @return 0 or error if initialization fails.
+ */
+	extern scc_return_t scc_zeroize_memories(void);
+
+/*!
+ * Perform a Triple DES encryption or decryption operation.
+ *
+ * This routine will cause the SCM to perform an encryption or decryption with
+ * its internal key.  If the SCC's #SMN_STATUS register shows that the SCC is
+ * in #SMN_STATE_SECURE, then the Secret Key will be used.  If it is
+ * #SMN_STATE_NON_SECURE (or health check), then the Default Key will be used.
+ *
+ * This function will perform in a variety of ways, depending upon the values
+ * of @c direction, @c crypto_mode, and @c check_mode.  If
+ * #SCC_VERIFY_MODE_CCITT_CRC mode is requested, upon successful completion,
+ * the @c count_in_bytes will be different from the returned value of @c
+ * count_out_bytes.  This is because the two-byte CRC and some amount of
+ * padding (at least one byte) will either be added or stripped.
+ *
+ * This function will not return until the SCC has performed the operation (or
+ * reported failure to do so).  It must therefore not be called from interrupt
+ * level.  In the current version, it will poll the SCC for completion.  In
+ * future versions, it may sleep.
+ *
+ * @param[in]    count_in_bytes The number of bytes to move through the crypto
+ *                            function.  Must be greater than zero.
+ *
+ * @param[in]    data_in      Pointer to the array of bytes to be used as input
+ *                            to the crypto function.
+ *
+ * @param[in]    init_vector  Pointer to the block-sized (8 byte) array of
+ *                            bytes which form the initialization vector for
+ *                            this operation.  A non-null value is required
+ *                            when @c crypto_mode has the value #SCC_CBC_MODE;
+ *                            the value is ignored in #SCC_ECB_MODE.
+ *
+ * @param[in]    direction    Direct the driver to perform encryption or
+ *                            decryption.
+ *
+ * @param[in]    crypto_mode  Run the crypto function in ECB or CBC mode.
+ *
+ * @param[in]    check_mode   During encryption, generate and append a check
+ *                            value to the plaintext and pad the resulting
+ *                            data.  During decryption, validate the plaintext
+ *                            with that check value and remove the padding.
+ *
+ * @param[in,out] count_out_bytes On input, the number of bytes available for
+ *                            copying to @c data_out.  On return, the number of
+ *                            bytes copied to @c data_out.
+ *
+ * @param[out] data_out       Pointer to the array of bytes that are where the
+ *                            output of the crypto function are to be placed.
+ *                            For encryption, this must be able to hold a
+ *                            longer ciphertext than the plaintext message at
+ *                            @c data_in.  The driver will append a 'pad' of
+ *                            1-8 bytes to the message, and if @c check_mode is
+ *                            used, additional bytes may be added, the number
+ *                            depending upon the type of check being requested.
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ *
+ * @internal
+ * This function will verify SCC state and the functions parameters.  It will
+ * acquire the crypto lock, and set up some SCC registers and variables common
+ * to encryption and decryption.  A rough check will be made to verify that
+ * enough space is available in @c count_out_bytes.  Upon success, either the
+ * #scc_encrypt or #scc_decrypt routine will be called to do the actual work.
+ * The crypto lock will then be released.
+ */
+	extern scc_return_t scc_crypt(unsigned long count_in_bytes,
+				      uint8_t * data_in, uint8_t * init_vector,
+				      scc_enc_dec_t direction,
+				      scc_crypto_mode_t crypto_mode,
+				      scc_verify_t check_mode,
+				      uint8_t * data_out,
+				      unsigned long *count_out_bytes);
+
+/*!
+ * Allocate a key slot for a stored key (or other stored value).
+ *
+ * This feature is to allow decrypted secret values to be kept in RED RAM.  This
+ * can all visibility of the data only by Sahara.
+ *
+ * @param   value_size_bytes  Size, in bytes, of RED key/value.  Currently only
+ *                            a size up to 32 bytes is supported.
+ *
+ * @param      owner_id       A value which will control access to the slot.  It
+ *                            must be passed into to any subsequent calls to
+ *                            use the assigned slot.
+ *
+ * @param[out] slot           The slot number for the key.
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_alloc_slot(uint32_t value_size_bytes,
+					   uint64_t owner_id, uint32_t * slot);
+
+/*!
+ * Deallocate the key slot of a stored key or secret value.
+ *
+ * @param      owner_id       The id which owns the @c slot.
+ *
+ * @param      slot           The slot number for the key.
+
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_dealloc_slot(uint64_t owner_id, uint32_t slot);
+
+/*!
+ * Load a value into a slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param key_data      Data to load into the slot
+ * @param key_length    Length, in bytes, of @c key_data to copy to SCC.
+ *
+ * @return SCC_RET_OK on success.  SCC_RET_FAIL will be returned if slot
+ * specified cannot be accessed for any reason, or SCC_RET_INSUFFICIENT_SPACE
+ * if @c key_length exceeds the size of the slot.
+ */
+	extern scc_return_t scc_load_slot(uint64_t owner_id, uint32_t slot,
+					  uint8_t * key_data,
+					  uint32_t key_length);
+
+/*!
+ * Allocate a key slot to fit the requested size.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param length        Length, in bytes, of @c black_data
+ * @param black_data    Location to store result of encrypting RED data in slot
+ *
+ * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
+ *         accessed for any reason.
+ */
+	extern scc_return_t scc_encrypt_slot(uint64_t owner_id, uint32_t slot,
+					     uint32_t length,
+					     uint8_t * black_data);
+
+/*!
+ * Decrypt some black data and leave result in the slot.
+ *
+ * @param owner_id      Value of owner of slot
+ * @param slot          Handle of slot
+ * @param length        Length, in bytes, of @c black_data
+ * @param black_data    Location of data to dencrypt and store in slot
+ *
+ * @return SCC_RET_OK on success, SCC_RET_FAIL if slot specified cannot be
+ *         accessed for any reason.
+ */
+	extern scc_return_t scc_decrypt_slot(uint64_t owner_id, uint32_t slot,
+					     uint32_t length,
+					     const uint8_t * black_data);
+
+/*!
+ * Get attributes of data in RED slot.
+ *
+ * @param      owner_id         The id which owns the @c slot.
+ *
+ * @param      slot             The slot number for the key.
+ *
+ * @param[out] address          Physical address of RED value.
+ *
+ * @param[out] value_size_bytes Length, in bytes, of RED value,
+ *                              or NULL if unneeded..
+ *
+ * @param[out] slot_size_bytes  Length, in bytes, of slot size,
+ *                              or NULL if unneeded..
+ *
+ * @return     0 on success, non-zero on failure.  See #scc_return_t.
+ */
+	extern scc_return_t scc_get_slot_info(uint64_t owner_id, uint32_t slot,
+					      uint32_t *address,
+					      uint32_t *value_size_bytes,
+					      uint32_t *slot_size_bytes);
+
+/*!
+ * Signal a software alarm to the SCC.  This will take the SCC and other PISA
+ * parts out of Secure mode and into Security Failure mode.  The SCC will stay
+ * in failed mode until a reboot.
+ *
+ * @internal
+ * If the SCC is not already in fail state, simply write the
+ * #SMN_COMMAND_SET_SOFTWARE_ALARM bit in #SMN_COMMAND.  Since there is no
+ * reason to wait for the interrupt to bounce back, simply act as though
+ * one did.
+ */
+	extern void scc_set_sw_alarm(void);
+
+/*!
+ * This routine will register a function to be called should a Security Failure
+ * be signalled by the SCC (Security Monitor).
+ *
+ * The callback function may be called from interrupt level, it may be called
+ * from some process' task.  It should therefore not take a long time to
+ * perform its operation, and it may not sleep.
+ *
+ * @param  callback_func  Function pointer to routine which will receive
+ *                        notification of the security failure.
+ * @return         0 if function was successfully registered, non-zero on
+ *                 failure.  See #scc_return_t.
+ *
+ * @internal
+ *  There is a fixed global static array which keeps track of the requests to
+ *  monitor the failure.
+ *
+ *  Add @c callback_func to the first empty slot in #scc_callbacks[].  If there
+ *  is no room, return #SCC_RET_TOO_MANY_FUNCTIONS.
+ */
+	extern scc_return_t scc_monitor_security_failure(void
+							 callback_func(void));
+
+/*!
+ * This routine will deregister a function previously registered with
+ * #scc_monitor_security_failure().
+ *
+ * @param callback_func Function pointer to routine previously registered with
+ *                      #scc_stop_monitoring_security_failure().
+ */
+	extern void scc_stop_monitoring_security_failure(void
+							 callback_func(void));
+
+/*!
+ * Read value from an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]   register_offset  The (byte) offset within the SCC block
+ *                               of the register to be queried.
+ * @param[out]  value            Pointer to where value from the register
+ *                               should be placed.
+ * @return      0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a readable
+ *  register, and c) the SCC is in a state which would allow a read of this
+ *  register.
+ */
+	extern scc_return_t scc_read_register(int register_offset,
+					      uint32_t * value);
+
+/*!
+ * Write a new value into an SCC register.
+ * The offset will be checked for validity (range) as well as whether it is
+ * accessible (e.g. not busy, not in failed state) at the time of the call.
+ *
+ * @param[in]  register_offset  The (byte) offset within the SCC block
+ *                              of the register to be modified.  
+ * @param[in]  value            The value to store into the register.
+ * @return     0 if OK, non-zero on error.  See #scc_return_t.
+ *
+ * @internal
+ *  Verify that the register_offset is a) valid, b) refers to a writeable
+ *  register, and c) the SCC is in a state which would allow a write to this
+ *  register.
+ */
+	extern scc_return_t scc_write_register(int register_offset,
+					       uint32_t value);
+
+/*
+ * NOTE TO MAINTAINERS
+ *
+ * All of the doxygen comments for the register offset values are in this the
+ * following comment section.  Any changes to register names or definitions
+ * must be reflected in this section and other versions of the memory map.
+ *
+ */
+
+/*!
+ * @name SCM Registers
+ *
+ * These values are offsets into the SCC for the Secure Memory
+ * (SCM) registers.  They are used in the @c register_offset parameter of
+ * #scc_read_register() and #scc_write_register().
+ */
+/*! @{ */
+/*! @def SCM_RED_START
+ * Starting block offset in red memory for cipher function. */
+
+/*! @def SCM_BLACK_START
+ * Starting block offset in black memory for cipher function. */
+
+/*! @def SCM_LENGTH
+ * Number of blocks to process during cipher function */
+
+/*! @def SCM_CONTROL
+ * SCM Control register.
+ * See "SCM Control Register definitions" for details.
+ */
+
+/*! @def SCM_STATUS
+ * SCM Status register.
+ * See "SCM Status Register Definitions" for details.
+ */
+
+/*! @def SCM_ERROR_STATUS
+ * SCM Error Status Register.
+ * See "SCM Error Status Register definitions" for
+ * details. */
+
+/*! @def SCM_INTERRUPT_CTRL
+ * SCM Interrupt Control Register.
+ * See "SCM Interrupt Control Register definitions"
+ * for details.
+ */
+
+/*! @def SCM_CONFIGURATION
+ * SCM Configuration Register.
+ * See "SCM Configuration Register Definitions" for
+ * details.
+ */
+
+/*! @def SCM_INIT_VECTOR_0
+ * Upper Half of the Initialization Vector */
+
+/*! @def SCM_INIT_VECTOR_1
+ * Lower Half of the Initialization Vector */
+
+/*! @def SCM_RED_MEMORY
+ * Starting location of first block of Red memory */
+
+/*! @def SCM_BLACK_MEMORY
+ * Starting location of first block of Black memory */
+
+	/*! @} *//* end of SCM group */
+
+/*!
+ * @name SMN Registers
+ *
+ * These values are offsets into the SCC for the Security Monitor
+ * (SMN) registers.  They are used in the @c register_offset parameter of the
+ * #scc_read_register() and #scc_write_register().
+ */
+/*! @{ */
+/*! @def SMN_STATUS
+ * Status register for SMN.
+ * See "SMN Status Register definitions" for further
+ * information.
+ */
+
+/** @def SMN_COMMAND
+ * Command register for SMN. See
+ * "Command Register Definitions" for further
+ * information.
+ */
+
+/*! @def SMN_SEQUENCE_START
+ * Sequence Start register for ASC. See #SMN_SEQUENCE_START_MASK
+ */
+
+/*! @def SMN_SEQUENCE_END
+ * Sequence End register for ASC. See #SMN_SEQUENCE_CHECK_MASK
+ */
+
+/*! @def SMN_SEQUENCE_CHECK
+ * Sequence Check register for ASC. See #SMN_SEQUENCE_END_MASK
+ */
+
+/*! @def SMN_BIT_COUNT
+ * Bit Bank Repository for AIC. See #SMN_BIT_COUNT_MASK
+ */
+
+/*! @def SMN_BITBANK_INC_SIZE
+ * Bit Bank Increment Size for AIC. See #SMN_BITBANK_INC_SIZE_MASK
+ */
+
+/*! @def SMN_BITBANK_DECREMENT
+ * Bit Bank Decrement for AIC. See #SMN_BITBANK_DECREMENT_MASK
+ */
+
+/*! @def SMN_COMPARE_SIZE
+ * Compare Size register for Plaintext/Ciphertext checker.  See
+ * #SMN_COMPARE_SIZE_MASK */
+
+/*! @def SMN_PLAINTEXT_CHECK
+ * Plaintext Check register for Plaintext/Ciphertext checker.
+ */
+
+/*! @def SMN_CIPHERTEXT_CHECK
+ * Ciphertext Check register for Plaintext/Ciphertext checker.
+ */
+
+/*! @def SMN_TIMER_IV
+ * Timer Initial Value register
+ */
+
+/*! @def SMN_TIMER_CONTROL
+ * Timer Control register.
+ * See "SMN Timer Control Register definitions".
+ */
+
+/*! @def SMN_DEBUG_DETECT_STAT
+ * Debug Detector Status Register
+ * See "SMN Debug Detector Status Register"for definitions.
+ */
+
+/*! @def SMN_TIMER
+ * Current value of the Timer Register
+ */
+
+	/*! @} *//* end of SMN group */
+
+/*
+ * SCC MEMORY MAP
+ *
+ */
+
+/* SCM registers */
+#define SCM_RED_START           0x00000000	/*          read/write       */
+#define SCM_BLACK_START         0x00000004	/*          read/write       */
+#define SCM_LENGTH              0x00000008	/*          read/write       */
+#define SCM_CONTROL             0x0000000C	/*          read/write       */
+#define SCM_STATUS              0x00000010	/*          read only        */
+#define SCM_ERROR_STATUS        0x00000014	/*          read/write       */
+#define SCM_INTERRUPT_CTRL      0x00000018	/*          read/write       */
+#define SCM_CONFIGURATION       0x0000001C	/*          read only        */
+#define SCM_INIT_VECTOR_0       0x00000020	/*          read/write       */
+#define SCM_INIT_VECTOR_1       0x00000024	/*          read/write       */
+#define SCM_RED_MEMORY          0x00000400	/*          read/write       */
+#define SCM_BLACK_MEMORY        0x00000800	/*          read/write       */
+
+/* SMN Registers */
+#define SMN_STATUS              0x00001000	/*          read/write       */
+#define SMN_COMMAND             0x00001004	/*          read/write       */
+#define SMN_SEQUENCE_START      0x00001008	/*          read/write       */
+#define SMN_SEQUENCE_END        0x0000100C	/*          read/write       */
+#define SMN_SEQUENCE_CHECK      0x00001010	/*          read/write       */
+#define SMN_BIT_COUNT           0x00001014	/*          read only        */
+#define SMN_BITBANK_INC_SIZE    0x00001018	/*          read/write       */
+#define SMN_BITBANK_DECREMENT   0x0000101C	/*          write only       */
+#define SMN_COMPARE_SIZE        0x00001020	/*          read/write       */
+#define SMN_PLAINTEXT_CHECK     0x00001024	/*          read/write       */
+#define SMN_CIPHERTEXT_CHECK    0x00001028	/*          read/write       */
+#define SMN_TIMER_IV            0x0000102C	/*          read/write       */
+#define SMN_TIMER_CONTROL       0x00001030	/*          read/write       */
+#define SMN_DEBUG_DETECT_STAT   0x00001034	/*          read/write       */
+#define SMN_TIMER               0x00001038	/*          read only        */
+
+/*! Total address space of the SCC, in bytes */
+#define SCC_ADDRESS_RANGE    0x103c
+
+/*!
+ * @name SMN Status Register definitions (SMN_STATUS)
+ */
+/*! @{ */
+/*! SMN version id. */
+#define SMN_STATUS_VERSION_ID_MASK        0xfc000000
+/*!  number of bits to shift #SMN_STATUS_VERSION_ID_MASK to get it to LSB */
+#define SMN_STATUS_VERSION_ID_SHIFT       26
+/*! Cacheable access to SMN attempted.  */
+#define SMN_STATUS_CACHEABLE_ACCESS       0x02000000
+/*! Illegal bus master access attempted. */
+#define SMN_STATUS_ILLEGAL_MASTER         0x01000000
+/*! Scan mode entered/exited since last reset. */
+#define SMN_STATUS_SCAN_EXIT              0x00800000
+/*! Unaligned access attempted. */
+#define SMN_STATUS_UNALIGNED_ACCESS       0x00400000
+/*! Bad byte offset access attempted. */
+#define SMN_STATUS_BYTE_ACCESS            0x00200000
+/*! Illegal address access attempted. */
+#define SMN_STATUS_ILLEGAL_ADDRESS        0x00100000
+/*! User access attempted. */
+#define SMN_STATUS_USER_ACCESS            0x00080000
+/*! SCM is using DEFAULT key.  */
+#define SMN_STATUS_DEFAULT_KEY            0x00040000
+/*! SCM detects weak or bad key.  */
+#define SMN_STATUS_BAD_KEY                0x00020000
+/*! Illegal access to SCM detected. */
+#define SMN_STATUS_ILLEGAL_ACCESS         0x00010000
+/*! Internal error detected in SCM. */
+#define SMN_STATUS_SCM_ERROR              0x00008000
+/*! SMN has an outstanding interrupt. */
+#define SMN_STATUS_SMN_STATUS_IRQ         0x00004000
+/*! Software Alarm was triggered. */
+#define SMN_STATUS_SOFTWARE_ALARM         0x00002000
+/*! Timer has expired. */
+#define SMN_STATUS_TIMER_ERROR            0x00001000
+/*! Plaintext/Ciphertext compare failed. */
+#define SMN_STATUS_PC_ERROR               0x00000800
+/*! Bit Bank detected overflow or underflow */
+#define SMN_STATUS_BITBANK_ERROR          0x00000400
+/*! Algorithm Sequence Check failed. */
+#define SMN_STATUS_ASC_ERROR              0x00000200
+/*! Security Policy Block detected error. */
+#define SMN_STATUS_SECURITY_POLICY_ERROR  0x00000100
+/*! At least one Debug signal is active. */
+#define SMN_STATUS_DEBUG_ACTIVE           0x00000080
+/*! SCM failed to zeroize its memory. */
+#define SMN_STATUS_ZEROIZE_FAIL           0x00000040
+/*! Processor booted from internal ROM. */
+#define SMN_STATUS_INTERNAL_BOOT          0x00000020
+/*! SMN's internal state. */
+#define SMN_STATUS_STATE_MASK             0x0000001F
+/*! Number of bits to shift #SMN_STATUS_STATE_MASK to get it to LSB. */
+#define SMN_STATUS_STATE_SHIFT            0
+/*! @} */
+
+/*!
+ * @name SMN Model Secure State Controller States (SMN_STATE_MASK)
+ */
+/*! @{ */
+/*! This is the first state of the SMN after power-on reset  */
+#define SMN_STATE_START         0x0
+/*! The SMN is zeroizing its RAM during reset */
+#define SMN_STATE_ZEROIZE_RAM   0x5
+/*! SMN has passed internal checks, and is waiting for Software check-in */
+#define SMN_STATE_HEALTH_CHECK  0x6
+/*! Fatal Security Violation.  SMN is locked, SCM is inoperative. */
+#define SMN_STATE_FAIL          0x9
+/*! SCC is in secure state.  SCM is using secret key. */
+#define SMN_STATE_SECURE        0xA
+/*! Due to non-fatal error, device is not secure.  SCM is using default key. */
+#define SMN_STATE_NON_SECURE    0xC
+/*! @} */
+
+/*!
+ * @name SCM Configuration Register definitions (SCM_CONFIGURATION)
+ **/
+/*! @{ */
+/*! Version number of the Secure Memory. */
+#define SCM_CFG_VERSION_ID_MASK         0xf8000000
+/*! Number of bits to shift #SCM_CFG_VERSION_ID_MASK to get it to LSB. */
+#define SCM_CFG_VERSION_ID_SHIFT        27
+/*! Version one value for SCC configuration */
+#define SCM_VERSION_1    1
+/*! Size, in blocks, of Red memory. */
+#define SCM_CFG_BLACK_SIZE_MASK         0x07fe0000
+/*! Number of bits to shift #SCM_CFG_BLACK_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_BLACK_SIZE_SHIFT        17
+/*! Size, in blocks, of Black memory. */
+#define SCM_CFG_RED_SIZE_MASK           0x0001ff80
+/*! Number of bits to shift #SCM_CFG_RED_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_RED_SIZE_SHIFT          7
+/*! Number of bytes per block. */
+#define SCM_CFG_BLOCK_SIZE_MASK         0x0000007f
+/*! Number of bits to shift #SCM_CFG_BLOCK_SIZE_MASK to get it to LSB. */
+#define SCM_CFG_BLOCK_SIZE_SHIFT        0
+/*! @} */
+
+/*!
+ * @name SMN Command Register Definitions (SMN_COMMAND)
+ */
+/*! @{ */
+#define SMN_COMMAND_ZEROS_MASK   0xfffffff0	/*!< These bits are unimplemented
+						   or reserved */
+#define SMN_COMMAND_CLEAR_INTERRUPT     0x8	/*!< Clear SMN Interrupt */
+#define SMN_COMMAND_CLEAR_BIT_BANK      0x4	/*!< Clear SMN Bit Bank */
+#define SMN_COMMAND_ENABLE_INTERRUPT    0x2	/*!< Enable SMN Interrupts */
+#define SMN_COMMAND_SET_SOFTWARE_ALARM  0x1	/*!< Set Software Alarm */
+/*! @} */
+
+/*!
+ * @name SMN Timer Control Register definitions (SMN_TIMER_CONTROL)
+ */
+/*! @{ */
+/*! These bits are reserved or zero */
+#define SMN_TIMER_CTRL_ZEROS_MASK 0xfffffffc
+/*! Load the timer from #SMN_TIMER_IV */
+#define SMN_TIMER_LOAD_TIMER             0x2
+/*! Setting to zero stops the Timer */
+#define SMN_TIMER_STOP_MASK              0x1
+/*! Setting this value starts the timer */
+#define SMN_TIMER_START_TIMER            0x1
+/*! @} */
+
+/*!
+ * @name SCM Interrupt Control Register definitions (SCM_INTERRUPT_CTRL)
+ *
+ * These are the bit definitions for the #SCM_INTERRUPT_CTRL register.
+ */
+/*! @{ */
+/*! Clear SCM memory */
+#define SCM_INTERRUPT_CTRL_ZEROIZE_MEMORY      0x4
+/*! Clear outstanding SCM interrupt */
+#define SCM_INTERRUPT_CTRL_CLEAR_INTERRUPT     0x2
+/*! Inhibit SCM interrupts */
+#define SCM_INTERRUPT_CTRL_MASK_INTERRUPTS     0x1
+/*! @} */
+
+/*!
+ * @name SCM Control Register definitions (SCM_CONTROL).
+ * These values are used with the #SCM_CONTROL register.
+ */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_CONTROL_ZEROS_MASK    0xfffffff8
+/*! Setting this will start encrypt/decrypt */
+#define SCM_CONTROL_START_CIPHER        0x04
+/*! CBC/ECB flag.
+ * See "Chaining Mode bit definitions."
+ */
+#define SCM_CONTROL_CHAINING_MODE_MASK  0x02
+/*! Encrypt/decrypt choice.
+ * See "Cipher Mode bit definitions." */
+#define SCM_CONTROL_CIPHER_MODE_MASK    0x01
+/*! @} */
+
+/*!
+ * @name SCM_CHAINING_MODE_MASK - Bit definitions
+ */
+/*! @{ */
+#define SCM_CBC_MODE            0x2	/*!< Cipher block chaining */
+#define SCM_ECB_MODE            0x0	/*!< Electronic codebook. */
+/*! @} */
+
+/* Bit definitions in the SCM_CIPHER_MODE_MASK */
+/*!
+ * @name SCM_CIPHER_MODE_MASK - Bit definitions
+ */
+/*! @{ */
+#define SCM_DECRYPT_MODE        0x1	/*!< decrypt from black to red memory */
+#define SCM_ENCRYPT_MODE        0x0	/*!< encrypt from red to black memory */
+/*! @} */
+
+/*!
+ * @name SCM Status Register (SCM_STATUS).
+ * Bit and field definitions of the SCM_STATUS register.
+ */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_STATUS_ZEROS_MASK        0xffffe000
+/*! Ciphering failed due to length error. */
+#define SCM_STATUS_LENGTH_ERROR          0x1000
+/*! SMN has stopped blocking access to the SCM */
+#define SCM_STATUS_BLOCK_ACCESS_REMOVED  0x0800
+/*! Ciphering done. */
+#define SCM_STATUS_CIPHERING_DONE        0x0400
+/*! Zeroizing done. */
+#define SCM_STATUS_ZEROIZING_DONE        0x0200
+/*! SCM wants attention. Interrupt status is available. */
+#define SCM_STATUS_INTERRUPT_STATUS      0x0100
+/*! Secret Key is in use. */
+#define SCM_STATUS_SECRET_KEY            0x0080
+/*! Secret Key is in use.  Deprecated.  Use #SCM_STATUS_SECRET_KEY. */
+#define SCM_STATUS_DEFAULT_KEY           0x0080
+/*! Internal error to SCM. */
+#define SCM_STATUS_INTERNAL_ERROR        0x0040
+/*! Secret key is not valid. */
+#define SCM_STATUS_BAD_SECRET_KEY        0x0020
+/*! Failed to zeroize memory. */
+#define SCM_STATUS_ZEROIZE_FAILED        0x0010
+/*! SMN is blocking access to Secure Memory. */
+#define SCM_STATUS_SMN_BLOCKING_ACCESS   0x0008
+/*! SCM is current encrypting or decrypting data. */
+#define SCM_STATUS_CIPHERING             0x0004
+/*! SCM is currently zeroizing data. */
+#define SCM_STATUS_ZEROIZING             0x0002
+/*! SCM is busy and access to memory is blocked. */
+#define SCM_STATUS_BUSY                  0x0001
+/*! @} */
+
+/*!
+ * @name SCM Error Status Register (SCM_ERROR_STATUS)
+ *
+ * These definitions are associated with the SCM Error Status Register
+ * (SCM_ERROR_STATUS).
+ */
+/*! @{ */
+/*! These bits are zero or reserved */
+#define SCM_ERR_ZEROS_MASK      0xffffc000
+/*! Cacheable access to SCM was attempted */
+#define SCM_ERR_CACHEABLE_ACCESS    0x2000
+/*! Access attempted by illegal bus master */
+#define SCM_ERR_ILLEGAL_MASTER      0x1000
+/*! Unaligned access attempted */
+#define SCM_ERR_UNALIGNED_ACCESS    0x0800
+/*! Byte or half-word access attempted */
+#define SCM_ERR_BYTE_ACCESS         0x0400
+/*! Illegal address attempted */
+#define SCM_ERR_ILLEGAL_ADDRESS     0x0200
+/*! User access attempted */
+#define SCM_ERR_USER_ACCESS         0x0100
+/*! Access attempted while SCM was using default key */
+#define SCM_ERR_SECRET_KEY_IN_USE   0x0080
+/*! Access attempted while SCM had internal error */
+#define SCM_ERR_INTERNAL_ERROR      0x0040
+/*! Access attempted while SCM was detecting Bad Key */
+#define SCM_ERR_BAD_SECRET_KEY      0x0020
+/*! The SCM failed to Zeroize memory */
+#define SCM_ERR_ZEROIZE_FAILED      0x0010
+/*! Access attempted while SMN was Blocking Access */
+#define SCM_ERR_SMN_BLOCKING_ACCESS 0x0008
+/*! Access attempted while SCM was CIPHERING */
+#define SCM_ERR_CIPHERING           0x0004
+/*! Access attempted while SCM was ZEROIZING */
+#define SCM_ERR_ZEROIZING           0x0002
+/*! Access attempted while SCM was BUSY */
+#define SCM_ERR_BUSY                0x0001
+/*! @} */
+
+/*!
+ * @name SMN Debug Detector Status Register (SCM_DEBUG_DETECT_STAT)
+ */
+/*! @{ */
+#define SMN_DBG_ZEROS_MASK  0xfffff000	/*!< These bits are zero or reserved */
+#define SMN_DBG_D12             0x0800	/*!< Error detected on Debug Port D12 */
+#define SMN_DBG_D11             0x0400	/*!< Error detected on Debug Port D11 */
+#define SMN_DBG_D10             0x0200	/*!< Error detected on Debug Port D10 */
+#define SMN_DBG_D9              0x0100	/*!< Error detected on Debug Port D9 */
+#define SMN_DBG_D8              0x0080	/*!< Error detected on Debug Port D8 */
+#define SMN_DBG_D7              0x0040	/*!< Error detected on Debug Port D7 */
+#define SMN_DBG_D6              0x0020	/*!< Error detected on Debug Port D6 */
+#define SMN_DBG_D5              0x0010	/*!< Error detected on Debug Port D5 */
+#define SMN_DBG_D4              0x0008	/*!< Error detected on Debug Port D4 */
+#define SMN_DBG_D3              0x0004	/*!< Error detected on Debug Port D3 */
+#define SMN_DBG_D2              0x0002	/*!< Error detected on Debug Port D2 */
+#define SMN_DBG_D1              0x0001	/*!< Error detected on Debug Port D1 */
+/*! @} */
+
+/*! Mask for the usable bits of the Sequence Start Register
+    (#SMN_SEQUENCE_START) */
+#define SMN_SEQUENCE_START_MASK    0x0000ffff
+
+/*! Mask for the usable bits of the Sequence End Register
+    (#SMN_SEQUENCE_END) */
+#define SMN_SEQUENCE_END_MASK      0x0000ffff
+
+/*! Mask for the usable bits of the Sequence Check Register
+    (#SMN_SEQUENCE_CHECK) */
+#define SMN_SEQUENCE_CHECK_MASK    0x0000ffff
+
+/*! Mask for the usable bits of the Bit Counter Register
+    (#SMN_BIT_COUNT) */
+#define SMN_BIT_COUNT_MASK         0x000007ff
+
+/*! Mask for the usable bits of the Bit Bank Increment Size Register
+    (#SMN_BITBANK_INC_SIZE) */
+#define SMN_BITBANK_INC_SIZE_MASK  0x000007ff
+
+/*! Mask for the usable bits of the Bit Bank Decrement Register
+    (#SMN_BITBANK_DECREMENT) */
+#define SMN_BITBANK_DECREMENT_MASK 0x000007ff
+
+/*! Mask for the usable bits of the Compare Size Register
+    (#SMN_COMPARE_SIZE) */
+#define SMN_COMPARE_SIZE_MASK      0x0000003f
+
+/* Close out marker for C++ compilers */
+#ifdef __cplusplus
+}
+#endif
+#endif				/* __ASM_ARCH_MXC_SCC_DRIVER_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_scc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc_scc.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_scc.h
+ *
+ * @brief This is intended to be the file which contains all of code or changes
+ * needed to port the driver.
+ *
+ * @ingroup MXCSCC
+ */
+
+#ifndef __ASM_ARCH_MXC_SCC_H__
+#define __ASM_ARCH_MXC_SCC_H__
+
+#include <asm/hardware.h>
+
+/*!
+ * Expected to come from platform header files.
+ * This symbol must be the address of the SCC
+ */
+#define SCC_BASE        SCC_BASE_ADDR
+
+/*!
+ *  This must be the interrupt line number of the SCM interrupt.
+ */
+#define INT_SCM         INT_SCC_SCM
+
+/*!
+ *  if #USE_SMN_INTERRUPT is defined, this must be the interrupt line number of
+ *  the SMN interrupt.
+ */
+#define INT_SMN         INT_SCC_SMN
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_security_api.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc_security_api.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,680 @@
+
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup MXCSECDRVRS Security Drivers
+ */
+
+/*!
+ * @defgroup MXC_Security Security Drivers for HACC and RTIC
+ * @ingroup MXCSECDRVRS
+ */
+/*!
+ * @defgroup RNG RNG driver module for RNGA and RNGC
+ * @ingroup MXCSECDRVRS
+ */
+
+/*!
+ * @file mxc_security_api.h
+ *
+ * @brief MXC Security user header file.
+ *
+ * This header file provides interface for accessing the Security module
+ * mentioned below. It contains declarations of datatypes and functions. The
+ * modules that it contains are:
+ *
+ * \b HAC is used to Hash the data stored in the memory. It can even Hash the
+ * data in non-contiguous memory locations.
+ *
+ * \b RTIC is used to Hash the data stored in the memory during system boot
+ * and during run-time execution.
+ *
+ * @ingroup MXC_Security
+ */
+
+#ifndef __ASM_ARCH_MXC_SECURITY_API_H__
+#define __ASM_ARCH_MXC_SECURITY_API_H__
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+typedef unsigned char unchar;
+#endif
+#include <linux/platform_device.h>
+
+/*!
+ * @name HAC module data types.
+ */
+
+/*! @{ */
+
+/*!
+ * These values are returned to indicate the status after the Hashing process
+ * in the HAC module.
+ */
+typedef enum {
+	/*!
+	 * Hashing of data is completed.
+	 */
+	HAC_DONE,
+
+	/*!
+	 * Busy hashing the data.
+	 */
+	HAC_BUSY,
+
+	/*!
+	 * Hashing was aborted due to bus error during HAC access over
+	 * the AHB (Advanced High-Performance Bus).
+	 */
+	HAC_ERR,
+
+	/*!
+	 * Hashing status unknown. This may be when the hashing process has not
+	 * been initiated altleast once or 'ERROR' bit or 'DONE' bits were
+	 * reset after the hashing process was completed.
+	 */
+	HAC_UNKNOWN
+} hac_hash_status;
+
+/*!
+ * These parameters are used for controlling the Hashing action to be
+ * performed.
+ */
+typedef enum {
+	/*!
+	 * Start the Hashing process.
+	 */
+	HAC_START,
+
+	/*!
+	 * Start the Hashing of data with last block.
+	 */
+	HAC_START_LAST,
+
+	/*!
+	 * Continue the Hashing process.
+	 */
+	HAC_CONTINUE,
+
+	/*!
+	 * Continue the Hashing of data with last block.
+	 */
+	HAC_LAST
+} hac_hash;
+
+/*!
+ * These values are returned for HAC routines.
+ */
+typedef enum {
+	/*!
+	 * Successfully finished the routine.
+	 */
+	HAC_SUCCESS = 0,
+
+	/*!
+	 * Encountered some errors in the routine.
+	 */
+	HAC_FAILURE = -1,
+
+	/*!
+	 * HAC module is busy in Hashing process.
+	 */
+	HAC_HASH_BUSY = -2
+} hac_ret;
+
+/*!
+ * These parameters are used to configure HAC Burst mode.
+ */
+typedef enum {
+	/*!
+	 * Configures Incremental Burst Mode.
+	 */
+	HAC_INR_BURST,
+
+	/*!
+	 * Configures 16WORD Burst Mode.
+	 */
+	HAC_16WORD_BURST
+} hac_burst_mode_config;
+
+/*!
+ * These parameters are used to configure HAC Burst Read.
+ */
+typedef enum {
+	/*!
+	 * Configures 16 Word Burst Read.
+	 */
+	HAC_16WORD_BURST_READ,
+
+	/*!
+	 * Configures 8 Word Burst Read.
+	 */
+	HAC_8WORD_BURST_READ,
+
+	/*!
+	 * Configures 4 Word Burst Read.
+	 */
+	HAC_4WORD_BURST_READ,
+
+	/*!
+	 * Configures No Word Burst Read.
+	 */
+	HAC_NO_WORD_BURST_READ
+} hac_burst_read_config;
+
+/*!
+ * Gets Hashing result value from HSH Registers.
+ */
+typedef struct {
+	/*!
+	 * Stores the hash result.
+	 */
+	ulong hash_result[5];
+} hac_hash_rlt;
+
+/*! @} */
+
+/*!
+ * @name RTIC module data types.
+ */
+
+/*! @{ */
+
+/*!
+ * These parameters are used for selecting RTIC mode of operation.
+ */
+typedef enum {
+	/*!
+	 * RTIC in ONE_TIME Hash Mode.
+	 */
+	RTIC_ONE_TIME,
+
+	/*!
+	 * RTIC in RUN_TIME Hash mode.
+	 */
+	RTIC_RUN_TIME
+} rtic_mode;
+
+/*!
+ * These parameter are used to enable or disable the interrupt.
+ */
+typedef enum {
+	/*!
+	 * RTIC interrupt enable.
+	 */
+	RTIC_INTERRUPT_ENABLE,
+
+	/*!
+	 * RTIC interrupt disable.
+	 */
+	RTIC_INTERRUPT_DISABLE
+} rtic_interrupt;
+
+/*!
+ * These parameter are used to enable or disable the RTIC SW Reset.
+ */
+typedef enum {
+	/*!
+	 * RTIC SW RESET enable.
+	 */
+	RTIC_RST_ENABLE,
+
+	/*!
+	 * RTIC SW RESET disable.
+	 */
+	RTIC_RST_DISABLE
+} rtic_sw_rst;
+
+/*!
+ * These parameter are used to Clear IRQ.
+ */
+typedef enum {
+	/*!
+	 * RTIC CLR IRQ enable.
+	 */
+	RTIC_CLR_IRQ_ENABLE,
+
+	/*!
+	 * RTIC CLR IRQ disable.
+	 */
+	RTIC_CLR_IRQ_DISABLE
+} rtic_clear_irq;
+
+/*!
+ * These parameters are used to select RTIC memory block for Hashing.
+ */
+typedef enum {
+	/*!
+	 * Select Memory Block A1.
+	 */
+	RTIC_A1,
+
+	/*!
+	 * Select Memory Block A2.
+	 */
+	RTIC_A2,
+
+	/*!
+	 * Select Memory Block B1.
+	 */
+	RTIC_B1,
+
+	/*!
+	 * Select Memory Block B2.
+	 */
+	RTIC_B2,
+
+	/*!
+	 * Select Memory Block C1.
+	 */
+	RTIC_C1,
+
+	/*!
+	 * Select Memory Block C2.
+	 */
+	RTIC_C2,
+
+	/*!
+	 * Select Memory Block D1.
+	 */
+	RTIC_D1,
+
+	/*!
+	 * Select Memory Block D2.
+	 */
+	RTIC_D2
+} rtic_memblk;
+
+/*!
+ * These values are returned when queried for the status of the RTIC module.
+ */
+typedef enum {
+	/*!
+	 * Busy hashing the data.
+	 */
+	RTIC_STAT_HASH_BUSY = 0x0,
+
+	/*!
+	 * Hashing of data is completed.
+	 */
+	RTIC_STAT_HASH_DONE = 0x02,
+
+	/*!
+	 * Hashing was aborted due to corruption in memory block
+	 * during RUN_TIME Hashing or address/length error has
+	 * occurred.
+	 */
+	RTIC_STAT_HASH_ERR = 0x04,
+
+	/*!
+	 * Hashing status unknown. This may happen when: 1) Hashing process has
+	 * not been initiated atleast once. 2) Error bit or Done bit was reset
+	 * after the hashing process was completed.
+	 */
+	RTIC_UNKNOWN
+} rtic_status;
+
+/*!
+ * These values are returned for RTIC routines.
+ */
+typedef enum {
+	/*!
+	 * Successfully finished the routine.
+	 */
+	RTIC_SUCCESS = 0,
+
+	/*!
+	 * Encountered some errors in the routine.
+	 */
+	RTIC_FAILURE = -1
+} rtic_ret;
+
+/*!
+ * These parameters are used to configure RTIC DMA Burst size.
+ */
+typedef enum {
+	/*!
+	 * This parameter will configure DMA Burst read as 1 word.
+	 */
+	RTIC_DMA_1_WORD,
+	/*!
+	 * This parameter will configure DMA Burst read as 2 words.
+	 */
+	RTIC_DMA_2_WORD,
+	/*!
+	 * This parameter will configure DMA Burst read as 4 words.
+	 */
+	RTIC_DMA_4_WORD,
+	/*!
+	 * This parameter will configure DMA Burst read as 8 words.
+	 */
+	RTIC_DMA_8_WORD,
+	/*!
+	 * This parameter will configure DMA Burst read as 16 words.
+	 */
+	RTIC_DMA_16_WORD,
+} rtic_dma_word;
+
+/*!
+ * Gets Hashing result value from RTIC Hash Result Registers.
+ */
+typedef struct {
+	/*!
+	 * Stores the hash result.
+	 */
+	ulong hash_result[5];
+} rtic_hash_rlt;
+/*! @} */
+
+/*!
+ * @name HAC module APIs.
+ */
+
+/*! @{ */
+
+/*!
+ * This API configures the start address and block length of the data that needs
+ * to be hashed. Start address indicates starting location from where the data
+ * in the flash memory is to be hashed. The number of blocks that needs to be
+ * hashed is loaded in the block count register. This API also does the stating
+ * of Hashing process or continue with Hashing of next block of data configured
+ * in the START_ADDR, BLOCK_COUNT register depending on the hash parameter
+ * passed.
+ *
+ * @param   start_address   starting address of the flash memory to be hashed.
+ * @param   blk_len         number of blocks to be hashed.
+ * @param   hash            mode of operation like Start or Continue hashing.
+ *                          Following parameters are passed:
+ *                          HAC_START       : Starts the Hashing process.
+ *                          HAC_LAST_START  : Starts the Hashing process with
+ *                                            last block of data.
+ *                          HAC_CONTINUE    : Continue the Hashing process.
+ *                          HAC_LAST        : Continue the Hashing process with
+ *                                            last block of data.
+ *
+ * @return  HAC_SUCCESS    Success on completion of configuring HAC for
+ *                         Hashing.\n
+ *          HAC_FAILURE    Failure in completion.
+ */
+hac_ret hac_hash_data(ulong start_address, ulong blk_len, hac_hash hash);
+
+/*!
+ * This API returns the status of the Hashing.
+ *
+ * @return      HAC_BUSY : Indicated HAC Module is busy with Hashing.\n
+ *              HAC_DONE : Indicates Hashing of data is done.\n
+ *              HAC_ERR  : Indicates error has occurred during Hashing.
+ *              HAC_UNKNOWN: Hashing status unknown. This may be when the
+ *                           hashing process has not been initiated atleast
+ *                           once or 'ERROR' bit or 'DONE' bits were reset
+ *                           after the hashing process was completed.
+ */
+hac_hash_status hac_hashing_status(void);
+
+/*!
+ * This API returns the status of the Hash module.
+ *
+ * @return      Value of the Hashing control register.
+ */
+ulong hac_get_status(void);
+
+/*!
+ * This API stops the Hashing process when the Hashing is in progress.
+ */
+hac_ret hac_stop(void);
+
+/*!
+ * This API reads 160 bit hash result from Hash result register. The data is
+ * copied to the memory pointed by the input pointer.
+ *
+ * @param    hash_result_reg    structure Pointer where the hash result is
+ *                              copied.
+ */
+hac_ret hac_hash_result(hac_hash_rlt * hash_result_reg);
+
+/*!
+ * This API will initiates software reset of the entire HAC module. It resets
+ * all state machine to their default values. All status bits (BUSY/ERROR/DONE)
+ * and any pending interrupts are cleared.
+ *
+ * @return  HAC_SUCCESS    Successfully in doing software reset.\n
+ *          HAC_FAILURE    Error in doing software reset.
+ */
+hac_ret hac_swrst(void);
+
+/*!
+ * This API configures the burst mode of the HAC. When Burst mode set in HAC
+ * Control register then ARM9 is configured for a 16-WORD burst, while Burst
+ * mode is cleared then ARM9 is configured for a incremental burst.
+ *
+ * @param  burst_mode   Configures burst mode operations.
+ *
+ * @return  HAC_SUCCESS    Successfully in configuring burst mode.\n
+ *          HAC_FAILURE    Error in configuring burst mode.
+ */
+hac_ret hac_burst_mode(hac_burst_mode_config burst_mode);
+
+/*!
+ * This API configures HAC burst read nature.
+ *
+ * @param  burst_read   Configures burst read.
+ *
+ * @return  HAC_SUCCESS    Successfully in configuring burst read.\n
+ *          HAC_FAILURE    Error in configuring burst read.
+ */
+hac_ret hac_burst_read(hac_burst_read_config burst_read);
+
+/*!
+ * This function is called to put the HAC in a low power state. Refer to the
+ * document driver-model/driver.txt in the kernel source tree for more
+ * information.
+ *
+ * @param   dev   the device structure used to give information on HAC
+ *                to suspend.
+ * @param   state the power state the device is entering.
+ * @param   level the stage in device suspension process that we want the
+ *                device to be put in.
+ *
+ * @return  The function always returns 0.
+ */
+hac_ret hac_suspend(struct platform_device *pdev, pm_message_t state);
+
+/*!
+ * This function is called to bring the HAC back from a low power state.
+ * Refer to the document driver-model/driver.txt in the kernel source tree
+ * for more information.
+ *
+ * @param   dev   the device structure used to give information on HAC
+ *                to resume.
+ * @param   level the stage in device resumption process that we want the
+ *                device to be put in.
+ *
+ * @return  The function always returns 0.
+ */
+hac_ret hac_resume(struct platform_device *pdev);
+
+/*! @} */
+
+/*!
+ * @name RTIC module APIs.
+ */
+
+/*! @{ */
+
+/*!
+ * The following api is used to enable the RTIC IP CLK and RTIC HCLK.
+ * Before start using other APIs make sure that init is called.
+ *
+ * @param   void
+ *
+ * return   void
+ */
+void rtic_init(void);
+
+/*!
+ * This API configures the memory block (A, B, C, D) into
+ * ONE_TIME Mode or RUN_TIME Mode for Hashing of data in memory.
+ * RTIC does not support enabling multiple memory blocks that aren't
+ * grouped together(i.e. enabling only memory blocks A & C without memory
+ * B enabled).
+ *
+ * @param  mode         RTIC mode of operation (ONE_TIME or RUN_TIME).
+ * @param  mem_blk      Memory block to be hashed.
+ *
+ * @return  RTIC_SUCCESS    Successfully hashed the data.\n
+ *          RTIC_FAILURE    Error in the parameters passed.
+ */
+rtic_ret rtic_configure_mode(rtic_mode mode, rtic_memblk mem_blk);
+
+/*!
+ * This API allows to configure start address and block length of the
+ * memory content to be hashed. Start address indicates starting location from
+ * where the data in the memory is to be hashed. The number of blocks that
+ * needs to be hashed is loaded in the block count register.
+ * There are four memory blocks available. The user can configure any one of
+ * these four memory blocks by passing their appropriate address and block
+ * length to be Hashed.
+ *
+ * @param    start_addr       Starting address of the memory to be hashed.
+ * @param    blk_len          Block length of data in memory.
+ * @param    mem_blk          Memory block to be hashed.
+ *
+ * @return  RTIC_SUCCESS    Successfully hashed the data.\n
+ *          RTIC_FAILURE    Error in the parameters passed.
+ */
+
+rtic_ret rtic_configure_mem_blk(ulong start_addr, ulong blk_len,
+				rtic_memblk mem_blk);
+
+/*!
+ * This API will configure to start the Hashing of data in memory
+ * either in One-Time Hash mode or Run-Time Hash mode.
+ *
+ * @param       mode    Memory block to be hashed.
+ *
+ * @return  RTIC_SUCCESS    Successfully hashed the data.\n
+ *          RTIC_FAILURE    Error in the parameters passed.
+ */
+rtic_ret rtic_start_hash(rtic_mode mode);
+
+/*!
+ * This API will read the RTIC status register.
+ *
+ * @return  Status of Hashing.
+ */
+ulong rtic_get_status(void);
+
+/*!
+ * This API will read the RTIC control register.
+ *
+ * @return  Control register value.
+ */
+ulong rtic_get_control(void);
+
+/*!
+ * This API enables or disables interrupt for RTIC module.
+ *
+ * @param  irq_en    To enable or disable interrupt.
+ *
+ * @return  RTIC_SUCCESS    Successfully hashed the data.\n
+ *          RTIC_FAILURE    Error in the parameters passed.
+ */
+rtic_ret rtic_configure_interrupt(rtic_interrupt irq_en);
+
+/*!
+ * This API reads the Fault address of the RTIC module.
+ *
+ * @return   Fault address register value.
+ */
+ulong rtic_get_faultaddress(void);
+
+/*!
+ * This API reads 160 bit hash result from Hash result register.The data is
+ * copied to the memory pointed by the input pointer.
+ *
+ * @param    mem_blk            Memory block to be hashed.
+ * @param    mode               RTIC mode of operation (ONE_TIME or RUN_TIME).
+ * @param    hash_result_reg    Hashed value.
+ *
+ * @return  RTIC_SUCCESS    Successfully hashed the data.\n
+ *          RTIC_FAILURE    Error in the parameters passed.
+ */
+rtic_ret rtic_hash_result(rtic_memblk mem_blk, rtic_mode mode,
+			  rtic_hash_rlt * hash_result_reg);
+
+/*!
+ * This API configures RTIC DMA Burst Size. It configures maximum number of
+ * words to burst read through DMA. This cannot be modified during run-time.
+ *
+ *      @param  dma_burst       Maximum DMA Burst Size.
+ *
+ *      @return  RTIC_SUCCESS    RTIC DMA successfully configured.\n
+ *               RTIC_FAILURE    Error DMA configuration.
+ */
+rtic_ret rtic_dma_burst_read(rtic_dma_word dma_burst);
+
+/*!
+ * This API sets DMA throttle register to 0x00 during boot time to minimize the
+ * performance impact at startup.
+ *
+ *    @return  RTIC_SUCCESS    DMA throttle register set to 0x00 successfully.
+ *             RTIC_FAILURE    Failure in programing DMA throttle register..
+ */
+rtic_ret rtic_hash_once_dma_throttle(void);
+
+/*! This API programs the DMA Programmable Timer to set to specify how many
+ * cycles to wait between DMA bus access.
+ *
+ *      @param  dma_delay       DMA Bus Duty Cycle Delay.
+ *
+ *      @return  RTIC_SUCCESS    RTIC DMA Duty Cycle delay set successfully.\n
+ *               RTIC_FAILURE    Failure in programing DMA bus delay.
+ */
+rtic_ret rtic_dma_delay(ulong dma_delay);
+
+/*!
+ * This API Configures DMA Watchdog timer.
+ *
+ * @param       wd_timer        DMA Watchdog timer value.
+ *
+ * @return  RTIC_SUCCESS    RTIC DMA Watchdog Timer set successfully.\n
+ *          RTIC_FAILURE    Failure in programing DMA Watchdog Timer.
+ *
+ */
+rtic_ret rtic_wd_timer(ulong wd_timer);
+
+/*!
+ * This API is used for Software reset RTIC Module.
+ *
+ * @param   rtic_rst        To Enable and Disable RTIC SW Reset.
+ *
+ * @return  RTIC_SUCCESS    RTIC SW Reset Configured successfully.\n
+ *          RTIC_FAILURE    Failure in configuring.
+ */
+rtic_ret rtic_sw_reset(rtic_sw_rst rtic_rst);
+
+/*!
+ * This API is used RTIC to clear IRQ.
+ *
+ * @param   rtic_irq_clr    To Clear RTIC IRQ.
+ *
+ * @return  RTIC_SUCCESS    Clear RTIC IRQ Successfully.\n
+ *          RTIC_FAILURE    Failure in Clearing RTIC IRQ.
+ */
+rtic_ret rtic_clr_irq(rtic_clear_irq rtic_irq_clr);
+
+/*! @} */
+
+#endif				/* __ASM_ARCH_MXC_SECURITY_API_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_uart.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc_uart.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,262 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup UART Universal Asynchronous Receiver Transmitter (UART) Driver
+ */
+
+/*!
+ * @file mxc_uart.h
+ *
+ * @brief This file contains the UART configuration structure definition.
+ *
+ *
+ * @ingroup UART
+ */
+
+#ifndef __ASM_ARCH_MXC_UART_H__
+#define __ASM_ARCH_MXC_UART_H__
+
+#ifdef __KERNEL__
+
+#include <linux/serial_core.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/dma.h>
+
+/*!
+ * This structure is used to store the the physical and virtual
+ * addresses of the UART DMA receive buffer.
+ */
+typedef struct {
+	/*!
+	 * DMA Receive buffer virtual address
+	 */
+	char *rx_buf;
+	/*!
+	 * DMA Receive buffer physical address
+	 */
+	dma_addr_t rx_handle;
+} mxc_uart_rxdmamap;
+
+/*!
+ * This structure is a way for the low level driver to define their own
+ * \b uart_port structure. This structure includes the core \b uart_port
+ * structure that is provided by Linux as an element and has other
+ * elements that are specifically required by this low-level driver.
+ */
+typedef struct {
+	/*!
+	 * The port structure holds all the information about the UART
+	 * port like base address, and so on.
+	 */
+	struct uart_port port;
+	/*!
+	 * Flag to determine if the interrupts are muxed.
+	 */
+	int ints_muxed;
+	/*!
+	 * Array that holds the receive and master interrupt numbers
+	 * when the interrupts are not muxed.
+	 */
+	int irqs[2];
+	/*!
+	 * Flag to determine the DTE/DCE mode.
+	 */
+	int mode;
+	/*!
+	 * Flag to hold the IR mode of the port.
+	 */
+	int ir_mode;
+	/*!
+	 * Flag to enable/disable the UART port.
+	 */
+	int enabled;
+	/*!
+	 * Flag to indicate if we wish to use hardware-driven hardware
+	 * flow control.
+	 */
+	int hardware_flow;
+	/*!
+	 * Holds the threshold value at which the CTS line is deasserted in
+	 * case we use hardware-driven hardware flow control.
+	 */
+	unsigned int cts_threshold;
+	/*!
+	 * Flag to enable/disable DMA data transfer.
+	 */
+	int dma_enabled;
+	/*!
+	 * Holds the DMA receive buffer size.
+	 */
+	int dma_rxbuf_size;
+	/*!
+	 * DMA Receive buffers information
+	 */
+	mxc_uart_rxdmamap *rx_dmamap;
+	/*!
+	 * DMA RX buffer id
+	 */
+	int dma_rxbuf_id;
+	/*!
+	 * DMA Transmit buffer virtual address
+	 */
+	char *tx_buf;
+	/*!
+	 * DMA Transmit buffer physical address
+	 */
+	dma_addr_t tx_handle;
+	/*!
+	 * Holds the RxFIFO threshold value.
+	 */
+	unsigned int rx_threshold;
+	/*!
+	 * Holds the TxFIFO threshold value.
+	 */
+	unsigned int tx_threshold;
+	/*!
+	 * Information whether this is a shared UART
+	 */
+	unsigned int shared;
+	/*!
+	 * Clock id from clock.h
+	 */
+	enum mxc_clocks clock_id;
+	/*!
+	 * Information whether RXDMUXSEL must be set or not for IR port
+	 */
+	int rxd_mux;
+	/*!
+	 * DMA ID for transmit
+	 */
+	mxc_dma_device_t dma_tx_id;
+	/*!
+	 * DMA ID for receive
+	 */
+	mxc_dma_device_t dma_rx_id;
+} uart_mxc_port;
+
+/* Address offsets of the UART registers */
+#define MXC_UARTURXD            0x000	/* Receive reg */
+#define MXC_UARTUTXD            0x040	/* Transmitter reg */
+#define	MXC_UARTUCR1            0x080	/* Control reg 1 */
+#define MXC_UARTUCR2            0x084	/* Control reg 2 */
+#define MXC_UARTUCR3            0x088	/* Control reg 3 */
+#define MXC_UARTUCR4            0x08C	/* Control reg 4 */
+#define MXC_UARTUFCR            0x090	/* FIFO control reg */
+#define MXC_UARTUSR1            0x094	/* Status reg 1 */
+#define MXC_UARTUSR2            0x098	/* Status reg 2 */
+#define MXC_UARTUESC            0x09C	/* Escape character reg */
+#define MXC_UARTUTIM            0x0A0	/* Escape timer reg */
+#define MXC_UARTUBIR            0x0A4	/* BRM incremental reg */
+#define MXC_UARTUBMR            0x0A8	/* BRM modulator reg */
+#define MXC_UARTUBRC            0x0AC	/* Baud rate count reg */
+#define MXC_UARTONEMS           0x0B0	/* One millisecond reg */
+#define MXC_UARTUTS             0x0B4	/* Test reg */
+
+/* Bit definations of UCR1 */
+#define MXC_UARTUCR1_ADEN       0x8000
+#define MXC_UARTUCR1_ADBR       0x4000
+#define MXC_UARTUCR1_TRDYEN     0x2000
+#define MXC_UARTUCR1_IDEN       0x1000
+#define MXC_UARTUCR1_RRDYEN     0x0200
+#define MXC_UARTUCR1_RXDMAEN    0x0100
+#define MXC_UARTUCR1_IREN       0x0080
+#define MXC_UARTUCR1_TXMPTYEN   0x0040
+#define MXC_UARTUCR1_RTSDEN     0x0020
+#define MXC_UARTUCR1_SNDBRK     0x0010
+#define MXC_UARTUCR1_TXDMAEN    0x0008
+#define MXC_UARTUCR1_ATDMAEN    0x0004
+#define MXC_UARTUCR1_DOZE       0x0002
+#define MXC_UARTUCR1_UARTEN     0x0001
+
+/* Bit definations of UCR2 */
+#define MXC_UARTUCR2_ESCI       0x8000
+#define MXC_UARTUCR2_IRTS       0x4000
+#define MXC_UARTUCR2_CTSC       0x2000
+#define MXC_UARTUCR2_CTS        0x1000
+#define MXC_UARTUCR2_PREN       0x0100
+#define MXC_UARTUCR2_PROE       0x0080
+#define MXC_UARTUCR2_STPB       0x0040
+#define MXC_UARTUCR2_WS         0x0020
+#define MXC_UARTUCR2_RTSEN      0x0010
+#define MXC_UARTUCR2_ATEN       0x0008
+#define MXC_UARTUCR2_TXEN       0x0004
+#define MXC_UARTUCR2_RXEN       0x0002
+#define MXC_UARTUCR2_SRST       0x0001
+
+/* Bit definations of UCR3 */
+#define MXC_UARTUCR3_DTREN      0x2000
+#define MXC_UARTUCR3_PARERREN   0x1000
+#define MXC_UARTUCR3_FRAERREN   0x0800
+#define MXC_UARTUCR3_DSR        0x0400
+#define MXC_UARTUCR3_DCD        0x0200
+#define MXC_UARTUCR3_RI         0x0100
+#define MXC_UARTUCR3_RXDSEN     0x0040
+#define MXC_UARTUCR3_AWAKEN     0x0010
+#define MXC_UARTUCR3_DTRDEN     0x0008
+#define MXC_UARTUCR3_RXDMUXSEL  0x0004
+#define MXC_UARTUCR3_INVT       0x0002
+
+/* Bit definations of UCR4 */
+#define MXC_UARTUCR4_CTSTL_OFFSET       10
+#define MXC_UARTUCR4_CTSTL_MASK         (0x3F << 10)
+#define MXC_UARTUCR4_INVR               0x0200
+#define MXC_UARTUCR4_ENIRI              0x0100
+#define MXC_UARTUCR4_REF16              0x0040
+#define MXC_UARTUCR4_IRSC               0x0020
+#define MXC_UARTUCR4_TCEN               0x0008
+#define MXC_UARTUCR4_OREN               0x0002
+#define MXC_UARTUCR4_DREN               0x0001
+
+/* Bit definations of UFCR */
+#define MXC_UARTUFCR_RFDIV              0x0200	/* Ref freq div is set to 2 */
+#define MXC_UARTUFCR_RFDIV_OFFSET       7
+#define MXC_UARTUFCR_RFDIV_MASK         (0x7 << 7)
+#define MXC_UARTUFCR_TXTL_OFFSET        10
+#define MXC_UARTUFCR_DCEDTE             0x0040
+
+/* Bit definations of URXD */
+#define MXC_UARTURXD_ERR        0x4000
+#define MXC_UARTURXD_OVRRUN     0x2000
+#define MXC_UARTURXD_FRMERR     0x1000
+#define MXC_UARTURXD_BRK        0x0800
+#define MXC_UARTURXD_PRERR      0x0400
+
+/* Bit definations of USR1 */
+#define MXC_UARTUSR1_PARITYERR  0x8000
+#define MXC_UARTUSR1_RTSS       0x4000
+#define MXC_UARTUSR1_TRDY       0x2000
+#define MXC_UARTUSR1_RTSD       0x1000
+#define MXC_UARTUSR1_FRAMERR    0x0400
+#define MXC_UARTUSR1_RRDY       0x0200
+#define MXC_UARTUSR1_AGTIM      0x0100
+#define MXC_UARTUSR1_DTRD       0x0080
+#define MXC_UARTUSR1_AWAKE      0x0010
+
+/* Bit definations of USR2 */
+#define MXC_UARTUSR2_TXFE       0x4000
+#define MXC_UARTUSR2_IDLE       0x1000
+#define MXC_UARTUSR2_RIDELT     0x0400
+#define MXC_UARTUSR2_RIIN       0x0200
+#define MXC_UARTUSR2_DCDDELT    0x0040
+#define MXC_UARTUSR2_DCDIN      0x0020
+#define MXC_UARTUSR2_TXDC       0x0008
+#define MXC_UARTUSR2_ORE        0x0002
+#define MXC_UARTUSR2_RDR        0x0001
+
+/* Bit definations of UTS */
+#define MXC_UARTUTS_LOOP        0x1000
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_UART_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_v4l2.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc_v4l2.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @file mxc_v4l2.h
+ *
+ * @brief mxc V4L2 private structures
+ *
+ * @ingroup MXC_V4L2_CAPTURE
+ */
+
+#ifndef __ASM_ARCH_MXC_V4L2_H__
+#define __ASM_ARCH_MXC_V4L2_H__
+
+#define V4L2_CID_MXC_ROT		(V4L2_CID_PRIVATE_BASE + 0)
+#define V4L2_CID_MXC_FLASH		(V4L2_CID_PRIVATE_BASE + 1)
+
+#define V4L2_MXC_ROTATE_NONE			0
+#define V4L2_MXC_ROTATE_VERT_FLIP		1
+#define V4L2_MXC_ROTATE_HORIZ_FLIP		2
+#define V4L2_MXC_ROTATE_180			3
+#define V4L2_MXC_ROTATE_90_RIGHT		4
+#define V4L2_MXC_ROTATE_90_RIGHT_VFLIP		5
+#define V4L2_MXC_ROTATE_90_RIGHT_HFLIP		6
+#define V4L2_MXC_ROTATE_90_LEFT			7
+
+struct v4l2_mxc_offset {
+	uint32_t u_offset;
+	uint32_t v_offset;
+};
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_vpu.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/mxc_vpu.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+/*!
+ * @defgroup VPU Video Processor Unit Driver
+ */
+
+/*!
+ * @file mxc_vpu.h
+ *
+ * @brief VPU system initialization and file operation definition
+ *
+ * @ingroup VPU
+ */
+
+#ifndef __ASM_ARCH_MXC_VPU_H__
+#define __ASM_ARCH_MXC_VPU_H__
+
+#include <linux/fs.h>
+
+typedef struct vpu_mem_desc {
+	u32 size;
+	dma_addr_t phy_addr;
+	u32 cpu_addr;		/* cpu address to free the dma mem */
+	u32 virt_uaddr;		/* virtual user space address */
+} vpu_mem_desc;
+
+#define VPU_IOC_MAGIC  'V'
+
+#define VPU_IOC_PHYMEM_ALLOC	_IO(VPU_IOC_MAGIC, 0)
+#define VPU_IOC_PHYMEM_FREE	_IO(VPU_IOC_MAGIC, 1)
+#define VPU_IOC_WAIT4INT	_IO(VPU_IOC_MAGIC, 2)
+#define VPU_IOC_PHYMEM_DUMP	_IO(VPU_IOC_MAGIC, 3)
+#define VPU_IOC_REG_DUMP	_IO(VPU_IOC_MAGIC, 4)
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/param.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/param.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*!
+ * @file param.h
+ *
+ * @brief This file exists only because other kernel files include it.
+ *
+ * @ingroup System
+ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pcmcia.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pcmcia.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,218 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PCMCIA_H__
+#define __ASM_ARCH_MXC_PCMCIA_H__
+
+#include <asm/arch/hardware.h>
+
+#define	WINDOW_SIZE	0x1000000	/* The size of a window: 16M    */
+#define PCMCIA_WINDOWS  5	/* How many windows / socket    */
+#define SOCKET_NO	1	/* How many sockets             */
+
+#define ATTRIBUTE_MEMORY_WINDOW	0
+#define IO_WINDOW		1
+#define COMMON_MEMORY_WINDOW	2
+
+/*
+ * PCMCIA socket
+ */
+#define	PCMCIAPrtSp	WINDOW_SIZE	/* PCMCIA window size              */
+#define PCMCIASp	(4*PCMCIAPrtSp)	/* PCMCIA Space [byte]             */
+#define PCMCIAIOSp	PCMCIAPrtSp	/* PCMCIA I/O Space [byte]         */
+#define PCMCIAAttrSp	PCMCIAPrtSp	/* PCMCIA Attribute Space [byte]   */
+#define PCMCIAMemSp	PCMCIAPrtSp	/* PCMCIA Memory Space [byte]      */
+
+#define PCMCIA0Sp	PCMCIASp	/* PCMCIA 0 Space [byte]           */
+#define PCMCIA0IOSp	PCMCIAIOSp	/* PCMCIA 0 I/O Space [byte]       */
+#define PCMCIA0AttrSp	PCMCIAAttrSp	/* PCMCIA 0 Attribute Space [byte] */
+#define PCMCIA0MemSp	PCMCIAMemSp	/* PCMCIA 0 Memory Space [byte]    */
+
+#define _PCMCIA(Nb)			/* PCMCIA [0..1]		   */ \
+			(PCMCIA_MEM_BASE_ADDR + (Nb) * PCMCIASp)
+
+#define _PCMCIAAttr(Nb)	_PCMCIA (Nb)	/* PCMCIA I/O [0..1]               */
+
+#define _PCMCIAIO(Nb)			/* PCMCIA Attribute [0..1]	   */ \
+			(_PCMCIA (Nb) + (IO_WINDOW) * PCMCIAPrtSp)
+#define _PCMCIAMem(Nb)			/* PCMCIA Memory [0..1]		   */ \
+			(_PCMCIA (Nb) + (COMMON_MEMORY_WINDOW) * PCMCIAPrtSp)
+
+#define _PCMCIA0	_PCMCIA (0)	/* PCMCIA 0                        */
+#define _PCMCIA0IO	_PCMCIAIO (0)	/* PCMCIA 0 I/O                    */
+#define _PCMCIA0Attr	_PCMCIAAttr (0)	/* PCMCIA 0 Attribute              */
+#define _PCMCIA0Mem	_PCMCIAMem (0)	/* PCMCIA 0 Memory                 */
+
+/*
+ * Module: PCMCIA, Addr Range: 0xB8004000 - 0xB8004FFF, Size: 4 Kbyte
+ */
+#define PCMCIA_BASE_ADDR	(PCMCIA_CTL_BASE_ADDR)	/* PCMCIA Base Address */
+#define PCMCIA_IO_ADDR(x)	(* (volatile u32 *)PCMCIA_IO_ADDRESS(x))
+
+#define _reg_PCMCIA_PIPR	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x00)	/* PCMCIA input pins register */
+#define _reg_PCMCIA_PSCR	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x04)	/* PCMCIA Status Changed Register */
+#define _reg_PCMCIA_PER		PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x08)	/* PCMCIA Enable Register */
+
+/* win: 0-4 */
+#define _reg_PCMCIA_PBR(win)	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x0C + 4 * (win))	/* PCMCIA Base Register x */
+#define _reg_PCMCIA_POR(win)	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x28 + 4 * (win))	/* PCMCIA Option Register x */
+#define _reg_PCMCIA_POFR(win)	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x44 + 4 * (win))	/* PCMCIA Offset Register x */
+
+#define _reg_PCMCIA_PGCR	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x60)	/* PCMCIA General Control Register */
+#define _reg_PCMCIA_PGSR	PCMCIA_IO_ADDR(PCMCIA_BASE_ADDR + 0x64)	/* PCMCIA General Status Register */
+
+/* PCMCIA_PIPR - PCMCIA Input Pins Register - fields */
+#define PCMCIA_PIPR_POWERON            (1 <<  8)	/* card indicates "power on" */
+#define PCMCIA_PIPR_RDY                (1 <<  7)	/* card is ready */
+#define PCMCIA_PIPR_BVD2               (1 <<  6)	/* battery voltage 2/SPKR in */
+#define PCMCIA_PIPR_BVD1               (1 <<  5)	/* battery voltage 1/STSCHG */
+#define PCMCIA_PIPR_CD                 (3 <<  3)	/* card detect 1 and 2 */
+#define PCMCIA_PIPR_WP                 (1 <<  2)	/* write protect switch enabled */
+#define PCMCIA_PIPR_VS                 (3 <<  0)	/* voltage sense bits */
+#define PCMCIA_PIPR_VS_5V              (1 <<  0)	/* 5v */
+
+/* PCMCIA_PSCR - PCMCIA Status Change Register - fields */
+#define PCMCIA_PSCR_POWC               (1 << 11)	/*  */
+#define PCMCIA_PSCR_RDYR               (1 << 10)	/*  */
+#define PCMCIA_PSCR_RDYF               (1 <<  9)	/*  */
+#define PCMCIA_PSCR_RDYH               (1 <<  8)	/*  */
+#define PCMCIA_PSCR_RDYL               (1 <<  7)	/*  */
+#define PCMCIA_PSCR_BVDC2              (1 <<  6)	/*  */
+#define PCMCIA_PSCR_BVDC1              (1 <<  5)	/*  */
+#define PCMCIA_PSCR_CDC2               (1 <<  4)	/*  */
+#define PCMCIA_PSCR_CDC1               (1 <<  3)	/*  */
+#define PCMCIA_PSCR_WPC                (1 <<  2)	/*  */
+#define PCMCIA_PSCR_VSC2               (1 <<  1)	/*  */
+#define PCMCIA_PSCR_VSC1               (1 <<  0)	/*  */
+
+/* PCMCIA_PER - PCMCIA Enable Register - fields */
+#define PCMCIA_PER_ERRINTEN            (1 << 12)	/* error interrupt enable */
+#define PCMCIA_PER_POWERONEN           (1 << 11)	/* power on interrupt enable */
+#define PCMCIA_PER_RDYRE               (1 << 10)	/* RDY/nIREQ pin rising edge */
+#define PCMCIA_PER_RDYFE               (1 <<  9)	/* RDY/nIREQ pin falling edge */
+#define PCMCIA_PER_RDYHE               (1 <<  8)	/* RDY/nIREQ pin high */
+#define PCMCIA_PER_RDYLE               (1 <<  7)	/* RDY/nIREQ pin low */
+#define PCMCIA_PER_BVDE2               (1 <<  6)	/* battery voltage 2/SPKR in */
+#define PCMCIA_PER_BVDE1               (1 <<  5)	/* battery voltage 1/STSCHG */
+#define PCMCIA_PER_CDE2                (1 <<  4)	/* card detect 2  */
+#define PCMCIA_PER_CDE1                (1 <<  3)	/* card detect 1 */
+#define PCMCIA_PER_WPE                 (1 <<  2)	/* write protect */
+#define PCMCIA_PER_VSE2                (1 <<  1)	/* voltage sense 2 */
+#define PCMCIA_PER_VSE1                (1 <<  0)	/* voltage sense 1 */
+
+/* PCMCIA_POR[0-4] - PCMCIA Option Registers 0-4 - fields */
+#define PCMCIA_POR_PV                  (1 << 29)	/* set iff bank is valid */
+#define PCMCIA_POR_WPEN                (1 << 28)	/* write protect (WP) input signal is enabled */
+#define PCMCIA_POR_WP                  (1 << 27)	/* write protected */
+
+#define PCMCIA_POR_PRS_SHIFT           (25)
+#define PCMCIA_POR_PRS(x)              (((x) & 0x3) << PCMCIA_POR_PRS_SHIFT )
+#define PCMCIA_POR_PRS_MASK            PCMCIA_POR_PRS(3)	/* PCMCIA region select */
+#define PCMCIA_POR_PRS_COMMON          (0)	/* values of POR_PRS field */
+#define PCMCIA_POR_PRS_TRUE_IDE        (1)
+#define PCMCIA_POR_PRS_ATTRIBUTE       (2)
+#define PCMCIA_POR_PRS_IO              (3)
+
+#define PCMCIA_POR_PPS_8               (1 << 24)	/* PCMCIA Port size =  8bits */
+#define PCMCIA_POR_PPS_16              (0 << 24)	/* PCMCIA Port size = 16bits */
+
+#define PCMCIA_POR_PSL_SHIFT           (17)	/* strobe length */
+#define PCMCIA_POR_PSL(x)              (((x) & 0x7F) << PCMCIA_POR_PSL_SHIFT)
+#define PCMCIA_POR_PSL_MASK            PCMCIA_POR_PSL(0x7f)
+
+#define PCMCIA_POR_PSST_SHIFT          (11)	/* strobe setup time */
+#define PCMCIA_POR_PSST(x)             (((x) & 0x3F) << PCMCIA_POR_PSST_SHIFT)
+#define PCMCIA_POR_PSST_MASK           PCMCIA_POR_PSST(0x3f)
+
+#define PCMCIA_POR_PSHT_SHIFT          (5)	/* strobe hold time  */
+#define PCMCIA_POR_PSHT(x)             (((x) & 0x3F) << PCMCIA_POR_PSHT_SHIFT)
+#define PCMCIA_POR_PSHT_MASK           PCMCIA_POR_PSHT(0x3f)
+
+#define PCMCIA_POR_BSIZE_SHIFT         (0)	/* bank size */
+#define PCMCIA_POR_BSIZE(x)            (((x) & 0x1F) << PCMCIA_POR_BSIZE_SHIFT)
+#define PCMCIA_POR_BSIZE_MASK          PCMCIA_POR_BSIZE(0x1F)
+
+/* some handy BSIZE values */
+#define POR_BSIZE_1                    PCMCIA_POR_BSIZE(0x00)
+#define POR_BSIZE_2                    PCMCIA_POR_BSIZE(0x01)
+#define POR_BSIZE_4                    PCMCIA_POR_BSIZE(0x03)
+#define POR_BSIZE_8                    PCMCIA_POR_BSIZE(0x02)
+#define POR_BSIZE_16                   PCMCIA_POR_BSIZE(0x06)
+#define POR_BSIZE_32                   PCMCIA_POR_BSIZE(0x07)
+#define POR_BSIZE_64                   PCMCIA_POR_BSIZE(0x05)
+#define POR_BSIZE_128                  PCMCIA_POR_BSIZE(0x04)
+#define POR_BSIZE_256                  PCMCIA_POR_BSIZE(0x0C)
+#define POR_BSIZE_512                  PCMCIA_POR_BSIZE(0x0D)
+#define POR_BSIZE_1K                   PCMCIA_POR_BSIZE(0x0F)
+#define POR_BSIZE_2K                   PCMCIA_POR_BSIZE(0x0E)
+
+#define POR_BSIZE_4K                   PCMCIA_POR_BSIZE(0x0A)
+#define POR_BSIZE_8K                   PCMCIA_POR_BSIZE(0x0B)
+#define POR_BSIZE_16K                  PCMCIA_POR_BSIZE(0x09)
+#define POR_BSIZE_32K                  PCMCIA_POR_BSIZE(0x08)
+#define POR_BSIZE_64K                  PCMCIA_POR_BSIZE(0x18)
+#define POR_BSIZE_128K                 PCMCIA_POR_BSIZE(0x19)
+#define POR_BSIZE_256K                 PCMCIA_POR_BSIZE(0x1B)
+#define POR_BSIZE_512K                 PCMCIA_POR_BSIZE(0x1A)
+#define POR_BSIZE_1M                   PCMCIA_POR_BSIZE(0x1E)
+#define POR_BSIZE_2M                   PCMCIA_POR_BSIZE(0x1F)
+#define POR_BSIZE_4M                   PCMCIA_POR_BSIZE(0x1D)
+#define POR_BSIZE_8M                   PCMCIA_POR_BSIZE(0x1C)
+#define POR_BSIZE_16M                  PCMCIA_POR_BSIZE(0x14)
+#define POR_BSIZE_32M                  PCMCIA_POR_BSIZE(0x15)
+#define POR_BSIZE_64M                  PCMCIA_POR_BSIZE(0x17)
+
+/* Window size */
+#define POR_1		0x1
+#define POR_2		0x2
+#define POR_4		0x4
+#define POR_8		0x8
+#define POR_16		0x10
+#define POR_32		0x20
+#define POR_64		0x40
+#define POR_128		0x80
+#define POR_256		0x100
+#define POR_512		0x200
+
+#define POR_1K		0x400
+#define POR_2K		0x800
+#define POR_4K		0x1000
+#define POR_8K		0x2000
+#define POR_16K		0x4000
+#define POR_32K		0x8000
+#define POR_64K		0x10000
+#define POR_128K	0x20000
+#define POR_256K	0x40000
+#define POR_512K	0x80000
+
+#define POR_1M		0x100000
+#define POR_2M		0x200000
+#define POR_4M		0x400000
+#define POR_8M		0x800000
+#define POR_16M		0x1000000
+#define POR_32M		0x2000000
+#define POR_64M		0x4000000
+
+/* PCMCIA_PGCR - PCMCIA General Control Register - fields */
+#define PCMCIA_PGCR_LPMEN              (1 <<  3)	/* Low power Mode Enable */
+#define PCMCIA_PGCR_SPKREN             (1 <<  2)	/* SPKROUT routing enable */
+#define PCMCIA_PGCR_POE                (1 <<  1)	/* Controller out enable */
+#define PCMCIA_PGCR_RESET              (1 <<  0)	/* Card reset */
+
+/* PCMCIA_PGSR - PCMCIA General Status Register - fields */
+#define PCMCIA_PGSR_NWINE              (1 <<  4)	/* No Window error */
+#define PCMCIA_PGSR_LPE                (1 <<  3)	/* Low Power error */
+#define PCMCIA_PGSR_SE                 (1 <<  2)	/* Size error */
+#define PCMCIA_PGSR_CDE                (1 <<  1)	/* Card Detect error */
+#define PCMCIA_PGSR_WPE                (1 <<  0)	/* Write Protect error */
+
+#endif				/* __ASM_ARCH_MXC_PCMCIA_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pm_api.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pm_api.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,320 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup PM Dynamic Process Temperature Compensation (DPTC) & Dynamic Voltage Frequency Scaling (DVFS) Drivers
+ */
+
+/*!
+ * @file pm_api.h
+ *
+ * @brief MXC PM API header file.
+ *
+ * @ingroup PM
+ */
+#ifndef __ASM_ARCH_MXC_PM_API_H__
+#define __ASM_ARCH_MXC_PM_API_H__
+
+#include <linux/ioctl.h>
+
+/*!
+ * PM IOCTL Magic Number
+ */
+#define PM_MAGIC  0xDC
+
+/*!
+ * PM IOCTL update PM translation table command.\n
+ * This command changes the current DPTC table used by the driver. \n
+ * The command receives a string pointer to a new DPTC table, parses
+ * it and swiches the table.
+ */
+#define PM_IOCSTABLE		         _IOW(PM_MAGIC, 0, char*)
+
+/*!
+ * PM IOCTL get DPTC table command.\n
+ * This command returns DPTC table used by the driver. \n
+ * The command receives a string pointer for DPTC table,
+ * and dumps the current working table.
+ */
+#define PM_IOCGTABLE		        _IOR(PM_MAGIC, 1, char*)
+
+/*!
+ * DPTC IOCTL enable command.\n
+ * This command enables the dptc module.
+ */
+#define DPTC_IOCTENABLE			_IO(PM_MAGIC, 2)
+
+/*!
+ * DPTC IOCTL disable command.\n
+ * This command disables the dptc module.
+ */
+#define DPTC_IOCTDISABLE		 _IO(PM_MAGIC, 3)
+
+/*!
+ * DPTC IOCTL enable reference circuit command.\n
+ * This command enables the dptc reference circuits.
+ */
+#define DPTC_IOCSENABLERC			_IOW(PM_MAGIC, 4, unsigned char)
+
+/*!
+ * DPTC IOCTL disable reference circuit command.\n
+ * This command disables the dptc reference circuits.
+ */
+#define DPTC_IOCSDISABLERC			_IOW(PM_MAGIC, 5, unsigned char)
+
+/*!
+ * DPTC IOCTL get current state command.\n
+ * This command returns the current dptc module state (Enabled/Disabled).
+ */
+#define DPTC_IOCGSTATE         		_IO(PM_MAGIC, 6)
+
+/*!
+ * DPTC IOCTL set working point command.\n
+ * This command sets working point according to parameter.
+ */
+#define DPTC_IOCSWP         		_IOW(PM_MAGIC, 7, unsigned int)
+
+/*!
+ * DVFS IOCTL enable command.\n
+ * This command enables the dvfs module.
+ */
+#define DVFS_IOCTENABLE			_IO(PM_MAGIC, 8)
+
+/*!
+ * DVFS IOCTL disable command.\n
+ * This command disables the dvfs module.
+ */
+#define DVFS_IOCTDISABLE		 _IO(PM_MAGIC, 9)
+
+/*!
+ * DVFS IOCTL get current state command.\n
+ * This command returns the current dvfs module state (Enabled/Disabled).
+ */
+#define DVFS_IOCGSTATE         		_IO(PM_MAGIC, 10)
+
+/*!
+ * DVFS IOCTL set SW general purpose bits
+ */
+#define DVFS_IOCSSWGP         		_IOW(PM_MAGIC, 11, unsigned char)
+
+/*!
+ * DVFS IOCTL set wait-for-interrupt state
+ */
+#define DVFS_IOCSWFI         		_IOW(PM_MAGIC, 12, unsigned char)
+
+/*!
+ * PM IOCTL get current frequency command.\n
+ * This command returns the current frequency in Hz
+ */
+#define PM_IOCGFREQ         		_IO(PM_MAGIC, 13)
+
+/*!
+ * DVFS IOCTL set frequency command.\n
+ * This command sets frequency according to parameter. The parameter
+ * is the index of required frequency in current table.
+ */
+#define DVFS_IOCSFREQ         		_IOW(PM_MAGIC, 14, unsigned int)
+
+/*!
+ * DVFS IOCTL set mode command.\n
+ * This command sets DVFS mode.
+ * 0 - HW mode, 1 - SW predictive mode
+ */
+#define DVFS_IOCSMODE         		_IOW(PM_MAGIC, 15, unsigned int)
+
+/*!
+ * This defines refercence circuits default status
+ */
+#define DPTC_REF_CIRCUITS_STATUS  0xA
+
+/*!
+ * DCVR register structure
+ */
+typedef struct {
+	/*!
+	 * Reserved bits
+	 */
+	unsigned long Reserved:2;
+
+	/*!
+	 * Emergency limit threshold
+	 */
+	unsigned long EmergencyLimit:10;
+
+	/*!
+	 * Lower limit threshold
+	 */
+	unsigned long LowerLimit:10;
+
+	/*!
+	 * Upper limit threshold
+	 */
+	unsigned long UpperLimit:10;
+} dcvr_reg_s;
+
+/*!
+ * DCVR register represented as a union between a 32 bit word and a bit field
+ */
+typedef union {
+
+	/*!
+	 * DCVR register as a 32 bit word
+	 */
+	unsigned int AsInt;
+
+	/*!
+	 * DCVR register as a bit field
+	 */
+	dcvr_reg_s AsStruct;
+} dcvr_reg_u;
+
+/*!
+ * This struct represents DCVR registers state
+ */
+typedef struct {
+	/*!
+	 * dcvr registers values
+	 */
+	dcvr_reg_u dcvr_reg[4];
+} dcvr_state;
+
+/*!
+ * This struct defines DPTC working point
+ */
+typedef struct {
+	/*!
+	 * Working point index
+	 */
+	int wp_index;
+	/*!
+	 * PMIC regulators values
+	 */
+	unsigned long pmic_values[4];
+} dptc_wp;
+
+/*!
+ * This struct defines DVFS state
+ */
+typedef struct {
+	/*!
+	 * Flag for pll change when frequency should be decreased
+	 */
+	unsigned long pll_sw_down;
+	/*!
+	 * pdr0 register decrease value
+	 */
+	unsigned long pdr0_down;
+	/*!
+	 * pll register deccrease value
+	 */
+	unsigned long pll_down;
+	/*!
+	 * Flag for pll change when frequency should be increased
+	 */
+	unsigned long pll_sw_up;
+	/*!
+	 * pdr0 register increase value
+	 */
+	unsigned long pdr0_up;
+	/*!
+	 * pll register increase value
+	 */
+	unsigned long pll_up;
+	/*!
+	 * vscnt increase value
+	 */
+	unsigned long vscnt;
+} dvfs_state;
+
+/*!
+ * This structure holds the dptc translation table.\n
+ * This structure is used to translate a working point and frequency index to
+ * voltage value and DPTC thresholds.\n
+ * This structure is also used in the driver read and write operations.\n
+ * During read operation this structure is received from the dptc driver,
+ * and during write operation this structure should be sent to the driver.
+ */
+typedef struct {
+	/*!
+	 * Number of working points in dptc table
+	 */
+	int wp_num;
+
+	/*!
+	 * This variable holds the current working point
+	 */
+	int curr_wp;
+
+	/*!
+	 * DVFS translation table entries
+	 */
+	dvfs_state *table;
+
+	/*!
+	 * DCVR table
+	 */
+	dcvr_state **dcvr;
+
+	/*!
+	 * DPTC translation table entries
+	 */
+	dptc_wp *wp;
+
+	/*
+	 * Boolean flag. If it is 0 - uses 4 levels of frequency, 1 - uses 2 levels of frequency
+	 */
+	int use_four_freq;
+
+	/*!
+	 * Number of frequencies for each working point
+	 */
+	int dvfs_state_num;
+} dvfs_dptc_tables_s;
+
+/*!
+ * DPTC log buffer entry structure
+ */
+typedef struct {
+
+	/*!
+	 * Log entry time in jiffies
+	 */
+	unsigned long jiffies;
+
+	/*!
+	 * Log entry working point value
+	 */
+	int wp;
+
+	/*!
+	 * Log entry voltage index
+	 */
+	int voltage;
+
+	/*!
+	 * Log entry frequency index
+	 */
+	int freq;
+} dptc_log_entry_s;
+
+/*!
+ * This defines DVFS HW mode
+ */
+#define DVFS_HW_MODE   0
+
+/*!
+ * This defines DVFS predictive mode
+ */
+#define DVFS_PRED_MODE 1
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pmic_adc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pmic_adc.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,452 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_ADC_H__
+#define __ASM_ARCH_MXC_PMIC_ADC_H__
+
+/*!
+ * @defgroup PMIC_ADC PMIC Digitizer Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_adc.h
+ * @brief This is the header of PMIC ADC driver.
+ *
+ * @ingroup PMIC_ADC
+ */
+
+#include <asm/ioctl.h>
+#include <asm/arch/pmic_status.h>
+#include <asm/arch/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_INIT                   _IO('p', 0xb0)
+/*!
+ * De-initialize ADC.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEINIT                 _IO('p', 0xb1)
+/*!
+ * Convert one channel.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT                _IOWR('p', 0xb2, int)
+/*!
+ * Convert one channel eight samples.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_8X             _IOWR('p', 0xb3, int)
+/*!
+ * Convert multiple channels.
+ * Argument type: pointer to t_adc_convert_param.
+ */
+#define PMIC_ADC_CONVERT_MULTICHANNEL   _IOWR('p', 0xb4, int)
+/*!
+ * Set touch screen operation mode.
+ * Argument type: t_touch_mode.
+ */
+#define PMIC_ADC_SET_TOUCH_MODE         _IOW('p', 0xb5, int)
+/*!
+ * Get touch screen operation mode.
+ * Argument type: pointer to t_touch_mode.
+ */
+#define PMIC_ADC_GET_TOUCH_MODE         _IOR('p', 0xb6, int)
+/*!
+ * Get touch screen sample.
+ * Argument type: pointer to t_touch_sample.
+ */
+#define PMIC_ADC_GET_TOUCH_SAMPLE       _IOWR('p', 0xb7, int)
+/*!
+ * Get battery current.
+ * Argument type: pointer to unsigned short.
+ */
+#define PMIC_ADC_GET_BATTERY_CURRENT    _IOR('p', 0xb8, int)
+/*!
+ * Activate comparator.
+ * Argument type: pointer to t_adc_comp_param.
+ */
+#define PMIC_ADC_ACTIVATE_COMPARATOR    _IOW('p', 0xb9, int)
+/*!
+ * De-active comparator.
+ * Argument type: none.
+ */
+#define PMIC_ADC_DEACTIVE_COMPARATOR    _IOW('p', 0xba, int)
+
+/*!
+ * Install touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_INSTALL       _IOWR('D',4, int)
+/*!
+ * Remove touch screen read interface.
+ */
+#define TOUCH_SCREEN_READ_UNINSTALL     _IOWR('D',5, int)
+
+/*! @{ */
+/*!
+ * @name Touch Screen minimum and maximum values
+ */
+#define TS_X_MIN                80	/*! < Minimum X */
+#define TS_Y_MIN                80	/*! < Minimum Y */
+
+#define TS_X_MAX                1000	/*! < Maximum X */
+#define TS_Y_MAX                1000	/*! < Maximum Y */
+/*! @} */
+/*!
+ * This enumeration defines input channels for PMIC ADC
+ */
+
+typedef enum {
+	BATTERY_VOLTAGE,
+	BATTERY_CURRENT,
+	CHARGE_VOLTAGE,
+	CHARGE_CURRENT,
+	APPLICATION_SUPPLY,
+	TS_X_POS1,
+	TS_X_POS2,
+	TS_Y_POS1,
+	TS_Y_POS2,
+	GEN_PURPOSE_AD4,
+	GEN_PURPOSE_AD5,
+	GEN_PURPOSE_AD6,
+	GEN_PURPOSE_AD7,
+	GEN_PURPOSE_AD8,
+	GEN_PURPOSE_AD9,
+	GEN_PURPOSE_AD10,
+	GEN_PURPOSE_AD11,
+	USB_ID,
+	LICELL,
+	RAWEXTBPLUSSENSE,
+	MPBSENSE,
+	BATSENSE,
+	GND,
+	THERMISTOR,
+	DIE_TEMP
+} t_channel;
+
+/*!
+ * This enumeration defines reason of ADC Comparator interrupt.
+ */
+typedef enum {
+	/*!
+	 * Greater than WHIGH
+	 */
+	GTWHIGH,
+	/*!
+	 * Less than WLOW
+	 */
+	LTWLOW,
+} t_comp_exception;
+
+/*!
+ * ADC comparator callback function type
+ */
+typedef void (*t_comparator_cb) (t_comp_exception reason);
+
+/*!
+ * This enumeration defines the touch screen operation modes.
+ */
+typedef enum {
+	/*!
+	 * Touch Screen X position
+	 */
+	TS_X_POSITION = 0,
+	/*!
+	 * Touch Screen Y position
+	 */
+	TS_Y_POSITION = 1,
+	/*!
+	 * Pressure
+	 */
+	TS_PRESSURE = 2,
+	/*!
+	 * Plate X
+	 */
+	TS_PLATE_X = 3,
+	/*!
+	 * Plate Y
+	 */
+	TS_PLATE_Y = 4,
+	/*!
+	 * Standby
+	 */
+	TS_STANDBY = 5,
+	/*!
+	 * No touch screen, TSX1, TSX2, TSY1 and TSY2 are used as  general
+	 * purpose A/D inputs.
+	 */
+	TS_NONE = 6,
+} t_touch_mode;
+/*!
+ * This structure is used to report touch screen value.
+ */
+typedef struct {
+/*!
+	 * Touch Screen X position
+	 */
+	unsigned int x_position;
+	/*!
+	 * Touch Screen X position1
+	 */
+	unsigned int x_position1;
+	/*!
+	 * Touch Screen X position2
+	 */
+	unsigned int x_position2;
+	/*!
+	 * Touch Screen X position3
+	 */
+	unsigned int x_position3;
+	/*!
+	 * Touch Screen Y position
+	 */
+	unsigned int y_position;
+	/*!
+	 * Touch Screen Y position1
+	 */
+	unsigned int y_position1;
+	/*!
+	 * Touch Screen Y position2
+	 */
+	unsigned int y_position2;
+	/*!
+	 * Touch Screen Y position3
+	 */
+	unsigned int y_position3;
+	/*!
+	 * Touch Screen contact value
+	 */
+	unsigned int contact_resistance;
+} t_touch_screen;
+
+/*!
+ * This enumeration defines ADC conversion modes.
+ */
+typedef enum {
+	/*!
+	 * Sample 8 channels, 1 sample per channel
+	 */
+	ADC_8CHAN_1X = 0,
+	/*!
+	 * Sample 1 channel 8 times
+	 */
+	ADC_1CHAN_8X,
+} t_conversion_mode;
+
+/*!
+ * This structure is used with IOCTL code \a PMIC_ADC_CONVERT,
+ * \a PMIC_ADC_CONVERT_8X and \a PMIC_ADC_CONVERT_MULTICHANNEL.
+ */
+
+typedef struct {
+	/*!
+	 * channel or channels to be sampled.
+	 */
+	t_channel channel;
+	/*!
+	 * holds up to 16 sampling results
+	 */
+	unsigned short result[16];
+} t_adc_convert_param;
+
+/*!
+ * This structure is used to activate/deactivate ADC comparator. 
+ */
+typedef struct {
+	/*!
+	 * wlow.
+	 */
+	unsigned char wlow;
+	/*!
+	 * whigh.
+	 */
+	unsigned char whigh;
+	/*!
+	 * channel to monitor
+	 */
+	t_channel channel;
+	/*!
+	 * callback function.
+	 */
+	t_comparator_cb callback;
+} t_adc_comp_param;
+
+/* EXPORTED FUNCTIONS */
+
+#ifdef __KERNEL__
+/*!
+ * This function initializes all ADC registers with default values. This
+ * function also registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_init(void);
+
+/*!
+ * This function disables the ADC, de-registers the interrupt events.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deinit(void);
+
+/*!
+ * This function triggers a conversion and returns one sampling result of one
+ * channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to the conversion result. The memory
+ *                         should be allocated by the caller of this function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns eight sampling results of
+ * one channel.
+ *
+ * @param        channel   The channel to be sampled
+ * @param        result    The pointer to array to store eight sampling results.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_8x(t_channel channel, unsigned short *result);
+
+/*!
+ * This function triggers a conversion and returns sampling results of each
+ * specified channel.
+ *
+ * @param        channels  This input parameter is bitmap to specify channels
+ *                         to be sampled.
+ * @param        result    The pointer to array to store sampling result.
+ *                         The order of the result in the array is from lowest
+ *                         channel number to highest channel number of the
+ *                         sampled channels.
+ *                         The memory should be allocated by the caller of this
+ *                         function.
+ *			   Note that the behavior of this function might differ
+ *			   from one platform to another regarding especially
+ *			   channels order.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_convert_multichnnel(t_channel channels,
+					 unsigned short *result);
+
+/*!
+ * This function sets touch screen operation mode.
+ *
+ * @param        touch_mode   Touch screen operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_set_touch_mode(t_touch_mode touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_mode   Pointer to the retrieved touch screen operation
+ *                            mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_mode(t_touch_mode * touch_mode);
+
+/*!
+ * This function retrieves the current touch screen operation mode.
+ *
+ * @param        touch_sample Pointer to touch sample.
+ * @param        wait	Indicates if this function needs to block or not.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_touch_sample(t_touch_screen * ts_value, int wait);
+
+/*!
+ * This function starts a Battery Current mode conversion.
+ *
+ * @param        mode      Conversion mode.
+ * @param        result    Battery Current measurement result.
+ *                         if \a mode = ADC_8CHAN_1X, the result is \n
+ *                             result[0] = (BATTP - BATT_I) \n
+ *                         if \a mode = ADC_1CHAN_8X, the result is \n
+ *                             result[0] = BATTP \n
+ *                             result[1] = BATT_I \n
+ *                             result[2] = BATTP \n
+ *                             result[3] = BATT_I \n
+ *                             result[4] = BATTP \n
+ *                             result[5] = BATT_I \n
+ *                             result[6] = BATTP \n
+ *                             result[7] = BATT_I
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_get_battery_current(t_conversion_mode mode,
+					 unsigned short *result);
+
+/*!
+ * This function actives the comparator.  When comparator is activated and ADC
+ * is enabled, the 8th converted value will be digitally compared against the
+ * window defined by WLOW and WHIGH registers.
+ *
+ * @param        low      Comparison window low threshold (WLOW).
+ * @param        high     Comparison window high threshold (WHIGH).
+ * @param        callback Callback function to be called when the converted
+ *                        value is beyond the comparison window.  The callback
+ *                        function will pass a parameter of type
+ *                        \b t_comp_expection to indicate the reason of
+ *                        comparator exception.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_adc_active_comparator(unsigned char low,
+				       unsigned char high,
+				       t_channel channel,
+				       t_comparator_cb callback);
+
+/*!
+ * This function de-actives the comparator.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_adc_deactive_comparator(void);
+
+/*!
+ * This function enables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_install_ts(void);
+
+/*!
+ * This function disables the touch screen read interface.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_adc_remove_ts(void);
+#endif				/* _KERNEL */
+#endif				/* __ASM_ARCH_MXC_PMIC_ADC_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pmic_audio.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pmic_audio.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,2302 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_AUDIO_H__
+#define __ASM_ARCH_MXC_PMIC_AUDIO_H__
+
+/*!
+ * @defgroup PMIC_AUDIO  PMIC Audio Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_audio.h
+ * @brief External definitions for the PMIC Audio Client driver.
+ *
+ * The PMIC Audio driver and this API were developed to support the
+ * audio playback, recording, and mixing capabilities of the power
+ * management ICs that are available from Freescale Semiconductor, Inc.
+ *
+ * The following table shows which audio-related capabilities are supported
+ * by each power management IC:
+ *
+ * @ingroup PMIC_AUDIO
+ */
+
+#include <asm/arch/pmic_status.h>
+#include <asm/arch/pmic_external.h>
+
+/***************************************************************************
+ *                       TYPEDEFS AND ENUMERATIONS                         *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Audio Device Access Typedefs and Enumerations
+ * Typedefs and enumerations that are used for initial access to the
+ * PMIC Audio hardware.
+ */
+/*@{*/
+
+/*!
+ * @typedef PMIC_AUDIO_HANDLE
+ * @brief Define typedef for a handle to the PMIC Audio hardware.
+ *
+ * Define a "handle" that is returned when the PMIC Audio hardware
+ * is opened. This handle grants exclusive access to the PMIC Audio
+ * hardware and must be used in all subsequent function calls. When access
+ * to the PMIC Audio hardware is no longer required, then a close
+ * operation must be done with this handle. The handle is no longer valid
+ * if the close operation was successful.
+ */
+typedef long *PMIC_AUDIO_HANDLE;
+
+/*!
+ * @enum PMIC_AUDIO_EVENTS
+ * @brief Identify the audio events that have been detected and should be
+ * handled.
+ *
+ * This enumeration defines all of the possible PMIC Audio events. Multiple
+ * events may be selected when defining a mask and multiple events may be
+ * signalled together.
+ *
+ * Note that the MICROPHONE_DETECT and MICROPHONE_REMOVED events may also be
+ * used to signal the operation of a serial or parallel microphone switch
+ * when used with a combined headset+microphone device. In that case the
+ * HEADSET_DETECT state must also be checked to determine if it's only the
+ * microphone switch being operated or whether the microphone has truly been
+ * inserted/removed (along with the headset).
+ */
+typedef enum {
+	HEADSET_DETECTED = 1,	/*!< Detected headset insertion.      */
+	HEADSET_STEREO = 2,	/*!< Detected stereo headset device.  */
+	HEADSET_MONO = 4,	/*!< Detected mono headset device.    */
+	HEADSET_THERMAL_SHUTDOWN = 8,	/*!< Detected output amplifier
+					   shutdown due to thermal
+					   limits .      */
+	HEADSET_SHORT_CIRCUIT = 16,	/*!< Detected output amplifier
+					   short circuit condition
+					   .             */
+	HEADSET_REMOVED = 32,	/*!< Detected headset removal.        */
+	MICROPHONE_DETECTED = 64,	/*!< Detected microphone insertion.   */
+	MICROPHONE_REMOVED = 128,	/*!< Detected microphone removal.     */
+	PTT_BUTTON_PRESS = 256,	/*!< Detected PTT button down
+				   .        */
+	PTT_BUTTON_RANGE = 512,	/*!< Detected PTT button within
+				   voltage range
+				   .        */
+	PTT_SHORT_OR_INVALID = 1024	/*!< Detected PTT button outside
+					   of voltage range or invalid
+					   device  . */
+} PMIC_AUDIO_EVENTS;
+
+/*!
+ * @typedef PMIC_AUDIO_CALLBACK
+ * @brief Typedef for PMIC Audio event notification callback function.
+ *
+ * Define a typedef for the PMIC Audio event notification callback
+ * function. The signalled events are passed to the function as the first
+ * argument. The callback function should then process whatever events it
+ * can and then return the set of unhandled events (if any).
+ */
+typedef PMIC_AUDIO_EVENTS(*PMIC_AUDIO_CALLBACK) (const PMIC_AUDIO_EVENTS event);
+
+/*!
+ * @enum PMIC_AUDIO_SOURCE
+ * @brief Select an audio signal processing component.
+ *
+ * This enumeration defines all of the possible PMIC audio signal handling
+ * components which can be acquired by calling pmic_audio_open().
+ *
+ * Note that the EXTERNAL_STEREO_IN selection is used to simply gain access
+ * to the stereo input pins. The stereo input signal can then be routed
+ * directly to the output amplifiers. In this case, no signal processing is
+ * done by either the Voice CODEC or the Stereo DAC.
+ */
+typedef enum {
+	STEREO_DAC,		/*!< Open connection to Stereo DAC.             */
+	VOICE_CODEC,		/*!< Open connection to Voice CODEC.            */
+	EXTERNAL_STEREO_IN	/*!< Open connection to external stereo inputs. */
+} PMIC_AUDIO_SOURCE;
+
+/*@}*/
+
+/*!
+ * @name Data Bus Setup and Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used to define and configure
+ * the data bus protocol in order to communicate with the Stereo DAC
+ * or the Voice CODEC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_DATA_BUS
+ * @brief Select the data bus used to transfer data between the host and
+ *        Voice CODEC and/or the Stereo DAC.
+ *
+ * This enumeration defines all of the possible PMIC audio data buses that
+ * can be used to transfer data between the host and the Voice CODEC and/or
+ * the Stereo DAC on the PMIC.
+ *
+ * Note that the same data bus may be used to transfer audio data to/from
+ * the Voice CODEC and the Stereo DAC. However, in this case, the data bus
+ * must be configured for network mode with different timeslots assigned to
+ * the Voice CODEC and the Stereo DAC. Also, the sampling rates must be
+ * identical for both the Voice CODEC and the Stereo DAC in order to avoid
+ * a data bus timing conflict and audio signal distortion.
+ */
+typedef enum {
+	AUDIO_DATA_BUS_1,	/*!< Use data bus 1 for audio data. */
+	AUDIO_DATA_BUS_2	/*!< Use data bus 2 for audio data. */
+} PMIC_AUDIO_DATA_BUS;
+
+/*!
+ * @enum PMIC_AUDIO_BUS_PROTOCOL
+ * @brief Select the data bus protocol to be used.
+ *
+ * This enumeration defines all of the possible PMIC audio data bus protocols
+ * that may be selected.
+ */
+typedef enum {
+	NORMAL_MSB_JUSTIFIED_MODE,	/*!< Transmit and receive audio data
+					   in normal MSB-justified mode.       */
+	NETWORK_MODE,		/*!< Transmit and receive audio data
+				   in network mode.                    */
+	I2S_MODE,		/*!< Transmit and receive audio data
+				   in I2S mode.                        */
+	SPD_IF_MODE		/*!< Transmit and receive audio data
+				   in SPD/IF mode  . */
+} PMIC_AUDIO_BUS_PROTOCOL;
+
+/*!
+ * @enum PMIC_AUDIO_BUS_MODE
+ * @brief Select the data bus mode to be used.
+ *
+ * This enumeration defines all of the possible PMIC audio data bus modes
+ * that may be selected. When configured in BUS_MASTER_MODE, the PMIC is
+ * responsible for supplying the data bus clock signals. Alternatively,
+ * when configured in BUS_SLAVE_MODE, the PMIC will use the data bus clock
+ * signals that are supplied by the bus master.
+ */
+typedef enum {
+	BUS_MASTER_MODE = 0,	/*!< Operate as bus master.       */
+	BUS_SLAVE_MODE = 1	/*!< Operate as bus slave.        */
+} PMIC_AUDIO_BUS_MODE;
+
+/*!
+ * @enum PMIC_AUDIO_CLOCK_IN_SOURCE
+ * @brief Select the clock signal source when in bus master mode.
+ *
+ * This enumeration defines all of the possible PMIC audio clock signal
+ * sources that may be selected. One of these clock signal sources must
+ * be selected in order to use either the Voice CODEC or the Stereo DAC.
+ *
+ * When configured in BUS_MASTER_MODE, the PMIC's onboard PLL circuits
+ * will also be driven by the selected clock input signal.
+ */
+typedef enum {
+	CLOCK_IN_DEFAULT,	/*!< Just use default (power-up) clock input.      */
+	CLOCK_IN_CLIA,		/*!< Use the CLIA clock source (Stereo DAC
+				   default) .                 */
+	CLOCK_IN_CLIB,		/*!< Use the CLIB clock source (Voice CODEC
+				   default) .                 */
+	CLOCK_IN_CLKIN,		/*!< Use the CLKIN clock source
+				   .                     */
+	CLOCK_IN_MCLK,		/*!< Disable the internal PLL and use the MCLK
+				   clock source (Stereo DAC only)
+				   .                     */
+	CLOCK_IN_FSYNC,		/*!< Internal PLL input from external framesync
+				   (Stereo DAC only) .   */
+	CLOCK_IN_BITCLK		/*!< Internal PLL input from external bitclock
+				   (Stereo DAC only)     */
+} PMIC_AUDIO_CLOCK_IN_SOURCE;
+
+/*!
+ * @enum PMIC_AUDIO_CLOCK_INVERT
+ * @brief Select whether to invert the frame sync or bit clock signals.
+ *
+ * This enumeration enables or disables the inversion of the incoming
+ * frame sync or bit clock signals.
+ */
+typedef enum {
+	NO_INVERT = 0,		/*!< Do not invert the clock signals.    */
+	INVERT_BITCLOCK = 1,	/*!< Invert the BCLK input signal.       */
+	INVERT_FRAMESYNC = 2	/*!< Invert the FSYNC input signal.      */
+} PMIC_AUDIO_CLOCK_INVERT;
+
+/*!
+ * @enum PMIC_AUDIO_NUMSLOTS
+ * @brief Select whether to invert the frame sync or bit clock signals.
+ *
+ * This enumeration defines all of the possible number of timeslots that may
+ * be selected when the PMIC is configured as the data bus master. One of these
+ * options must be selected if the Stereo DAC is to provide the data bus
+ * clock signals.
+ *
+ * Note that the Voice CODEC currently only allows USE_4_TIMESLOTS when
+ * operating in data bus master mode.
+ */
+typedef enum {
+	USE_2_TIMESLOTS,	/*!< Configure for 2 timeslots. */
+	USE_4_TIMESLOTS,	/*!< Configure for 4 timeslots. */
+	USE_8_STAR_TIMESLOTS,	/*!< Configure for 8 (Left, Right, 6 other) timeslots. */
+	USE_8_TIMESLOTS		/*!< Configure for 8 timeslots. */
+} PMIC_AUDIO_NUMSLOTS;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_SAMPLING_RATE
+ * @brief Select the audio data sampling rate for the Stereo DAC.
+ *
+ * This enumeration defines all of the possible sampling rates currently
+ * supported by the Stereo DAC. One of these sampling rates must be selected
+ * and it must match that of the audio stream or else signal distortion will
+ * occur.
+ */
+typedef enum {
+	STDAC_RATE_8_KHZ,	/*!< Use 8 kHz sampling rate.      */
+	STDAC_RATE_11_025_KHZ,	/*!< Use 11.025 kHz sampling rate. */
+	STDAC_RATE_12_KHZ,	/*!< Use 12 kHz sampling rate.     */
+	STDAC_RATE_16_KHZ,	/*!< Use 16 kHz sampling rate.     */
+	STDAC_RATE_22_050_KHZ,	/*!< Use 22.050 kHz sampling rate. */
+	STDAC_RATE_24_KHZ,	/*!< Use 24 kHz sampling rate.     */
+	STDAC_RATE_32_KHZ,	/*!< Use 32 kHz sampling rate.     */
+	STDAC_RATE_44_1_KHZ,	/*!< Use 44.1 kHz sampling rate.   */
+	STDAC_RATE_48_KHZ,	/*!< Use 48 kHz sampling rate.     */
+	STDAC_RATE_64_KHZ,	/*!< Use 64 kHz sampling rate
+				   .          */
+	STDAC_RATE_96_KHZ	/*!< Use 96 kHz sampling rate.
+				   .          */
+} PMIC_AUDIO_STDAC_SAMPLING_RATE;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_SAMPLING_RATE
+ * @brief Select the audio data sampling rate for the Voice CODEC.
+ *
+ * This enumeration defines all of the possible sampling rates currently
+ * supported by the Voice CODEC. One of these sampling rates must be selected
+ * and it must match that of the audio stream or else signal distortion will
+ * occur.
+ */
+typedef enum {
+	VCODEC_RATE_8_KHZ,	/*!< Use 8 kHz sampling rate.      */
+	VCODEC_RATE_16_KHZ,	/*!< Use 16 kHz sampling rate.     */
+} PMIC_AUDIO_VCODEC_SAMPLING_RATE;
+
+/*!
+ * @enum PMIC_AUDIO_ANTI_POP_RAMP_SPEED
+ * @brief Select the anti-pop circuitry's ramp up speed.
+ *
+ * This enumeration defines all of the possible ramp up speeds for the
+ * anti-pop circuitry. A slow ramp up speed may be required in order to
+ * avoid the popping noise that is typically generated during the insertion
+ * or removal of a headset or microphone.
+ */
+typedef enum {
+	ANTI_POP_RAMP_FAST,	/*!< Select fast ramp up.          */
+	ANTI_POP_RAMP_SLOW	/*!< Select slow ramp up.          */
+} PMIC_AUDIO_ANTI_POP_RAMP_SPEED;
+
+/*@}*/
+
+/*!
+ * @name General Voice CODEC Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used to define and configure
+ * the basic operating options for the Voice CODEC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ
+ * @brief Select the Voice CODEC input clock frequency.
+ *
+ * This enumeration defines all of the supported Voice CODEC input clock
+ * frequencies. One of these frequencies must be selected in order to
+ * properly configure the Voice CODEC to operate at the required sampling
+ * rate.
+ */
+typedef enum {
+	VCODEC_CLI_13MHZ,	/*!< Clock frequency is 13MHz.    */
+	VCODEC_CLI_15_36MHZ,	/*!< Clock frequency is 15.36MHz. */
+	VCODEC_CLI_16_8MHZ,	/*!< Clock frequency is 16.8MHz
+				   .         */
+	VCODEC_CLI_26MHZ,	/*!< Clock frequency is 26MHz.    */
+	VCODEC_CLI_33_6MHZ,	/*!< Clock frequency is 33.6MHz.  */
+} PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_CONFIG
+ * @brief Select the Voice CODEC configuration options.
+ *
+ * This enumeration is used to enable/disable each of the Voice CODEC options.
+ * This includes the use of highpass digital filters and audio signal
+ * loopback modes.
+ *
+ * Note that resetting the digital filters is now handled by the
+ * pmic_audio_digital_filter_reset() API.
+ */
+typedef enum {
+	DITHERING = 1,		/*!< Enable/disable dithering.      */
+	INPUT_HIGHPASS_FILTER = 2,	/*!< Enable/disable the input high
+					   pass digital filter.           */
+	OUTPUT_HIGHPASS_FILTER = 4,	/*!< Enable/disable the output high
+					   pass digital filter.           */
+	ANALOG_LOOPBACK = 8,	/*!< Enable/disable the analog
+				   loopback path
+				   .           */
+	DIGITAL_LOOPBACK = 16,	/*!< Enable/disable the digital
+				   loopback path.                 */
+	VCODEC_MASTER_CLOCK_OUTPUTS = 32,	/*!< Enable/disable the bus master
+						   clock outputs.                 */
+	TRISTATE_TS = 64	/*!< Enable/disable FSYNC, BITCLK,
+				   and TX tristate.               */
+} PMIC_AUDIO_VCODEC_CONFIG;
+
+/*@}*/
+
+/*!
+ * @name General Stereo DAC Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used to define and configure
+ * the basic operating options for the Stereo DAC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_CLOCK_IN_FREQ
+ * @brief Select the Stereo DAC input clock frequency.
+ *
+ * This enumeration defines all of the supported Stereo DAC input clock
+ * frequencies. One of these frequencies must be selected in order to
+ * properly configure the Stereo DAC to operate at the required sampling
+ * rate.
+ */
+typedef enum {
+	STDAC_CLI_3_36864MHZ,	/*!< Clock frequency is 3.36864MHz
+				   .                */
+	STDAC_CLI_12MHZ,	/*!< Clock frequency is 12MHz.
+				   .                */
+	STDAC_CLI_13MHZ,	/*!< Clock frequency is 13MHz.           */
+	STDAC_CLI_15_36MHZ,	/*!< Clock frequency is 15.36MHz.        */
+	STDAC_CLI_16_8MHZ,	/*!< Clock frequency is 16.8MHz
+				   .                */
+	STDAC_CLI_26MHZ,	/*!< Clock frequency is 26MHz.           */
+	STDAC_CLI_33_6MHZ,	/*!< Clock frequency is 33.6MHz.         */
+	STDAC_MCLK_PLL_DISABLED,	/*!< Use MCLK and disable internal PLL.  */
+	STDAC_FSYNC_IN_PLL,	/*!< Use FSYNC as internal PLL input.    */
+	STDAC_BCLK_IN_PLL	/*!< Use BCLK as internal PLL input.     */
+} PMIC_AUDIO_STDAC_CLOCK_IN_FREQ;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_CONFIG
+ * @brief Select the Stereo DAC configuration options.
+ *
+ * This enumeration is used to enable/disable each of the Stereo DAC options.
+ */
+typedef enum {
+	STDAC_MASTER_CLOCK_OUTPUTS = 1	/*!< Enable/disable the bus master clock
+					   outputs.                             */
+} PMIC_AUDIO_STDAC_CONFIG;
+
+/*@}*/
+
+/*!
+ * @name Voice CODEC Audio Port Mixing Typedefs and Enumerations
+ * Typedefs and enumerations that are used for setting up the audio mixer
+ * within the Voice CODEC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_TIMESLOT
+ * @brief Select the Stereo DAC configuration options.
+ *
+ * This enumeration is used to select the timeslot for both the primary and
+ * secondary (for mc13783-only) audio channels to the Voice CODEC.
+ */
+typedef enum {
+	USE_TS0,		/*!< Use timeslot 0 for audio signal source
+				   .                    */
+	USE_TS1,		/*!< Use timeslot 1 for audio signal source
+				   .                    */
+	USE_TS2,		/*!< Use timeslot 2 for audio signal source
+				   .                    */
+	USE_TS3			/*!< Use timeslot 3 for audio signal source
+				   .                    */
+} PMIC_AUDIO_VCODEC_TIMESLOT;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_MIX_IN_GAIN
+ * @brief Select the secondary channel input gain for the Voice CODEC mixer.
+ *
+ * This enumeration selects the secondary channel input gain for the Voice
+ * CODEC mixer.
+ */
+typedef enum {
+	VCODEC_NO_MIX,		/*!< No audio mixing .  */
+	VCODEC_MIX_IN_0DB,	/*!< Mix with 0dB secondary channel gain
+				   .                  */
+	VCODEC_MIX_IN_MINUS_6DB,	/*!< Mix with -6dB secondary channel gain
+					   .                  */
+	VCODEC_MIX_IN_MINUS_12DB,	/*!< Mix with -12dB secondary channel gain
+					   .                  */
+} PMIC_AUDIO_VCODEC_MIX_IN_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_VCODEC_MIX_OUT_GAIN
+ * @brief Select the output gain for the Voice CODEC mixer.
+ *
+ * This enumeration selects the output gain for the Voice CODEC mixer.
+ */
+typedef enum {
+	VCODEC_MIX_OUT_0DB,	/*!< Select 0dB mixer output gain
+				   .                  */
+	VCODEC_MIX_OUT_MINUS_6DB,	/*!< Select -6dB mixer output gain
+					   .                  */
+} PMIC_AUDIO_VCODEC_MIX_OUT_GAIN;
+
+/*@}*/
+
+/*!
+ * @name Stereo DAC Audio Port Mixing Typedefs and Enumerations
+ * Typedefs and enumerations that are used for setting up the audio mixer
+ * within the Stereo DAC.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_TIMESLOTS
+ * @brief Select the timeslots used to transmit the left and right audio
+ *        channels to the Stereo DAC.
+ *
+ * This enumeration is used to select the timeslots used to transmit the
+ * data corresponding to the left and right audio channels to the Stereo
+ * DAC.
+ */
+typedef enum {
+	USE_TS0_TS1,		/*!< Use timeslots 0 and 1 for left and
+				   right channels, respectively.      */
+	USE_TS2_TS3,		/*!< Use timeslots 2 and 3 for left and
+				   right channels, respectively
+				   .               */
+	USE_TS4_TS5,		/*!< Use timeslots 4 and 5 for left and
+				   right channels, respectively
+				   .               */
+	USE_TS6_TS7		/*!< Use timeslots 6 and 7 for left and
+				   right channels, respectively
+				   .               */
+} PMIC_AUDIO_STDAC_TIMESLOTS;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_MIX_IN_GAIN
+ * @brief Select the secondary channel input gain for the Stereo DAC mixer.
+ *
+ * This enumeration is used to select the secondary channel input gain for
+ * the Stereo DAC mixer.
+ */
+typedef enum {
+	STDAC_NO_MIX,		/*!< No mixing, keep separate left
+				   and right audio channels.         */
+	STDAC_MIX_IN_0DB,	/*!< Mix left and right audio channels
+				   together with 0dB secondary
+				   channel gain.                     */
+	STDAC_MIX_IN_MINUS_6DB,	/*!< Mix left and right audio channels
+				   together with -6dB secondary
+				   channel gain.                     */
+	STDAC_MIX_IN_MINUS_12DB	/*!< Mix left and right audio channels
+				   together with -12dB secondary
+				   channel gain . */
+} PMIC_AUDIO_STDAC_MIX_IN_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_STDAC_MIX_OUT_GAIN
+ * @brief Select the output gain for the Stereo DAC mixer.
+ *
+ * This enumeration is used to select the output gain for the Stereo DAC
+ * mixer.
+ */
+typedef enum {
+	STDAC_MIX_OUT_0DB,	/*!< Select 0dB mixer output gain.     */
+	STDAC_MIX_OUT_MINUS_6DB,	/*!< Select -6dB mixer output gain
+					   .              */
+} PMIC_AUDIO_STDAC_MIX_OUT_GAIN;
+
+/*@}*/
+
+/*!
+ * @name Microphone Input Typedefs and Enumerations
+ * Typedefs and enumerations that are used for selecting and setting up
+ * one or more or microphone inputs for recording.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_MIC_BIAS
+ * @brief Select the microphone bias circuit to be enabled/disabled.
+ *
+ * This enumeration lists all of the available microphone bias circuits that
+ * may be enabled or disabled.
+ */
+typedef enum {
+	NO_BIAS = 0,		/*!< No microphone bias circuit selected.      */
+	MIC_BIAS1 = 1,		/*!< Enable/disable microphone bias 1 circuit. */
+	MIC_BIAS2 = 2,		/*!< Enable/disable microphone bias 2 circuit. */
+} PMIC_AUDIO_MIC_BIAS;
+
+/*!
+ * @enum PMIC_AUDIO_INPUT_PORT
+ * @brief Select an audio input port for recording.
+ *
+ * This enumeration lists all of the available audio input ports that may
+ * be selected for a recording operation.
+ */
+typedef enum {
+	NO_MIC,			/*!< No microphone input selected.               */
+	MIC1_LEFT,		/*!< Enable left/mono channel microphone input
+				   .                        */
+	MIC1_RIGHT_MIC_MONO,	/*!< Enable right channel microphone input.      */
+	MIC2_AUX,		/*!< Enable auxiliary microphone input.          */
+	TXIN_EXT		/*!< Enable external mono input.                 */
+} PMIC_AUDIO_INPUT_PORT;
+
+/*!
+ * @enum PMIC_AUDIO_INPUT_MIC_STATE
+ * @brief Control whether the input microphone is on/off.
+ *
+ * This enumeration allows the currently selected input microphone amplifier
+ * to be turned on/off.
+ */
+typedef enum {
+	MICROPHONE_ON,		/*!< Turn microphone input on for recording. */
+	MICROPHONE_OFF		/*!< Turn microphone input off (mute).       */
+} PMIC_AUDIO_INPUT_MIC_STATE;
+
+/*!
+ * @enum PMIC_AUDIO_INPUT_CONFIG
+ * @brief Enable/disable the audio input options.
+ *
+ * This enumeration allows for enabling/disabling any of the audio input
+ * section options.
+ */
+typedef enum {
+	MIC_AMP_AUTO_DISABLE = 1	/*!< Enable/disable automatic disabling of
+					   microphone input amplifiers following
+					   headset insertion/removal          */
+} PMIC_AUDIO_INPUT_CONFIG;
+
+/*!
+ * @enum PMIC_AUDIO_MIC_AMP_MODE
+ * @brief Select the operating mode for the microphone amplifiers.
+ *
+ * This enumeration is used to select the operating mode for the microphone
+ * amplifier.
+ */
+typedef enum {
+	AMP_OFF,		/*!< Disable input amplifier.   */
+	VOLTAGE_TO_VOLTAGE,	/*!< Operate input amplifier in
+				   voltage-to-voltage mode
+				   .       */
+	CURRENT_TO_VOLTAGE	/*!< Operate input amplifier in
+				   current-to-voltage mode    */
+} PMIC_AUDIO_MIC_AMP_MODE;
+
+/*!
+ * @enum PMIC_AUDIO_MIC_GAIN
+ * @brief Select the microphone amplifier gain level.
+ *
+ * This enumeration lists all of the available microphone amplifier gain
+ * levels.
+ */
+typedef enum {
+	MIC_GAIN_MINUS_8DB,	/*!< Select -8dB microphone amplifier gain
+				   .                   */
+	MIC_GAIN_MINUS_7DB,	/*!< Select -7dB microphone amplifier gain
+				   .              */
+	MIC_GAIN_MINUS_6DB,	/*!< Select -6dB microphone amplifier gain
+				   .                   */
+	MIC_GAIN_MINUS_5DB,	/*!< Select -5dB microphone amplifier gain
+				   .                   */
+	MIC_GAIN_MINUS_4DB,	/*!< Select -4dB microphone amplifier gain
+				   .                   */
+	MIC_GAIN_MINUS_3DB,	/*!< Select -3dB microphone amplifier gain
+				   .                   */
+	MIC_GAIN_MINUS_2DB,	/*!< Select -2dB microphone amplifier gain
+				   .                   */
+	MIC_GAIN_MINUS_1DB,	/*!< Select -1dB microphone amplifier gain
+				   .                   */
+	MIC_GAIN_0DB,		/*!< Select 0dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_1DB,	/*!< Select 1dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_2DB,	/*!< Select 2dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_3DB,	/*!< Select 3dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_4DB,	/*!< Select 4dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_5DB,	/*!< Select 5dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_6DB,	/*!< Select 6dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_7DB,	/*!< Select 7dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_8DB,	/*!< Select 8dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_9DB,	/*!< Select 9dB microphone amplifier gain.  */
+	MIC_GAIN_PLUS_10DB,	/*!< Select 10dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_11DB,	/*!< Select 11dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_12DB,	/*!< Select 12dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_13DB,	/*!< Select 13dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_14DB,	/*!< Select 14dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_15DB,	/*!< Select 15dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_16DB,	/*!< Select 16dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_17DB,	/*!< Select 17dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_18DB,	/*!< Select 18dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_19DB,	/*!< Select 19dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_20DB,	/*!< Select 20dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_21DB,	/*!< Select 21dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_22DB,	/*!< Select 22dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_23DB,	/*!< Select 23dB microphone amplifier gain. */
+	MIC_GAIN_PLUS_24DB,	/*!< Select 24dB microphone amplifier gain
+				   .              */
+	MIC_GAIN_PLUS_25DB,	/*!< Select 25dB microphone amplifier gain
+				   .              */
+	MIC_GAIN_PLUS_26DB,	/*!< Select 26dB microphone amplifier gain
+				   .              */
+	MIC_GAIN_PLUS_27DB,	/*!< Select 27dB microphone amplifier gain
+				   .              */
+	MIC_GAIN_PLUS_28DB,	/*!< Select 28dB microphone amplifier gain
+				   .              */
+	MIC_GAIN_PLUS_29DB,	/*!< Select 29dB microphone amplifier gain
+				   .              */
+	MIC_GAIN_PLUS_30DB,	/*!< Select 30dB microphone amplifier gain
+				   .              */
+	MIC_GAIN_PLUS_31DB	/*!< Select 31dB microphone amplifier gain
+				   .              */
+} PMIC_AUDIO_MIC_GAIN;
+
+/*@}*/
+
+/*!
+ * @name Audio Output Section Typedefs and Enumerations
+ * Typedefs and enumerations that are used for selecting and setting up
+ * one or more or audio output ports for playback.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_PORT
+ * @brief Select the audio output port.
+ *
+ * This enumeration lists all of the available audio output ports. One or
+ * more may be selected as desired to handle the output audio stream from
+ * either the Voice CODEC or the Stereo DAC.
+ */
+typedef enum {
+	MONO_SPEAKER = 1,	/*!< Select mono output speaker.            */
+	MONO_LOUDSPEAKER = 2,	/*!< Select mono loudspeaker
+				   .                   */
+	MONO_ALERT = 4,		/*!< Select mono alert output               */
+	MONO_EXTOUT = 8,	/*!< Select mono external output            */
+	MONO_CDCOUT = 16,	/*!< Select dedicated Voice CODEC output
+				   .                   */
+	STEREO_LEFT_LOW_POWER = 32,	/*!< Select stereo left channel low power
+					   output .            */
+	STEREO_HEADSET_LEFT = 64,	/*!< Select stereo headset left channel.    */
+	STEREO_HEADSET_RIGHT = 128,	/*!< Select stereo headset right channel.   */
+	STEREO_OUT_LEFT = 256,	/*!< Select stereo external left channel
+				   output .            */
+	STEREO_OUT_RIGHT = 512	/*!< Select stereo external right channel
+				   output .            */
+} PMIC_AUDIO_OUTPUT_PORT;
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_CONFIG
+ * @brief Enable/disable the audio output section options.
+ *
+ * This enumeration is used to enable/disable any of the audio output section
+ * options.
+ */
+typedef enum {
+	MONO_SPEAKER_INVERT_OUT_ONLY = 1,	/*!< Enable/disable the non-inverted
+						   mono speaker output          */
+	MONO_LOUDSPEAKER_COMMON_BIAS = 2,	/*!< Enable/disable the loudspeaker
+						   output amplifier common bias
+						   .            */
+	HEADSET_DETECT_ENABLE = 4,	/*!< Enable/disable headset
+					   insertion/removal detection
+					   .            */
+	STEREO_HEADSET_AMP_AUTO_DISABLE = 8	/*!< Enable/disable automatic
+						   disabling of the stereo headset
+						   output amplifiers following
+						   headset insertion/removal.      */
+} PMIC_AUDIO_OUTPUT_CONFIG;
+
+/*!
+ * @enum PMIC_AUDIO_STEREO_IN_GAIN
+ * @brief Select the amplifier gain for the external stereo inputs.
+ *
+ * This enumeration is used to select the amplifier gain level to be used for
+ * the external stereo inputs.
+ */
+typedef enum {
+	STEREO_IN_GAIN_0DB,	/*!< Select 0dB external stereo signal
+				   input gain.                        */
+	STEREO_IN_GAIN_PLUS_18DB	/*!< Select 18dB external stereo signal
+					   input gain .    */
+} PMIC_AUDIO_STEREO_IN_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_PGA_GAIN
+ * @brief Select the output PGA amplifier gain level.
+ *
+ * This enumeration is used to select the output PGA amplifier gain level.
+ */
+typedef enum {
+	OUTPGA_GAIN_MINUS_33DB,	/*!< Select -33dB output PGA gain
+				   .          */
+	OUTPGA_GAIN_MINUS_30DB,	/*!< Select -30dB output PGA gain
+				   .          */
+	OUTPGA_GAIN_MINUS_27DB,	/*!< Select -27dB output PGA gain
+				   .          */
+	OUTPGA_GAIN_MINUS_24DB,	/*!< Select -24dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_21DB,	/*!< Select -21dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_18DB,	/*!< Select -18dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_15DB,	/*!< Select -15dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_12DB,	/*!< Select -12dB output PGA gain. */
+	OUTPGA_GAIN_MINUS_9DB,	/*!< Select -9dB output PGA gain.  */
+	OUTPGA_GAIN_MINUS_6DB,	/*!< Select -6dB output PGA gain.  */
+	OUTPGA_GAIN_MINUS_3DB,	/*!< Select -3dB output PGA gain.  */
+	OUTPGA_GAIN_0DB,	/*!< Select 0dB output PGA gain.   */
+	OUTPGA_GAIN_PLUS_3DB,	/*!< Select 3dB output PGA gain.   */
+	OUTPGA_GAIN_PLUS_6DB,	/*!< Select 6dB output PGA gain.   */
+	OUTPGA_GAIN_PLUS_9DB,	/*!< Select 9dB output PGA gain.
+				   .     */
+	OUTPGA_GAIN_PLUS_12DB,	/*!< Select 12dB output PGA gain
+				   .     */
+	OUTPGA_GAIN_PLUS_15DB,	/*!< Select 15dB output PGA gain
+				   .     */
+	OUTPGA_GAIN_PLUS_18DB,	/*!< Select 18dB output PGA gain
+				   .     */
+	OUTPGA_GAIN_PLUS_21DB	/*!< Select 21dB output PGA gain
+				   .     */
+} PMIC_AUDIO_OUTPUT_PGA_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+ * @brief Select the left/right channel balance gain level.
+ *
+ * This enumeration is used to select the balance gain level that is to be
+ * separately applied to the left and right audio channels.
+ */
+typedef enum {
+	BAL_GAIN_MINUS_21DB,	/*!< Select -21dB channel balance
+				   gain .        */
+	BAL_GAIN_MINUS_18DB,	/*!< Select -18dB channel balance
+				   gain .        */
+	BAL_GAIN_MINUS_15DB,	/*!< Select -15dB channel balance
+				   gain .        */
+	BAL_GAIN_MINUS_12DB,	/*!< Select -12dB channel balance
+				   gain .        */
+	BAL_GAIN_MINUS_9DB,	/*!< Select -9dB channel balance
+				   gain .        */
+	BAL_GAIN_MINUS_6DB,	/*!< Select -6dB channel balance
+				   gain .        */
+	BAL_GAIN_MINUS_3DB,	/*!< Select -3dB channel balance
+				   gain .        */
+	BAL_GAIN_0DB		/*!< Select 0dB channel balance gain. */
+} PMIC_AUDIO_OUTPUT_BALANCE_GAIN;
+
+/*!
+ * @enum PMIC_AUDIO_MONO_ADDER_MODE
+ * @brief Select the output mono adder operating mode.
+ *
+ * This enumeration is used to select the operating mode for the mono adder
+ * in the audio output section.
+ */
+typedef enum {
+	MONO_ADDER_OFF,		/*!< Disable mono adder (keep separate
+				   left and right channels).         */
+	MONO_ADD_LEFT_RIGHT,	/*!< Add left and right channels.      */
+	MONO_ADD_OPPOSITE_PHASE,	/*!< Add left and right channels but
+					   with outputs in opposite phase
+					   .              */
+	STEREO_OPPOSITE_PHASE	/*!< Keep separate left and right
+				   channels but invert phase of
+				   left channel . */
+} PMIC_AUDIO_MONO_ADDER_MODE;
+
+/*!
+ * @enum PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+ * @brief Select the mono adder output amplifier gain level.
+ *
+ * This enumeration is used to select the output amplifier gain level for
+ * the mono adder.
+ */
+typedef enum {
+	MONOADD_GAIN_MINUS_6DB,	/*!< Select -6dB mono adder output gain
+				   .          */
+	MONOADD_GAIN_MINUS_3DB,	/*!< Select -3dB mono adder output gain
+				   .          */
+	MONOADD_GAIN_0DB	/*!< Select 0dB mono adder output gain. */
+} PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN;
+
+/*@}*/
+
+/***************************************************************************
+ *                       PMIC-SPECIFIC DEFINITIONS                         *
+ ***************************************************************************/
+
+/*!
+ * @name Definition of PMIC-specific Capabilities
+ * Constants that are used to define PMIC-specific capabilities.
+ */
+/*@{*/
+
+/*!
+ * Define the minimum Stereo DAC sampling rate (Hz).
+ */
+extern const unsigned MIN_STDAC_SAMPLING_RATE_HZ;
+/*!
+ * Define the maximum Stereo DAC sampling rate (Hz).
+ */
+extern const unsigned MAX_STDAC_SAMPLING_RATE_HZ;
+
+/*@}*/
+
+#define DEBUG_AUDIO
+
+#ifdef __KERNEL__
+
+/***************************************************************************
+ *                          PMIC API DEFINITIONS                           *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Audio
+ * hardware.
+ */
+/*@{*/
+
+/*!
+ * This function enables the Headset detection mechanism in hardware
+ */
+PMIC_STATUS pmic_audio_set_autodetect(int val);
+
+/*!
+ * @brief Request exclusive access to the PMIC Audio hardware.
+ *
+ * Attempt to open and gain exclusive access to a key PMIC audio hardware
+ * component (e.g., the Stereo DAC or the Voice CODEC). Depending upon the
+ * type of audio operation that is desired and the nature of the audio data
+ * stream, the Stereo DAC and/or the Voice CODEC will be a required hardware
+ * component and needs to be acquired by calling this function.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls to complete
+ * the configuration of either the Stereo DAC or the Voice CODEC and along
+ * with any other associated audio hardware components that will be needed.
+ *
+ * The same handle must also be used in the close call when use of the PMIC
+ * audio hardware is no longer required.
+ *
+ * The open request will fail if the requested audio hardware component has
+ * already been acquired by a previous open call but not yet closed.
+ *
+ * @param[out]  handle          Device handle to be used for subsequent PMIC
+ *                              Connectivity API calls.
+ * @param[in]   device          The required PMIC audio hardware component.
+ *
+ * @retval      PMIC_SUCCESS         If the open request was successful
+ * @retval      PMIC_PARAMETER_ERROR If the handle argument is NULL.
+ * @retval      PMIC_ERROR           If the audio hardware component is
+ *                                   unavailable.
+ */
+PMIC_STATUS pmic_audio_open(PMIC_AUDIO_HANDLE * const handle,
+			    const PMIC_AUDIO_SOURCE device);
+
+/*!
+ * @brief Terminate further access to the PMIC audio hardware.
+ *
+ * Terminate further access to the PMIC audio hardware that was previously
+ * acquired by calling pmic_audio_open(). This now allows another thread to
+ * successfully call pmic_audio_open() to gain access.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_close(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Configure the data bus protocol to be used.
+ *
+ * Provide the parameters needed to properly configure the audio data bus
+ * protocol so that data can be read/written to either the Stereo DAC or
+ * the Voice CODEC.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   busID           Select data bus to be used.
+ * @param[in]   protocol        Select the data bus protocol.
+ * @param[in]   masterSlave     Select the data bus timing mode.
+ * @param[in]   numSlots        Define the number of timeslots (only if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the protocol parameters
+ *                                   are invalid.
+ */
+PMIC_STATUS pmic_audio_set_protocol(const PMIC_AUDIO_HANDLE handle,
+				    const PMIC_AUDIO_DATA_BUS busID,
+				    const PMIC_AUDIO_BUS_PROTOCOL protocol,
+				    const PMIC_AUDIO_BUS_MODE masterSlave,
+				    const PMIC_AUDIO_NUMSLOTS numSlots);
+
+/*!
+ * @brief Retrieve the current data bus protocol configuration.
+ *
+ * Retrieve the parameters that define the current audio data bus protocol.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  busID           The data bus being used.
+ * @param[out]  protocol        The data bus protocol being used.
+ * @param[out]  masterSlave     The data bus timing mode being used.
+ * @param[out]  numSlots        The number of timeslots being used (if in
+ *                              master mode).
+ *
+ * @retval      PMIC_SUCCESS         If the protocol was successful retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_protocol(const PMIC_AUDIO_HANDLE handle,
+				    PMIC_AUDIO_DATA_BUS * const busID,
+				    PMIC_AUDIO_BUS_PROTOCOL * const protocol,
+				    PMIC_AUDIO_BUS_MODE * const masterSlave,
+				    PMIC_AUDIO_NUMSLOTS * const numSlots);
+
+/*!
+ * @brief Enable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly enable the Stereo DAC or the Voice CODEC to begin audio
+ * playback or recording as required. This should only be done after
+ * successfully configuring all of the associated audio components (e.g.,
+ * microphones, amplifiers, etc.).
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was successful enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the device could not be enabled.
+ */
+PMIC_STATUS pmic_audio_enable(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Disable the Stereo DAC or the Voice CODEC.
+ *
+ * Explicitly disable the Stereo DAC or the Voice CODEC to end audio
+ * playback or recording as required.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the device was successful disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the device could not be disabled.
+ */
+PMIC_STATUS pmic_audio_disable(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Reset the selected audio hardware control registers to their
+ *        power on state.
+ *
+ * This resets all of the audio hardware control registers currently
+ * associated with the device handle back to their power on states. For
+ * example, if the handle is associated with the Stereo DAC and a
+ * specific output port and output amplifiers, then this function will
+ * reset all of those components to their power on state.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Reset all audio hardware control registers to their power on state.
+ *
+ * This resets all of the audio hardware control registers back to their
+ * power on states. Use this function with care since it also invalidates
+ * (i.e., automatically closes) all currently opened device handles.
+ *
+ * @retval      PMIC_SUCCESS         If the reset operation was successful.
+ * @retval      PMIC_ERROR           If the reset was unsuccessful.
+ */
+PMIC_STATUS pmic_audio_reset_all(void);
+
+/*!
+ * @brief Set the Audio callback function.
+ *
+ * Register a callback function that will be used to signal PMIC audio
+ * events. For example, the OSS audio driver should register a callback
+ * function in order to be notified of headset connect/disconnect events.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   func            A pointer to the callback function.
+ * @param[in]   eventMask       A mask selecting events to be notified.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully
+ *                                   registered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the eventMask is invalid.
+ */
+PMIC_STATUS pmic_audio_set_callback(const PMIC_AUDIO_HANDLE handle,
+				    const PMIC_AUDIO_CALLBACK func,
+				    const PMIC_AUDIO_EVENTS eventMask);
+
+/*!
+ * @brief Deregisters the existing audio callback function.
+ *
+ * Deregister the callback function that was previously registered by calling
+ * pmic_audio_set_callback().
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully
+ *                                   deregistered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_clear_callback(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Get the current audio callback function settings.
+ *
+ * Get the current callback function and event mask.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  func            The current callback function.
+ * @param[out]  eventMask       The current event selection mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback information was
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_audio_get_callback(const PMIC_AUDIO_HANDLE handle,
+				    PMIC_AUDIO_CALLBACK * const func,
+				    PMIC_AUDIO_EVENTS * const eventMask);
+
+/*!
+ * @brief Enable the anti-pop circuitry to avoid extra noise when inserting
+ *        or removing a external device (e.g., a headset).
+ *
+ * Enable the use of the built-in anti-pop circuitry to prevent noise from
+ * being generated when an external audio device is inserted or removed
+ * from an audio plug. A slow ramp speed may be needed to avoid extra noise.
+ *
+ * @param[in]   rampSpeed       The desired anti-pop circuitry ramp speed.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop circuitry was successfully
+ *                                   enabled.
+ * @retval      PMIC_ERROR           If the anti-pop circuitry could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_antipop_enable(const PMIC_AUDIO_ANTI_POP_RAMP_SPEED
+				      rampSpeed);
+
+/*!
+ * @brief Disable the anti-pop circuitry.
+ *
+ * Disable the use of the built-in anti-pop circuitry to prevent noise from
+ * being generated when an external audio device is inserted or removed
+ * from an audio plug.
+ *
+ * @retval      PMIC_SUCCESS         If the anti-pop circuitry was successfully
+ *                                   disabled.
+ * @retval      PMIC_ERROR           If the anti-pop circuitry could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_antipop_disable(void);
+
+/*!
+ * @brief Performs a reset of the Voice CODEC/Stereo DAC digital filter.
+ *
+ * This function performs a reset of the digital filter using the back-to-back
+ * SPI write procedure.
+ *
+ * @retval      PMIC_SUCCESS         If the digital filter was successfully
+ *                                   reset.
+ * @retval      PMIC_ERROR           If the digital filter could not be reset.
+ */
+PMIC_STATUS pmic_audio_digital_filter_reset(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Get the most recent PTT button voltage reading.
+ *
+ * This function returns the most recent reading for the PTT button voltage.
+ * The value may be used during the processing of the PTT_BUTTON_RANGE event
+ * as part of the headset ID detection process.
+ *
+ * @retval      PMIC_SUCCESS         If the most recent PTT button voltage was
+ *                                   returned.
+ * @retval      PMIC_PARAMETER_ERROR If a NULL pointer argument was given.
+ */
+PMIC_STATUS pmic_audio_get_ptt_button_level(unsigned int *const level);
+
+#ifdef DEBUG_AUDIO
+
+/*!
+ * @brief Provide a hexadecimal dump of all PMIC audio registers (DEBUG only).
+ *
+ * This function is intended strictly for debugging purposes only (i.e.,
+ * the DEBUG macro must be defined) and will print the current values of the
+ * following PMIC registers:
+ *
+ * - AUD_CODEC (Voice CODEC state)
+ * - ST_DAC (Stereo DAC state)
+ * - RX_AUD_AMPS (audio input section state)
+ * - TX_AUD_AMPS (audio output section state)
+ *
+ * The register fields will also be decoded.
+ */
+void pmic_audio_dump_registers(void);
+
+#endif				/* DEBUG */
+
+/*@}*/
+
+/*!
+ * @name General Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice
+ * CODEC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Voice CODEC clock source and operating characteristics.
+ *
+ * Define the Voice CODEC clock source and operating characteristics. This
+ * must be done before the Voice CODEC is enabled.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   clockIn         Select the clock signal source.
+ * @param[in]   clockFreq       Select the clock signal frequency.
+ * @param[in]   samplingRate    Select the audio data sampling rate.
+ * @param[in]   invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC clock settings were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock configuration was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock configuration
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_clock(const PMIC_AUDIO_HANDLE handle,
+					const PMIC_AUDIO_CLOCK_IN_SOURCE
+					clockIn,
+					const PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ
+					clockFreq,
+					const PMIC_AUDIO_VCODEC_SAMPLING_RATE
+					samplingRate,
+					const PMIC_AUDIO_CLOCK_INVERT invert);
+
+/*!
+ * @brief Get the Voice CODEC clock source and operating characteristics.
+ *
+ * Get the current Voice CODEC clock source and operating characteristics.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  clockIn         The clock signal source.
+ * @param[out]  clockFreq       The clock signal frequency.
+ * @param[out]  samplingRate    The audio data sampling rate.
+ * @param[out]  invert          Inversion of the frame sync and/or
+ *                              bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC clock settings were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC clock configuration
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_clock(const PMIC_AUDIO_HANDLE handle,
+					PMIC_AUDIO_CLOCK_IN_SOURCE *
+					const clockIn,
+					PMIC_AUDIO_VCODEC_CLOCK_IN_FREQ *
+					const clockFreq,
+					PMIC_AUDIO_VCODEC_SAMPLING_RATE *
+					const samplingRate,
+					PMIC_AUDIO_CLOCK_INVERT * const invert);
+
+/*!
+ * @brief Set the Voice CODEC primary audio channel timeslot.
+ *
+ * Set the Voice CODEC primary audio channel timeslot. This function must be
+ * used if the default timeslot for the primary audio channel is to be changed.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   timeslot        Select the primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC primary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC primary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+						const PMIC_AUDIO_VCODEC_TIMESLOT
+						timeslot);
+
+/*!
+ * @brief Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * Get the current Voice CODEC primary audio channel timeslot.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+						PMIC_AUDIO_VCODEC_TIMESLOT *
+						const timeslot);
+
+/*!
+ * @brief Set the Voice CODEC secondary recording audio channel timeslot.
+ *
+ * Set the Voice CODEC secondary audio channel timeslot. This function must be
+ * used if the default timeslot for the secondary audio channel is to be
+ * changed. The secondary audio channel timeslot is used to transmit the audio
+ * data that was recorded by the Voice CODEC from the secondary audio input
+ * channel.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   timeslot        Select the secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_secondary_txslot(const PMIC_AUDIO_HANDLE
+						   handle,
+						   const
+						   PMIC_AUDIO_VCODEC_TIMESLOT
+						   timeslot);
+
+/*!
+ * @brief Get the Voice CODEC secondary recording audio channel timeslot.
+ *
+ * Get the Voice CODEC secondary audio channel timeslot.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  timeslot        The secondary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC secondary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC secondary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_secondary_txslot(const PMIC_AUDIO_HANDLE
+						   handle,
+						   PMIC_AUDIO_VCODEC_TIMESLOT *
+						   const timeslot);
+
+/*!
+ * @brief Set/Enable the Voice CODEC options.
+ *
+ * Set or enable various Voice CODEC options. The available options include
+ * the use of dithering, highpass digital filters, and loopback modes.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Voice CODEC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_config(const PMIC_AUDIO_HANDLE handle,
+					 const PMIC_AUDIO_VCODEC_CONFIG config);
+
+/*!
+ * @brief Clear/Disable the Voice CODEC options.
+ *
+ * Clear or disable various Voice CODEC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Voice CODEC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Voice CODEC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_clear_config(const PMIC_AUDIO_HANDLE handle,
+					   const PMIC_AUDIO_VCODEC_CONFIG
+					   config);
+
+/*!
+ * @brief Get the current Voice CODEC options.
+ *
+ * Get the current Voice CODEC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of Voice CODEC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_config(const PMIC_AUDIO_HANDLE handle,
+					 PMIC_AUDIO_VCODEC_CONFIG *
+					 const config);
+
+/*!
+ * @brief Enable the Voice CODEC bypass audio pathway.
+ *
+ * Enables the Voice CODEC bypass pathway for audio data. This allows direct
+ * output of the voltages on the TX data bus line to the output amplifiers
+ * (bypassing the digital-to-analog converters within the Voice CODEC).
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_bypass(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Disable the Voice CODEC bypass audio pathway.
+ *
+ * Disables the Voice CODEC bypass pathway for audio data. This means that
+ * the TX data bus line will deliver digital data to the digital-to-analog
+ * converters within the Voice CODEC.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC bypass was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC bypass could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_bypass(const PMIC_AUDIO_HANDLE handle);
+
+/*@}*/
+
+/*!
+ * @name General Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo
+ * DAC hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the Stereo DAC clock source and operating characteristics.
+ *
+ * Define the Stereo DAC clock source and operating characteristics. This
+ * must be done before the Stereo DAC is enabled.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   clockIn         Select the clock signal source.
+ * @param[in]   clockFreq       Select the clock signal frequency.
+ * @param[in]   samplingRate    Select the audio data sampling rate.
+ * @param[in]   invert          Enable inversion of the frame sync and/or
+ *                              bit clock inputs.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or clock configuration was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_clock(const PMIC_AUDIO_HANDLE handle,
+				       const PMIC_AUDIO_CLOCK_IN_SOURCE clockIn,
+				       const PMIC_AUDIO_STDAC_CLOCK_IN_FREQ
+				       clockFreq,
+				       const PMIC_AUDIO_STDAC_SAMPLING_RATE
+				       samplingRate,
+				       const PMIC_AUDIO_CLOCK_INVERT invert);
+
+/*!
+ * @brief Get the Stereo DAC clock source and operating characteristics.
+ *
+ * Get the current Stereo DAC clock source and operating characteristics.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  clockIn         The clock signal source.
+ * @param[out]  clockFreq       The clock signal frequency.
+ * @param[out]  samplingRate    The audio data sampling rate.
+ * @param[out]  invert          Inversion of the frame sync and/or
+ *                              bit clock inputs is enabled/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC clock settings were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC clock configuration
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_clock(const PMIC_AUDIO_HANDLE handle,
+				       PMIC_AUDIO_CLOCK_IN_SOURCE *
+				       const clockIn,
+				       PMIC_AUDIO_STDAC_SAMPLING_RATE *
+				       const samplingRate,
+				       PMIC_AUDIO_STDAC_CLOCK_IN_FREQ *
+				       const clockFreq,
+				       PMIC_AUDIO_CLOCK_INVERT * const invert);
+
+/*!
+ * @brief Set the Stereo DAC primary audio channel timeslot.
+ *
+ * Set the Stereo DAC primary audio channel timeslot. This function must be
+ * used if the default timeslot for the primary audio channel is to be changed.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   timeslot        Select the primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio channel timeslot
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be set.
+ */
+PMIC_STATUS pmic_audio_stdac_set_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+					       const PMIC_AUDIO_STDAC_TIMESLOTS
+					       timeslot);
+
+/*!
+ * @brief Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * Get the current Stereo DAC primary audio channel timeslot.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  timeslot        The primary audio channel timeslot.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC primary audio channel
+ *                                   timeslot was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC primary audio channel
+ *                                   timeslot could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_rxtx_timeslot(const PMIC_AUDIO_HANDLE handle,
+					       PMIC_AUDIO_STDAC_TIMESLOTS *
+					       const timeslot);
+
+/*!
+ * @brief Set/Enable the Stereo DAC options.
+ *
+ * Set or enable various Stereo DAC options. The available options include
+ * enabling/disabling the bus master clock outputs.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Stereo DAC options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_set_config(const PMIC_AUDIO_HANDLE handle,
+					const PMIC_AUDIO_STDAC_CONFIG config);
+
+/*!
+ * @brief Clear/Disable the Stereo DAC options.
+ *
+ * Clear or disable various Stereo DAC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The Stereo DAC options to be cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the Stereo DAC options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_clear_config(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_STDAC_CONFIG config);
+
+/*!
+ * @brief Get the current Stereo DAC options.
+ *
+ * Get the current Stereo DAC options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of Stereo DAC options.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC options could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_stdac_get_config(const PMIC_AUDIO_HANDLE handle,
+					PMIC_AUDIO_STDAC_CONFIG * const config);
+
+/*@}*/
+
+/*!
+ * @name Audio Input Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio
+ * input hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Set/Enable the audio input section options.
+ *
+ * Set or enable various audio input section options. The only available
+ * option right now is to enable the automatic disabling of the microphone
+ * input amplifiers when a microphone/headset is inserted or removed.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The audio input section options to enable.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be successfully set/enabled.
+ */
+PMIC_STATUS pmic_audio_input_set_config(const PMIC_AUDIO_HANDLE handle,
+					const PMIC_AUDIO_INPUT_CONFIG config);
+
+/*!
+ * @brief Clear/Disable the audio input section options.
+ *
+ * Clear or disable various audio input section options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   config          The audio input section options to be
+ *                              cleared/disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully cleared/disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the audio input section
+ *                                   options were invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be cleared/disabled.
+ */
+PMIC_STATUS pmic_audio_input_clear_config(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_INPUT_CONFIG config);
+
+/*!
+ * @brief Get the current audio input section options.
+ *
+ * Get the current audio input section options.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  config          The current set of audio input section options.
+ *
+ * @retval      PMIC_SUCCESS         If the audio input section options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio input section options could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_input_get_config(const PMIC_AUDIO_HANDLE handle,
+					PMIC_AUDIO_INPUT_CONFIG * const config);
+
+/*@}*/
+
+/*!
+ * @name Audio Recording Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio recording.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the microphone inputs to be used for Voice CODEC recording.
+ *
+ * Select left  and right microphone inputs for Voice CODEC
+ * recording. It is possible to disable or not use a particular microphone
+ * input channel by specifying NO_MIC as a parameter.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   leftChannel     Select the left microphone input channel.
+ * @param[in]   rightChannel    Select the right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input ports
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be successfully enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic(const PMIC_AUDIO_HANDLE handle,
+				      const PMIC_AUDIO_INPUT_PORT leftChannel,
+				      const PMIC_AUDIO_INPUT_PORT rightChannel);
+
+/*!
+ * @brief Get the current microphone inputs being used for Voice CODEC
+ *        recording.
+ *
+ * Get the left  and right microphone inputs currently being
+ * used for Voice CODEC recording.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  leftChannel     The left microphone input channel.
+ * @param[out]  rightChannel    The right microphone input channel.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic(const PMIC_AUDIO_HANDLE handle,
+				      PMIC_AUDIO_INPUT_PORT * const leftChannel,
+				      PMIC_AUDIO_INPUT_PORT *
+				      const rightChannel);
+
+/*!
+ * @brief Enable/disable the microphone input.
+ *
+ * This function enables/disables the current microphone input channel. The
+ * input amplifier is automatically turned off when the microphone input is
+ * disabled.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[in]   leftChannel     The left microphone input channel state.
+ * @param[in]   rightChannel    the right microphone input channel state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channels were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input states
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the microphone input channels could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+					     const PMIC_AUDIO_INPUT_MIC_STATE
+					     leftChannel,
+					     const PMIC_AUDIO_INPUT_MIC_STATE
+					     rightChannel);
+
+/*!
+ * @brief Return the current state of the microphone inputs.
+ *
+ * This function returns the current state (on/off) of the microphone
+ * input channels.
+ *
+ * @param[in]   handle          Device handle from pmic_audio_open() call.
+ * @param[out]  leftChannel     The current left microphone input channel
+ *                              state.
+ * @param[out]  rightChannel    the current right microphone input channel
+ *                              state.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input channel states
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input channel states
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_mic_on_off(const PMIC_AUDIO_HANDLE handle,
+					     PMIC_AUDIO_INPUT_MIC_STATE *
+					     const leftChannel,
+					     PMIC_AUDIO_INPUT_MIC_STATE *
+					     const rightChannel);
+
+/*!
+ * @brief Set the microphone input amplifier mode and gain level.
+ *
+ * This function sets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[in]   leftChannelMode  The left microphone input amplifier mode.
+ * @param[in]   leftChannelGain  The left microphone input amplifier gain level.
+ * @param[in]   rightChannelMode The right microphone input amplifier mode.
+ * @param[in]   rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifiers were
+ *                                   successfully reconfigured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or microphone input amplifier
+ *                                   modes or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifiers could
+ *                                   not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_vcodec_set_record_gain(const PMIC_AUDIO_HANDLE handle,
+					      const PMIC_AUDIO_MIC_AMP_MODE
+					      leftChannelMode,
+					      const PMIC_AUDIO_MIC_GAIN
+					      leftChannelGain,
+					      const PMIC_AUDIO_MIC_AMP_MODE
+					      rightChannelMode,
+					      const PMIC_AUDIO_MIC_GAIN
+					      rightChannelGain);
+
+/*!
+ * @brief Get the current microphone input amplifier mode and gain level.
+ *
+ * This function gets the current microphone input amplifier operating mode
+ * and gain level.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[out]  leftChannelMode  The left microphone input amplifier mode.
+ * @param[out]  leftChannelGain  The left microphone input amplifier gain level.
+ * @param[out]  rightChannelMode The right microphone input amplifier mode.
+ * @param[out]  rightChannelGain The right microphone input amplifier gain
+ *                               level.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone input amplifier modes
+ *                                   and gain levels were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the microphone input amplifier modes
+ *                                   and gain levels could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_vcodec_get_record_gain(const PMIC_AUDIO_HANDLE handle,
+					      PMIC_AUDIO_MIC_AMP_MODE *
+					      const leftChannelMode,
+					      PMIC_AUDIO_MIC_GAIN *
+					      const leftChannelGain,
+					      PMIC_AUDIO_MIC_AMP_MODE *
+					      const rightChannelMode,
+					      PMIC_AUDIO_MIC_GAIN *
+					      const rightChannelGain);
+
+/*!
+ * @brief Enable a microphone bias circuit.
+ *
+ * This function enables one of the available microphone bias circuits.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[in]   biasCircuit      The microphone bias circuit to be enabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_micbias(const PMIC_AUDIO_HANDLE handle,
+					     const PMIC_AUDIO_MIC_BIAS
+					     biasCircuit);
+
+/*!
+ * @brief Disable a microphone bias circuit.
+ *
+ * This function disables one of the available microphone bias circuits.
+ *
+ * @param[in]   handle           Device handle from pmic_audio_open() call.
+ * @param[in]   biasCircuit      The microphone bias circuit to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the microphone bias circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or selected microphone bias
+ *                                   circuit was invalid.
+ * @retval      PMIC_ERROR           If the microphone bias circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_micbias(const PMIC_AUDIO_HANDLE handle,
+					      const PMIC_AUDIO_MIC_BIAS
+					      biasCircuit);
+
+/*@}*/
+
+/*!
+ * @name Audio Playback Using the Voice CODEC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Voice CODEC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Voice CODEC mixer.
+ *
+ * This function configures and enables the Voice CODEC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param[in]   gainIn              The secondary audio channel gain level.
+ * @param[in]   gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+					   const PMIC_AUDIO_VCODEC_TIMESLOT
+					   rxSecondaryTimeslot,
+					   const PMIC_AUDIO_VCODEC_MIX_IN_GAIN
+					   gainIn,
+					   const PMIC_AUDIO_VCODEC_MIX_OUT_GAIN
+					   gainOut);
+
+/*!
+ * @brief Disable the Voice CODEC mixer.
+ *
+ * This function disables the Voice CODEC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Voice CODEC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Voice CODEC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_vcodec_disable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*@}*/
+
+/*!
+ * @name Audio Playback Using the Stereo DAC Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Stereo DAC
+ * to perform audio playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Configure and enable the Stereo DAC mixer.
+ *
+ * This function configures and enables the Stereo DAC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   rxSecondaryTimeslot The timeslot used for the secondary audio
+ *                                  channel.
+ * @param[in]   gainIn              The secondary audio channel gain level.
+ * @param[in]   gainOut             The mixer output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mixer configuration
+ *                                   was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_stdac_enable_mixer(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_STDAC_TIMESLOTS
+					  rxSecondaryTimeslot,
+					  const PMIC_AUDIO_STDAC_MIX_IN_GAIN
+					  gainIn,
+					  const PMIC_AUDIO_STDAC_MIX_OUT_GAIN
+					  gainOut);
+
+/*!
+ * @brief Disable the Stereo DAC mixer.
+ *
+ * This function disables the Stereo DAC mixer.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the Stereo DAC mixer was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the Stereo DAC mixer could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_stdac_disable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*@}*/
+
+/*!
+ * @name Audio Output Section Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC audio output
+ * section to support playback.
+ */
+/*@{*/
+
+/*!
+ * @brief Select the audio output ports.
+ *
+ * This function selects the audio output ports to be used. This also enables
+ * the appropriate output amplifiers.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   port                The audio output ports to be used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   acquired.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   acquired.
+ */
+PMIC_STATUS pmic_audio_output_set_port(const PMIC_AUDIO_HANDLE handle,
+				       const PMIC_AUDIO_OUTPUT_PORT port);
+
+/*!
+ * @brief Deselect/disable the audio output ports.
+ *
+ * This function disables the audio output ports that were previously enabled
+ * by calling pmic_audio_output_set_port().
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   port                The audio output ports to be disabled.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or output ports were
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   disabled.
+ */
+PMIC_STATUS pmic_audio_output_clear_port(const PMIC_AUDIO_HANDLE handle,
+					 const PMIC_AUDIO_OUTPUT_PORT port);
+
+/*!
+ * @brief Get the current audio output ports.
+ *
+ * This function retrieves the audio output ports that are currently being
+ * used.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  port                The audio output ports currently being used.
+ *
+ * @retval      PMIC_SUCCESS         If the audio output ports were successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the audio output ports could not be
+ *                                   retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_port(const PMIC_AUDIO_HANDLE handle,
+				       PMIC_AUDIO_OUTPUT_PORT * const port);
+
+/*!
+ * @brief Set the gain level for the external stereo inputs.
+ *
+ * This function sets the gain levels for the external stereo inputs.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   gain                The external stereo input gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+						 const PMIC_AUDIO_STEREO_IN_GAIN
+						 gain);
+
+/*!
+ * @brief Get the current gain level for the external stereo inputs.
+ *
+ * This function retrieves the current gain levels for the external stereo
+ * inputs.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  gain                The current external stereo input gain
+ *                                  level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_stereo_in_gain(const PMIC_AUDIO_HANDLE handle,
+						 PMIC_AUDIO_STEREO_IN_GAIN *
+						 const gain);
+
+/*!
+ * @brief Set the output PGA gain level.
+ *
+ * This function sets the audio output PGA gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   gain                The output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_pgaGain(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_OUTPUT_PGA_GAIN
+					  gain);
+
+/*!
+ * @brief Get the output PGA gain level.
+ *
+ * This function retrieves the current audio output PGA gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  gain                The current output PGA gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the gain level was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the gain level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_pgaGain(const PMIC_AUDIO_HANDLE handle,
+					  PMIC_AUDIO_OUTPUT_PGA_GAIN *
+					  const gain);
+
+/*!
+ * @brief Enable the output mixer.
+ *
+ * This function enables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Disable the output mixer.
+ *
+ * This function disables the output mixer for the audio stream that
+ * corresponds to the current handle (i.e., the Voice CODEC, Stereo DAC, or
+ * the external stereo inputs).
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mixer was successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mixer could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mixer(const PMIC_AUDIO_HANDLE handle);
+
+/*!
+ * @brief Configure and enable the output balance amplifiers.
+ *
+ * This function configures and enables the output balance amplifiers.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   leftGain            The desired left channel gain level.
+ * @param[in]   rightGain           The desired right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifiers were
+ *                                   successfully configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain levels were invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifiers could not
+ *                                   be reconfigured or enabled.
+ */
+PMIC_STATUS pmic_audio_output_set_balance(const PMIC_AUDIO_HANDLE handle,
+					  const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+					  leftGain,
+					  const PMIC_AUDIO_OUTPUT_BALANCE_GAIN
+					  rightGain);
+
+/*!
+ * @brief Get the current output balance amplifier gain levels.
+ *
+ * This function retrieves the current output balance amplifier gain levels.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  leftGain            The current left channel gain level.
+ * @param[out]  rightGain           The current right channel gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the output balance amplifier gain levels
+ *                                   were successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the output balance amplifier gain levels
+ *                                   could be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_balance(const PMIC_AUDIO_HANDLE handle,
+					  PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+					  const leftGain,
+					  PMIC_AUDIO_OUTPUT_BALANCE_GAIN *
+					  const rightGain);
+
+/*!
+ * @brief Configure and enable the output mono adder.
+ *
+ * This function configures and enables the output mono adder.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   mode                The desired mono adder operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   configured and enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or mono adder mode was
+ *                                   invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be reconfigured
+ *                                   or enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_mono_adder(const PMIC_AUDIO_HANDLE handle,
+						const PMIC_AUDIO_MONO_ADDER_MODE
+						mode);
+
+/*!
+ * @brief Disable the output mono adder.
+ *
+ * This function disables the output mono adder.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder was successfully
+ *                                   disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder could not be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_mono_adder(const PMIC_AUDIO_HANDLE
+						 handle);
+
+/*!
+ * @brief Configure the mono adder output gain level.
+ *
+ * This function configures the mono adder output amplifier gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   gain                The desired output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or gain level was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be reconfigured.
+ */
+PMIC_STATUS pmic_audio_output_set_mono_adder_gain(const PMIC_AUDIO_HANDLE
+						  handle,
+						  const
+						  PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+						  gain);
+
+/*!
+ * @brief Get the current mono adder output gain level.
+ *
+ * This function retrieves the current mono adder output amplifier gain level.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  gain                The current output gain level.
+ *
+ * @retval      PMIC_SUCCESS         If the mono adder output amplifier gain
+ *                                   level was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the mono adder output amplifier gain
+ *                                   level could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_mono_adder_gain(const PMIC_AUDIO_HANDLE
+						  handle,
+						  PMIC_AUDIO_MONO_ADDER_OUTPUT_GAIN
+						  * const gain);
+
+/*!
+ * @brief Set various audio output section options.
+ *
+ * This function sets one or more audio output section configuration
+ * options. The currently supported options include whether to disable
+ * the non-inverting mono speaker output, enabling the loudspeaker common
+ * bias circuit, enabling detection of headset insertion/removal, and
+ * whether to automatically disable the headset amplifiers when a headset
+ * insertion/removal has been detected.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   config              The desired audio output section
+ *                                  configuration options to be set.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be set.
+ */
+PMIC_STATUS pmic_audio_output_set_config(const PMIC_AUDIO_HANDLE handle,
+					 const PMIC_AUDIO_OUTPUT_CONFIG config);
+
+/*!
+ * @brief Clear various audio output section options.
+ *
+ * This function clears one or more audio output section configuration
+ * options.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[in]   config              The desired audio output section
+ *                                  configuration options to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the desired configuration options were
+ *                                   all successfully cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or configuration options
+ *                                   were invalid.
+ * @retval      PMIC_ERROR           If the desired configuration options
+ *                                   could not be cleared.
+ */
+PMIC_STATUS pmic_audio_output_clear_config(const PMIC_AUDIO_HANDLE handle,
+					   const PMIC_AUDIO_OUTPUT_CONFIG
+					   config);
+
+/*!
+ * @brief Get the current audio output section options.
+ *
+ * This function retrieves the current audio output section configuration
+ * option settings.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ * @param[out]  config              The current audio output section
+ *                                  configuration option settings.
+ *
+ * @retval      PMIC_SUCCESS         If the current configuration options were
+ *                                   successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the current configuration options
+ *                                   could not be retrieved.
+ */
+PMIC_STATUS pmic_audio_output_get_config(const PMIC_AUDIO_HANDLE handle,
+					 PMIC_AUDIO_OUTPUT_CONFIG *
+					 const config);
+
+/*!
+ * @brief Enable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function enables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully enabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be enabled.
+ */
+PMIC_STATUS pmic_audio_output_enable_phantom_ground(const PMIC_AUDIO_HANDLE
+						    handle);
+
+/*!
+ * @brief Disable the phantom ground circuit that is used to help identify
+ *        the type of headset that has been inserted.
+ *
+ * This function disables the phantom ground circuit that is used to help
+ * identify the type of headset (e.g., stereo or mono) that has been inserted.
+ *
+ * @param[in]   handle              Device handle from pmic_audio_open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the phantom ground circuit was
+ *                                   successfully disabled.
+ * @retval      PMIC_PARAMETER_ERROR If the handle was invalid.
+ * @retval      PMIC_ERROR           If the phantom ground circuit could not
+ *                                   be disabled.
+ */
+PMIC_STATUS pmic_audio_output_disable_phantom_ground(const PMIC_AUDIO_HANDLE
+						     handle);
+
+/*@}*/
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_AUDIO_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pmic_battery.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pmic_battery.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,374 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_BATTERY_H__
+#define __ASM_ARCH_MXC_PMIC_BATTERY_H__
+
+/*!
+ * @defgroup PMIC_BATTERY PMIC Battery Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_battery.h
+ * @brief This is the header of PMIC Battery driver.
+ *
+ * @ingroup PMIC_BATTERY
+ */
+
+#include <asm/ioctl.h>
+#include <asm/arch/pmic_status.h>
+#include <asm/arch/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable and disable charger.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_CHARGER_CONTROL              _IOW('p', 0xc0, int)
+/*!
+ * Set charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_SET_CHARGER                  _IOW('p', 0xc1, int)
+/*!
+ * Get charger configuration.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER                  _IOR('p', 0xc2, int)
+/*!
+ * Get charger current.
+ * Argument type: pointer to t_charger_setting
+ */
+#define PMIC_BATT_GET_CHARGER_CURRENT          _IOR('p', 0xc3, int)
+/*!
+ * Set EOL control
+ * Argument type: pointer to t_eol_setting
+ */
+#define PMIC_BATT_EOL_CONTROL                   _IOW('p', 0xc4, int)
+/*!
+ * Enable and disable charging LED.
+ * Argument type: bool
+ */
+#define PMIC_BATT_LED_CONTROL                   _IOW('p', 0xc5, int)
+/*!
+ * Enable and disable reverse supply.
+ * Argument type: bool
+ */
+#define PMIC_BATT_REV_SUPP_CONTROL              _IOW('p', 0xc6, int)
+/*!
+ * Enable and disable unregulated charging mode.
+ * Argument type: bool
+ */
+#define PMIC_BATT_UNREG_CONTROL                 _IOW('p', 0xc7, int)
+
+/*!
+ * Set the output controls.
+ * Argument type: t_control
+ */
+#define PMIC_BATT_SET_OUT_CONTROL                _IOW('p', 0xc8, int)
+/*!
+ * Set the over voltage threshold.
+ * Argument type: int
+ */
+#define PMIC_BATT_SET_THRESHOLD	                 _IOW('p', 0xc9, int)
+/*! @} */
+
+/*!
+ * This enumeration defines battery chargers.
+ */
+typedef enum {
+	BATT_MAIN_CHGR = 0,	/*!< Main battery charger */
+	BATT_CELL_CHGR,		/*!< Cell battery charger */
+	BATT_TRCKLE_CHGR	/*!< Trickle charger (only available on mc13783) */
+} t_batt_charger;
+
+/*!
+ * This enumeration defines the bp threshold.
+ */
+typedef enum {
+	BATT_BP_0 = 0,		/*!< LOBATL UVDET + 0.2 */
+	BATT_BP_1,		/*!< LOBATL UVDET + 0.3 */
+	BATT_BP_2,		/*!< LOBATL UVDET + 0.4 */
+	BATT_BP_3		/*!< LOBATL UVDET + 0.5 */
+} t_bp_threshold;
+
+/*!
+ * This enumeration of all types of output controls
+ */
+typedef enum {
+	/*!
+	 * controlled hardware
+	 */
+	CONTROL_HARDWARE = 0,
+	/*!
+	 * BPFET is driven low, BATTFET is driven high
+	 */
+	CONTROL_BPFET_LOW,
+	/*!
+	 * BPFET is driven high, BATTFET is driven low
+	 */
+	CONTROL_BPFET_HIGH,
+} t_control;
+
+/*!
+ * This enumeration define all battery interrupt
+ */
+typedef enum {
+	/*!
+	 * Charge detection interrupt
+	 */
+	BAT_IT_CHG_DET,
+	/*!
+	 * Charge over voltage detection it
+	 */
+	BAT_IT_CHG_OVERVOLT,
+	/*!
+	 * Charge path reverse current it
+	 */
+	BAT_IT_CHG_REVERSE,
+	/*!
+	 * Charge path short circuitin revers supply mode it
+	 */
+	BAT_IT_CHG_SHORT_CIRCUIT,
+	/*!
+	 * Charger has switched its mode (CC to CV or CV to CC)
+	 */
+	BAT_IT_CCCV,
+	/*!
+	 * Charge current has dropped below its threshold
+	 */
+	BAT_IT_BELOW_THRESHOLD,
+} t_batt_event;
+
+/*!
+ * This structure is used for the following battery changer control
+ * IOCTLs:
+ * - PMIC_BATT_CHARGER_CONTROL
+ * - PMIC_BATT_SET_CHARGER
+ * - PMIC_BATT_GET_CHARGER
+ */
+typedef struct {
+	/*!
+	 * Charger
+	 */
+	t_batt_charger chgr;
+	/*!
+	 * Turn on charger
+	 */
+	bool on;
+	/*!
+	 * Charging voltage
+	 */
+	unsigned char c_voltage;
+	/*!
+	 * Charging current
+	 */
+	unsigned char c_current;
+} t_charger_setting;
+
+/*!
+ * This structure is used for EOL setting IOCTL PMIC_BATT_EOL_CONTROL
+ */
+typedef struct {
+	/*!
+	 * Enable EOL comparator
+	 */
+	bool enable;
+	/*!
+	 * bp threshold - Used on mc13783
+	 */
+	t_bp_threshold typical;
+} t_eol_setting;
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function is used to start charging a battery. For different charger,
+ * different c_voltage and current range are supported. \n
+ *
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage     Charging voltage.
+ * @param      c_current     Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_charger(t_batt_charger chgr,
+				     unsigned char c_voltage,
+				     unsigned char c_current);
+
+/*!
+ * This function turns off a charger.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_charger(t_batt_charger chgr);
+
+/*!
+ * This function is used to change the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Charging voltage.
+ * @param      c_current   Charging current.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_charger(t_batt_charger chgr,
+				  unsigned char c_voltage,
+				  unsigned char c_current);
+
+/*!
+ * This function is used to retrieve the charger setting.
+ *
+ * @param      chgr        Charger as defined in \b t_batt_charger.
+ * @param      c_voltage   Output parameter for charging c_voltage setting.
+ * @param      c_current   Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_get_charger_setting(t_batt_charger chgr,
+					  unsigned char *c_voltage,
+					  unsigned char *c_current);
+
+/*!
+ * This function is retrieves the main battery charging current.
+ *
+ * @param      c_current     Output parameter for charging current setting.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_batt_get_charge_current(unsigned short *c_current);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      threshold  End-of-Life threshold.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_enable_eol(unsigned char threshold);
+
+/*!
+ * This function enables End-of-Life comparator.
+ *
+ * @param      typical  Falling Edge Threshold threshold.
+ *                      @verbatim
+                        BPDET   UVDET   LOBATL
+                        ____    _____   ___________
+                        0       2.6     UVDET + 0.2
+                        1       2.6     UVDET + 0.3
+                        2       2.6     UVDET + 0.4
+                        3       2.6     UVDET + 0.5
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_bp_enable_eol(t_bp_threshold typical);
+
+/*!
+ * This function disables End-of-Life comparator.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_disable_eol(void);
+
+/*!
+ * This function sets the output controls.
+ * It sets the FETOVRD and FETCTRL bits of mc13783
+ *
+ * @param        control        type of control.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_out_control(t_control control);
+
+/*!
+ * This function sets over voltage threshold.
+ *
+ * @param        threshold      value of over voltage threshold.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_set_threshold(int threshold);
+
+/*!
+ * This function controls charge LED.
+ *
+ * @param      on   If on is true, LED will be turned on,
+ *                  or otherwise, LED will be turned off.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_led_control(bool on);
+
+/*!
+ * This function sets reverse supply mode.
+ *
+ * @param      enable     If enable is true, reverse supply mode is enable,
+ *                        or otherwise, reverse supply mode is disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_reverse_supply(bool enable);
+
+/*!
+ * This function sets unregulated charging mode on main battery.
+ *
+ * @param      enable     If enable is true, unregulated charging mode is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_unregulated(bool enable);
+
+/*!
+ * This function sets a 5K pull down at CHRGRAW.
+ * To be used in the dual path charging configuration.
+ *
+ * @param      enable     If enable is true, 5k pull down is
+ *                        enable, or otherwise, disabled.
+ *
+ * @return     This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_batt_set_5k_pull(bool enable);
+
+/*!
+ * This function is used to subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_subscribe(t_batt_event event, void *callback);
+
+/*!
+ * This function is used to un subscribe on battery event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_batt_event_unsubscribe(t_batt_event event, void *callback);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_BATTERY_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pmic_convity.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pmic_convity.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,873 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_CONVITY_H__
+#define __ASM_ARCH_MXC_PMIC_CONVITY_H__
+
+/*!
+ * @defgroup PMIC_CONNECTIVITY PMIC Connectivity Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_convity.h
+ * @brief External definitions for the PMIC Connectivity Client driver.
+ *
+ * The PMIC Connectivity driver and this API were developed to support the
+ * external connectivity capabilities of several power management ICs that
+ * are available from Freescale Semiconductor, Inc.
+ *
+ * The following operating modes, in terms of external connectivity, are
+ * supported:
+ *
+ *
+ *
+ * @ingroup PMIC_CONNECTIVITY
+ */
+
+#include <asm/arch/pmic_status.h>
+#include <asm/arch/pmic_external.h>
+
+/***************************************************************************
+ *                       TYPEDEFS AND ENUMERATIONS                         *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Configuration Typedefs and Enumerations
+ * Typedefs and enumerations that are used for initial access to and
+ * configuration of the PMIC Connectivity hardware.
+ */
+/*@{*/
+
+#define DEBUG_CONVITY
+
+/*!
+ * @typedef PMIC_CONVITY_HANDLE
+ * @brief Define typedef for a handle to the PMIC Connectivity hardware.
+ *
+ * Define a "handle" that is returned when the PMIC Connectivity hardware
+ * is opened. This handle grants exclusive access to the PMIC Connectivity
+ * hardware and must be used in all subsequent function calls. When access
+ * to the PMIC Connectivity hardware is no longer required, then a close
+ * operation must be done with this handle. The handle is no longer valid
+ * if the close operation was successful.
+ */
+typedef long PMIC_CONVITY_HANDLE;
+
+/*!
+ * @enum PMIC_CONVITY_MODE
+ * @brief Select the main Connectivity operating mode.
+ *
+ * Defines all possible PMIC Connectivity main operating modes. Only one of
+ * these modes can be active at a time.
+ */
+typedef enum {
+	USB,			/*!< Select USB mode (this is also the Reset/Default
+				   mode).                                          */
+	RS232,			/*!< Select RS-232 mode.                           */
+	RS232_1,		/*!< Select RS-232_1 mode.                         */
+	RS232_2,		/*!< Select RS-232_2 mode.                         */
+	CEA936_MONO,		/*!< Select CE-936 Mono mode .    */
+	CEA936_STEREO,		/*!< Select CE-936 Stereo mode .  */
+	CEA936_TEST_RIGHT,	/*!< Select CE-936 Right Channel Test mode
+				   .                            */
+	CEA936_TEST_LEFT	/*!< Select CE-936 Left Channel Test mode
+				   .                            */
+} PMIC_CONVITY_MODE;
+
+/*!
+ * @enum PMIC_CONVITY_EVENTS
+ * @brief Identify the connectivity events that have been detected and should
+ * be handled.
+ *
+ * Defines all possible PMIC Connectivity events. Multiple events may be
+ * selected when defining a mask.
+ */
+typedef enum {
+	USB_DETECT_4V4_RISE = 1,	/*!< Detected 4.4V rising edge.      */
+	USB_DETECT_4V4_FALL = 2,	/*!< Detected 4.4V falling edge.     */
+	USB_DETECT_2V0_RISE = 4,	/*!< Detected 2.0V rising edge.      */
+	USB_DETECT_2V0_FALL = 8,	/*!< Detected 2.0V falling edge.     */
+	USB_DETECT_0V8_RISE = 16,	/*!< Detected 0.8V rising edge.      */
+	USB_DETECT_0V8_FALL = 32,	/*!< Detected 0.8V falling edge.     */
+	USB_DETECT_MINI_A = 64,	/*!< Detected USB mini A plug.       */
+	USB_DETECT_MINI_B = 128,	/*!< Detected USB mini B plug.       */
+	USB_DETECT_NON_USB_ACCESSORY = 256,	/*!< Detected a non-USB connection
+						   .            */
+	USB_DETECT_FACTORY_MODE = 512,	/*!< Detected a factory-mode
+					   connection . */
+	USB_DP_HI = 1024,
+
+	USB_DM_HI = 2048
+} PMIC_CONVITY_EVENTS;
+
+/*!
+ * @typedef PMIC_CONVITY_CALLBACK
+ * @brief Typedef for PMIC Connectivity event notification callback function.
+ *
+ * Define a typedef for the PMIC Connectivity event notification callback
+ * function. The signalled events are passed to the function as the first
+ * argument. The callback function should then process whatever events it
+ * can and then return the set of unhandled events (if any).
+ */
+typedef void (*PMIC_CONVITY_CALLBACK) (const PMIC_CONVITY_EVENTS event);
+
+/*@}*/
+
+/*!
+ * @name USB and USB On-The-Go Mode-specific Typedefs and Enumerations
+ * Typedefs and enumerations that are used only for setting up and controlling
+ * the USB and USB On-The-Go modes of operation.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_CONVITY_USB_DEVICE_TYPE
+ * @brief Select the USB device type (either A or B).
+ *
+ * Defines all possible USB device types. This must match the physical
+ * connector being used.
+ */
+typedef enum {
+	USB_A_DEVICE,
+	USB_B_DEVICE
+} PMIC_CONVITY_USB_DEVICE_TYPE;
+
+/*!
+ * @enum PMIC_CONVITY_USB_SPEED
+ * @brief Select the USB transceiver operating speed.
+ *
+ * Defines all possible USB transceiver operating speeds. Only one
+ * speed setting may be used at a time.
+ */
+typedef enum {
+	USB_LOW_SPEED,		/*!< Select 1.5 Mbps.              */
+	USB_FULL_SPEED,		/*!< Select 12 Mbps.               */
+	USB_HIGH_SPEED		/*!< Select 480 Mbps <b>(currently
+				   not supported)</b>.           */
+} PMIC_CONVITY_USB_SPEED;
+
+/*!
+ * @enum PMIC_CONVITY_USB_MODE
+ * @brief Select the USB transceiver operating mode.
+ *
+ * Defines all possible USB transceiver operating modes. Only one
+ * mode may be used at a time. The selected mode, in combination with
+ * the USB bus speed, determines the selection of pull-up and pull-down
+ * resistors.
+ */
+typedef enum {
+	USB_HOST,
+	USB_PERIPHERAL
+} PMIC_CONVITY_USB_MODE;
+
+/*!
+ * @enum PMIC_CONVITY_USB_POWER_IN
+ * @brief Select the USB transceiver's power regulator input source.
+ *
+ * Defines all possible input power sources for the USB transceiver power
+ * regulator. Only one power supply source may be selected at a time.
+ */
+typedef enum {
+
+	USB_POWER_INTERNAL_BOOST,	/*!< Select internal power source
+					   with boost.                  */
+
+	USB_POWER_VBUS,		/*!< Select VBUS power source.    */
+
+	USB_POWER_INTERNAL	/*!< Select internal power source
+				   .         */
+} PMIC_CONVITY_USB_POWER_IN;
+
+/*!
+ * @enum PMIC_CONVITY_USB_POWER_OUT
+ * @brief Select the USB transceiver power regulator output voltage.
+ *
+ * Defines all possible output voltages for the USB transceiver power
+ * regulator. Only one power output voltage level may be selected at
+ * a time.
+ */
+typedef enum {
+	USB_POWER_2V775,	/*!< Select 2.775V output voltage
+				   .         */
+	USB_POWER_3V3		/*!< Select 3.3V output voltage.  */
+} PMIC_CONVITY_USB_POWER_OUT;
+
+/*!
+ * @enum PMIC_CONVITY_USB_TRANSCEIVER_MODE
+ * @brief Select the USB transceiver operating mode.
+ *
+ * Defines all valid USB transceiver operating modes. Only one of the
+ * following USB transceiver modes may be selected at a time.
+ */
+typedef enum {
+	USB_TRANSCEIVER_OFF,	/*!< USB transceiver currently off
+				   .            */
+	USB_SINGLE_ENDED_UNIDIR,	/*!< Select Single-ended
+					   unidirectional transmit mode.   */
+	USB_SINGLE_ENDED_UNIDIR_TX,	/*!< Select Single-ended
+					   unidirectional transmit mode.   */
+	USB_SINGLE_ENDED_UNIDIR_RX,	/*!< Select Single-ended
+					   unidirectional receive mode.    */
+	USB_SINGLE_ENDED_BIDIR,	/*!< Select Single-ended
+				   bidirectional transmit mode.    */
+	USB_SINGLE_ENDED_LOW,	/*!< Select USB SE0 mode.            */
+	USB_DIFFERENTIAL_UNIDIR_TX,	/*!< Select Differential
+					   unidirectional transmit mode
+					   .            */
+	USB_DIFFERENTIAL_UNIDIR,	/*!< Select Differential
+					   unidirectional transmit mode
+					   .            */
+
+	USB_DIFFERENTIAL_UNIDIR_RX,	/*!< Select Differential
+					   unidirectional receive mode.    */
+	USB_DIFFERENTIAL_BIDIR,	/*!< Select Differential
+				   bidirectional transmit mode
+				 */
+	USB_SUSPEND_ON,		/*!< Select Suspend mode.            */
+	USB_SUSPEND_OFF,	/*!< Terminate Suspend mode.         */
+	USB_OTG_SRP_DLP_START,	/*!< Start USB On-The-Go Session
+				   Request Protocol using Data
+				   Line Pulsing.                   */
+	USB_OTG_SRP_DLP_STOP	/*!< Terminate USB On-The-Go Session
+				   Request Protocol using Data
+				   Line Pulsing.                   */
+} PMIC_CONVITY_USB_TRANSCEIVER_MODE;
+
+/*!
+ * @enum PMIC_CONVITY_USB_OTG_CONFIG
+ * @brief Select the USB On-The-Go configuration options.
+ *
+ * Defines all possible USB On-The-Go configuration options. Multiple
+ * configuration options may be selected at the same time. However, only one
+ * VBUS current limit may be selected at a time. Selecting more than one
+ * VBUS current limit will result in undefined and implementation-dependent
+ * behavior.
+ */
+typedef enum {
+	USB_OTG_SE0CONN = 0x00001,	/*!< Enable automatic
+					   connection of a pull-up
+					   resistor to VUSB when the
+					   SE0 condition is detected. */
+	USB_OTG_DLP_SRP = 0x00002,	/*!< Enable use of the hardware
+					   timer to control the
+					   duration of the data line
+					   pulse during the session
+					   request protocol.          */
+	USB_PULL_OVERRIDE = 0x00004,	/*!< Enable automatic disconnect
+					   of pull-up and pull-down
+					   resistors when transmitter
+					   is enabled.                */
+
+	USB_DP150K_PU = 0x00008,
+
+	USB_VBUS_CURRENT_LIMIT_HIGH = 0x00010,	/*!< Select current limit to 200mA
+						   for VBUS regulator.        */
+	USB_VBUS_CURRENT_LIMIT_LOW = 0x00020,	/*!< Select low current limit
+						   for VBUS regulator.        */
+	USB_VBUS_CURRENT_LIMIT_LOW_10MS = 0x00040,	/*!< Select low current limit
+							   for VBUS regulator for
+							   10 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_20MS = 0x00080,	/*!< Select low current limit
+							   for VBUS regulator for
+							   20 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_30MS = 0x00100,	/*!< Select low current limit
+							   for VBUS regulator for
+							   30 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_40MS = 0x00200,	/*!< Select low current limit
+							   for VBUS regulator for
+							   40 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_50MS = 0x00400,	/*!< Select low current limit
+							   for VBUS regulator for
+							   50 ms . */
+	USB_VBUS_CURRENT_LIMIT_LOW_60MS = 0x00800,	/*!< Select low current limit
+							   for VBUS regulator for
+							   60 ms . */
+
+	USB_VBUS_PULLDOWN = 0x01000,	/*!< Enable VBUS pull-down.     */
+
+	USB_USBCNTRL = 0x02000,
+
+	USB_UDP_PD = 0x04000,
+
+	USB_UDM_PD = 0x08000,
+
+	USB_PU = 0x10000,
+
+	USBXCVREN = 0x20000
+} PMIC_CONVITY_USB_OTG_CONFIG;
+/*@}*/
+
+/*!
+ * @name RS-232 Mode-specific Typedefs and Enumerations
+ * Typedefs and enumerations that are used only for setting up and controlling
+ * the RS-232 mode of operation.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_CONVITY_RS232_EXTERNAL
+ * @brief Select the RS-232 transceiver external connections.
+ *
+ * Defines all valid RS-232 transceiver external RX/TX connection options.
+ * Only one connection mode may be selected at a time.
+ */
+typedef enum {
+	RS232_TX_UDM_RX_UDP,	/*!< Select RS-232 TX on UDM   */
+	RS232_TX_UDP_RX_UDM,	/*!< Select RS-232 TX on UDP
+				   . */
+	RS232_TX_RX_EXTERNAL_DEFAULT	/*!< Use power on default.        */
+} PMIC_CONVITY_RS232_EXTERNAL;
+
+/*!
+ * @enum PMIC_CONVITY_RS232_INTERNAL
+ * @brief Select the RS-232 transceiver internal connections.
+ *
+ * Defines all valid RS-232 transceiver internal RX/TX connection options.
+ * Only one connection mode can be selected at a time.
+ */
+typedef enum {
+	RS232_TX_USE0VM_RX_UDATVP,	/*!< Select RS-232 TX from USE0VM
+					   .         */
+	RS232_TX_UDATVP_RX_URXVM,	/*!< Select RS-232 TX from UDATVP
+					   .         */
+	RS232_TX_UTXDI_RX_URXDO,	/*!< Select RS-232 TX from UTXDI
+					   .    */
+	RS232_TX_RX_INTERNAL_DEFAULT	/*!< Use power on default.     */
+} PMIC_CONVITY_RS232_INTERNAL;
+
+/*@}*/
+
+/*!
+ * @name CEA-936 Mode-specific Typedefs and Enumerations
+ * Typedefs and enumerations that are used only for setting up and controlling
+ * the CEA-936 mode of operation.
+ */
+/*@{*/
+
+/*!
+ * @enum PMIC_CONVITY_CEA936_EXIT_SIGNAL
+ * @brief Select the CEA-936 mode exit signal.
+ *
+ * Defines all valid CEA-936 connection termination signals. Only one
+ * termination signal can be selected at a time.
+ */
+typedef enum {
+	CEA936_UID_NO_PULLDOWN,	/*!< No UID pull-down . */
+	CEA936_UID_PULLDOWN_6MS,	/*!< UID pull-down for 6 ms (+/-2 ms)
+					   .                  */
+	CEA936_UID_PULLDOWN,	/*!< UID pulled down .  */
+	CEA936_UDMPULSE		/*!< UDM pulsed .       */
+} PMIC_CONVITY_CEA936_EXIT_SIGNAL;
+
+/*@}*/
+
+/***************************************************************************
+ *                          PMIC API DEFINITIONS                           *
+ ***************************************************************************/
+
+/*!
+ * @name General Setup and Configuration APIs
+ * Functions for general setup and configuration of the PMIC Connectivity
+ * hardware.
+ */
+/*@{*/
+
+/*!
+ * @brief Request exclusive access to the PMIC Connectivity hardware.
+ *
+ * Attempt to open and gain exclusive access to the PMIC Connectivity
+ * hardware. An initial operating mode (e.g., USB or RS-232) must also
+ * be specified.
+ *
+ * If the open request is successful, then a numeric handle is returned
+ * and this handle must be used in all subsequent function calls. The
+ * same handle must also be used in the close call when use of the PMIC
+ * connectivity hardware is no longer required.
+ *
+ * The open request will fail if another thread has already obtained the
+ * device handle and has not yet called pmic_convity_close() with it.
+ *
+ * @param   handle          Device handle to be used for subsequent PMIC
+ *                              Connectivity API calls.
+ * @param   mode            Initial connectivity operating mode.
+ *
+ * @retval      PMIC_SUCCESS    If the open request was successful
+ * @retval      PMIC_ERROR      If the connectivity hardware cannot be opened.
+ */
+PMIC_STATUS pmic_convity_open(PMIC_CONVITY_HANDLE * const handle,
+			      const PMIC_CONVITY_MODE mode);
+
+/*!
+ * @brief Terminate further access to the PMIC Connectivity hardware.
+ *
+ * Terminate further access to the PMIC Connectivity hardware. This also
+ * allows another thread to successfully call pmic_convity_open() to gain
+ * access.
+ *
+ * @param   handle          Device handle from open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the close request was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_close(const PMIC_CONVITY_HANDLE handle);
+
+/*!
+ * @brief Set the PMIC Connectivity main operating mode.
+ *
+ * Change the current operating mode of the PMIC Connectivity hardware.
+ * The available connectivity operating modes are hardware-dependent and
+ * consists of one or more of the following: USB (including USB On-the-Go),
+ * RS-232, and CEA-936. Requesting an operating mode that is not supported
+ * by the PMIC hardware will return PMIC_NOT_SUPPORTED.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   mode            Desired operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the requested mode was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the PMIC hardware does not support
+ *                                   the desired operating mode.
+ */
+PMIC_STATUS pmic_convity_set_mode(const PMIC_CONVITY_HANDLE handle,
+				  const PMIC_CONVITY_MODE mode);
+
+/*!
+ * @brief Get the current PMIC Connectivity main operating mode.
+ *
+ * Get the current operating mode for the PMIC Connectivity hardware.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   mode            The current PMIC Connectivity operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the requested mode was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_get_mode(const PMIC_CONVITY_HANDLE handle,
+				  PMIC_CONVITY_MODE * const mode);
+
+/*!
+ * @brief Reset the Connectivity hardware to it's power on state.
+ *
+ * Restore all registers to the initial power-on/reset state.
+ *
+ * @param   handle          Device handle from open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the reset was successful.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_reset(const PMIC_CONVITY_HANDLE handle);
+
+/*!
+ * @brief Set the Connectivity callback function.
+ *
+ * Register a callback function that will be used to signal PMIC Connectivity
+ * events. For example, the USB subsystem should register a callback function
+ * in order to be notified of device connect/disconnect events. Note, however,
+ * that non-USB events may also be signalled depending upon the PMIC hardware
+ * capabilities. Therefore, the callback function must be able to properly
+ * handle all of the possible events if support for non-USB peripherals is
+ * also to be included.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   func            A pointer to the callback function.
+ * @param   eventMask       A mask selecting events to be notified.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully registered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the eventMask is invalid.
+ */
+PMIC_STATUS pmic_convity_set_callback(const PMIC_CONVITY_HANDLE handle,
+				      const PMIC_CONVITY_CALLBACK func,
+				      const PMIC_CONVITY_EVENTS eventMask);
+
+/*!
+ * @brief Deregisters the existing Connectivity callback function.
+ *
+ * Deregister the callback function that was previously registered by calling
+ * pmic_convity_set_callback().
+ *
+ * @param   handle          Device handle from open() call.
+ *
+ * @retval      PMIC_SUCCESS         If the callback was successfully deregistered.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_clear_callback(const PMIC_CONVITY_HANDLE handle);
+
+/*!
+ * @brief Get the current Connectivity callback function settings.
+ *
+ * Get the current callback function and event mask.
+ *
+ * @param  handle          Device handle from open() call.
+ * @param  func            The current callback function.
+ * @param  eventMask       The current event selection mask.
+ *
+ * @retval      PMIC_SUCCESS         If the callback information was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_get_callback(const PMIC_CONVITY_HANDLE handle,
+				      PMIC_CONVITY_CALLBACK * const func,
+				      PMIC_CONVITY_EVENTS * const eventMask);
+
+/*@}*/
+
+/***************************************************************************/
+
+/*!
+ * @name USB and USB On-The-Go APIs
+ * USB Connectivity mode-specific configuration and setup functions.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the USB transceiver's operating speed.
+ *
+ * Set the USB transceiver speed.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   speed           The desired USB transceiver speed.
+ *
+ * @retval      PMIC_SUCCESS         If the transceiver speed was successfully
+ *                                   set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the high speed (480 Mbps) mode is
+ *                                   requested.
+ */
+PMIC_STATUS pmic_convity_usb_set_speed(const PMIC_CONVITY_HANDLE handle,
+				       const PMIC_CONVITY_USB_SPEED speed);
+
+/*!
+ * This function enables/disables VUSB and VBUS output.
+ * This API configures the VUSBEN and VBUSEN bits of USB register
+ *
+ * @param   handle          Device handle from open() call.
+ * @param        out_type true, for VUSB
+ *                        false, for VBUS
+ * @param        out 	if true, output is enabled
+ *                      if false, output is disabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_convity_set_output(const PMIC_CONVITY_HANDLE handle,
+				    bool out_type, bool out);
+
+/*!
+ * @brief Get the USB transceiver's operating speed.
+ *
+ * Get the USB transceiver speed.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  speed           The current USB transceiver speed.
+ * @param  mode            The current USB transceiver mode.
+ *
+ * @retval      PMIC_SUCCESS         If the transceiver speed was successfully
+ *                                   set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ *                                   obtained
+ */
+PMIC_STATUS pmic_convity_usb_get_speed(const PMIC_CONVITY_HANDLE handle,
+				       PMIC_CONVITY_USB_SPEED * const speed,
+				       PMIC_CONVITY_USB_MODE * const mode);
+
+/*!
+ * @brief Set the USB transceiver's power supply configuration.
+ *
+ * Set the USB transceiver's power supply configuration.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   pwrin           USB transceiver regulator input power source.
+ * @param   pwrout          USB transceiver regulator output power level.
+ *
+ * @retval      PMIC_SUCCESS         If the USB transceiver's power supply
+ *                                   configuration was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the PMIC hardware does not support
+ *                                   the desired configuration.
+ */
+PMIC_STATUS pmic_convity_usb_set_power_source(const PMIC_CONVITY_HANDLE handle,
+					      const PMIC_CONVITY_USB_POWER_IN
+					      pwrin,
+					      const PMIC_CONVITY_USB_POWER_OUT
+					      pwrout);
+
+/*!
+ * @brief Get the USB transceiver's power supply configuration.
+ *
+ * Get the USB transceiver's current power supply configuration.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  pwrin           USB transceiver regulator input power source
+ * @param  pwrout          USB transceiver regulator output power level
+ *
+ * @retval      PMIC_SUCCESS         If the USB transceiver's power supply
+ *                                   configuration was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_usb_get_power_source(const PMIC_CONVITY_HANDLE handle,
+					      PMIC_CONVITY_USB_POWER_IN *
+					      const pwrin,
+					      PMIC_CONVITY_USB_POWER_OUT *
+					      const pwrout);
+
+/*!
+ * @brief Set the current USB transceiver operating mode.
+ *
+ * Set the USB transceiver's operating mode.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   mode            Desired operating mode.
+ *
+ * @retval      PMIC_SUCCESS    If the USB transceiver's operating mode
+ *                              was successfully configured.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB transceiver mode is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_set_xcvr(const PMIC_CONVITY_HANDLE handle,
+				      const PMIC_CONVITY_USB_TRANSCEIVER_MODE
+				      mode);
+
+/*!
+ * @brief Get the current USB transceiver operating mode.
+ *
+ * Get the USB transceiver's current operating mode.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  mode            Current operating mode.
+ *
+ * @retval      PMIC_SUCCESS         If the USB transceiver's operating mode
+ *                                   was successfully retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_usb_get_xcvr(const PMIC_CONVITY_HANDLE handle,
+				      PMIC_CONVITY_USB_TRANSCEIVER_MODE *
+				      const mode);
+
+/*!
+ * @brief Set the current USB On-The-Go data line pulse duration (ms).
+ *
+ * Set the Data Line Pulse duration (in milliseconds) for the USB OTG
+ * Session Request Protocol.
+ *
+ * Note that for mc13783 the duration is fixed at 7.5 ms and calling this
+ * function will simply return PMIC_NOT_SUPPORTED.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   duration        The data line pulse duration (ms).
+ *
+ * @retval      PMIC_SUCCESS         If the pulse duration was successfully set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle or the data line pulse
+ *                                   duration is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired data line pulse duration
+ *                                   is not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_dlp_duration(const PMIC_CONVITY_HANDLE
+						  handle,
+						  const unsigned int duration);
+
+/*!
+ * @brief Get the current USB On-The-Go data line pulse duration (ms).
+ *
+ * Get the current Data Line Pulse duration (in milliseconds) for the USB
+ * OTG Session Request Protocol.
+ *
+ * Note that the Data Line Pulse duration is fixed at 7.5 ms for the mc13783
+ * PMIC. Therefore, calling this function while using the mc13783 PMIC will
+ * simply return PMIC_NOT_SUPPORTED.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  duration        The data line pulse duration (ms).
+ *
+ * @retval      PMIC_SUCCESS         If the pulse duration was successfully
+ *                                   obtained.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If called using the mc13783 PMIC.
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_dlp_duration(const PMIC_CONVITY_HANDLE
+						  handle,
+						  unsigned int *const duration);
+
+/*!
+ * @brief Start the USB OTG Host Negotiation Protocol (HNP) process.
+ *
+ * This function must be called during the start of the HNP process to
+ * properly reconfigure the pull-up resistor on the D+ line for both
+ * the USB A and B devices.
+ *
+ * @param   handle          device handle from open() call
+ * @param   deviceType      the USB device type (either A or B)
+ *
+ * @return      PMIC_SUCCESS    if the HNP was successfully started
+ */
+PMIC_STATUS pmic_convity_usb_otg_begin_hnp(const PMIC_CONVITY_HANDLE handle,
+					   const PMIC_CONVITY_USB_DEVICE_TYPE
+					   deviceType);
+
+/*!
+ * @brief Complete the USB OTG Host Negotiation Protocol (HNP) process.
+ *
+ * This function must be called during the end of the HNP process to
+ * properly reconfigure the pull-up resistor on the D+ line for both
+ * the USB A and B devices.
+ *
+ * @param   handle          device handle from open() call
+ * @param   deviceType      the USB device type (either A or B)
+ *
+ * @return      PMIC_SUCCESS    if the HNP was successfully ended
+ */
+PMIC_STATUS pmic_convity_usb_otg_end_hnp(const PMIC_CONVITY_HANDLE handle,
+					 const PMIC_CONVITY_USB_DEVICE_TYPE
+					 deviceType);
+
+/*!
+ * @brief Set the current USB On-The-Go configuration.
+ *
+ * Set the USB On-The-Go (OTG) configuration. Multiple configuration settings
+ * may be OR'd together in a single call. However, selecting conflicting
+ * settings (e.g., multiple VBUS current limits) will result in undefined
+ * behavior.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             Desired USB OTG configuration.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB OTG configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_set_config(const PMIC_CONVITY_HANDLE handle,
+					    const PMIC_CONVITY_USB_OTG_CONFIG
+					    cfg);
+
+/*!
+ * @brief Clear the current USB On-The-Go configuration.
+ *
+ * Clears the USB On-The-Go (OTG) configuration. Multiple configuration settings
+ * may be OR'd together in a single call. However, selecting conflicting
+ * settings (e.g., multiple VBUS current limits) will result in undefined
+ * behavior.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             USB OTG configuration settings to be cleared.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   cleared.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired USB OTG configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_usb_otg_clear_config(const PMIC_CONVITY_HANDLE handle,
+					      const PMIC_CONVITY_USB_OTG_CONFIG
+					      cfg);
+
+/*!
+ * @brief Get the current USB On-The-Go configuration.
+ *
+ * Get the current USB On-The-Go (OTG) configuration.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfg             The current USB OTG configuration.
+ *
+ * @retval      PMIC_SUCCESS         If the OTG configuration was successfully
+ *                                   retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_usb_otg_get_config(const PMIC_CONVITY_HANDLE handle,
+					    PMIC_CONVITY_USB_OTG_CONFIG *
+					    const cfg);
+
+/*@}*/
+
+/***************************************************************************/
+
+/*!
+ * @name RS-232 APIs
+ * RS-232 Connectivity mode-specific configuration and setup functions.
+ */
+/*@{*/
+
+/*!
+ * @brief Set the current RS-232 operating configuration.
+ *
+ * Set the connectivity interface to the selected RS-232 operating mode.
+ * Note that the RS-232 operating mode will be automatically overridden
+ * if the USB_EN is asserted at any time (e.g., when a USB device is
+ * attached).
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   cfgInternal     RS-232 transceiver internal connections.
+ * @param   cfgExternal     RS-232 transceiver external connections.
+ *
+ * @retval      PMIC_SUCCESS         If the requested RS-232 mode was set.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired RS-232 configuration is
+ *                                   not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_rs232_set_config(const PMIC_CONVITY_HANDLE handle,
+					  const PMIC_CONVITY_RS232_INTERNAL
+					  cfgInternal,
+					  const PMIC_CONVITY_RS232_EXTERNAL
+					  cfgExternal);
+
+/*!
+ * @brief Get the current RS-232 operating configuration.
+ *
+ * Get the connectivity interface's current RS-232 operating mode.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param  cfgInternal     RS-232 transceiver internal connections.
+ * @param  cfgExternal     RS-232 transceiver external connections.
+ *
+ * @retval      PMIC_SUCCESS         If the requested RS-232 mode was retrieved.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ */
+PMIC_STATUS pmic_convity_rs232_get_config(const PMIC_CONVITY_HANDLE handle,
+					  PMIC_CONVITY_RS232_INTERNAL *
+					  const cfgInternal,
+					  PMIC_CONVITY_RS232_EXTERNAL *
+					  const cfgExternal);
+
+/***************************************************************************/
+
+/*@}*/
+
+/*!
+ * @name CE-936 APIs
+ * CE-936 Connectivity mode-specific configuration and setup functions.
+ */
+/*@{*/
+
+/*!
+ * @brief Send a signal to exit CEA-936 mode.
+ *
+ * Signal the attached device to exit the current CEA-936 operating mode.
+ * Returns an error if the current operating mode is not CEA-936.
+ *
+ * @param   handle          Device handle from open() call.
+ * @param   signal          Type of exit signal to be sent.
+ *
+ * @retval      PMIC_SUCCESS         If the CEA-936 exit mode signal was sent.
+ * @retval      PMIC_PARAMETER_ERROR If the handle is invalid.
+ * @retval      PMIC_NOT_SUPPORTED   If the desired CEA-936 exit mode signal
+ *                                   is not supported by the PMIC hardware.
+ */
+PMIC_STATUS pmic_convity_cea936_exit_signal(const PMIC_CONVITY_HANDLE handle,
+					    const
+					    PMIC_CONVITY_CEA936_EXIT_SIGNAL
+					    signal);
+
+/*@}*/
+
+#endif				/* __ASM_ARCH_MXC_PMIC_CONVITY_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pmic_external.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pmic_external.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,867 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+#define __ASM_ARCH_MXC_PMIC_EXTERNAL_H__
+
+#ifdef __KERNEL__
+#include <linux/list.h>
+#endif
+
+/*!
+ * @defgroup PMIC_DRVRS PMIC Drivers
+ */
+
+/*!
+ * @defgroup PMIC_CORE PMIC Protocol Drivers
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_external.h
+ * @brief This file contains interface of PMIC protocol driver.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+#include <asm/ioctl.h>
+#include <asm/arch/pmic_status.h>
+
+/*!
+ * This is the enumeration of versions of PMIC
+ */
+typedef enum {
+	PMIC_MC13783 = 1,	/*!< MC13783 */
+} pmic_id_t;
+
+/*!
+ * @struct pmic_version_t
+ * @brief PMIC version and revision
+ */
+typedef struct {
+	/*!
+	 * PMIC version identifier.
+	 */
+	pmic_id_t id;
+	/*!
+	 * Revision of the PMIC.
+	 */
+	int revision;
+} pmic_version_t;
+
+/*!
+ * struct pmic_event_callback_t
+ * @brief This structure contains callback function pointer and its 
+ * parameter to be used when un/registering and launching a callback 
+ * for an event.
+ */
+typedef struct {
+	/*!
+	 * call back function 
+	 */
+	void (*func) (void *);
+
+	/*!
+	 * call back function parameter
+	 */
+	void *param;
+} pmic_event_callback_t;
+
+/*!
+ * This structure is used with IOCTL.
+ * It defines register, register value, register mask and event number
+ */
+typedef struct {
+	/*!
+	 * register number
+	 */
+	int reg;
+	/*!
+	 * value of register
+	 */
+	unsigned int reg_value;
+	/*!
+	 * mask of bits, only used with PMIC_WRITE_REG
+	 */
+	unsigned int reg_mask;
+} register_info;
+
+/*!
+ * @name IOCTL definitions for pmic core driver
+ */
+/*! @{ */
+/*! Read a PMIC register */
+#define PMIC_READ_REG          _IOWR('P', 0xa0, register_info*)
+/*! Write a PMIC register */
+#define PMIC_WRITE_REG         _IOWR('P', 0xa1, register_info*)
+/*! Subscribe a PMIC interrupt event */
+#define PMIC_SUBSCRIBE         _IOR('P', 0xa2, int)
+/*! Unsubscribe a PMIC interrupt event */
+#define PMIC_UNSUBSCRIBE       _IOR('P', 0xa3, int)
+/*! Subscribe a PMIC event for user notification*/
+#define PMIC_NOTIFY_USER       _IOR('P', 0xa4, int)
+/*! Get the PMIC event occured for which user recieved notification */
+#define PMIC_GET_NOTIFY	       _IOW('P', 0xa5, int)
+/*! @} */
+
+/*!
+ * This is PMIC registers valid bits
+ */
+#define PMIC_ALL_BITS           0xFFFFFF
+#define PMIC_MAX_EVENTS		48
+
+#ifdef CONFIG_MXC_PMIC_MC13783
+
+#define PMIC_ARBITRATION	"NULL"
+/*!
+ * This is the enumeration of register names of MC13783
+ */
+typedef enum {
+	/*!
+	 * REG_INTERRUPT_STATUS_0
+	 */
+	REG_INTERRUPT_STATUS_0 = 0,
+	/*!
+	 * REG_INTERRUPT_MASK_0
+	 */
+	REG_INTERRUPT_MASK_0,
+	/*!
+	 * REG_INTERRUPT_SENSE_0
+	 */
+	REG_INTERRUPT_SENSE_0,
+	/*!
+	 * REG_INTERRUPT_STATUS_1
+	 */
+	REG_INTERRUPT_STATUS_1,
+	/*!
+	 * REG_INTERRUPT_MASK_1
+	 */
+	REG_INTERRUPT_MASK_1,
+	/*!
+	 * REG_INTERRUPT_SENSE_1
+	 */
+	REG_INTERRUPT_SENSE_1,
+	/*!
+	 * REG_POWER_UP_MODE_SENSE
+	 */
+	REG_POWER_UP_MODE_SENSE,
+	/*!
+	 * REG_REVISION
+	 */
+	REG_REVISION,
+	/*!
+	 * REG_SEMAPHORE
+	 */
+	REG_SEMAPHORE,
+	/*!
+	 * REG_ARBITRATION_PERIPHERAL_AUDIO
+	 */
+	REG_ARBITRATION_PERIPHERAL_AUDIO,
+	/*!
+	 * REG_ARBITRATION_SWITCHERS
+	 */
+	REG_ARBITRATION_SWITCHERS,
+	/*!
+	 * REG_ARBITRATION_REGULATORS_0
+	 */
+	REG_ARBITRATION_REGULATORS_0,
+	/*!
+	 * REG_ARBITRATION_REGULATORS_1
+	 */
+	REG_ARBITRATION_REGULATORS_1,
+	/*!
+	 * REG_POWER_CONTROL_0
+	 */
+	REG_POWER_CONTROL_0,
+	/*!
+	 * REG_POWER_CONTROL_1
+	 */
+	REG_POWER_CONTROL_1,
+	/*!
+	 * REG_POWER_CONTROL_2
+	 */
+	REG_POWER_CONTROL_2,
+	/*!
+	 * REG_REGEN_ASSIGNMENT
+	 */
+	REG_REGEN_ASSIGNMENT,
+	/*!
+	 * REG_CONTROL_SPARE
+	 */
+	REG_CONTROL_SPARE,
+	/*!
+	 * REG_MEMORY_A
+	 */
+	REG_MEMORY_A,
+	/*!
+	 * REG_MEMORY_B
+	 */
+	REG_MEMORY_B,
+	/*!
+	 * REG_RTC_TIME
+	 */
+	REG_RTC_TIME,
+	/*!
+	 * REG_RTC_ALARM
+	 */
+	REG_RTC_ALARM,
+	/*!
+	 * REG_RTC_DAY
+	 */
+	REG_RTC_DAY,
+	/*!
+	 * REG_RTC_DAY_ALARM
+	 */
+	REG_RTC_DAY_ALARM,
+	/*!
+	 * REG_SWITCHERS_0
+	 */
+	REG_SWITCHERS_0,
+	/*!
+	 * REG_SWITCHERS_1
+	 */
+	REG_SWITCHERS_1,
+	/*!
+	 * REG_SWITCHERS_2
+	 */
+	REG_SWITCHERS_2,
+	/*!
+	 * REG_SWITCHERS_3
+	 */
+	REG_SWITCHERS_3,
+	/*!
+	 * REG_SWITCHERS_4
+	 */
+	REG_SWITCHERS_4,
+	/*!
+	 * REG_SWITCHERS_5
+	 */
+	REG_SWITCHERS_5,
+	/*!
+	 * REG_REGULATOR_SETTING_0
+	 */
+	REG_REGULATOR_SETTING_0,
+	/*!
+	 * REG_REGULATOR_SETTING_1
+	 */
+	REG_REGULATOR_SETTING_1,
+	/*!
+	 * REG_REGULATOR_MODE_0
+	 */
+	REG_REGULATOR_MODE_0,
+	/*!
+	 * REG_REGULATOR_MODE_1
+	 */
+	REG_REGULATOR_MODE_1,
+	/*!
+	 * REG_POWER_MISCELLANEOUS
+	 */
+	REG_POWER_MISCELLANEOUS,
+	/*!
+	 * REG_POWER_SPARE
+	 */
+	REG_POWER_SPARE,
+	/*!
+	 * REG_AUDIO_RX_0
+	 */
+	REG_AUDIO_RX_0,
+	/*!
+	 * REG_AUDIO_RX_1
+	 */
+	REG_AUDIO_RX_1,
+	/*!
+	 * REG_AUDIO_TX
+	 */
+	REG_AUDIO_TX,
+	/*!
+	 * REG_AUDIO_SSI_NETWORK
+	 */
+	REG_AUDIO_SSI_NETWORK,
+	/*!
+	 * REG_AUDIO_CODEC
+	 */
+	REG_AUDIO_CODEC,
+	/*!
+	 * REG_AUDIO_STEREO_DAC
+	 */
+	REG_AUDIO_STEREO_DAC,
+	/*!
+	 * REG_AUDIO_SPARE
+	 */
+	REG_AUDIO_SPARE,
+	/*!
+	 * REG_ADC_0
+	 */
+	REG_ADC_0,
+	/*!
+	 * REG_ADC_1
+	 */
+	REG_ADC_1,
+	/*!
+	 * REG_ADC_2
+	 */
+	REG_ADC_2,
+	/*!
+	 * REG_ADC_3
+	 */
+	REG_ADC_3,
+	/*!
+	 * REG_ADC_4
+	 */
+	REG_ADC_4,
+	/*!
+	 * REG_CHARGER
+	 */
+	REG_CHARGER,
+	/*!
+	 * REG_USB
+	 */
+	REG_USB,
+	/*!
+	 * REG_CHARGE_USB_SPARE
+	 */
+	REG_CHARGE_USB_SPARE,
+	/*!
+	 * REG_LED_CONTROL_0
+	 */
+	REG_LED_CONTROL_0,
+	/*!
+	 * REG_LED_CONTROL_1
+	 */
+	REG_LED_CONTROL_1,
+	/*!
+	 * REG_LED_CONTROL_2
+	 */
+	REG_LED_CONTROL_2,
+	/*!
+	 * REG_LED_CONTROL_3
+	 */
+	REG_LED_CONTROL_3,
+	/*!
+	 * REG_LED_CONTROL_4
+	 */
+	REG_LED_CONTROL_4,
+	/*!
+	 * REG_LED_CONTROL_5
+	 */
+	REG_LED_CONTROL_5,
+	/*!
+	 * REG_SPARE
+	 */
+	REG_SPARE,
+	/*!
+	 * REG_TRIM_0
+	 */
+	REG_TRIM_0,
+	/*!
+	 * REG_TRIM_1
+	 */
+	REG_TRIM_1,
+	/*!
+	 * REG_TEST_0
+	 */
+	REG_TEST_0,
+	/*!
+	 * REG_TEST_1
+	 */
+	REG_TEST_1,
+	/*!
+	 * REG_TEST_2
+	 */
+	REG_TEST_2,
+	/*!
+	 * REG_TEST_3
+	 */
+	REG_TEST_3,
+	/*!
+	 * REG_NB
+	 */
+	REG_NB,
+} pmic_reg;
+
+/*!
+ * This is event list of mc13783 interrupt
+ */
+
+typedef enum {
+	/*!
+	 * ADC has finished requested conversions
+	 */
+	EVENT_ADCDONEI = 0,
+	/*!
+	 * ADCBIS has finished requested conversions
+	 */
+	EVENT_ADCBISDONEI = 1,
+	/*!
+	 * Touchscreen wakeup
+	 */
+	EVENT_TSI = 2,
+	/*!
+	 * ADC reading above high limit
+	 */
+	EVENT_WHIGHI = 3,
+	/*!
+	 * ADC reading below low limit
+	 */
+	EVENT_WLOWI = 4,
+	/*!
+	 * Charger attach and removal
+	 */
+	EVENT_CHGDETI = 6,
+	/*!
+	 * Charger over-voltage detection
+	 */
+	EVENT_CHGOVI = 7,
+	/*!
+	 * Charger path reverse current
+	 */
+	EVENT_CHGREVI = 8,
+	/*!
+	 * Charger path short circuit
+	 */
+	EVENT_CHGSHORTI = 9,
+	/*!
+	 * BP regulator current or voltage regulation
+	 */
+	EVENT_CCCVI = 10,
+	/*!
+	 * Charge current below threshold
+	 */
+	EVENT_CHRGCURRI = 11,
+	/*!
+	 * BP turn on threshold detection
+	 */
+	EVENT_BPONI = 12,
+	/*!
+	 * End of life / low battery detect
+	 */
+	EVENT_LOBATLI = 13,
+	/*!
+	 * Low battery warning
+	 */
+	EVENT_LOBATHI = 14,
+	/*!
+	 * USB detect
+	 */
+	EVENT_USBI = 16,
+	/*!
+	 * USB ID Line detect
+	 */
+	EVENT_IDI = 19,
+	/*!
+	 * Single ended 1 detect
+	 */
+	EVENT_SE1I = 21,
+	/*!
+	 * Car-kit detect
+	 */
+	EVENT_CKDETI = 22,
+	/*!
+	 * 1 Hz time-tick
+	 */
+	EVENT_E1HZI = 24,
+	/*!
+	 * Time of day alarm
+	 */
+	EVENT_TODAI = 25,
+	/*!
+	 * ON1B event
+	 */
+	EVENT_ONOFD1I = 27,
+	/*!
+	 * ON2B event
+	 */
+	EVENT_ONOFD2I = 28,
+	/*!
+	 * ON3B event
+	 */
+	EVENT_ONOFD3I = 29,
+	/*!
+	 * System reset
+	 */
+	EVENT_SYSRSTI = 30,
+	/*!
+	 * RTC reset occurred
+	 */
+	EVENT_RTCRSTI = 31,
+	/*!
+	 * Power cut event
+	 */
+	EVENT_PCI = 32,
+	/*!
+	 * Warm start event
+	 */
+	EVENT_WARMI = 33,
+	/*!
+	 * Memory hold event
+	 */
+	EVENT_MEMHLDI = 34,
+	/*!
+	 * Power ready
+	 */
+	EVENT_PWRRDYI = 35,
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	EVENT_THWARNLI = 36,
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	EVENT_THWARNHI = 37,
+	/*!
+	 * Clock source change
+	 */
+	EVENT_CLKI = 38,
+	/*!
+	 * Semaphore
+	 */
+	EVENT_SEMAFI = 39,
+	/*!
+	 * Microphone bias 2 detect
+	 */
+	EVENT_MC2BI = 41,
+	/*!
+	 * Headset attach
+	 */
+	EVENT_HSDETI = 42,
+	/*!
+	 * Stereo headset detect
+	 */
+	EVENT_HSLI = 43,
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	EVENT_ALSPTHI = 44,
+	/*!
+	 * Short circuit on AHS outputs
+	 */
+	EVENT_AHSSHORTI = 45,
+	/*!
+	 * number of event
+	 */
+	EVENT_NB,
+} type_event;
+
+/*!
+ * This enumeration all senses of MC13783.
+ */
+typedef enum {
+	/*!
+	 * Charger attach sense
+	 */
+	SENSE_CHGDETS,
+	/*!
+	 * Charger over-voltage sense
+	 */
+	SENSE_CHGOVS,
+	/*!
+	 * Charger reverse current
+	 * If 1 current flows into phone
+	 */
+	SENSE_CHGREVS,
+	/*!
+	 * Charger short circuit
+	 */
+	SENSE_CHGSHORTS,
+	/*!
+	 * Charger regulator operating mode
+	 */
+	SENSE_CCCVS,
+	/*!
+	 * Charger current below threshold
+	 */
+	SENSE_CHGCURRS,
+	/*!
+	 * BP turn on
+	 */
+	SENSE_BPONS,
+	/*!
+	 * Low bat detect
+	 */
+	SENSE_LOBATLS,
+	/*!
+	 * Low bat warning
+	 */
+	SENSE_LOBATHS,
+	/*!
+	 * USB 4V4
+	 */
+	SENSE_USB4V4S,
+	/*!
+	 * USB 2V0
+	 */
+	SENSE_USB2V0S,
+	/*!
+	 * USB 0V8
+	 */
+	SENSE_USB0V8S,
+	/*!
+	 * ID Floats
+	 */
+	SENSE_ID_FLOATS,
+	/*!
+	 * ID Gnds
+	 */
+	SENSE_ID_GNDS,
+	/*!
+	 * Single ended
+	 */
+	SENSE_SE1S,
+	/*!
+	 * Car-kit detect
+	 */
+	SENSE_CKDETS,
+	/*!
+	 * mic bias detect
+	 */
+	SENSE_MC2BS,
+	/*!
+	 * headset attached
+	 */
+	SENSE_HSDETS,
+	/*!
+	 * ST headset attached
+	 */
+	SENSE_HSLS,
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	SENSE_ALSPTHS,
+	/*!
+	 * short circuit on AHS
+	 */
+	SENSE_AHSSHORTS,
+	/*!
+	 * ON1B pin is hight
+	 */
+	SENSE_ONOFD1S,
+	/*!
+	 * ON2B pin is hight
+	 */
+	SENSE_ONOFD2S,
+	/*!
+	 * ON3B pin is hight
+	 */
+	SENSE_ONOFD3S,
+	/*!
+	 * System reset power ready
+	 */
+	SENSE_PWRRDYS,
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	SENSE_THWARNHS,
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	SENSE_THWARNLS,
+	/*!
+	 * Clock source is XTAL
+	 */
+	SENSE_CLKS,
+} t_sensor;
+
+/*!
+ * This structure is used to read all sense bits of MC13783.
+ */
+typedef struct {
+	/*!
+	 * Charger attach sense
+	 */
+	bool sense_chgdets;
+	/*!
+	 * Charger over-voltage sense
+	 */
+	bool sense_chgovs;
+	/*!
+	 * Charger reverse current
+	 * If 1 current flows into phone
+	 */
+	bool sense_chgrevs;
+	/*!
+	 * Charger short circuit
+	 */
+	bool sense_chgshorts;
+	/*!
+	 * Charger regulator operating mode
+	 */
+	bool sense_cccvs;
+	/*!
+	 * Charger current below threshold
+	 */
+	bool sense_chgcurrs;
+	/*!
+	 * BP turn on
+	 */
+	bool sense_bpons;
+	/*!
+	 * Low bat detect
+	 */
+	bool sense_lobatls;
+	/*!
+	 * Low bat warning
+	 */
+	bool sense_lobaths;
+	/*!
+	 * USB 4V4
+	 */
+	bool sense_usb4v4s;
+	/*!
+	 * USB 2V0
+	 */
+	bool sense_usb2v0s;
+	/*!
+	 * USB 0V8
+	 */
+	bool sense_usb0v8s;
+	/*!
+	 * ID Floats
+	 */
+	bool sense_id_floats;
+	/*!
+	 * ID Gnds
+	 */
+	bool sense_id_gnds;
+	/*!
+	 * Single ended
+	 */
+	bool sense_se1s;
+	/*!
+	 * Car-kit detect
+	 */
+	bool sense_ckdets;
+	/*!
+	 * mic bias detect
+	 */
+	bool sense_mc2bs;
+	/*!
+	 * headset attached
+	 */
+	bool sense_hsdets;
+	/*!
+	 * ST headset attached
+	 */
+	bool sense_hsls;
+	/*!
+	 * Thermal shutdown ALSP
+	 */
+	bool sense_alspths;
+	/*!
+	 * short circuit on AHS
+	 */
+	bool sense_ahsshorts;
+	/*!
+	 * ON1B pin is hight
+	 */
+	bool sense_onofd1s;
+	/*!
+	 * ON2B pin is hight
+	 */
+	bool sense_onofd2s;
+	/*!
+	 * ON3B pin is hight
+	 */
+	bool sense_onofd3s;
+	/*!
+	 * System reset power ready
+	 */
+	bool sense_pwrrdys;
+	/*!
+	 * Thermal warning higher threshold
+	 */
+	bool sense_thwarnhs;
+	/*!
+	 * Thermal warning lower threshold
+	 */
+	bool sense_thwarnls;
+	/*!
+	 * Clock source is XTAL
+	 */
+	bool sense_clks;
+} t_sensor_bits;
+#endif
+
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function is used to determine the PMIC type and its revision.
+ *
+ * @return      Returns the PMIC type and its revision.
+ */
+pmic_version_t pmic_get_version(void);
+
+/*!
+ * This function is called by PMIC clients to read a register on PMIC.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value   return value of register
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_read_reg(int reg, unsigned int *reg_value,
+			  unsigned int reg_mask);
+/*!
+ * This function is called by PMIC clients to write a register on MC13783.
+ *
+ * @param        priority   priority of access
+ * @param        reg        number of register
+ * @param        reg_value  New value of register
+ * @param        reg_mask   Bitmap mask indicating which bits to modify
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_write_reg(int reg, unsigned int reg_value,
+			   unsigned int reg_mask);
+
+/*!
+ * This function is called by PMIC clients to subscribe on an event.
+ *
+ * @param        event_sub   structure of event, it contains type of event and callback
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_event_subscribe(type_event event,
+				 pmic_event_callback_t callback);
+/*!
+* This function is called by PMIC clients to un-subscribe on an event.
+*
+* @param        event_unsub   structure of event, it contains type of event and callback
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_event_unsubscribe(type_event event,
+				   pmic_event_callback_t callback);
+/*!
+* This function is called to read all sensor bits of PMIC.
+*
+* @param        sensor    Sensor to be checked.
+*
+* @return       This function returns true if the sensor bit is high;
+*               or returns false if the sensor bit is low.
+*/
+bool pmic_check_sensor(t_sensor sensor);
+
+/*!
+* This function checks one sensor of PMIC.
+*
+* @param        sensor_bits  structure of all sensor bits.
+*
+* @return       This function returns PMIC_SUCCESS if successful.
+*/
+PMIC_STATUS pmic_get_sensors(t_sensor_bits * sensor_bits);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_EXTERNAL_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pmic_light.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pmic_light.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,1032 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_LIGHT_H__
+#define __ASM_ARCH_MXC_PMIC_LIGHT_H__
+
+/*!
+ * @defgroup PMIC_LIGHT PMIC Light Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_light.h
+ * @brief This is the header of PMIC Light driver.
+ *
+ * @ingroup PMIC_LIGHT
+ */
+
+#include <asm/ioctl.h>
+#include <asm/arch/pmic_status.h>
+#include <asm/arch/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+
+/*! @{ */
+/*!
+ * Enable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_ENABLE                   _IO('p', 0xe0)
+/*!
+ * Disable Backlight.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_DISABLE                  _IO('p', 0xe1)
+/*!
+ * Set backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_SET_BKLIT                      _IOW('p', 0xe2, int)
+/*!
+ * Get backlight configuration.
+ * Argument type: pointer to t_bklit_setting_param
+ */
+#define PMIC_GET_BKLIT                      _IOWR('p', 0xe3, int)
+/*!
+ * Ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPUP_BKLIT                   _IOW('p', 0xe4, int)
+/*!
+ * Ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_RAMPDOWN_BKLIT                 _IOW('p', 0xe5, int)
+/*!
+ * Enable Tri-color LED.
+ * Argument type: t_tcled_enable_param
+ */
+#define PMIC_TCLED_ENABLE                   _IOW('p', 0xe6, int)
+/*!
+ * Disable Tri-color LED.
+ * Argument type: t_funlight_bank
+ */
+#define PMIC_TCLED_DISABLE                  _IOW('p', 0xe7, int)
+/*!
+ * Start Tri-color LED pattern.
+ * Argument type: t_fun_param
+ */
+#define PMIC_TCLED_PATTERN                  _IOW('p', 0xe8, int)
+/*!
+ * Enable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_ENABLE             _IO('p', 0xe9)
+/*!
+ * Disable Backlight & tcled.
+ * Argument type: none.
+ */
+#define PMIC_BKLIT_TCLED_DISABLE            _IO('p', 0xea)
+/*!
+ * Reset ramp up configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPUP_BKLIT               _IOW('p', 0xeb, int)
+/*!
+ * Reset ramp down configuration.
+ * Argument type: t_bklit_channel
+ */
+#define PMIC_OFF_RAMPDOWN_BKLIT             _IOW('p', 0xec, int)
+/*!
+ * Set tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_SET_TCLED			    _IOW('p', 0xed, int)
+/*!
+ * Get tcled ind configuration.
+ * Argument type: t_tcled_ind_param
+ */
+#define PMIC_GET_TCLED			    _IOWR('p', 0xee, int)
+/*! @} */
+/*!
+ * @enum t_bklit_mode
+ * @brief Backlight modes.
+ */
+typedef enum {
+	BACKLIGHT_CURRENT_CTRL_MODE,	/*! < Current control mode */
+	BACKLIGHT_TRIODE_MODE	/*! < Triode mode */
+} t_bklit_mode;
+
+/*!
+ * @enum t_bklit_channel
+ * @brief Backlight channels.
+ */
+typedef enum {
+	BACKLIGHT_LED1,		/*! < Backlight channel 1 */
+	BACKLIGHT_LED2,		/*! < Backlight channel 2 */
+	BACKLIGHT_LED3		/*! < Backlight channel 3 */
+} t_bklit_channel;
+
+/*!
+ * @enum t_bklit_strobe_mode
+ * @brief Backlight Strobe Light Pulsing modes.
+ */
+typedef enum {
+	/*!
+	 * No Strobe Light Pulsing
+	 */
+	BACKLIGHT_STROBE_NONE,
+	/*!
+	 * Strobe Light Pulsing at 3.3% duty cycle over 300msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_FAST,
+	/*!
+	 * Strobe Light Pulsing at 10% duty cycle over 100msec (Driver goes
+	 * into Triode Mode with pulses constrained to 10msec.)
+	 */
+	BACKLIGHT_STROBE_SLOW
+} t_bklit_strobe_mode;
+
+/*!
+ * @struct t_bklit_setting_param
+ * @brief Backlight setting.
+ */
+
+typedef struct {
+	t_bklit_channel channel;	/*!< Channel */
+	t_bklit_mode mode;	/*!< Mode */
+	t_bklit_strobe_mode strobe;	/*!< Strobe mode */
+	unsigned char current_level;	/*!< Current level */
+	unsigned char duty_cycle;	/*!< Duty cycle */
+	unsigned char cycle_time;	/*!< Cycle time */
+	bool edge_slow;		/*!< Edge Slow */
+	bool en_dis;		/*!< Enable disable boost mode */
+	unsigned int abms;	/*!< Adaptive boost
+				 *   mode selection */
+	unsigned int abr;	/*!< Adaptive
+				 *   boost reference */
+} t_bklit_setting_param;
+
+/*!
+ * @enum t_funlight_bank
+ * @brief Tri-color LED fun light banks.
+ */
+typedef enum {
+	TCLED_FUN_BANK1 = 0,	/*! < Fun light bank 1 */
+	TCLED_FUN_BANK2,	/*! < Fun light bank 2 */
+	TCLED_FUN_BANK3		/*! < Fun light bank 3 */
+} t_funlight_bank;
+
+/*!
+ * @enum t_tcled_mode
+ * @brief Tri-color LED operation modes.
+ *
+ * The Tri-Color LED Driver circuitry includes 2 modes of operation. In LED
+ * Indicator Mode, this circuitry operates as Red and Green LED Drivers with
+ * flasher timing to indicate GSM network status. In Fun Light Mode, this
+ * circuitry provides expanded capability for current control and distribution
+ * that supplements the three channels.
+ */
+typedef enum {
+	TCLED_IND_MODE = 0,	/*! < LED Indicator Mode */
+	TCLED_FUN_MODE		/*! < Fun Light Mode */
+} t_tcled_mode;
+
+/*!
+ * @struct t_tcled_enable_param
+ * @brief enable setting.
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< Bank */
+	t_tcled_mode mode;	/*!< Mode */
+} t_tcled_enable_param;
+
+/*!
+ * @enum t_ind_channel
+ * @brief Tri-color LED indicator mode channels.
+ *
+ */
+
+typedef enum {
+	TCLED_IND_RED = 0,	/*! < Red LED */
+	TCLED_IND_GREEN,	/*! < Green LED */
+	TCLED_IND_BLUE		/*! < Blue LED */
+} t_ind_channel;
+
+/*!
+ * @enum t_funlight_channel
+ * @brief Tri-color LED fun light mode channels.
+ *
+ */
+typedef enum {
+	TCLED_FUN_CHANNEL1 = 0,	/*! < Fun light channel 1 (Red) */
+	TCLED_FUN_CHANNEL2,	/*! < Fun light channel 2 (Green) */
+	TCLED_FUN_CHANNEL3	/*! < Fun light channel 3 (Blue) */
+} t_funlight_channel;
+
+/*!
+ * @enum t_tcled_ind_blink_pattern
+ * @brief Tri-color LED Indicator Mode blinking mode.
+ */
+typedef enum {
+	TCLED_IND_OFF = 0,	/*! < Continuous off */
+	TCLED_IND_BLINK_1,	/*! < 1 / 31 */
+	TCLED_IND_BLINK_2,	/*! < 2 / 31 */
+	TCLED_IND_BLINK_3,	/*! < 3 / 31  */
+	TCLED_IND_BLINK_4,	/*! < 4 / 31  */
+	TCLED_IND_BLINK_5,	/*! < 5 / 31  */
+	TCLED_IND_BLINK_6,	/*! < 6 / 31  */
+	TCLED_IND_BLINK_7,	/*! < 7 / 31  */
+	TCLED_IND_BLINK_8,	/*! < 8 / 31  */
+	TCLED_IND_BLINK_9,	/*! < 9 / 31  */
+	TCLED_IND_BLINK_10,	/*! < 10 / 31  */
+	TCLED_IND_BLINK_11,	/*! < 11 / 31  */
+	TCLED_IND_BLINK_12,	/*! < 12 / 31  */
+	TCLED_IND_BLINK_13,	/*! < 13 / 31  */
+	TCLED_IND_BLINK_14,	/*! < 14 / 31  */
+	TCLED_IND_BLINK_15,	/*! < 15 / 31  */
+	TCLED_IND_BLINK_16,	/*! < 16 / 31  */
+	TCLED_IND_BLINK_17,	/*! < 17 / 31  */
+	TCLED_IND_BLINK_18,	/*! < 18 / 31  */
+	TCLED_IND_BLINK_19,	/*! < 19 / 31  */
+	TCLED_IND_BLINK_20,	/*! < 20 / 31  */
+	TCLED_IND_BLINK_21,	/*! < 21 / 31  */
+	TCLED_IND_BLINK_22,	/*! < 22 / 31  */
+	TCLED_IND_BLINK_23,	/*! < 23 / 31  */
+	TCLED_IND_BLINK_24,	/*! < 24 / 31  */
+	TCLED_IND_BLINK_25,	/*! < 25 / 31  */
+	TCLED_IND_BLINK_26,	/*! < 26 / 31  */
+	TCLED_IND_BLINK_27,	/*! < 27 / 31  */
+	TCLED_IND_BLINK_28,	/*! < 28 / 31  */
+	TCLED_IND_BLINK_29,	/*! < 29 / 31  */
+	TCLED_IND_BLINK_30,	/*! < 30 / 31  */
+	TCLED_IND_ON		/*! < Continuous on */
+} t_tcled_ind_blink_pattern;
+
+/*!
+ * @enum t_tcled_cur_level
+ * @brief Tri-color LED current levels.
+ */
+typedef enum {
+	TCLED_CUR_LEVEL_1 = 0,	/*! < Tri-Color LED current level 1 */
+	TCLED_CUR_LEVEL_2,	/*! < Tri-Color LED current level 2 */
+	TCLED_CUR_LEVEL_3,	/*! < Tri-Color LED current level 3 */
+	TCLED_CUR_LEVEL_4	/*! < Tri-Color LED current level 4 */
+} t_tcled_cur_level;
+
+/*!
+ * @enum t_tcled_fun_cycle_time
+ * @brief Tri-color LED fun light mode cycle time.
+ */
+typedef enum {
+	TC_CYCLE_TIME_1 = 0,	/*! < Tri-Color LED cycle time 1 */
+	TC_CYCLE_TIME_2,	/*! < Tri-Color LED cycle time 2 */
+	TC_CYCLE_TIME_3,	/*! < Tri-Color LED cycle time 3 */
+	TC_CYCLE_TIME_4		/*! < Tri-Color LED cycle time 4 */
+} t_tcled_fun_cycle_time;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_OFF = 0,		/*! < Tri-Color pattern off */
+	TC_SLOW,		/*! < Tri-Color slow pattern */
+	TC_FAST			/*! < Tri-Color fast pattern */
+} t_tcled_fun_speed;
+
+/*!
+ * @enum t_tcled_fun_speed
+ * @brief Tri-color LED fun light mode pattern speed.
+ */
+typedef enum {
+	TC_STROBE_OFF = 0,	/*! < No strobe */
+	TC_STROBE_SLOW,		/*! < Slow strobe pattern */
+	TC_STROBE_FAST		/*! < fast strobe pattern */
+} t_tcled_fun_strobe_speed;
+
+/*!
+ * @enum t_chaselight_pattern
+ * @brief Tri-color LED fun light mode chasing light patterns.
+ */
+typedef enum {
+	PMIC_RGB = 0,		/*!< R -> G -> B */
+	BGR			/*!< B -> G -> R */
+} t_chaselight_pattern;
+
+/*!
+ * This enumeration of Fun Light Pattern.
+ */
+typedef enum {
+	/*!
+	 * Blended ramps slow
+	 */
+	BLENDED_RAMPS_SLOW,
+	/*!
+	 * Blended ramps fast
+	 */
+	BLENDED_RAMPS_FAST,
+	/*!
+	 * Saw ramps slow
+	 */
+	SAW_RAMPS_SLOW,
+	/*!
+	 * Saw ramps fast
+	 */
+	SAW_RAMPS_FAST,
+	/*!
+	 * Blended bowtie slow
+	 */
+	BLENDED_BOWTIE_SLOW,
+	/*!
+	 * Blended bowtie fast
+	 */
+	BLENDED_BOWTIE_FAST,
+	/*!
+	 * Strobe slow
+	 */
+	STROBE_SLOW,
+	/*!
+	 * Strobe fast
+	 */
+	STROBE_FAST,
+	/*!
+	 * Chasing Light RGB Slow
+	 */
+	CHASING_LIGHT_RGB_SLOW,
+	/*!
+	 * Chasing Light RGB fast
+	 */
+	CHASING_LIGHT_RGB_FAST,
+	/*!
+	 * Chasing Light BGR Slow
+	 */
+	CHASING_LIGHT_BGR_SLOW,
+	/*!
+	 * Chasing Light BGR fast
+	 */
+	CHASING_LIGHT_BGR_FAST,
+} t_fun_pattern;
+
+/*!
+ * @struct t_fun_param
+ * @brief LED fun pattern IOCTL parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*!< TCLED bank */
+	t_funlight_channel channel;	/*!< TCLED channel */
+	t_fun_pattern pattern;	/*!< Fun pattern */
+} t_fun_param;
+
+/*!
+ * @enum t_led_channel
+ * @brief LED channels including backlight and tri-color LEDs.
+ */
+typedef enum {
+	AUDIO_LED1,		/*! < Backlight channel 1 */
+	AUDIO_LED2,		/*! < Backlight channel 2 */
+	AUDIO_LEDR,		/*! < Fun light channel 1 (Red) */
+	AUDIO_LEDG,		/*! < Fun light channel 2 (Green) */
+	AUDIO_LEDB		/*! < Fun light channel 3 (Blue) */
+} t_led_channel;
+
+/*!
+ * @enum t_aud_path
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	MIXED_RX = 0,		/*!<  Mixed L & R Channel RX audio */
+	TX			/*!<  TX path */
+} t_aud_path;
+
+/*!
+ * @enum t_aud_gain
+ * @brief LED audio modulation in-out audio channels
+ */
+typedef enum {
+	GAIN_MINUS6DB = 0,	/*!< -6 dB */
+	GAIN_0DB,		/*!< 0 dB */
+	GAIN_6DB,		/*!< 6 dB */
+	GAIN_12DB		/*!< 12 dB */
+} t_aud_gain;
+
+/*!
+ * @struct t_tcled_ind_param
+ * @brief LED parameter
+ */
+typedef struct {
+	t_funlight_bank bank;	/*! < tcled bank */
+	t_ind_channel channel;	/*! < tcled channel */
+	t_tcled_cur_level level;	/*! < tcled current level */
+	t_tcled_ind_blink_pattern pattern;	/*! < tcled dutty cycle */
+	bool skip;		/*! < tcled skip */
+	bool rampup;		/*! < tcled rampup */
+	bool rampdown;		/*! < tcled rampdown */
+	bool half_current;	/*! < tcled half current */
+} t_tcled_ind_param;
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+/*!
+ * This function enables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_tcled_master_enable(void);
+
+/*!
+ * This function disables backlight & tcled.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful
+ */
+PMIC_STATUS pmic_bklit_tcled_master_disable(void);
+
+/*!
+ * This function enables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_enable(void);
+
+/*!
+ * This function disables backlight.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_master_disable(void);
+
+/*!
+ * This function sets backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Backlight current level, as the following table.
+ *                         @verbatim
+                               level     current
+                               ------    -----------
+                                 0         0 mA
+                                 1         12 mA
+                                 2         24 mA
+                                 3         36 mA
+                                 4         48 mA
+                                 5         60 mA
+                                 6         72 mA
+                                 7         84 mA
+                            @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_current(t_bklit_channel channel,
+				   unsigned char level);
+
+/*!
+ * This function retrives backlight current level.
+ *
+ * @param        channel   Backlight channel
+ * @param        level     Pointer to store backlight current level result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_current(t_bklit_channel channel,
+				   unsigned char *level);
+
+/*!
+ * This function sets a backlight channel duty cycle.
+ * LED perceived brightness for each zone may be individually set by setting
+ * duty cycle. The default setting is for 0% duty cycle; this keeps all zone
+ * drivers turned off even after the master enable command. Each LED current
+ * sink can be turned on and adjusted for brightness with an independent 4 bit
+ * word for a duty cycle ranging from 0% to 100% in approximately 6.7% steps.
+ *
+ * @param        channel   Backlight channel.
+ * @param        dc        Backlight duty cycle, as the following table.
+ *                         @verbatim
+                                dc        Duty Cycle (% On-time over Cycle Time)
+                               ------    ---------------------------------------
+                                  0        0%
+                                  1        6.7%
+                                  2        13.3%
+                                  3        20%
+                                  4        26.7%
+                                  5        33.3%
+                                  6        40%
+                                  7        46.7%
+                                  8        53.3%
+                                  9        60%
+                                 10        66.7%
+                                 11        73.3%
+                                 12        80%
+                                 13        86.7%
+                                 14        93.3%
+                                 15        100%
+                             @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_dutycycle(t_bklit_channel channel, unsigned char dc);
+
+/*!
+ * This function retrives a backlight channel duty cycle.
+ *
+ * @param        channel   Backlight channel.
+ * @param        cycle     Pointer to backlight duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_dutycycle(t_bklit_channel channel,
+				     unsigned char *dc);
+
+/*!
+ * This function sets a backlight channel cycle time.
+ * Cycle Time is defined as the period of a complete cycle of
+ * Time_on + Time_off. The default Cycle Time is set to 0.01 seconds such that
+ * the 100 Hz on-off cycling is averaged out by the eye to eliminate
+ * flickering. Additionally, the Cycle Time can be programmed to intentionally
+ * extend the period of on-off cycles for a visual pulsating or blinking effect.
+ *
+ * @param        period    Backlight cycle time, as the following table.
+ *                         @verbatim
+                                period      Cycle Time
+                               --------    ------------
+                                  0          0.01 seconds
+                                  1          0.1 seconds
+                                  2          0.5 seconds
+                                  3          2 seconds
+                             @endverbatim
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_cycle_time(unsigned char period);
+
+/*!
+ * This function retrives a backlight channel cycle time setting.
+ *
+ * @param        period    Pointer to save backlight cycle time setting result.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_cycle_time(unsigned char *period);
+
+/*!
+ * This function sets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_mode(t_bklit_channel channel, t_bklit_mode mode);
+/*!
+ * This function gets backlight operation mode. There are two modes of
+ * operations: current control and triode mode.
+ * The Duty Cycle/Cycle Time control is retained in Triode Mode. Audio
+ * coupling is not available in Triode Mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Backlight operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_mode(t_bklit_channel channel, t_bklit_mode * mode);
+/*!
+ * This function starts backlight brightness ramp up function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampup(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp up function;
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampup(t_bklit_channel channel);
+/*!
+ * This function starts backlight brightness ramp down function; ramp time is
+ * fixed at 0.5 seconds.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_rampdown(t_bklit_channel channel);
+/*!
+ * This function stops backlight brightness ramp down function.
+ *
+ * @param        channel   Backlight channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_off_rampdown(t_bklit_channel channel);
+/*!
+ * This function enables backlight analog edge slowing mode. Analog Edge
+ * Slowing slows down the transient edges to reduce the chance of coupling LED
+ * modulation activity into other circuits. Rise and fall times will be targeted
+ * for approximately 50usec.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_enable_edge_slow(void);
+
+/*!
+ * This function disables backlight analog edge slowing mode. The backlight
+ * drivers will default to an Instant On mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_disable_edge_slow(void);
+/*!
+ * This function gets backlight analog edge slowing mode. DThe backlight
+ *
+ * @param        edge      Edge slowing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_get_edge_slow(bool * edge);
+/*!
+ * This function sets backlight Strobe Light Pulsing mode.
+ *
+ * @param        channel   Backlight channel.
+ * @param        mode      Strobe Light Pulsing mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_bklit_set_strobemode(t_bklit_channel channel,
+				      t_bklit_strobe_mode mode);
+
+/*!
+ * This function enables tri-color LED.
+ *
+ * @param        mode      Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_enable(t_tcled_mode mode, t_funlight_bank bank);
+/*!
+ * This function disables tri-color LED.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_disable(t_funlight_bank bank);
+/*!
+ * This function retrives tri-color LED operation mode.
+ *
+ * @param        mode      Pointer to Tri-color LED operation mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_mode(t_tcled_mode * mode, t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_set_current(t_ind_channel channel,
+				       t_tcled_cur_level level,
+				       t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel current level in indicator mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_current(t_ind_channel channel,
+				       t_tcled_cur_level * level,
+				       t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel blinking pattern in indication
+ * mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Blinking pattern.
+ * @param        skip         If true, skip a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+
+PMIC_STATUS pmic_tcled_ind_set_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern pattern,
+					     bool skip, t_funlight_bank bank);
+/*!
+ * This function retrives a tri-color LED channel blinking pattern in
+ * indication mode.
+ *
+ * @param        channel      Tri-color LED channel.
+ * @param        pattern      Pointer to Blinking pattern.
+ * @param        skip         Pointer to a boolean variable indicating if skip
+ *                            a cycle after each cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_ind_get_blink_pattern(t_ind_channel channel,
+					     t_tcled_ind_blink_pattern *
+					     pattern, bool * skip,
+					     t_funlight_bank bank);
+/*!
+ * This function sets a tri-color LED channel current level in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level level);
+
+/*!
+ * This function retrives a tri-color LED channel current level
+ * in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        level        Pointer to current level.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_current(t_funlight_bank bank,
+				       t_funlight_channel channel,
+				       t_tcled_cur_level * level);
+
+/*!
+ * This function sets tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time ct);
+
+/*!
+ * This function retrives tri-color LED cycle time in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        ct           Pointer to cycle time.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_cycletime(t_funlight_bank bank,
+					 t_tcled_fun_cycle_time * ct);
+
+/*!
+ * This function sets a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_set_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char dc);
+
+/*!
+ * This function retrives a tri-color LED channel duty cycle in Fun Light mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        dc           Pointer to duty cycle.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_get_dutycycle(t_funlight_bank bank,
+					 t_funlight_channel channel,
+					 unsigned char *dc);
+
+/*!
+ * This function initiates Blended Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedramps(t_funlight_bank bank,
+					t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Saw Ramp fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_sawramps(t_funlight_bank bank,
+				    t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Blended Bowtie fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_blendedbowtie(t_funlight_bank bank,
+					 t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Chasing Lights fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        pattern      Chasing light pattern mode.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_chasinglightspattern(t_funlight_bank bank,
+						t_chaselight_pattern pattern,
+						t_tcled_fun_speed speed);
+
+/*!
+ * This function initiates Strobe Mode fun light pattern.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        speed        Speed of pattern.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_strobe(t_funlight_bank bank,
+				  t_funlight_channel channel,
+				  t_tcled_fun_strobe_speed speed);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampup(t_funlight_bank bank,
+				  t_funlight_channel channel, bool rampup);
+/*!
+ * This function gets Tri-color LED brightness Ramp Up function; Ramp time
+ * is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampup       Ramp-up configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampup(t_funlight_bank bank,
+				      t_funlight_channel channel,
+				      bool * rampup);
+
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_rampdown(t_funlight_bank bank,
+				    t_funlight_channel channel, bool rampdown);
+/*!
+ * This function initiates Tri-color LED brightness Ramp Down function; Ramp
+ * time is fixed at 1 second.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ * @param        rampdown     Ramp-down configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_get_fun_rampdown(t_funlight_bank bank,
+					t_funlight_channel channel,
+					bool * rampdown);
+
+/*!
+ * This function enables a Tri-color channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_on(t_funlight_bank bank,
+				     t_funlight_channel channel);
+
+/*!
+ * This function disables a Tri-color LED channel triode mode.
+ *
+ * @param        bank         Tri-color LED bank
+ * @param        channel      Tri-color LED channel.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_tcled_fun_triode_off(t_funlight_bank bank,
+				      t_funlight_channel channel);
+
+/*!
+ * This function enables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_edge_slow(void);
+
+/*!
+ * This function disables Tri-color LED edge slowing.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_edge_slow(void);
+
+/*!
+ * This function enables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_half_current(void);
+
+/*!
+ * This function disables Tri-color LED half current mode.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_half_current(void);
+
+/*!
+ * This function enables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_enable_audio_modulation(t_led_channel channel,
+					       t_aud_path path,
+					       t_aud_gain gain,
+					       bool lpf_bypass);
+
+/*!
+ * This function disables backlight or Tri-color LED audio modulation.
+ *
+ * @return       This function returns PMIC_NOT_SUPPORTED.
+ */
+PMIC_STATUS pmic_tcled_disable_audio_modulation(void);
+/*!
+ * This function enables the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_set_boost_mode(bool en_dis);
+
+/*!
+ * This function gets the boost mode.
+ * Only on mc13783 2.0 or higher
+ *
+ * @param       en_dis   Enable or disable the boost mode
+ *
+ * @return      This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_get_boost_mode(bool * en_dis);
+
+/*!
+ * This function sets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_config_boost_mode(unsigned int abms, unsigned int abr);
+
+/*!
+ * This function gets boost mode configuration
+ * Only on mc13783 2.0 or higher
+ *
+ * @param    abms      Define adaptive boost mode selection
+ * @param    abr       Define adaptive boost reference
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_bklit_gets_boost_mode(unsigned int *abms, unsigned int *abr);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_LIGHT_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pmic_power.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pmic_power.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,1358 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_POWER_H__
+#define __ASM_ARCH_MXC_PMIC_POWER_H__
+
+/*!
+ * @defgroup PMIC_POWER  PMIC Power Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_power.h
+ * @brief This is the header of PMIC power driver.
+ *
+ * @ingroup PMIC_POWER
+ */
+
+#include <asm/ioctl.h>
+#include <asm/arch/pmic_status.h>
+#include <asm/arch/pmic_external.h>
+
+/*!
+ * @name IOCTL user space interface
+ */
+/*! @{ */
+
+/*!
+ * Turn on a regulator.
+ */
+#define PMIC_REGULATOR_ON			_IOWR('p', 0xf0, int)
+
+/*!
+ * Turn off a regulator.
+ */
+#define PMIC_REGULATOR_OFF        	 	_IOWR('p', 0xf1, int)
+
+/*!
+ * Set regulator configuration.
+ */
+#define PMIC_REGULATOR_SET_CONFIG         	_IOWR('p', 0xf2, int)
+
+/*!
+ * Get regulator configuration.
+ */
+#define PMIC_REGULATOR_GET_CONFIG         	_IOWR('p', 0xf3, int)
+
+/*!
+ * Miscellaneous Power Test.
+ */
+#define PMIC_POWER_CHECK_MISC			_IOWR('p', 0xf4, int)
+
+/*! @} */
+
+/*!
+ * This enumeration define all power interrupts
+ */
+typedef enum {
+	/*!
+	 * BP turn on threshold detection
+	 */
+	PWR_IT_BPONI = 0,
+	/*!
+	 * End of life / low battery detect
+	 */
+	PWR_IT_LOBATLI,
+	/*!
+	 * Low battery warning
+	 */
+	PWR_IT_LOBATHI,
+	/*!
+	 * ON1B event
+	 */
+	PWR_IT_ONOFD1I,
+	/*!
+	 * ON2B event
+	 */
+	PWR_IT_ONOFD2I,
+	/*!
+	 * ON3B event
+	 */
+	PWR_IT_ONOFD3I,
+	/*!
+	 * System reset
+	 */
+	PWR_IT_SYSRSTI,
+	/*!
+	 * Power ready
+	 */
+	PWR_IT_PWRRDYI,
+	/*!
+	 * Power cut event
+	 */
+	PWR_IT_PCI,
+	/*!
+	 * Warm start event
+	 */
+	PWR_IT_WARMI,
+	/*!
+	 * Memory hold event
+	 */
+} t_pwr_int;
+
+/*!
+ * VHOLD regulator output voltage setting.
+ */
+typedef enum {
+	VH_1_875V,		/*!< 1.875V */
+	VH_2_5V,		/*!< 2.5V */
+	VH_1_55V,		/*!< 1.55V */
+	VH_PASSTHROUGH,		/*!< Pass-through mode */
+} t_vhold_voltage;
+
+/*!
+ * PMIC power control configuration.
+ */
+
+typedef struct {
+	bool pc_enable;		/*!< Power cut enable */
+	unsigned char pc_timer;	/*!< Power cut timer value */
+	bool pc_count_enable;	/*!< Power cut counter enable,
+				   If TURE, Power cuts are disabled
+				   when pc_count > pc_max_count;
+				   If FALSE, Power cuts are not
+				   disabled when
+				   pc_count > pc_max_count */
+	unsigned char pc_count;	/*!< Power cut count */
+	unsigned char pc_max_count;	/*!< Power cut maximum count */
+	bool warm_enable;	/*!< User Off state enable */
+	bool user_off_pc;	/*!< Automatic transition to user off
+				   during power cut */
+	bool clk_32k_enable;	/*!< 32 kHz output buffer enable
+				   during memory hold */
+	bool clk_32k_user_off;	/*!< Keeps the CLK32KMCU active during
+				   user off power cut modes */
+	bool en_vbkup1;		/*!< enable VBKUP1 regulator */
+	bool auto_en_vbkup1;	/*!< automatically enable VBKUP1
+				   regulator in the memory hold
+				   and user of modes */
+	t_vhold_voltage vhold_voltage;	/*!< output voltage for VBKUP1 */
+	bool en_vbkup2;		/*!< enable VBKUP2 regulator */
+	bool auto_en_vbkup2;	/*!< automatically enable VBKUP2
+				   regulator in the memory hold
+				   and user of modes */
+	t_vhold_voltage vhold_voltage2;	/*!< output voltage for VBKUP2 */
+	unsigned char mem_timer;	/*!< duration of the memory hold
+					   timer */
+	bool mem_allon;		/*!< memory hold timer infinity mode,
+				   If TRUE, the memory hold timer
+				   will be set to infinity and
+				   the mem_timer filed will be
+				   ignored */
+} t_pc_config;
+
+/*!
+ * brief PMIC regulators.
+ */
+
+typedef enum {
+	SW_SW1A = 0,		/*!< SW1A or SW1 */
+	SW_SW1B,		/*!< SW1B */
+	SW_SW2A,		/*!< SW2A or SW2 */
+	SW_SW2B,		/*!< SW2B */
+	SW_SW3,			/*!< SW3 */
+	SW_PLL,			/*!< PLL */
+	REGU_VAUDIO,		/*!< VAUDIO */
+	REGU_VIOHI,		/*!< VIOHI */
+	REGU_VIOLO,		/*!< VIOLO */
+	REGU_VDIG,		/*!< VDIG */
+	REGU_VGEN,		/*!< VGEN */
+	REGU_VRFDIG,		/*!< VRFDIG */
+	REGU_VRFREF,		/*!< VRFREF */
+	REGU_VRFCP,		/*!< VRFCP */
+	REGU_VSIM,		/*!< VSIM */
+	REGU_VESIM,		/*!< VESIM */
+	REGU_VCAM,		/*!< VCAM */
+	REGU_VRFBG,		/*!< VRFBG */
+	REGU_VVIB,		/*!< VVIB */
+	REGU_VRF1,		/*!< VRF1 */
+	REGU_VRF2,		/*!< VRF2 */
+	REGU_VMMC1,		/*!< VMMC1 or VMMC */
+	REGU_VMMC2,		/*!< VMMC2 */
+	REGU_GPO1,		/*!< GPIO1 */
+	REGU_GPO2,		/*!< GPO2 */
+	REGU_GPO3,		/*!< GPO3 */
+	REGU_GPO4,		/*!< GPO4 */
+	REGU_V1,		/*!< V1 */
+	REGU_V2,		/*!< V2 */
+	REGU_V3,		/*!< V3 */
+	REGU_V4,		/*!< V4 */
+} t_pmic_regulator;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw1
+ * @brief PMIC Switch mode regulator SW1 output voltages.
+ */
+
+typedef enum {
+	SW1_1V = 0,		/*!< 1.0 V */
+	SW1_1_1V,		/*!< 1.1 V */
+	SW1_1_2V,		/*!< 1.2 V */
+	SW1_1_3V,		/*!< 1.3 V */
+	SW1_1_4V,		/*!< 1.4 V */
+	SW1_1_55V,		/*!< 1.55 V */
+	SW1_1_625V,		/*!< 1.625 V */
+	SW1_1_875V,		/*!< 1.875 V */
+} t_pmic_regulator_voltage_sw1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw1a
+ * @brief PMIC regulator SW1A output voltage.
+ */
+typedef enum {
+	SW1A_0_9V = 0,		/*!< 0.900 V */
+	SW1A_0_925V,		/*!< 0.925 V */
+	SW1A_0_95V,		/*!< 0.950 V */
+	SW1A_0_975V,		/*!< 0.975 V */
+	SW1A_1V,		/*!< 1.000 V */
+	SW1A_1_025V,		/*!< 1.025 V */
+	SW1A_1_05V,		/*!< 1.050 V */
+	SW1A_1_075V,		/*!< 1.075 V */
+	SW1A_1_1V,		/*!< 1.100 V */
+	SW1A_1_125V,		/*!< 1.125 V */
+	SW1A_1_15V,		/*!< 1.150 V */
+	SW1A_1_175V,		/*!< 1.175 V */
+	SW1A_1_2V,		/*!< 1.200 V */
+	SW1A_1_225V,		/*!< 1.225 V */
+	SW1A_1_25V,		/*!< 1.250 V */
+	SW1A_1_275V,		/*!< 1.275 V */
+	SW1A_1_3V,		/*!< 1.300 V */
+	SW1A_1_325V,		/*!< 1.325 V */
+	SW1A_1_35V,		/*!< 1.350 V */
+	SW1A_1_375V,		/*!< 1.375 V */
+	SW1A_1_4V,		/*!< 1.400 V */
+	SW1A_1_425V,		/*!< 1.425 V */
+	SW1A_1_45V,		/*!< 1.450 V */
+	SW1A_1_475V,		/*!< 1.475 V */
+	SW1A_1_5V,		/*!< 1.500 V */
+	SW1A_1_525V,		/*!< 1.525 V */
+	SW1A_1_55V,		/*!< 1.550 V */
+	SW1A_1_575V,		/*!< 1.575 V */
+	SW1A_1_6V,		/*!< 1.600 V */
+	SW1A_1_625V,		/*!< 1.625 V */
+	SW1A_1_65V,		/*!< 1.650 V */
+	SW1A_1_675V,		/*!< 1.675 V */
+	SW1A_1_7V,		/*!< 1.700 V */
+	SW1A_1_8V = 36,		/*!< 1.800 V */
+	SW1A_1_85V = 40,	/*!< 1.850 V */
+	SW1A_2V = 44,		/*!< 2_000 V */
+	SW1A_2_1V = 48,		/*!< 2_100 V */
+	SW1A_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw1a;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw1b
+ * @brief PMIC regulator SW1B output voltage.
+ */
+typedef enum {
+	SW1B_0_9V = 0,		/*!< 0.900 V */
+	SW1B_0_925V,		/*!< 0.925 V */
+	SW1B_0_95V,		/*!< 0.950 V */
+	SW1B_0_975V,		/*!< 0.975 V */
+	SW1B_1V,		/*!< 1.000 V */
+	SW1B_1_025V,		/*!< 1.025 V */
+	SW1B_1_05V,		/*!< 1.050 V */
+	SW1B_1_075V,		/*!< 1.075 V */
+	SW1B_1_1V,		/*!< 1.100 V */
+	SW1B_1_125V,		/*!< 1.125 V */
+	SW1B_1_15V,		/*!< 1.150 V */
+	SW1B_1_175V,		/*!< 1.175 V */
+	SW1B_1_2V,		/*!< 1.200 V */
+	SW1B_1_225V,		/*!< 1.225 V */
+	SW1B_1_25V,		/*!< 1.250 V */
+	SW1B_1_275V,		/*!< 1.275 V */
+	SW1B_1_3V,		/*!< 1.300 V */
+	SW1B_1_325V,		/*!< 1.325 V */
+	SW1B_1_35V,		/*!< 1.350 V */
+	SW1B_1_375V,		/*!< 1.375 V */
+	SW1B_1_4V,		/*!< 1.400 V */
+	SW1B_1_425V,		/*!< 1.425 V */
+	SW1B_1_45V,		/*!< 1.450 V */
+	SW1B_1_475V,		/*!< 1.475 V */
+	SW1B_1_5V,		/*!< 1.500 V */
+	SW1B_1_525V,		/*!< 1.525 V */
+	SW1B_1_55V,		/*!< 1.550 V */
+	SW1B_1_575V,		/*!< 1.575 V */
+	SW1B_1_6V,		/*!< 1.600 V */
+	SW1B_1_625V,		/*!< 1.625 V */
+	SW1B_1_65V,		/*!< 1.650 V */
+	SW1B_1_675V,		/*!< 1.675 V */
+	SW1B_1_7V,		/*!< 1.700 V */
+	SW1B_1_8V = 36,		/*!< 1.800 V */
+	SW1B_1_85V = 40,	/*!< 1.850 V */
+	SW1B_2V = 44,		/*!< 2_000 V */
+	SW1B_2_1V = 48,		/*!< 2_100 V */
+	SW1B_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw1b;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw2
+ * @brief PMIC Switch mode regulator SW2 output voltages.
+  */
+typedef enum {
+	SW2_1V = 0,		/*!< 1.0 V */
+	SW2_1_1V,		/*!< 1.1 V */
+	SW2_1_2V,		/*!< 1.2 V */
+	SW2_1_3V,		/*!< 1.3 V */
+	SW2_1_4V,		/*!< 1.4 V */
+	SW2_1_55V,		/*!< 1.55 V */
+	SW2_1_625V,		/*!< 1.625 V */
+	SW2_1_875V,		/*!< 1.875 V */
+} t_pmic_regulator_voltage_sw2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw2a
+ * @brief PMIC regulator SW2A output voltage.
+ */
+typedef enum {
+	SW2A_0_9V = 0,		/*!< 0.900 V */
+	SW2A_0_925V,		/*!< 0.925 V */
+	SW2A_0_95V,		/*!< 0.950 V */
+	SW2A_0_975V,		/*!< 0.975 V */
+	SW2A_1V,		/*!< 1.000 V */
+	SW2A_1_025V,		/*!< 1.025 V */
+	SW2A_1_05V,		/*!< 1.050 V */
+	SW2A_1_075V,		/*!< 1.075 V */
+	SW2A_1_1V,		/*!< 1.100 V */
+	SW2A_1_125V,		/*!< 1.125 V */
+	SW2A_1_15V,		/*!< 1.150 V */
+	SW2A_1_175V,		/*!< 1.175 V */
+	SW2A_1_2V,		/*!< 1.200 V */
+	SW2A_1_225V,		/*!< 1.225 V */
+	SW2A_1_25V,		/*!< 1.250 V */
+	SW2A_1_275V,		/*!< 1.275 V */
+	SW2A_1_3V,		/*!< 1.300 V */
+	SW2A_1_325V,		/*!< 1.325 V */
+	SW2A_1_35V,		/*!< 1.350 V */
+	SW2A_1_375V,		/*!< 1.375 V */
+	SW2A_1_4V,		/*!< 1.400 V */
+	SW2A_1_425V,		/*!< 1.425 V */
+	SW2A_1_45V,		/*!< 1.450 V */
+	SW2A_1_475V,		/*!< 1.475 V */
+	SW2A_1_5V,		/*!< 1.500 V */
+	SW2A_1_525V,		/*!< 1.525 V */
+	SW2A_1_55V,		/*!< 1.550 V */
+	SW2A_1_575V,		/*!< 1.575 V */
+	SW2A_1_6V,		/*!< 1.600 V */
+	SW2A_1_625V,		/*!< 1.625 V */
+	SW2A_1_65V,		/*!< 1.650 V */
+	SW2A_1_675V,		/*!< 1.675 V */
+	SW2A_1_7V,		/*!< 1.700 V */
+	SW2A_1_8V = 36,		/*!< 1.800 V */
+	SW2A_1_9V = 40,		/*!< 1.900 V */
+	SW2A_2V = 44,		/*!< 2_000 V */
+	SW2A_2_1V = 48,		/*!< 2_100 V */
+	SW2A_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw2a;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw2b
+ * @brief PMIC regulator SW2B output voltage.
+ */
+typedef enum {
+	SW2B_0_9V = 0,		/*!< 0.900 V */
+	SW2B_0_925V,		/*!< 0.925 V */
+	SW2B_0_95V,		/*!< 0.950 V */
+	SW2B_0_975V,		/*!< 0.975 V */
+	SW2B_1V,		/*!< 1.000 V */
+	SW2B_1_025V,		/*!< 1.025 V */
+	SW2B_1_05V,		/*!< 1.050 V */
+	SW2B_1_075V,		/*!< 1.075 V */
+	SW2B_1_1V,		/*!< 1.100 V */
+	SW2B_1_125V,		/*!< 1.125 V */
+	SW2B_1_15V,		/*!< 1.150 V */
+	SW2B_1_175V,		/*!< 1.175 V */
+	SW2B_1_2V,		/*!< 1.200 V */
+	SW2B_1_225V,		/*!< 1.225 V */
+	SW2B_1_25V,		/*!< 1.250 V */
+	SW2B_1_275V,		/*!< 1.275 V */
+	SW2B_1_3V,		/*!< 1.300 V */
+	SW2B_1_325V,		/*!< 1.325 V */
+	SW2B_1_35V,		/*!< 1.350 V */
+	SW2B_1_375V,		/*!< 1.375 V */
+	SW2B_1_4V,		/*!< 1.400 V */
+	SW2B_1_425V,		/*!< 1.425 V */
+	SW2B_1_45V,		/*!< 1.450 V */
+	SW2B_1_475V,		/*!< 1.475 V */
+	SW2B_1_5V,		/*!< 1.500 V */
+	SW2B_1_525V,		/*!< 1.525 V */
+	SW2B_1_55V,		/*!< 1.550 V */
+	SW2B_1_575V,		/*!< 1.575 V */
+	SW2B_1_6V,		/*!< 1.600 V */
+	SW2B_1_625V,		/*!< 1.625 V */
+	SW2B_1_65V,		/*!< 1.650 V */
+	SW2B_1_675V,		/*!< 1.675 V */
+	SW2B_1_7V,		/*!< 1.700 V */
+	SW2B_1_8V = 36,		/*!< 1.800 V */
+	SW2B_1_9V = 40,		/*!< 1.900 V */
+	SW2B_2V = 44,		/*!< 2_000 V */
+	SW2B_2_1V = 48,		/*!< 2_100 V */
+	SW2B_2_2V = 52,		/*!< 2_200 V */
+} t_pmic_regulator_voltage_sw2b;
+
+/*!
+ * @enum t_pmic_regulator_voltage_sw3
+ * @brief PMIC Switch mode regulator SW3 output voltages.
+ */
+typedef enum {
+	SW3_5V = 0,		/*!< 5.0 V */
+	SW3_5_1V = 0,		/*!< 5.1 V */
+	SW3_5_6V,		/*!< 5.6 V */
+} t_pmic_regulator_voltage_sw3;
+
+/*!
+ * @enum t_switcher_factor
+ * @brief PLL multiplication factor
+ */
+typedef enum {
+	FACTOR_28 = 0,		/*!< 917 504 kHz */
+	FACTOR_29,		/*!< 950 272 kHz */
+	FACTOR_30,		/*!< 983 040 kHz */
+	FACTOR_31,		/*!< 1 015 808 kHz */
+	FACTOR_32,		/*!< 1 048 576 kHz */
+	FACTOR_33,		/*!< 1 081 344 kHz */
+	FACTOR_34,		/*!< 1 114 112 kHz */
+	FACTOR_35,		/*!< 1 146 880 kHz */
+} t_switcher_factor;
+
+/*!
+ * @enum t_pmic_regulator_voltage_violo
+ * @brief PMIC regulator VIOLO output voltage.
+ */
+typedef enum {
+	VIOLO_1_2V = 0,		/*!< 1.2 V */
+	VIOLO_1_3V,		/*!< 1.3 V */
+	VIOLO_1_5V,		/*!< 1.5 V */
+	VIOLO_1_8V,		/*!< 1.8 V */
+} t_pmic_regulator_voltage_violo;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vdig
+ * @brief PMIC regulator VDIG output voltage.
+ */
+typedef enum {
+	VDIG_1_2V = 0,		/*!< 1.2 V */
+	VDIG_1_3V,		/*!< 1.3 V */
+	VDIG_1_5V,		/*!< 1.5 V */
+	VDIG_1_8V,		/*!< 1.8 V */
+} t_pmic_regulator_voltage_vdig;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vgen
+ * @brief PMIC regulator VGEN output voltage.
+ */
+typedef enum {
+	VGEN_1_2V = 0,		/*!< 1.2 V */
+	VENG_1_3V,		/*!< 1.3 V */
+	VGEN_1_5V,		/*!< 1.5 V */
+	VGEN_1_8V,		/*!< 1.8 V */
+	VGEN_1_1V,		/*!< 1.1 V */
+	VGEN_2V,		/*!< 2 V */
+	VGEN_2_775V,		/*!< 2.775 V */
+	VGEN_2_4V,		/*!< 2.4 V */
+} t_pmic_regulator_voltage_vgen;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrfdig
+ * @brief PMIC regulator VRFDIG output voltage.
+ */
+typedef enum {
+	VRFDIG_1_2V = 0,	/*!< 1.2 V */
+	VRFDIG_1_5V,		/*!< 1.5 V */
+	VRFDIG_1_8V,		/*!< 1.8 V */
+	VRFDIG_1_875V,		/*!< 1.875 V */
+} t_pmic_regulator_voltage_vrfdig;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrfref
+ * @brief PMIC regulator VRFREF output voltage.
+ */
+typedef enum {
+	VRFREF_2_475V = 0,	/*!< 2.475 V */
+	VRFREF_2_6V,		/*!< 2.600 V */
+	VRFREF_2_7V,		/*!< 2.700 V */
+	VRFREF_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrfref;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrfcp
+ * @brief PMIC regulator VRFCP output voltage.
+ */
+typedef enum {
+	VRFCP_2_7V = 0,		/*!< 2.700 V */
+	VRFCP_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrfcp;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vsim
+ * @brief PMIC linear regulator VSIM output voltage.
+ */
+typedef enum {
+	VSIM_1_8V = 0,		/*!< 1.8 V */
+	VSIM_2_9V,		/*!< 2.90 V */
+	VSIM_3V = 1,		/*!< 3 V */
+} t_pmic_regulator_voltage_vsim;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vesim
+ * @brief PMIC regulator VESIM output voltage.
+ */
+typedef enum {
+	VESIM_1_8V = 0,		/*!< 1.80 V */
+	VESIM_2_9V,		/*!< 2.90 V */
+} t_pmic_regulator_voltage_vesim;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vcam
+ * @brief PMIC regulator VCAM output voltage.
+ */
+typedef enum {
+	VCAM_1_5V = 0,		/*!< 1.50 V */
+	VCAM_1_8V,		/*!< 1.80 V */
+	VCAM_2_5V,		/*!< 2.50 V */
+	VCAM_2_55V,		/*!< 2.55 V */
+	VCAM_2_6V,		/*!< 2.60 V */
+	VCAM_2_75V,		/*!< 2.75 V */
+	VCAM_2_8V,		/*!< 2.80 V */
+	VCAM_3V,		/*!< 3.00 V */
+} t_pmic_regulator_voltage_vcam;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vvib
+ * @brief PMIC linear regulator V_VIB output voltage.
+ */
+typedef enum {
+	VVIB_1_3V = 0,		/*!< 1.30 V */
+	VVIB_1_8V,		/*!< 1.80 V */
+	VVIB_2V,		/*!< 2 V */
+	VVIB_3V,		/*!< 3 V */
+} t_pmic_regulator_voltage_vvib;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrf1
+ * @brief PMIC regulator VRF1 output voltage.
+ */
+typedef enum {
+	VRF1_1_5V = 0,		/*!< 1.500 V */
+	VRF1_1_875V,		/*!< 1.875 V */
+	VRF1_2_7V,		/*!< 2.700 V */
+	VRF1_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrf1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vrf2
+ * @brief PMIC regulator VRF2 output voltage.
+ */
+typedef enum {
+	VRF2_1_5V = 0,		/*!< 1.500 V */
+	VRF2_1_875V,		/*!< 1.875 V */
+	VRF2_2_7V,		/*!< 2.700 V */
+	VRF2_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_vrf2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vmmc
+ * @brief PMIC linear regulator VMMC output voltage.
+ */
+typedef enum {
+	VMMC_OFF = 0,		/*!< Output off */
+	VMMC_1_6V,		/*!< 1.6 V */
+	VMMC_1_8V,		/*!< 1.8 V */
+	VMMC_2V,		/*!< 2 V */
+	VMMC_2_2V,		/*!< 2.2 V */
+	VMMC_2_4V,		/*!< 2.4 V */
+	VMMC_2_6V,		/*!< 2.6 V */
+	VMMC_2_8V,		/*!< 2.8 V */
+	VMMC_3V,		/*!< 3 V */
+	VMMC_3_2V,		/*!< 3.2 V */
+	VMMC_3_3V,		/*!< 3.3 V */
+	VMMC_3_4V,		/*!< 3.4 V */
+} t_pmic_regulator_voltage_vmmc;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vmmc1
+ * @brief PMIC regulator VMMC1 output voltage.
+ */
+typedef enum {
+	VMMC1_1_6V = 0,		/*!< 1.60 V */
+	VMMC1_1_8V,		/*!< 1.80 V */
+	VMMC1_2V,		/*!< 2.00 V */
+	VMMC1_2_6V,		/*!< 2.60 V */
+	VMMC1_2_7V,		/*!< 2.70 V */
+	VMMC1_2_8V,		/*!< 2.80 V */
+	VMMC1_2_9V,		/*!< 2.90 V */
+	VMMC1_3V,		/*!< 3.00 V */
+} t_pmic_regulator_voltage_vmmc1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_vmmc2
+ * @brief PMIC regulator VMMC2 output voltage.
+ */
+typedef enum {
+	VMMC2_1_6V = 0,		/*!< 1.60 V */
+	VMMC2_1_8V,		/*!< 1.80 V */
+	VMMC2_2V,		/*!< 2.00 V */
+	VMMC2_2_6V,		/*!< 2.60 V */
+	VMMC2_2_7V,		/*!< 2.70 V */
+	VMMC2_2_8V,		/*!< 2.80 V */
+	VMMC2_2_9V,		/*!< 2.90 V */
+	VMMC2_3V,		/*!< 3.00 V */
+} t_pmic_regulator_voltage_vmmc2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v1
+ * @brief PMIC linear regulator V1 output voltages.
+ */
+typedef enum {
+	V1_2_775V = 0,		/*!< 2.775 V */
+	V1_1_2V,		/*!< 1.2 V */
+	V1_1_3V,		/*!< 1.3 V */
+	V1_1_4V,		/*!< 1.4 V */
+	V1_1_55V,		/*!< 1.55 V */
+	V1_1_75V,		/*!< 1.75 V */
+	V1_1_875V,		/*!< 1.875 V */
+	V1_2_475V,		/*!< 2.475 V */
+} t_pmic_regulator_voltage_v1;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v2
+ * @brief PMIC linear regulator V2 output voltage, V2 has fixed
+ * output voltage 2.775 volts.
+ */
+typedef enum {
+	V2_2_775V = 0,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_v2;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v3
+ * @brief PMIC linear regulator V3 output voltage.
+ */
+typedef enum {
+	V3_1_875V = 0,		/*!< 1.875 V */
+	V3_2_775V,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_v3;
+
+/*!
+ * @enum t_pmic_regulator_voltage_v4
+ * @brief PMIC linear regulator V4 output voltage, V4 has fixed
+ * output voltage 2.775 volts.
+ */
+typedef enum {
+	V4_2_775V = 0,		/*!< 2.775 V */
+} t_pmic_regulator_voltage_v4;
+
+/*!
+ * @union t_regulator_voltage
+ * @brief PMIC regulator output voltages.
+ */
+typedef union {
+	t_pmic_regulator_voltage_sw1 sw1;	/*!< SW1 voltage */
+	t_pmic_regulator_voltage_sw1a sw1a;	/*!< SW1A voltage */
+	t_pmic_regulator_voltage_sw1b sw1b;	/*!< SW1B voltage */
+	t_pmic_regulator_voltage_sw2 sw2;	/*!< SW2 voltage */
+	t_pmic_regulator_voltage_sw2a sw2a;	/*!< SW2A voltage */
+	t_pmic_regulator_voltage_sw2b sw2b;	/*!< SW2B voltage */
+	t_pmic_regulator_voltage_sw3 sw3;	/*!< SW3 voltage */
+	t_pmic_regulator_voltage_violo violo;	/*!< VIOLO voltage */
+	t_pmic_regulator_voltage_vdig vdig;	/*!< VDIG voltage */
+	t_pmic_regulator_voltage_vgen vgen;	/*!< VGEN voltage */
+	t_pmic_regulator_voltage_vrfdig vrfdig;	/*!< VRFDIG voltage */
+	t_pmic_regulator_voltage_vrfref vrfref;	/*!< VRFREF voltage */
+	t_pmic_regulator_voltage_vrfcp vrfcp;	/*!< VRFCP voltage */
+	t_pmic_regulator_voltage_vsim vsim;	/*!< VSIM voltage */
+	t_pmic_regulator_voltage_vesim vesim;	/*!< VESIM voltage */
+	t_pmic_regulator_voltage_vcam vcam;	/*!< VCAM voltage */
+	t_pmic_regulator_voltage_vvib vvib;	/*!< VVIB voltage */
+	t_pmic_regulator_voltage_vrf1 vrf1;	/*!< VRF1 voltage */
+	t_pmic_regulator_voltage_vrf2 vrf2;	/*!< VRF2 voltage */
+	t_pmic_regulator_voltage_vmmc vmmc;	/*!< VMMC voltage */
+	t_pmic_regulator_voltage_vmmc1 vmmc1;	/*!< VMMC1 voltage */
+	t_pmic_regulator_voltage_vmmc2 vmmc2;	/*!< VMMC2 voltage */
+	t_pmic_regulator_voltage_v1 v1;	/*!< V1 voltage */
+	t_pmic_regulator_voltage_v2 v2;	/*!< V2 voltage */
+	t_pmic_regulator_voltage_v3 v3;	/*!< V3 voltage */
+	t_pmic_regulator_voltage_v4 v4;	/*!< V4 voltage */
+} t_regulator_voltage;
+
+/*!
+ * @enum t_pmic_regulator_sw_mode
+ * @brief define switch mode regulator mode.
+ *
+ * The synchronous rectifier can be disabled (and pulse-skipping enabled)
+ * to improve low current efficiency. Software should disable synchronous 
+ * rectifier / enable the pulse skipping for average loads less than 
+ * approximately 30 mA, depending on the quiescent current penalty due to 
+ * synchronous mode.
+ */
+typedef enum {
+	SYNC_RECT = 0,
+	NO_PULSE_SKIP,
+	PULSE_SKIP,
+	LOW_POWER,
+} t_pmic_regulator_sw_mode;
+
+/*!
+ * Generic PMIC switch mode regulator mode.
+ */
+typedef t_pmic_regulator_sw_mode t_regulator_sw_mode;
+typedef t_pmic_regulator_sw_mode t_regulator_stby_mode;
+
+/*!
+ * @enum t_regulator_lp_mode
+ * @brief Low power mode control modes.
+ */
+
+typedef enum {
+	/*!
+	 * Low Power Mode is disabled
+	 */
+	LOW_POWER_DISABLED = 0,
+	/*!
+	 * Low Power Mode is controlled by STANDBY pin and/or LVS pin
+	 */
+	LOW_POWER_CTRL_BY_PIN,
+	/*!
+	 * Set Low Power mode no matter of hardware pins
+	 */
+	LOW_POWER_EN,
+	/*!
+	 * Set Low Power mode and control by STANDBY
+	 */
+	LOW_POWER_AND_LOW_POWER_CTRL_BY_PIN,
+} t_regulator_lp_mode;
+
+/*!
+ * @enum t_switcher_dvs_speed
+ * @brief DVS speed setting
+ */
+typedef enum {
+	/*!
+	 * Transition speed is dictated by the current
+	 * limit and input -output conditions
+	 */
+	DICTATED = 0,
+	/*!
+	 * 25mV step each 4us
+	 */
+	DVS_4US,
+	/*!
+	 * 25mV step each 8us
+	 */
+	DVS_8US,
+	/*!
+	 * 25mV step each 16us
+	 */
+	DVS_16US,
+} t_switcher_dvs_speed;
+
+/*!
+ * @struct t_regulator_config
+ * @brief regulator configuration.
+ *
+ */
+
+typedef struct {
+	/*!
+	 * Switch mode regulator operation mode. This field only applies to
+	 * switch mode regulators.
+	 */
+	t_regulator_sw_mode mode;
+	/*!
+	 * Switch mode stby regulator operation mode. This field only applies
+	 * to switch mode regulators.
+	 */
+	t_regulator_stby_mode stby_mode;
+	/*!
+	 * Regulator output voltage.
+	 */
+	t_regulator_voltage voltage;
+	/*!
+	 * Regulator output voltage in LVS mode.
+	 */
+	t_regulator_voltage voltage_lvs;
+	/*!
+	 * Regulator output voltage in standby mode.
+	 */
+	t_regulator_voltage voltage_stby;
+	/*!
+	 * Regulator low power mode.
+	 */
+	t_regulator_lp_mode lp_mode;
+	/*!
+	 * Switcher dvs speed
+	 */
+	t_switcher_dvs_speed dvs_speed;
+	/*!
+	 * Switcher panic mode
+	 */
+	bool panic_mode;
+	/*!
+	 * Switcher softstart
+	 */
+	bool softstart;
+	/*!
+	 * PLL Multiplication factor
+	 */
+	t_switcher_factor factor;
+} t_regulator_config;
+
+/*!
+ * @struct t_regulator_cfg_param
+ * @brief regulator configuration structure for IOCTL.
+ *
+ */
+typedef struct {
+	/*!
+	 * Regulator.
+	 */
+	t_pmic_regulator regulator;
+	/*!
+	 * Regulator configuration.
+	 */
+	t_regulator_config cfg;
+} t_regulator_cfg_param;
+
+/*!
+ * This struct list all state reads in Power Up Sense
+ */
+struct t_p_up_sense {
+	/*!
+	 * power up sense ictest
+	 */
+	bool state_ictest;
+	/*!
+	 * power up sense clksel
+	 */
+	bool state_clksel;
+	/*!
+	 * power up mode supply 1
+	 */
+	bool state_pums1;
+	/*!
+	 * power up mode supply 2
+	 */
+	bool state_pums2;
+	/*!
+	 * power up mode supply 3
+	 */
+	bool state_pums3;
+	/*!
+	 * power up sense charge mode 0
+	 */
+	bool state_chrgmode0;
+	/*!
+	 * power up sense charge mode 1
+	 */
+	bool state_chrgmode1;
+	/*!
+	 * power up sense USB mode
+	 */
+	bool state_umod;
+	/*!
+	 * power up sense boot mode enable for USB/RS232
+	 */
+	bool state_usben;
+	/*!
+	 * power up sense switcher 1a1b joined
+	 */
+	bool state_sw_1a1b_joined;
+	/*!
+	 * power up sense switcher 1a1b joined
+	 */
+	bool state_sw_2a2b_joined;
+};
+
+/*!
+ * This enumeration define all On_OFF button
+ */
+typedef enum {
+	/*!
+	 * ON1B
+	 */
+	BT_ON1B = 0,
+	/*!
+	 * ON2B
+	 */
+	BT_ON2B,
+	/*!
+	 * ON3B
+	 */
+	BT_ON3B,
+} t_button;
+
+#ifdef __KERNEL__
+/* EXPORTED FUNCTIONS */
+
+/*!
+ * This function sets user power off in power control register and thus powers
+ * off the phone.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_off(void);
+
+/*!
+ * This function sets the power control configuration.
+ *
+ * @param        pc_config   power control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_set_pc_config(t_pc_config * pc_config);
+
+/*!
+ * This function retrives the power control configuration.
+ *
+ * @param        pc_config   pointer to power control configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_pc_config(t_pc_config * pc_config);
+
+/*!
+ * This function turns on a regulator.
+ *
+ * @param        regulator    The regulator to be turned on.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_on(t_pmic_regulator regulator);
+
+/*!
+ * This function turns off a regulator.
+ *
+ * @param        regulator    The regulator to be turned off.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_off(t_pmic_regulator regulator);
+
+/*!
+ * This function sets the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        voltage      The regulator output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_voltage(t_pmic_regulator regulator,
+					     t_regulator_voltage voltage);
+
+/*!
+ * This function retrieves the regulator output voltage.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        voltage      Pointer to regulator output voltage.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_voltage(t_pmic_regulator regulator,
+					     t_regulator_voltage * voltage);
+
+/*!
+ * This function sets the DVS voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs(t_pmic_regulator regulator,
+					t_regulator_voltage dvs);
+
+/*!
+ * This function gets the DVS voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        dvs          The switch Dynamic Voltage Scaling
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs(t_pmic_regulator regulator,
+					t_regulator_voltage * dvs);
+
+/*!
+ * This function sets the standby voltage
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_stby(t_pmic_regulator regulator,
+					 t_regulator_voltage stby);
+
+/*!
+ * This function gets the standby voltage
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        stby         The switch standby voltage
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_stby(t_pmic_regulator regulator,
+					 t_regulator_voltage * stby);
+
+/*!
+ * This function sets the switchers mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        mode         The switcher mode
+ * @param        stby         Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_mode(t_pmic_regulator regulator,
+					 t_regulator_sw_mode mode, bool stby);
+
+/*!
+ * This function gets the switchers mode.
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        mode         The switcher mode.
+ * @param        stby         Switch between main and standby.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_mode(t_pmic_regulator regulator,
+					 t_regulator_sw_mode * mode, bool stby);
+
+/*!
+ * This function sets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        speed        The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_dvs_speed(t_pmic_regulator regulator,
+					      t_switcher_dvs_speed speed);
+
+/*!
+ * This function gets the switch dvs speed
+ *
+ * @param        regulator    The regulator to be handled.
+ * @param        speed        The dvs speed.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_dvs_speed(t_pmic_regulator regulator,
+					      t_switcher_dvs_speed * speed);
+
+/*!
+ * This function sets the switch panic mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_panic_mode(t_pmic_regulator regulator,
+					       bool panic_mode);
+
+/*!
+ * This function gets the switch panic mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        panic_mode   Enable or disable panic mode
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_panic_mode(t_pmic_regulator regulator,
+					       bool * panic_mode);
+
+/*!
+ * This function sets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_softstart(t_pmic_regulator regulator,
+					      bool softstart);
+
+/*!
+ * This function gets the switch softstart mode
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        softstart    Enable or disable softstart.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_softstart(t_pmic_regulator regulator,
+					      bool * softstart);
+
+/*!
+ * This function sets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        factor              The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_set_factor(t_pmic_regulator regulator,
+					   t_switcher_factor factor);
+
+/*!
+ * This function gets the PLL multiplication factor
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        factor       The multiplication factor.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_switcher_get_factor(t_pmic_regulator regulator,
+					   t_switcher_factor * factor);
+
+/*!
+ * This function enables or disables low power mode.
+ *
+ * @param        regulator    The regulator to be configured.
+ * @param        mode         Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_lp_mode(t_pmic_regulator regulator,
+					     t_regulator_lp_mode lp_mode);
+
+/*!
+ * This function gets low power mode.
+ *
+ * @param        regulator    The regulator to be handled
+ * @param        mode         Select nominal or low power mode.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_lp_mode(t_pmic_regulator regulator,
+					     t_regulator_lp_mode * lp_mode);
+
+/*!
+ * This function sets the regulator configuration.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        config       The regulator output configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_set_config(t_pmic_regulator regulator,
+					    t_regulator_config * config);
+
+/*!
+ * This function retrieves the regulator output configuration.
+ *
+ * @param        regulator    The regulator to be turned off.
+ * @param        config       Pointer to regulator configuration.
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_regulator_get_config(t_pmic_regulator regulator,
+					    t_regulator_config * config);
+
+/*!
+ * This function enables automatically VBKUP2 in the memory hold modes.
+ *
+ * @param        en           if true, enable VBKUP2AUTOMH
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vbkup2_auto_en(bool en);
+
+/*!
+ * This function gets state of automatically VBKUP2.
+ *
+ * @param        en           if true, VBKUP2AUTOMH is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_vbkup2_auto_state(bool * en);
+
+/*!
+ * This function enables battery detect function.
+ *
+ * @param        en           if true, enable BATTDETEN
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_bat_det_en(bool en);
+
+/*!
+ * This function gets state of battery detect function.
+ *
+ * @param        en           if true, BATTDETEN is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_bat_det_state(bool * en);
+
+/*!
+ * This function enables control of VVIB by VIBEN pin.
+ *
+ * @param        en           if true, enable VIBPINCTRL
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_vib_pin_en(bool en);
+
+/*!
+ * This function gets state of control of VVIB by VIBEN pin.
+ * @param        en           if true, VIBPINCTRL is enabled
+ *
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_gets_vib_pin_state(bool * en);
+
+/*!
+ * This function returns power up sense value
+ *
+ * @param        p_up_sense     value of power up sense
+ * @return       This function returns PMIC_SUCCESS if successful.
+ */
+PMIC_STATUS pmic_power_get_power_mode_sense(struct t_p_up_sense *p_up_sense);
+
+/*!
+ * This function configures the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         if true, the regulator is enabled by regen.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_assig(t_pmic_regulator regulator, bool en_dis);
+
+/*!
+ * This function gets the Regen assignment for all regulator
+ *
+ * @param        regulator      type of regulator
+ * @param        en_dis         return value, if true :
+ *       		         the regulator is enabled by regen.
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_regen_assig(t_pmic_regulator regu, bool * en_dis);
+
+/*!
+ * This function sets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_regen_inv(bool en_dis);
+
+/*!
+ * This function gets the Regen polarity.
+ *
+ * @param        en_dis         If true regen is inverted.
+ *
+ * @return       This function returns 0 if successful.
+ */
+
+PMIC_STATUS pmic_power_get_regen_inv(bool * en_dis);
+
+/*!
+ * This function enables esim control voltage.
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_esim_v_en(bool vesim, bool vmmc1, bool vmmc2);
+
+/*!
+ * This function gets esim control voltage values.
+ *
+ * @param        vesim          if true, enable VESIMESIMEN
+ * @param        vmmc1          if true, enable VMMC1ESIMEN
+ * @param        vmmc2          if true, enable VMMC2ESIMEN
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_gets_esim_v_state(bool * vesim,
+					 bool * vmmc1, bool * vmmc2);
+
+/*!
+ * This function enables auto reset after a system reset.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_auto_reset_en(bool en);
+
+/*!
+ * This function gets auto reset configuration.
+ *
+ * @param        en         if true, the auto reset is enabled
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_auto_reset_en(bool * en);
+
+/*!
+ * This function configures a system reset on a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, enable the system reset on this button
+ * @param       deb_time   sets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_set_conf_button(t_button bt, bool sys_rst, int deb_time);
+
+/*!
+ * This function gets configuration of a button.
+ *
+ * @param       bt         type of button.
+ * @param       sys_rst    if true, the system reset is enabled on this button
+ * @param       deb_time   gets the debounce time on this button pin
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_get_conf_button(t_button bt,
+				       bool * sys_rst, int *deb_time);
+
+/*!
+ * This function is used to subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_sub(t_pwr_int event, void *callback);
+
+/*!
+ * This function is used to un subscribe on power event IT.
+ *
+ * @param        event          type of event.
+ * @param        callback       event callback function.
+ *
+ * @return       This function returns 0 if successful.
+ */
+PMIC_STATUS pmic_power_event_unsub(t_pwr_int event, void *callback);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_POWER_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pmic_rtc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pmic_rtc.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,153 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_PMIC_RTC_H__
+#define __ASM_ARCH_MXC_PMIC_RTC_H__
+
+/*!
+ * @defgroup PMIC_RTC PMIC RTC Driver
+ * @ingroup PMIC_DRVRS
+ */
+
+/*!
+ * @file pmic_rtc.h
+ * @brief This is the header of PMIC RTC driver.
+ *
+ * @ingroup PMIC_RTC
+ */
+
+/*
+ * Includes
+ */
+#include <asm/ioctl.h>
+#include <asm/arch/pmic_status.h>
+#include <asm/arch/pmic_external.h>
+
+#define         PMIC_RTC_SET_TIME                    _IOWR('p',0xd1, int)
+#define         PMIC_RTC_GET_TIME                    _IOWR('p',0xd2, int)
+#define         PMIC_RTC_SET_ALARM		     _IOWR('p',0xd3, int)
+#define         PMIC_RTC_GET_ALARM		     _IOWR('p',0xd4, int)
+#define         PMIC_RTC_WAIT_ALARM		     _IOWR('p',0xd5, int)
+#define         PMIC_RTC_ALARM_REGISTER              _IOWR('p',0xd6, int)
+#define         PMIC_RTC_ALARM_UNREGISTER            _IOWR('p',0xd7, int)
+
+/*!
+ * This enumeration define all RTC interrupt
+ */
+typedef enum {
+	/*!
+	 * Time of day alarm
+	 */
+	RTC_IT_ALARM,
+	/*!
+	 * 1 Hz timetick
+	 */
+	RTC_IT_1HZ,
+	/*!
+	 * RTC reset occurred
+	 */
+	RTC_IT_RST,
+} t_rtc_int;
+
+/*
+ * RTC PMIC API
+ */
+
+/* EXPORTED FUNCTIONS */
+#ifdef __KERNEL__
+
+/*!
+ * This function set the real time clock of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time(struct timeval *pmic_time);
+
+/*!
+ * This function set the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_set_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function get the real time clock alarm of PMIC
+ *
+ * @param        pmic_time  	return value of date and time
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_get_time_alarm(struct timeval *pmic_time);
+
+/*!
+ * This function wait the Alarm event
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_wait_alarm(void);
+
+/*!
+ * This function is used to un/subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ * @param        sub      	define if Un/subscribe event.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event(t_rtc_int event, void *callback, bool sub);
+
+/*!
+ * This function is used to subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_sub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to un-subscribe on RTC event IT.
+ *
+ * @param        event  	type of event.
+ * @param        callback  	event callback function.
+ *
+ * @return       This function returns PMIC_STATUS if successful.
+ */
+PMIC_STATUS pmic_rtc_event_unsub(t_rtc_int event, void *callback);
+
+/*!
+ * This function is used to tell if PMIC RTC has been correctly loaded.
+ *
+ * @return       This function returns 1 if RTC was successfully loaded
+ * 		 0 otherwise.
+ */
+int pmic_rtc_loaded(void);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_PMIC_RTC_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/pmic_status.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/pmic_status.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,60 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU Lesser General 
+ * Public License.  You may obtain a copy of the GNU Lesser General 
+ * Public License Version 2.1 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/lgpl-license.html
+ * http://www.gnu.org/copyleft/lgpl.html
+ */
+#ifndef __ASM_ARCH_MXC_PMIC_STATUS_H__
+#define __ASM_ARCH_MXC_PMIC_STATUS_H__
+#include <asm-generic/errno-base.h>
+/*!
+ * @file pmic_status.h
+ * @brief PMIC APIs return code definition.
+ *
+ * @ingroup PMIC_CORE
+ */
+
+/*!
+ * Define bool type if it is not defined.
+ */
+#ifndef bool
+#define bool int
+#endif
+
+/*!
+ * @enum PMIC_STATUS
+ * @brief Define return values for all PMIC APIs.
+ *
+ * These return values are used by all of the PMIC APIs.
+ *
+ * @ingroup PMIC
+ */
+typedef enum {
+	PMIC_SUCCESS = 0,	/*!< The requested operation was successfully
+				   completed.                                     */
+	PMIC_ERROR = -1,	/*!< The requested operation could not be completed
+				   due to an error.                               */
+	PMIC_PARAMETER_ERROR = -2,	/*!< The requested operation failed because
+					   one or more of the parameters was
+					   invalid.                             */
+	PMIC_NOT_SUPPORTED = -3,	/*!< The requested operation could not be
+					   completed because the PMIC hardware
+					   does not support it. */
+	PMIC_SYSTEM_ERROR_EINTR = -EINTR,
+
+	PMIC_MALLOC_ERROR = -5,	/*!< Error in malloc function             */
+	PMIC_UNSUBSCRIBE_ERROR = -6,	/*!< Error in un-subscribe event          */
+	PMIC_EVENT_NOT_SUBSCRIBED = -7,	/*!< Event occur and not subscribed       */
+	PMIC_EVENT_CALL_BACK = -8,	/*!< Error - bad call back                */
+	PMIC_CLIENT_NBOVERFLOW = -9,	/*!< The requested operation could not be
+					   completed because there are too many
+					   PMIC client requests */
+} PMIC_STATUS;
+
+#endif				/* __ASM_ARCH_MXC_PMIC_STATUS_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/sdma.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/sdma.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,433 @@
+
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ASM_ARCH_MXC_SDMA_H__
+#define __ASM_ARCH_MXC_SDMA_H__
+
+/*!
+ * @defgroup SDMA Smart Direct Memory Access (SDMA) Driver
+ */
+
+/*!
+ * @file sdma.h
+ *
+ * @brief This file contains the SDMA API declarations.
+ *
+ * SDMA is responsible on moving data between peripherals and memories (MCU, EMI and DSP).
+ *
+ * @ingroup SDMA
+ */
+
+#include <linux/interrupt.h>
+#include <asm/dma.h>
+#include <stdarg.h>
+
+#include <asm/hardware.h>
+
+/*!
+ * This defines maximum DMA address
+ */
+#define MAX_DMA_ADDRESS 0xffffffff
+
+/*!
+ * This defines maximum number of DMA channels
+ */
+#ifdef CONFIG_MXC_SDMA_API
+#define MAX_DMA_CHANNELS 32
+#define MAX_BD_NUMBER    16
+#else
+#define MAX_DMA_CHANNELS 0
+#endif
+
+/*!
+ * This enumerates  transfer types
+ */
+typedef enum {
+	emi_2_per = 0,		/*!< EMI memory to peripheral */
+	emi_2_int,		/*!< EMI memory to internal RAM */
+	emi_2_emi,		/*!< EMI memory to EMI memory */
+	emi_2_dsp,		/*!< EMI memory to DSP memory */
+	per_2_int,		/*!< Peripheral to internal RAM */
+	per_2_emi,		/*!< Peripheral to internal EMI memory */
+	per_2_dsp,		/*!< Peripheral to DSP memory */
+	int_2_per,		/*!< Internal RAM to peripheral */
+	int_2_int,		/*!< Internal RAM to Internal RAM */
+	int_2_emi,		/*!< Internal RAM to EMI memory */
+	int_2_dsp,		/*!< Internal RAM to DSP memory */
+	dsp_2_per,		/*!< DSP memory to peripheral */
+	dsp_2_int,		/*!< DSP memory to internal RAM */
+	dsp_2_emi,		/*!< DSP memory to EMI memory */
+	dsp_2_dsp,		/*!< DSP memory to DSP memory */
+	emi_2_dsp_loop,		/*!< EMI memory to DSP memory loopback */
+	dsp_2_emi_loop,		/*!< DSP memory to EMI memory loopback */
+	dvfs_pll,		/*!< DVFS script with PLL change       */
+	dvfs_pdr		/*!< DVFS script without PLL change    */
+} sdma_transferT;
+
+/*!
+ * This enumerates peripheral types
+ */
+typedef enum {
+	SSI,			/*!< MCU domain SSI */
+	SSI_SP,			/*!< Shared SSI */
+	MMC,			/*!< MMC */
+	SDHC,			/*!< SDHC */
+	UART,			/*!< MCU domain UART */
+	UART_SP,		/*!< Shared UART */
+	FIRI,			/*!< FIRI */
+	CSPI,			/*!< MCU domain CSPI */
+	CSPI_SP,		/*!< Shared CSPI */
+	SIM,			/*!< SIM */
+	ATA,			/*!< ATA */
+	CCM,			/*!< CCM */
+	EXT,			/*!< External peripheral */
+	MSHC,			/*!< Memory Stick Host Controller */
+	DSP,			/*!< DSP */
+	MEMORY			/*!< Memory */
+} sdma_periphT;
+
+#ifndef TRANSFER_32BIT
+/*!
+ * This defines SDMA access data size
+ */
+#define TRANSFER_32BIT      0x00
+#define TRANSFER_8BIT       0x01
+#define TRANSFER_16BIT      0x02
+#define TRANSFER_24BIT      0x03
+
+#endif
+
+/*!
+ * This defines maximum device name length passed during mxc_request_dma().
+ */
+#define MAX_DEVNAME_LENGTH 32
+
+/*!
+ * This defines SDMA interrupt callback function prototype.
+ */
+typedef void (*dma_callback_t) (void *arg);
+
+/*!
+ * Structure containing sdma channel parameters.
+ */
+typedef struct {
+	__u32 watermark_level;	/*!< Lower/upper threshold that
+				 *   triggers SDMA event
+				 */
+	__u32 per_address;	/*!< Peripheral source/destination
+				 *   physical address
+				 */
+	sdma_periphT peripheral_type;	/*!< Peripheral type */
+	sdma_transferT transfer_type;	/*!< Transfer type   */
+	int event_id;		/*!< Event number,
+				 *   needed by all channels
+				 *   that started by peripherals dma
+				 *   request (per_2_*,*_2_per)
+				 *   Not used for memory and DSP
+				 *   transfers.
+				 */
+	int event_id2;		/*!< Second event number,
+				 *   used in ATA scripts only.
+				 */
+	int bd_number;		/*!< Buffer descriptors number.
+				 *   If not set, single buffer
+				 *   descriptor will be used.
+				 */
+	dma_callback_t callback;	/*!   callback function            */
+	void *arg;		/*!   callback argument            */
+	unsigned long word_size:8;	/*!< SDMA data access word size    */
+} dma_channel_params;
+
+/*!
+ * Structure containing sdma request  parameters.
+ */
+typedef struct {
+	/*!   physical source memory address        */
+	__u8 *sourceAddr;
+	/*!   physical destination memory address   */
+	__u8 *destAddr;
+	/*!   amount of data to transfer,
+	 * updated during mxc_dma_get_config
+	 */
+	__u16 count;
+	/*!< DONE bit of the buffer descriptor,
+	 * updated during mxc_dma_get_config
+	 * 0 - means the BD is done and closed by SDMA
+	 * 1 - means the BD is still being processed by SDMA
+	 */
+	int bd_done;
+	/*!< CONT bit of the buffer descriptor,
+	 * set it if full multi-buffer descriptor mechanism
+	 * required.
+	 */
+	int bd_cont;
+	/*!< ERROR bit of the buffer descriptor,
+	 * updated during mxc_dma_get_config.
+	 * If it is set - there was an error during BD processing.
+	 */
+	int bd_error;
+} dma_request_t;
+
+/*!
+ * Structure containing sdma request  parameters.
+ */
+typedef struct {
+	/*! address of ap_2_ap script */
+	int mxc_sdma_ap_2_ap_addr;
+	/*! address of ap_2_bp script */
+	int mxc_sdma_ap_2_bp_addr;
+	/*! address of bp_2_ap script */
+	int mxc_sdma_bp_2_ap_addr;
+	/*! address of loopback_on_dsp_side script */
+	int mxc_sdma_loopback_on_dsp_side_addr;
+	/*! address of mcu_interrupt_only script */
+	int mxc_sdma_mcu_interrupt_only_addr;
+
+	/*! address of firi_2_per script */
+	int mxc_sdma_firi_2_per_addr;
+	/*! address of firi_2_mcu script */
+	int mxc_sdma_firi_2_mcu_addr;
+	/*! address of per_2_firi script */
+	int mxc_sdma_per_2_firi_addr;
+	/*! address of mcu_2_firi script */
+	int mxc_sdma_mcu_2_firi_addr;
+
+	/*! address of uart_2_per script */
+	int mxc_sdma_uart_2_per_addr;
+	/*! address of uart_2_mcu script */
+	int mxc_sdma_uart_2_mcu_addr;
+	/*! address of per_2_app script */
+	int mxc_sdma_per_2_app_addr;
+	/*! address of mcu_2_app script */
+	int mxc_sdma_mcu_2_app_addr;
+
+	/*! address of uartsh_2_per script */
+	int mxc_sdma_uartsh_2_per_addr;
+	/*! address of uartsh_2_mcu script */
+	int mxc_sdma_uartsh_2_mcu_addr;
+	/*! address of per_2_shp script */
+	int mxc_sdma_per_2_shp_addr;
+	/*! address of mcu_2_shp script */
+	int mxc_sdma_mcu_2_shp_addr;
+
+	/*! address of ata_2_mcu script */
+	int mxc_sdma_ata_2_mcu_addr;
+	/*! address of mcu_2_ata script */
+	int mxc_sdma_mcu_2_ata_addr;
+
+	/*! address of app_2_per script */
+	int mxc_sdma_app_2_per_addr;
+	/*! address of app_2_mcu script */
+	int mxc_sdma_app_2_mcu_addr;
+	/*! address of shp_2_per script */
+	int mxc_sdma_shp_2_per_addr;
+	/*! address of shp_2_mcu script */
+	int mxc_sdma_shp_2_mcu_addr;
+
+	/*! address of mshc_2_mcu script */
+	int mxc_sdma_mshc_2_mcu_addr;
+	/*! address of mcu_2_mshc script */
+	int mxc_sdma_mcu_2_mshc_addr;
+
+	/*! address of dptc_dvfs script */
+	int mxc_sdma_dptc_dvfs_addr;
+
+	/*! address where ram code starts */
+	int mxc_sdma_ram_code_start_addr;
+	/*! size of the ram code */
+	int mxc_sdma_ram_code_size;
+	/*! RAM image address */
+	unsigned short *mxc_sdma_start_addr;
+} sdma_script_start_addrs;
+
+/*! Structure to store the initialized dma_channel parameters */
+typedef struct mxc_sdma_channel_params {
+	/*! Channel params */
+	dma_channel_params chnl_params;
+	/*! Channel type (static channel number or dynamic channel) */
+	unsigned int channel_num;
+} mxc_sdma_channel_params_t;
+
+/*! Private SDMA data structure */
+typedef struct mxc_dma_channel_private {
+	/*! ID of the buffer that was processed */
+	unsigned int buf_tail;
+	/*! Tasklet for the channel */
+	struct tasklet_struct chnl_tasklet;
+	/*! Flag indicates if interrupt is required after every BD transfer */
+	int intr_after_every_bd;
+} mxc_dma_channel_private_t;
+
+/*!
+ * Setup channel according to parameters.
+ * Must be called once after mxc_request_dma()
+ *
+ * @param   channel           channel number
+ * @param   p                 channel parameters pointer
+ * @return  0 on success, error code on fail
+ */
+int mxc_dma_setup_channel(int channel, dma_channel_params * p);
+
+/*!
+ * Allocates dma channel.
+ * If channel's value is 0, then the function allocates a free channel
+ * dynamically and sets its value to channel.
+ * Else allocates requested channel if it is free.
+ * If the channel is busy or no free channels (in dynamic allocation) -EBUSY returned.
+ *
+ * @param   channel           pointer to channel number
+ * @param   devicename        device name
+ * @return  0 on success, error code on fail
+ */
+int mxc_request_dma(int *channel, const char *devicename);
+
+/*!
+ * Configures request parameters. Can be called multiple times after
+ * mxc_request_dma() and mxc_dma_setup_channel().
+ *
+ *
+ * @param   channel           channel number
+ * @param   p                 request parameters pointer
+ * @param   bd_index          index of buffer descriptor to set
+ * @return  0 on success, error code on fail
+ */
+/* int mxc_dma_set_config(int channel, dma_request_t *p, int bd_index); */
+int mxc_dma_set_config(int channel, dma_request_t * p, int bd_index);
+
+/*!
+ * Returns request parameters.
+ *
+ * @param   channel           channel number
+ * @param   p                 request parameters pointer
+ * @param   bd_index          index of buffer descriptor to get
+ * @return  0 on success, error code on fail
+ */
+/* int mxc_dma_get_config(int channel, dma_request_t *p, int bd_index); */
+int mxc_dma_get_config(int channel, dma_request_t * p, int bd_index);
+
+/*!
+ * Starts dma channel.
+ *
+ * @param   channel           channel number
+ */
+int mxc_dma_start(int channel);
+
+/*!
+ * Stops dma channel.
+ *
+ * @param   channel           channel number
+ */
+int mxc_dma_stop(int channel);
+
+/*!
+ * Frees dma channel.
+ *
+ * @param   channel           channel number
+ */
+void mxc_free_dma(int channel);
+
+/*!
+ * Sets callback function. Used with standard dma api
+ *  for supporting interrupts
+ *
+ * @param   channel           channel number
+ * @param   callback          callback function pointer
+ * @param   arg               argument for callback function
+ */
+void mxc_dma_set_callback(int channel, dma_callback_t callback, void *arg);
+
+/*!
+ * Allocates uncachable buffer. Uses hash table.
+ *
+ * @param   size    size of allocated buffer
+ * @return  pointer to buffer
+ */
+void *sdma_malloc(size_t size);
+
+/*!
+ * Frees uncachable buffer. Uses hash table.
+ */
+void sdma_free(void *buf);
+
+/*!
+ * Converts virtual to physical address. Uses hash table.
+ *
+ * @param   buf  virtual address pointer
+ * @return  physical address value
+ */
+unsigned long sdma_virt_to_phys(void *buf);
+
+/*!
+ * Converts physical to virtual address. Uses hash table.
+ *
+ * @param   buf  physical address value
+ * @return  virtual address pointer
+ */
+void *sdma_phys_to_virt(unsigned long buf);
+
+/*!
+ * Configures the BD_INTR bit on a buffer descriptor parameters.
+ *
+ *
+ * @param   channel           channel number
+ * @param   bd_index          index of buffer descriptor to set
+ * @param   bd_intr           flag to set or clear the BD_INTR bit
+ */
+void mxc_dma_set_bd_intr(int channel, int bd_index, int bd_intr);
+
+/*!
+ * Gets the BD_INTR bit on a buffer descriptor.
+ *
+ *
+ * @param   channel           channel number
+ * @param   bd_index          index of buffer descriptor to set
+ *
+ * @return returns the BD_INTR bit status
+ */
+int mxc_dma_get_bd_intr(int channel, int bd_index);
+
+/*!
+ * Stop the current transfer
+ *
+ * @param   channel           channel number
+ * @param   buffer_number     number of buffers (beginning with 0),
+ *                            whose done bits should be reset to 0
+ */
+int mxc_dma_reset(int channel, int buffer_number);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id);
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ *
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t * chnl);
+
+/*!
+ * Initializes SDMA driver
+ */
+int __init sdma_init(void);
+
+#define DEFAULT_ERR     1
+#define MXC_SDMA_DSPDMA 1
+
+#endif
--- linux-2.6.19.2/include/asm-arm/arch-mxc/spba.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/spba.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,66 @@
+
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @defgroup SPBA Shared Peripheral Bus Arbiter (SPBA)
+ * @ingroup MSL
+ */
+
+/*!
+ * @file spba.h
+ * @brief This file contains the Shared Peripheral Bus Arbiter (spba) API.
+ *
+ * @ingroup SPBA
+ */
+
+#ifndef __ASM_ARCH_MXC_SPBA_H__
+#define __ASM_ARCH_MXC_SPBA_H__
+
+#ifdef __KERNEL__
+
+#define MXC_SPBA_RAR_MASK       0x7
+
+/*!
+ * Defines three SPBA masters: A - ARM, C - SDMA (no master B for MX31)
+ */
+enum spba_masters {
+	SPBA_MASTER_A = 1,
+	SPBA_MASTER_B = 2,
+	SPBA_MASTER_C = 4,
+};
+
+/*!
+ * This function allows the three masters (A, B, C) to take ownership of a
+ * shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_take_ownership(int mod, int master);
+
+/*!
+ * This function releases the ownership for a shared peripheral.
+ *
+ * @param  mod          specified module as defined in \b enum \b #spba_module
+ * @param  master       one of more (or-ed together) masters as defined in \b enum \b #spba_masters
+ *
+ * @return 0 if successful; -1 otherwise.
+ */
+int spba_rel_ownership(int mod, int master);
+
+#endif				/* __KERNEL__ */
+
+#endif				/* __ASM_ARCH_MXC_SPBA_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/system.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/system.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,53 @@
+/*
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MXC_SYSTEM_H__
+#define __ASM_ARCH_MXC_SYSTEM_H__
+
+/*!
+ * @defgroup MSL Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @defgroup System System-wide Misc Files for MSL
+ * @ingroup MSL
+ */
+
+/*!
+ * @file system.h
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup System
+ */
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+extern void arch_idle(void);
+
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+extern void arch_reset(char mode);
+
+#endif				/* __ASM_ARCH_MXC_SYSTEM_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/timex.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/timex.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,26 @@
+/*
+ *  Copyright (C) 1999 ARM Limited
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MXC_TIMEX_H__
+#define __ASM_ARCH_MXC_TIMEX_H__
+
+#include <asm/arch/hardware.h>
+#include <asm/io.h>
+
+#endif				/* __ASM_ARCH_MXC_TIMEX_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/uncompress.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/uncompress.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,78 @@
+/*
+ *  include/asm-arm/arch-mxc/uncompress.h
+ *
+ *
+ *
+ *  Copyright (C) 1999 ARM Limited
+ *  Copyright (C) Shane Nay (shane@minirl.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ASM_ARCH_MXC_UNCOMPRESS_H__
+#define __ASM_ARCH_MXC_UNCOMPRESS_H__
+
+#define __MXC_BOOT_UNCOMPRESS
+
+#include <asm/arch/hardware.h>
+
+unsigned int system_rev;
+
+#define UART(x) (*(volatile unsigned long *)(serial_port + (x)))
+
+#define USR2 0x98
+#define USR2_TXFE (1<<14)
+#define TXR  0x40
+#define UCR1 0x80
+#define UCR1_UARTEN 1
+
+/*
+ * The following code assumes the serial port has already been
+ * initialized by the bootloader.  We search for the first enabled
+ * port in the most probable order.  If you didn't setup a port in
+ * your bootloader then nothing will appear (which might be desired).
+ *
+ * This does not append a newline
+ */
+
+static void putc(int ch)
+{
+	static unsigned long serial_port = 0;
+
+	if (unlikely(serial_port == 0)) do {
+		serial_port = UART1_BASE_ADDR;
+		if (UART(UCR1) & UCR1_UARTEN)
+			break;
+		serial_port = UART2_BASE_ADDR;
+		if (UART(UCR1) & UCR1_UARTEN)
+			break;
+		return;
+	} while (0);
+
+	while (!(UART(USR2) & USR2_TXFE))
+		barrier();
+
+	UART(TXR) = ch;
+}
+
+#define flush() do { } while (0)
+
+/*
+ * nothing to do
+ */
+#define arch_decomp_setup()
+
+#define arch_decomp_wdog()
+
+#endif				/* __ASM_ARCH_MXC_UNCOMPRESS_H__ */
--- linux-2.6.19.2/include/asm-arm/arch-mxc/vmalloc.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/include/asm-arm/arch-mxc/vmalloc.h	2007-01-10 17:09:59.000000000 -0700
@@ -0,0 +1,53 @@
+/*
+ *  Copyright (C) 2000 Russell King.
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_MXC_VMALLOC_H__
+#define __ASM_ARCH_MXC_VMALLOC_H__
+
+/*!
+ * @file vmalloc.h
+ *
+ * @brief This file contains the macros for vmalloc.
+ *
+ * @ingroup System
+ */
+
+/*!
+ * Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason.
+ */
+#define VMALLOC_OFFSET	  (8*1024*1024)
+
+/*!
+ * vmalloc start address
+ */
+#define VMALLOC_START	  (((unsigned long)high_memory + \
+                           VMALLOC_OFFSET) & ~(VMALLOC_OFFSET-1))
+#define VMALLOC_VMADDR(x) ((unsigned long)(x))
+
+/*!
+ * vmalloc ending address
+ */
+#define VMALLOC_END       (PAGE_OFFSET + 0x10000000)
+
+#endif				/* __ASM_ARCH_MXC_VMALLOC_H__ */
