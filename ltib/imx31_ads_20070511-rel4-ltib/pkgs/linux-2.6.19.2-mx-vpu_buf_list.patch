Patch to convert vpu buffer management from array to list.
===================================================================
RCS file: /cvs/local/ltib/imx27ads/linux-2.6.19/drivers/mxc/vpu/mxc_vpu.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -u -p -r1.2 -r1.3
--- linux-2.6.19.2/drivers/mxc/vpu/mxc_vpu.c	15 Jan 2007 05:50:47 -0000	1.2
+++ linux-2.6.19.2-mx/drivers/mxc/vpu/mxc_vpu.c	29 Jan 2007 23:36:00 -0000	1.3
@@ -33,6 +33,7 @@
 #include <linux/kdev_t.h>
 #include <linux/dma-mapping.h>
 #include <linux/wait.h>
+#include <linux/list.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -47,45 +48,48 @@
 #define	BIT_INT_STATUS		0x010
 #define BIT_INT_ENABLE		0x170
 
-typedef struct vpu_t {
+struct vpu {
 	struct fasync_struct *async_queue;
-} vpu_t;
+};
+
+/* To mark the allocated memory buffer */
+struct memalloc_record {
+	struct list_head list;
+	vpu_mem_desc mem;
+};
+
+static DEFINE_SPINLOCK(vpu_lock);
+LIST_HEAD(head);
 
 static int vpu_major = 0;
 static struct class *vpu_class;
-static struct vpu_t vpu_data;
+static struct vpu vpu_data;
 static u8 open_count = 0;
 
-#define	MAX_BUFS_NUMS		20
-static vpu_mem_desc mem[MAX_BUFS_NUMS];
-static unsigned int buf_idx;
-
 /* implement the blocking ioctl */
 static int codec_done = 0;
 static wait_queue_head_t vpu_queue;
 
 /*!
  * Private function to free buffers
- * @param mem		Array of buffers to be freed
- * @param num_buf	Number of buffers to be freed
  * @return status  0 success.
  */
-static int vpu_free_buffers(vpu_mem_desc mem[], int num_buf)
+static int vpu_free_buffers(void)
 {
-	int i;
-
-	for (i = 0; i < num_buf; i++) {
-		if (mem[i].cpu_addr != 0) {
-			dma_free_coherent(0, mem[i].size,
-					  (void *)mem[i].cpu_addr,
-					  mem[i].phy_addr);
-			pr_debug("freed idx %u @ paddr=0x%08X\n", i,
-				 mem[i].phy_addr);
-			mem[i].phy_addr = 0;
-			mem[i].cpu_addr = 0;
-		}
+	struct memalloc_record *rec, *n;
+	vpu_mem_desc mem;
+	unsigned long flags;
+
+	spin_lock_irqsave(&vpu_lock, flags);
+	list_for_each_entry_safe(rec, n, &head, list) {
+		mem = rec->mem;
+		dma_free_coherent(0, mem.size,
+				  (void *)mem.cpu_addr, mem.phy_addr);
+		pr_debug("[FREE] freed paddr=0x%08X\n", mem.phy_addr);
+		list_del(&rec->list);
+		kfree(rec);
 	}
-	buf_idx = 0;
+	spin_unlock_irqrestore(&vpu_lock, flags);
 
 	return 0;
 }
@@ -95,8 +99,8 @@ static int vpu_free_buffers(vpu_mem_desc
  */
 static irqreturn_t vpu_irq_handler(int irq, void *dev_id)
 {
-	struct vpu_t *dev;
-	dev = (struct vpu_t *)dev_id;
+	struct vpu *dev;
+	dev = (struct vpu *)dev_id;
 	__raw_readl(IO_ADDRESS(VPU_BASE_ADDR + BIT_INT_STATUS));
 	__raw_writel(0x1, IO_ADDRESS(VPU_BASE_ADDR + BIT_INT_CLEAR));
 	if (dev->async_queue)
@@ -160,57 +164,72 @@ static int vpu_open(struct inode *inode,
 static int vpu_ioctl(struct inode *inode, struct file *filp, u_int cmd,
 		     u_long arg)
 {
+	unsigned long flags;
 	int ret = 0;
 
 	switch (cmd) {
 	case VPU_IOC_PHYMEM_ALLOC:
 		{
-			copy_from_user(&mem[buf_idx], (vpu_mem_desc *) arg,
+			struct memalloc_record *rec;
+
+			rec = kzalloc(sizeof(*rec), GFP_KERNEL);
+			if (!rec)
+				return -ENOMEM;
+
+			copy_from_user(&(rec->mem), (vpu_mem_desc *) arg,
 				       sizeof(vpu_mem_desc));
-			pr_debug("mem alloc size = 0x%x\n", mem[buf_idx].size);
-			mem[buf_idx].cpu_addr = (unsigned long)
+			pr_debug("[ALLOC] mem alloc size = 0x%x\n",
+				 rec->mem.size);
+			rec->mem.cpu_addr = (unsigned long)
 			    dma_alloc_coherent(NULL,
-					       PAGE_ALIGN(mem[buf_idx].size),
+					       PAGE_ALIGN(rec->mem.size),
 					       (dma_addr_t
-						*) (&(mem[buf_idx].phy_addr)),
+						*) (&(rec->mem.phy_addr)),
 					       GFP_DMA | GFP_KERNEL);
-			pr_debug("mem alloc cpu_addr = 0x%x, buf_idx = %u\n",
-				 mem[buf_idx].cpu_addr, buf_idx);
-			if ((void *)(mem[buf_idx].cpu_addr) == NULL) {
+			pr_debug("[ALLOC] mem alloc cpu_addr = 0x%x\n",
+				 rec->mem.cpu_addr);
+			if ((void *)(rec->mem.cpu_addr) == NULL) {
+				kfree(rec);
 				printk(KERN_ERR
 				       "Physical memory allocation error!\n");
-				ret = -1;
+				ret = -ENOMEM;
 				break;
 			}
-			copy_to_user((void __user *)arg, &mem[buf_idx],
+			copy_to_user((void __user *)arg, &(rec->mem),
 				     sizeof(vpu_mem_desc));
-			buf_idx++;
+
+			spin_lock_irqsave(&vpu_lock, flags);
+			list_add(&rec->list, &head);
+			spin_unlock_irqrestore(&vpu_lock, flags);
+
 			break;
 		}
 	case VPU_IOC_PHYMEM_FREE:
 		{
-			int i;
+			struct memalloc_record *rec, *n;
 			vpu_mem_desc vpu_mem;
+
 			copy_from_user(&vpu_mem, (vpu_mem_desc *) arg,
 				       sizeof(vpu_mem_desc));
-			pr_debug("mem freed cpu_addr = 0x%x\n",
+			pr_debug("[FREE] mem freed cpu_addr = 0x%x\n",
 				 vpu_mem.cpu_addr);
-			if ((void *)vpu_mem.cpu_addr != NULL) {
-				dma_free_coherent(NULL,
-						  PAGE_ALIGN(vpu_mem.size),
-						  (void *)vpu_mem.cpu_addr,
-						  (dma_addr_t) vpu_mem.
-						  phy_addr);
-			}
 
-			/* mark the freed buffers */
-			for (i = 0; i < buf_idx; i++) {
-				if (mem[i].cpu_addr == vpu_mem.cpu_addr) {
-					mem[i].phy_addr = 0;
-					mem[i].cpu_addr = 0;
+			spin_lock_irqsave(&vpu_lock, flags);
+			list_for_each_entry_safe(rec, n, &head, list) {
+				if (rec->mem.cpu_addr == vpu_mem.cpu_addr) {
+					dma_free_coherent(NULL,
+							  PAGE_ALIGN(vpu_mem.size),
+							  (void *)vpu_mem.cpu_addr,
+							  (dma_addr_t) vpu_mem.
+							  phy_addr);
+
+					/* delete from list */
+					list_del(&rec->list);
+					kfree(rec);
 					break;
 				}
 			}
+			spin_unlock_irqrestore(&vpu_lock, flags);
 
 			break;
 		}
@@ -251,7 +270,7 @@ static int vpu_release(struct inode *ino
 {
 	if (--open_count == 0) {
 		__raw_writel(0x0, IO_ADDRESS(VPU_BASE_ADDR + BIT_INT_ENABLE));
-		vpu_free_buffers(mem, buf_idx);
+		vpu_free_buffers();
 		vpu_hardware_disable();
 	}
 
@@ -264,7 +283,7 @@ static int vpu_release(struct inode *ino
  */
 static int vpu_fasync(int fd, struct file *filp, int mode)
 {
-	struct vpu_t *dev = (struct vpu_t *)filp->private_data;
+	struct vpu *dev = (struct vpu *)filp->private_data;
 	return fasync_helper(fd, filp, mode, &dev->async_queue);
 }
 
@@ -374,7 +393,6 @@ static int vpu_dev_probe(struct platform
 
 /*! Driver definition
  *
- * This structure contains pointers to the power management callback functions.
  */
 static struct platform_driver mxcvpu_driver = {
 	.driver = {
