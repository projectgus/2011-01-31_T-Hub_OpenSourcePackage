TLSbo87363_fix_convity_multiple_open_mode.patch

Modified code to allow multiple modes to be opened simultaneously.
===================================================================
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/pmic/mc13783/pmic_convity.c linux-2.6.19.2/drivers/mxc/pmic/mc13783/pmic_convity.c
--- linux-2.6.19.2.orig/drivers/mxc/pmic/mc13783/pmic_convity.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/pmic/mc13783/pmic_convity.c	2007-04-25 17:36:58.000000000 -0600
@@ -223,7 +223,7 @@ static pmic_event_callback_t eventNotify
 
 typedef struct {
 	PMIC_CONVITY_HANDLE handle;	/*!< Device handle.   */
-	HANDLE_STATE handleState;	/*!< Device handle
+	HANDLE_STATE handle_state;	/*!< Device handle
 					   state.           */
 	PMIC_CONVITY_MODE mode;	/*!< Device mode.     */
 	PMIC_CONVITY_CALLBACK callback;	/*!< Event callback function pointer. */
@@ -248,7 +248,79 @@ typedef struct {
 							   connections.     */
 	PMIC_CONVITY_RS232_EXTERNAL rs232CfgExternal;	/*!< RS-232 external
 							   connections.     */
-} PMIC_CONVITY_STATE_STRUCT;
+} pmic_convity_state_struct;
+
+/*!
+ * @brief This structure is used to maintain the current device driver state.
+ *
+ * This structure maintains the current state of the driver in USB mode. This
+ * includes both the PMIC hardware state as well as the device handle and
+ * callback states.
+ */
+
+typedef struct {
+	PMIC_CONVITY_HANDLE handle;	/*!< Device handle.   */
+	HANDLE_STATE handle_state;	/*!< Device handle
+					   state.           */
+	PMIC_CONVITY_MODE mode;	/*!< Device mode.     */
+	PMIC_CONVITY_CALLBACK callback;	/*!< Event callback function pointer. */
+	PMIC_CONVITY_EVENTS eventMask;	/*!< Event mask.      */
+	PMIC_CONVITY_USB_SPEED usbSpeed;	/*!< USB connection
+						   speed.           */
+	PMIC_CONVITY_USB_MODE usbMode;	/*!< USB connection
+					   mode.            */
+	PMIC_CONVITY_USB_POWER_IN usbPowerIn;	/*!< USB transceiver
+						   power source.    */
+	PMIC_CONVITY_USB_POWER_OUT usbPowerOut;	/*!< USB transceiver
+						   power output
+						   level.           */
+	PMIC_CONVITY_USB_TRANSCEIVER_MODE usbXcvrMode;	/*!< USB transceiver
+							   mode.            */
+	unsigned int usbDlpDuration;	/*!< USB Data Line
+					   Pulsing duration. */
+	PMIC_CONVITY_USB_OTG_CONFIG usbOtgCfg;	/*!< USB OTG
+						   configuration
+						   options.         */
+} pmic_convity_usb_state;
+
+/*!
+ * @brief This structure is used to maintain the current device driver state.
+ *
+ * This structure maintains the current state of the driver in RS_232 mode. This
+ * includes both the PMIC hardware state as well as the device handle and
+ * callback states.
+ */
+
+typedef struct {
+	PMIC_CONVITY_HANDLE handle;	/*!< Device handle.   */
+	HANDLE_STATE handle_state;	/*!< Device handle
+					   state.           */
+	PMIC_CONVITY_MODE mode;	/*!< Device mode.     */
+	PMIC_CONVITY_CALLBACK callback;	/*!< Event callback function pointer. */
+	PMIC_CONVITY_EVENTS eventMask;	/*!< Event mask.      */
+	PMIC_CONVITY_RS232_INTERNAL rs232CfgInternal;	/*!< RS-232 internal
+							   connections.     */
+	PMIC_CONVITY_RS232_EXTERNAL rs232CfgExternal;	/*!< RS-232 external
+							   connections.     */
+} pmic_convity_rs232_state;
+
+/*!
+ * @brief This structure is used to maintain the current device driver state.
+ *
+ * This structure maintains the current state of the driver in cea-936 mode. This
+ * includes both the PMIC hardware state as well as the device handle and
+ * callback states.
+ */
+
+typedef struct {
+	PMIC_CONVITY_HANDLE handle;	/*!< Device handle.   */
+	HANDLE_STATE handle_state;	/*!< Device handle
+					   state.           */
+	PMIC_CONVITY_MODE mode;	/*!< Device mode.     */
+	PMIC_CONVITY_CALLBACK callback;	/*!< Event callback function pointer. */
+	PMIC_CONVITY_EVENTS eventMask;	/*!< Event mask.      */
+
+} pmic_convity_cea936_state;
 
 /*!
  * @brief Identifies the hardware interrupt source.
@@ -263,13 +335,10 @@ typedef enum {
 	CORE_EVENT_ABDET	/*!< Detected USB mini A-B connector event. */
 } PMIC_CORE_EVENT;
 
-/*! Define the maximum Data Line Pulse duration in milliseconds. */
-//static const unsigned int MAX_DLP_DURATION_MS = 7;
-
 /*!
  * @brief This structure defines the reset/power on state for the Connectivity driver.
  */
-static const PMIC_CONVITY_STATE_STRUCT reset = {
+static const pmic_convity_state_struct reset = {
 	0,
 	HANDLE_FREE,
 	USB,
@@ -292,7 +361,7 @@ static const PMIC_CONVITY_STATE_STRUCT r
  * The initial values must be identical to the reset state defined by the
  * #reset variable.
  */
-static PMIC_CONVITY_STATE_STRUCT convity = {
+static pmic_convity_usb_state usb = {
 	0,
 	HANDLE_FREE,
 	USB,
@@ -305,11 +374,39 @@ static PMIC_CONVITY_STATE_STRUCT convity
 	USB_TRANSCEIVER_OFF,
 	0,
 	USB_PULL_OVERRIDE | USB_VBUS_CURRENT_LIMIT_HIGH,
+};
+
+/*!
+ * @brief This structure maintains the current state of the Connectivity driver.
+ *
+ * The initial values must be identical to the reset state defined by the
+ * #reset variable.
+ */
+static pmic_convity_rs232_state rs_232 = {
+	0,
+	HANDLE_FREE,
+	RS232_1,
+	NULL,
+	0,
 	RS232_TX_USE0VM_RX_UDATVP,
 	RS232_TX_UDM_RX_UDP
 };
 
 /*!
+ * @brief This structure maintains the current state of the Connectivity driver.
+ *
+ * The initial values must be identical to the reset state defined by the
+ * #reset variable.
+ */
+static pmic_convity_cea936_state cea_936 = {
+	0,
+	HANDLE_FREE,
+	CEA936_MONO,
+	NULL,
+	0,
+};
+
+/*!
  * @brief This spinlock is used to provide mutual exclusion.
  *
  * Create a spinlock that can be used to provide mutually exclusive
@@ -419,15 +516,28 @@ PMIC_STATUS pmic_convity_open(PMIC_CONVI
 	/* Check the current device handle state and acquire the handle if
 	 * it is available.
 	 */
-	if (convity.handleState != HANDLE_FREE) {
+	if ((usb.handle_state != HANDLE_FREE)
+	    && (rs_232.handle_state != HANDLE_FREE)
+	    && (cea_936.handle_state != HANDLE_FREE)) {
+
 		/* Cannot open the PMIC connectivity hardware at this time or an invalid
 		 * mode was requested.
 		 */
 		*handle = reset.handle;
 	} else {
+
+		if (mode == USB) {
+			usb.handle = (PMIC_CONVITY_HANDLE) (&usb);
+			usb.handle_state = HANDLE_IN_USE;
+		} else if (mode == (RS232_1 || RS232_2)) {
+			rs_232.handle = (PMIC_CONVITY_HANDLE) (&rs_232);
+			rs_232.handle_state = HANDLE_IN_USE;
+		} else {
+			cea_936.handle = (PMIC_CONVITY_HANDLE) (&cea_936);
+			cea_936.handle_state = HANDLE_IN_USE;
+
+		}
 		/* Let's begin by acquiring the connectivity device handle. */
-		convity.handle = (PMIC_CONVITY_HANDLE) (&convity);
-		convity.handleState = HANDLE_IN_USE;
 		/* Then we can try to set the desired operating mode. */
 		rc = pmic_convity_set_mode_internal(mode);
 
@@ -435,13 +545,27 @@ PMIC_STATUS pmic_convity_open(PMIC_CONVI
 			/* Successfully set the desired operating mode, now return the
 			 * handle to the caller.
 			 */
-			*handle = convity.handle;
+			if (mode == USB) {
+				*handle = usb.handle;
+			} else if (mode == (RS232_1 || RS232_2)) {
+				*handle = rs_232.handle;
+			} else {
+				*handle = cea_936.handle;
+			}
 		} else {
 			/* Failed to set the desired mode, return the handle to an unused
 			 * state.
 			 */
-			convity.handle = reset.handle;
-			convity.handleState = reset.handleState;
+			if (mode == USB) {
+				usb.handle = reset.handle;
+				usb.handle_state = reset.handle_state;
+			} else if (mode == (RS232_1 || RS232_2)) {
+				rs_232.handle = reset.handle;
+				rs_232.handle_state = reset.handle_state;
+			} else {
+				cea_936.handle = reset.handle;
+				cea_936.handle_state = reset.handle_state;
+			}
 
 			*handle = reset.handle;
 		}
@@ -475,33 +599,52 @@ PMIC_STATUS pmic_convity_close(const PMI
 	/* Confirm that the device handle matches the one assigned in the
 	 * pmic_convity_open() call and then close the connection.
 	 */
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
+	if (((handle == usb.handle) &&
+	     (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						      && (rs_232.handle_state ==
+							  HANDLE_IN_USE))
+	    || ((handle == cea_936.handle)
+		&& (cea_936.handle_state == HANDLE_IN_USE))) {
 		rc = PMIC_SUCCESS;
 
 		/* Deregister for all existing callbacks if necessary and make sure
 		 * that the event handling settings are consistent following the
 		 * close operation.
 		 */
-		if (convity.callback != reset.callback) {
+		if ((usb.callback != reset.callback)
+		    || (rs_232.callback != reset.callback)
+		    || (cea_936.callback != reset.callback)) {
 			/* Deregister the existing callback function and all registered
 			 * events before we completely close the handle.
 			 */
 			rc = pmic_convity_deregister_all();
+			if (rc == PMIC_SUCCESS) {
 
-		} else if (convity.eventMask != reset.eventMask) {
-			/* Having a non-zero eventMask without a callback function being
-			 * defined should never occur but let's just make sure here that
-			 * we keep things consistent.
-			 */
-			convity.eventMask = reset.eventMask;
-		}
+			} else if (usb.eventMask != reset.eventMask) {
+				/* Having a non-zero eventMask without a callback function being
+				 * defined should never occur but let's just make sure here that
+				 * we keep things consistent.
+				 */
+				usb.eventMask = reset.eventMask;
+				/* Mark the connectivity device handle as being closed. */
+				usb.handle = reset.handle;
+				usb.handle_state = reset.handle_state;
+
+			} else if (rs_232.eventMask != reset.eventMask) {
+
+				rs_232.eventMask = reset.eventMask;
+				/* Mark the connectivity device handle as being closed. */
+				rs_232.handle = reset.handle;
+				rs_232.handle_state = reset.handle_state;
+
+			} else if (cea_936.eventMask != reset.eventMask) {
+				cea_936.eventMask = reset.eventMask;
+				/* Mark the connectivity device handle as being closed. */
+				cea_936.handle = reset.handle;
+				cea_936.handle_state = reset.handle_state;
 
-		if (rc == PMIC_SUCCESS) {
-			/* Mark the connectivity device handle as being closed. */
+			}
 
-			convity.handle = reset.handle;
-			convity.handleState = reset.handleState;
 		}
 	}
 
@@ -518,7 +661,8 @@ PMIC_STATUS pmic_convity_close(const PMI
  * RS-232, and CEA-936. Requesting an operating mode that is not supported
  * by the PMIC hardware will return PMIC_NOT_SUPPORTED.
  *
- * @param       handle          device handle from open() call
+ * @param       handle          device handle from 
+					open() call
  * @param       mode            desired operating mode
  *
  * @return      PMIC_SUCCESS    if the requested mode was successfully set
@@ -532,8 +676,12 @@ PMIC_STATUS pmic_convity_set_mode(const 
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
+	if (((handle == usb.handle) &&
+	     (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						      && (rs_232.handle_state ==
+							  HANDLE_IN_USE))
+	    || ((handle == cea_936.handle)
+		&& (cea_936.handle_state == HANDLE_IN_USE))) {
 		rc = pmic_convity_set_mode_internal(mode);
 	}
 
@@ -560,11 +708,16 @@ PMIC_STATUS pmic_convity_get_mode(const 
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE) &&
-	    (mode != (PMIC_CONVITY_MODE *) NULL)) {
+	if ((((handle == usb.handle) &&
+	      (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						       && (rs_232.
+							   handle_state ==
+							   HANDLE_IN_USE))
+	     || ((handle == cea_936.handle)
+		 && (cea_936.handle_state == HANDLE_IN_USE)))
+	    && (mode != (PMIC_CONVITY_MODE *) NULL)) {
 
-		*mode = convity.mode;
+		*mode = usb.mode;
 
 		rc = PMIC_SUCCESS;
 	}
@@ -589,9 +742,13 @@ PMIC_STATUS pmic_convity_reset(const PMI
 	/* Use a critical section to maintain a consistent state. */
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
+	if (((handle == usb.handle) &&
+	     (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						      && (rs_232.handle_state ==
+							  HANDLE_IN_USE))
+	    || ((handle == cea_936.handle)
+		&& (cea_936.handle_state == HANDLE_IN_USE))) {
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
 		/* Reset the PMIC Connectivity register to it's power on state. */
 		rc = pmic_write_reg(REG_USB, RESET_USBCNTRL_REG_0,
 				    REG_FULLMASK);
@@ -601,7 +758,7 @@ PMIC_STATUS pmic_convity_reset(const PMI
 
 		if (rc == PMIC_SUCCESS) {
 			/* Also reset the device driver state data structure. */
-			convity = reset;
+
 		}
 	}
 
@@ -645,8 +802,7 @@ PMIC_STATUS pmic_convity_set_callback(co
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
 
 		/* Return an error if either the callback function or event mask
 		 * is not properly defined.
@@ -658,7 +814,7 @@ PMIC_STATUS pmic_convity_set_callback(co
 		 * before trying to register a new callback function.
 		 */
 		if ((func == NULL) || (eventMask == 0)
-		    || (convity.callback != NULL)) {
+		    || (usb.callback != NULL)) {
 			rc = PMIC_ERROR;
 
 			/* Register for PMIC events from the core protocol driver. */
@@ -726,8 +882,8 @@ PMIC_STATUS pmic_convity_set_callback(co
 			spin_lock_irqsave(&lock, flags);
 
 			/* Successfully registered for all events. */
-			convity.callback = func;
-			convity.eventMask = eventMask;
+			usb.callback = func;
+			usb.eventMask = eventMask;
 			spin_unlock_irqrestore(&lock, flags);
 
 			goto End;
@@ -793,9 +949,13 @@ PMIC_STATUS pmic_convity_clear_callback(
 	/* Use a critical section to maintain a consistent state. */
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
+	if (((handle == usb.handle) &&
+	     (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						      && (rs_232.handle_state ==
+							  HANDLE_IN_USE))
+	    || ((handle == cea_936.handle)
+		&& (cea_936.handle_state == HANDLE_IN_USE))) {
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
 		rc = pmic_convity_deregister_all();
 	}
 
@@ -824,13 +984,17 @@ PMIC_STATUS pmic_convity_get_callback(co
 	/* Use a critical section to maintain a consistent state. */
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
-
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE) &&
-	    (func != (PMIC_CONVITY_CALLBACK *) NULL) &&
-	    (eventMask != (PMIC_CONVITY_EVENTS *) NULL)) {
-		*func = convity.callback;
-		*eventMask = convity.eventMask;
+	if ((((handle == usb.handle) &&
+	      (usb.handle_state == HANDLE_IN_USE)) || ((handle == rs_232.handle)
+						       && (rs_232.
+							   handle_state ==
+							   HANDLE_IN_USE))
+	     || ((handle == cea_936.handle)
+		 && (cea_936.handle_state == HANDLE_IN_USE)))
+	    && (func != (PMIC_CONVITY_CALLBACK *) NULL)
+	    && (eventMask != (PMIC_CONVITY_EVENTS *) NULL)) {
+		*func = usb.callback;
+		*eventMask = usb.eventMask;
 
 		rc = PMIC_SUCCESS;
 	}
@@ -874,47 +1038,52 @@ PMIC_STATUS pmic_convity_usb_set_speed(c
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
-		/* Validate the function parameters and if they are valid, then
-		 * configure the pull-up and pull-down resistors as required for
-		 * the desired operating mode.
-		 */
-		if ((speed == USB_HIGH_SPEED)) {
-			/* 
-			 * The USB transceiver also does not support the high speed mode
-			 * (which is also optional under the USB OTG specification).
-			 */
-			rc = PMIC_NOT_SUPPORTED;
-		} else if ((speed != USB_LOW_SPEED)
-			   && (speed != USB_FULL_SPEED)) {
-			/* Final validity check on the speed parameter. */
-			rc = PMIC_ERROR;;
-		} else {
-			/* First configure the D+ and D- pull-up/pull-down resistors as
-			 * per the USB OTG specification.
+	if (handle == (rs_232.handle || cea_936.handle)) {
+		return PMIC_PARAMETER_ERROR;
+	} else {
+		if ((handle == usb.handle) &&
+		    (usb.handle_state == HANDLE_IN_USE)) {
+			/* Validate the function parameters and if they are valid, then
+			 * configure the pull-up and pull-down resistors as required for
+			 * the desired operating mode.
 			 */
-			if (speed == USB_FULL_SPEED) {
-				/* Activate pull-up on D+ and pull-down on D-. */
-				reg_value = SET_BITS(regUSB0, UDM_PD, 1);
-			} else if (speed == USB_LOW_SPEED) {
-				/* Activate pull-up on D+ and pull-down on D-. */
-				reg_value = SET_BITS(regUSB0, FSENB, 1);
-			}
+			if ((speed == USB_HIGH_SPEED)) {
+				/* 
+				 * The USB transceiver also does not support the high speed mode
+				 * (which is also optional under the USB OTG specification).
+				 */
+				rc = PMIC_NOT_SUPPORTED;
+			} else if ((speed != USB_LOW_SPEED)
+				   && (speed != USB_FULL_SPEED)) {
+				/* Final validity check on the speed parameter. */
+				rc = PMIC_ERROR;;
+			} else {
+				/* First configure the D+ and D- pull-up/pull-down resistors as
+				 * per the USB OTG specification.
+				 */
+				if (speed == USB_FULL_SPEED) {
+					/* Activate pull-up on D+ and pull-down on D-. */
+					reg_value =
+					    SET_BITS(regUSB0, UDM_PD, 1);
+				} else if (speed == USB_LOW_SPEED) {
+					/* Activate pull-up on D+ and pull-down on D-. */
+					reg_value = SET_BITS(regUSB0, FSENB, 1);
+				}
 
-			/* Now set the desired USB transceiver speed. Note that
-			 * USB_FULL_SPEED simply requires FSENB=0 (which it
-			 * already is).
-			 */
+				/* Now set the desired USB transceiver speed. Note that
+				 * USB_FULL_SPEED simply requires FSENB=0 (which it
+				 * already is).
+				 */
 
-			rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
+				rc = pmic_write_reg(REG_USB, reg_value,
+						    reg_mask);
 
-			if (rc == PMIC_SUCCESS) {
-				convity.usbSpeed = speed;
+				if (rc == PMIC_SUCCESS) {
+					usb.usbSpeed = speed;
+				}
 			}
 		}
 	}
-
 	/* Exit the critical section. */
 	up(&mutex);
 
@@ -941,12 +1110,12 @@ PMIC_STATUS pmic_convity_usb_get_speed(c
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE) &&
+	if ((handle == usb.handle) &&
+	    (usb.handle_state == HANDLE_IN_USE) &&
 	    (speed != (PMIC_CONVITY_USB_SPEED *) NULL) &&
 	    (mode != (PMIC_CONVITY_USB_MODE *) NULL)) {
-		*speed = convity.usbSpeed;
-		*mode = convity.usbMode;
+		*speed = usb.usbSpeed;
+		*mode = usb.usbMode;
 
 		rc = PMIC_SUCCESS;
 	}
@@ -982,8 +1151,7 @@ PMIC_STATUS pmic_convity_set_output(cons
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
 
 		if ((out_type == 0) && (out == 1)) {
 
@@ -1057,8 +1225,7 @@ PMIC_STATUS pmic_convity_usb_set_power_s
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
 
 		if (pwrin == USB_POWER_INTERNAL_BOOST) {
 			reg_value |= SET_BITS(regUSB1, VUSBIN, 0);
@@ -1085,8 +1252,8 @@ PMIC_STATUS pmic_convity_usb_set_power_s
 		rc = pmic_write_reg(REG_CHARGE_USB_SPARE, reg_value, reg_mask);
 
 		if (rc == PMIC_SUCCESS) {
-			convity.usbPowerIn = pwrin;
-			convity.usbPowerOut = pwrout;
+			usb.usbPowerIn = pwrin;
+			usb.usbPowerOut = pwrout;
 		}
 	}
 
@@ -1118,12 +1285,12 @@ PMIC_STATUS pmic_convity_usb_get_power_s
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE) &&
+	if ((handle == usb.handle) &&
+	    (usb.handle_state == HANDLE_IN_USE) &&
 	    (pwrin != (PMIC_CONVITY_USB_POWER_IN *) NULL) &&
 	    (pwrout != (PMIC_CONVITY_USB_POWER_OUT *) NULL)) {
-		*pwrin = convity.usbPowerIn;
-		*pwrout = convity.usbPowerOut;
+		*pwrin = usb.usbPowerIn;
+		*pwrout = usb.usbPowerOut;
 
 		rc = PMIC_SUCCESS;
 	}
@@ -1155,8 +1322,7 @@ PMIC_STATUS pmic_convity_usb_set_xcvr(co
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
 
 		if (mode == USB_TRANSCEIVER_OFF) {
 			reg_value = SET_BITS(regUSB0, USBXCVREN, 0);
@@ -1223,7 +1389,7 @@ PMIC_STATUS pmic_convity_usb_set_xcvr(co
 		rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
 
 		if (rc == PMIC_SUCCESS) {
-			convity.usbXcvrMode = mode;
+			usb.usbXcvrMode = mode;
 		}
 	}
 
@@ -1252,10 +1418,10 @@ PMIC_STATUS pmic_convity_usb_get_xcvr(co
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE) &&
+	if ((handle == usb.handle) &&
+	    (usb.handle_state == HANDLE_IN_USE) &&
 	    (mode != (PMIC_CONVITY_USB_TRANSCEIVER_MODE *) NULL)) {
-		*mode = convity.usbXcvrMode;
+		*mode = usb.usbXcvrMode;
 
 		rc = PMIC_SUCCESS;
 	}
@@ -1287,8 +1453,8 @@ PMIC_STATUS pmic_convity_usb_otg_set_dlp
 
 	/* No critical section is required. */
 
-	if ((handle != convity.handle)
-	    || (convity.handleState != HANDLE_IN_USE)) {
+	if ((handle != usb.handle)
+	    || (usb.handle_state != HANDLE_IN_USE)) {
 		/* Must return error indication for invalid handle parameter to be
 		 * consistent with other APIs.
 		 */
@@ -1317,8 +1483,8 @@ PMIC_STATUS pmic_convity_usb_otg_get_dlp
 
 	/* No critical section is required. */
 
-	if ((handle != convity.handle)
-	    || (convity.handleState != HANDLE_IN_USE)) {
+	if ((handle != usb.handle)
+	    || (usb.handle_state != HANDLE_IN_USE)) {
 		/* Must return error indication for invalid handle parameter to be
 		 * consistent with other APIs.
 		 */
@@ -1348,8 +1514,7 @@ PMIC_STATUS pmic_convity_usb_otg_set_con
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
 		if (cfg & USB_OTG_SE0CONN) {
 			reg_value = SET_BITS(regUSB0, SE0_CONN, 1);
 			reg_mask = SET_BITS(regUSB0, SE0_CONN, 1);
@@ -1438,7 +1603,7 @@ PMIC_STATUS pmic_convity_usb_otg_set_con
 				 * We guarantee this by first clearing both of the
 				 * status bits and then resetting the correct one.
 				 */
-				convity.usbOtgCfg &=
+				usb.usbOtgCfg &=
 				    ~(USB_VBUS_CURRENT_LIMIT_HIGH |
 				      USB_VBUS_CURRENT_LIMIT_LOW |
 				      USB_VBUS_CURRENT_LIMIT_LOW_10MS |
@@ -1449,7 +1614,7 @@ PMIC_STATUS pmic_convity_usb_otg_set_con
 				      USB_VBUS_CURRENT_LIMIT_LOW_60MS);
 			}
 
-			convity.usbOtgCfg |= cfg;
+			usb.usbOtgCfg |= cfg;
 		}
 	}
 	//}
@@ -1487,8 +1652,7 @@ PMIC_STATUS pmic_convity_usb_otg_clear_c
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
+	if ((handle == usb.handle) && (usb.handle_state == HANDLE_IN_USE)) {
 		/* if ((cfg & USB_VBUS_CURRENT_LIMIT_LOW_10MS) ||
 		   (cfg & USB_VBUS_CURRENT_LIMIT_LOW_20MS) ||
 		   (cfg & USB_VBUS_CURRENT_LIMIT_LOW_30MS) ||
@@ -1559,7 +1723,7 @@ PMIC_STATUS pmic_convity_usb_otg_clear_c
 		rc = pmic_write_reg(REG_USB, reg_value, reg_mask);
 
 		if (rc == PMIC_SUCCESS) {
-			convity.usbOtgCfg &= ~cfg;
+			usb.usbOtgCfg &= ~cfg;
 		}
 	}
 	//}
@@ -1589,10 +1753,10 @@ PMIC_STATUS pmic_convity_usb_otg_get_con
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE) &&
+	if ((handle == usb.handle) &&
+	    (usb.handle_state == HANDLE_IN_USE) &&
 	    (cfg != (PMIC_CONVITY_USB_OTG_CONFIG *) NULL)) {
-		*cfg = convity.usbOtgCfg;
+		*cfg = usb.usbOtgCfg;
 
 		rc = PMIC_SUCCESS;
 	}
@@ -1643,8 +1807,7 @@ PMIC_STATUS pmic_convity_rs232_set_confi
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE)) {
+	if ((handle == rs_232.handle) && (rs_232.handle_state == HANDLE_IN_USE)) {
 		rc = PMIC_SUCCESS;
 
 		/* Validate the calling parameters. */
@@ -1686,8 +1849,8 @@ PMIC_STATUS pmic_convity_rs232_set_confi
 					    reg_value1, reg_mask);
 
 			if (rc == PMIC_SUCCESS) {
-				convity.rs232CfgInternal = cfgInternal;
-				convity.rs232CfgExternal = cfgExternal;
+				rs_232.rs232CfgInternal = cfgInternal;
+				rs_232.rs232CfgExternal = cfgExternal;
 			}
 		}
 	}
@@ -1719,12 +1882,12 @@ PMIC_STATUS pmic_convity_rs232_get_confi
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle == convity.handle) &&
-	    (convity.handleState == HANDLE_IN_USE) &&
+	if ((handle == rs_232.handle) &&
+	    (rs_232.handle_state == HANDLE_IN_USE) &&
 	    (cfgInternal != (PMIC_CONVITY_RS232_INTERNAL *) NULL) &&
 	    (cfgExternal != (PMIC_CONVITY_RS232_EXTERNAL *) NULL)) {
-		*cfgInternal = convity.rs232CfgInternal;
-		*cfgExternal = convity.rs232CfgExternal;
+		*cfgInternal = rs_232.rs232CfgInternal;
+		*cfgExternal = rs_232.rs232CfgExternal;
 
 		rc = PMIC_SUCCESS;
 	}
@@ -1771,8 +1934,8 @@ PMIC_STATUS pmic_convity_cea936_exit_sig
 	if (down_interruptible(&mutex))
 		return PMIC_SYSTEM_ERROR_EINTR;
 
-	if ((handle != convity.handle)
-	    || (convity.handleState != HANDLE_IN_USE)) {
+	if ((handle != cea_936.handle)
+	    || (cea_936.handle_state != HANDLE_IN_USE)) {
 		/* Must return error indication for invalid handle parameter to be
 		 * consistent with other APIs.
 		 */
@@ -1950,7 +2113,14 @@ static PMIC_STATUS pmic_convity_set_mode
 	}
 
 	if (rc == PMIC_SUCCESS) {
-		convity.mode = mode;
+		if (mode == USB) {
+			usb.mode = mode;
+		} else if (mode == RS232_1 || RS232_1) {
+			rs_232.mode = mode;
+		} else if (mode == CEA936_MONO || CEA936_STEREO
+			   || CEA936_TEST_RIGHT || CEA936_TEST_LEFT) {
+			cea_936.mode = mode;
+		}
 	}
 
 	return rc;
@@ -1981,10 +2151,10 @@ static PMIC_STATUS pmic_convity_deregist
 	 * registered for by using pmic_event_subscribe().
 	 */
 
-	if ((convity.eventMask & USB_DETECT_MINI_A) ||
-	    (convity.eventMask & USB_DETECT_MINI_B) ||
-	    (convity.eventMask & USB_DETECT_NON_USB_ACCESSORY) ||
-	    (convity.eventMask & USB_DETECT_FACTORY_MODE)) {
+	if ((usb.eventMask & USB_DETECT_MINI_A) ||
+	    (usb.eventMask & USB_DETECT_MINI_B) ||
+	    (usb.eventMask & USB_DETECT_NON_USB_ACCESSORY) ||
+	    (usb.eventMask & USB_DETECT_FACTORY_MODE)) {
 		//EVENT_AB_DETI or EVENT_IDI
 		eventNotify.func = pmic_convity_event_handler;
 		eventNotify.param = (void *)(CORE_EVENT_ABDET);
@@ -1997,10 +2167,10 @@ static PMIC_STATUS pmic_convity_deregist
 
 			spin_lock_irqsave(&lock, flags);
 
-			convity.eventMask &= ~(USB_DETECT_MINI_A |
-					       USB_DETECT_MINI_B |
-					       USB_DETECT_NON_USB_ACCESSORY |
-					       USB_DETECT_FACTORY_MODE);
+			usb.eventMask &= ~(USB_DETECT_MINI_A |
+					   USB_DETECT_MINI_B |
+					   USB_DETECT_NON_USB_ACCESSORY |
+					   USB_DETECT_FACTORY_MODE);
 
 			spin_unlock_irqrestore(&lock, flags);
 		} else {
@@ -2011,8 +2181,8 @@ static PMIC_STATUS pmic_convity_deregist
 		}
 	}
 
-	else if ((convity.eventMask & USB_DETECT_0V8_RISE) ||
-		 (convity.eventMask & USB_DETECT_0V8_FALL)) {
+	else if ((usb.eventMask & USB_DETECT_0V8_RISE) ||
+		 (usb.eventMask & USB_DETECT_0V8_FALL)) {
 		//EVENT_USB_08VI or EVENT_USBI
 		eventNotify.func = pmic_convity_event_handler;
 		eventNotify.param = (void *)(CORE_EVENT_0V8);
@@ -2023,8 +2193,8 @@ static PMIC_STATUS pmic_convity_deregist
 			 */
 			spin_lock_irqsave(&lock, flags);
 
-			convity.eventMask &= ~(USB_DETECT_0V8_RISE |
-					       USB_DETECT_0V8_FALL);
+			usb.eventMask &= ~(USB_DETECT_0V8_RISE |
+					   USB_DETECT_0V8_FALL);
 
 			spin_unlock_irqrestore(&lock, flags);
 		} else {
@@ -2036,8 +2206,8 @@ static PMIC_STATUS pmic_convity_deregist
 
 	}
 
-	else if ((convity.eventMask & USB_DETECT_2V0_RISE) ||
-		 (convity.eventMask & USB_DETECT_2V0_FALL)) {
+	else if ((usb.eventMask & USB_DETECT_2V0_RISE) ||
+		 (usb.eventMask & USB_DETECT_2V0_FALL)) {
 		//EVENT_USB_20VI or EVENT_USBI
 		eventNotify.func = pmic_convity_event_handler;
 		eventNotify.param = (void *)(CORE_EVENT_2V0);
@@ -2048,8 +2218,8 @@ static PMIC_STATUS pmic_convity_deregist
 			 */
 			spin_lock_irqsave(&lock, flags);
 
-			convity.eventMask &= ~(USB_DETECT_2V0_RISE |
-					       USB_DETECT_2V0_FALL);
+			usb.eventMask &= ~(USB_DETECT_2V0_RISE |
+					   USB_DETECT_2V0_FALL);
 
 			spin_unlock_irqrestore(&lock, flags);
 		} else {
@@ -2060,8 +2230,8 @@ static PMIC_STATUS pmic_convity_deregist
 		}
 	}
 
-	else if ((convity.eventMask & USB_DETECT_4V4_RISE) ||
-		 (convity.eventMask & USB_DETECT_4V4_FALL)) {
+	else if ((usb.eventMask & USB_DETECT_4V4_RISE) ||
+		 (usb.eventMask & USB_DETECT_4V4_FALL)) {
 
 		//EVENT_USB_44VI or EVENT_USBI
 		eventNotify.func = pmic_convity_event_handler;
@@ -2075,8 +2245,8 @@ static PMIC_STATUS pmic_convity_deregist
 			 */
 			spin_lock_irqsave(&lock, flags);
 
-			convity.eventMask &= ~(USB_DETECT_4V4_RISE |
-					       USB_DETECT_4V4_FALL);
+			usb.eventMask &= ~(USB_DETECT_4V4_RISE |
+					   USB_DETECT_4V4_FALL);
 
 			spin_unlock_irqrestore(&lock, flags);
 		} else {
@@ -2101,8 +2271,8 @@ static PMIC_STATUS pmic_convity_deregist
 		 * just in case some of the pmic_event_unsubscribe() calls above
 		 * failed for some reason (which normally shouldn't happen).
 		 */
-		convity.callback = reset.callback;
-		convity.eventMask = reset.eventMask;
+		usb.callback = reset.callback;
+		usb.eventMask = reset.eventMask;
 
 		spin_unlock_irqrestore(&lock, flags);
 	}
@@ -2168,7 +2338,7 @@ static void pmic_convity_tasklet(unsigne
 		activeEvents = pmic_check_sensor(SENSE_USB4V4S) ?
 		    USB_DETECT_4V4_RISE : USB_DETECT_4V4_FALL;
 
-		if (activeEvents & ~convity.eventMask) {
+		if (activeEvents & ~usb.eventMask) {
 			/* The default handler for 4.4 V rising/falling edge detection
 			 * is to simply ignore the event.
 			 */
@@ -2181,7 +2351,7 @@ static void pmic_convity_tasklet(unsigne
 
 		activeEvents = pmic_check_sensor(SENSE_USB2V0S) ?
 		    USB_DETECT_2V0_RISE : USB_DETECT_2V0_FALL;
-		if (activeEvents & ~convity.eventMask) {
+		if (activeEvents & ~usb.eventMask) {
 			/* The default handler for 2.0 V rising/falling edge detection
 			 * is to simply ignore the event.
 			 */
@@ -2195,7 +2365,7 @@ static void pmic_convity_tasklet(unsigne
 		activeEvents = pmic_check_sensor(SENSE_USB0V8S) ?
 		    USB_DETECT_0V8_RISE : USB_DETECT_0V8_FALL;
 
-		if (activeEvents & ~convity.eventMask) {
+		if (activeEvents & ~usb.eventMask) {
 			/* The default handler for 0.8 V rising/falling edge detection
 			 * is to simply ignore the event.
 			 */
@@ -2278,7 +2448,7 @@ static void pmic_convity_tasklet(unsigne
 
 			activeEvents = USB_DETECT_FACTORY_MODE;
 		}
-		if (activeEvents & ~convity.eventMask) {
+		if (activeEvents & ~usb.eventMask) {
 			/* The default handler for mini-A/mini-B connector detection
 			 * is to simply ignore the event.
 			 */
@@ -2294,9 +2464,9 @@ static void pmic_convity_tasklet(unsigne
 	spin_lock_irqsave(&lock, flags);
 
 	/* Finally, call the user-defined callback function if required. */
-	if ((convity.handleState == HANDLE_IN_USE) &&
-	    (convity.callback != NULL) && (activeEvents & convity.eventMask)) {
-		(*convity.callback) (activeEvents);
+	if ((usb.handle_state == HANDLE_IN_USE) &&
+	    (usb.callback != NULL) && (activeEvents & usb.eventMask)) {
+		(*usb.callback) (activeEvents);
 	}
 
 	spin_unlock_irqrestore(&lock, flags);
@@ -2346,8 +2516,12 @@ static void __exit mc13783_pmic_convity_
 	/* Close the device handle if it is still open. This will also
 	 * deregister any callbacks that may still be active.
 	 */
-	if (convity.handleState == HANDLE_IN_USE) {
-		pmic_convity_close(convity.handle);
+	if (usb.handle_state == HANDLE_IN_USE) {
+		pmic_convity_close(usb.handle);
+	} else if (usb.handle_state == HANDLE_IN_USE) {
+		pmic_convity_close(rs_232.handle);
+	} else if (usb.handle_state == HANDLE_IN_USE) {
+		pmic_convity_close(cea_936.handle);
 	}
 
 	/* Reset the PMIC Connectivity register to it's power on state.
