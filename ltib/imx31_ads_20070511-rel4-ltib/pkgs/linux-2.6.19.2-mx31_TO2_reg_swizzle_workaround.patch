diff -uNpr linux-2.6.19.2.orig/arch/arm/plat-mxc/Kconfig linux-2.6.19.2/arch/arm/plat-mxc/Kconfig
--- linux-2.6.19.2.orig/arch/arm/plat-mxc/Kconfig	2007-05-08 21:23:25.000000000 -0600
+++ linux-2.6.19.2/arch/arm/plat-mxc/Kconfig	2007-05-08 21:53:20.000000000 -0600
@@ -11,6 +11,20 @@ config ARCH_MX3
 	help
 	  This enables support for systems based on Freescale i.MX31
 
+config MX31_TO2_REG_SWIZZLE_WORKAROUND
+	bool "MX31-TO2 Register Swizzle Workaround"
+	depends on ARCH_MX3
+	help
+	  This option attempts to work around a problem discovered with
+	  MX31-TO2 silicon where a general register is loaded with an
+	  address constant from a PC-relative location.  Upon going
+	  indirect through this register, the address value contained
+	  in the register will have been rotated right by 8 bits, causing
+	  a memory fault.  The cause of the rotation is not known, nor is
+	  the reason why this work around seems to make the problem go
+	  away.  If you are using MX31-TO2 silicon and are faulting on
+	  rotated addresses, enable this option.
+
 config ARCH_MX27
 	bool "MX27-based"
 	select MXC_EMMA
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/pm/dvfs_dptc.c linux-2.6.19.2/drivers/mxc/pm/dvfs_dptc.c
--- linux-2.6.19.2.orig/drivers/mxc/pm/dvfs_dptc.c	2007-05-08 21:55:23.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/pm/dvfs_dptc.c	2007-05-08 21:57:43.000000000 -0600
@@ -422,7 +422,11 @@ static int __init dvfs_dptc_init_default
 		return -ENOMEM;
 	}
 
+#ifdef CONFIG_MX31_TO2_REG_SWIZZLE_WORKAROUND
+	table_str = default_table_str_rev2;
+#else
 	table_str = default_table_str;
+#endif
 	if (cpu_is_mx31()) {
 		if (system_rev < CHIP_REV_2_0) {
 			clk = clk_get(NULL, "ckih");
@@ -435,8 +439,10 @@ static int __init dvfs_dptc_init_default
 			}
 		} else {
 #ifdef CONFIG_ARCH_MX3
+#ifndef CONFIG_MX31_TO2_REG_SWIZZLE_WORKAROUND
 			table_str = default_table_str_rev2;
 #endif
+#endif
 		}
 		clk_put(clk);
 	}
