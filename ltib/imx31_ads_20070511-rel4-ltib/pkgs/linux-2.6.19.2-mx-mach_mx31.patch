--- linux-2.6.19.2/arch/arm/configs/imx31ads_defconfig	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/configs/imx31ads_defconfig	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,1596 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.18.1
+# Tue Dec 19 15:54:45 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_BLK_DEV_IO_TRACE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_L7200 is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Freescale MXC Implementations
+#
+CONFIG_ARCH_MX3=y
+# CONFIG_ARCH_MX27 is not set
+CONFIG_ISP1504_MXC=m
+
+#
+# MX3 Options
+#
+CONFIG_MACH_MX31ADS=y
+# CONFIG_MX3_DOZE_DURING_IDLE is not set
+CONFIG_MXC_SDMA_API=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_V6=y
+# CONFIG_CPU_32v6K is not set
+CONFIG_CPU_32v6=y
+CONFIG_CPU_ABRT_EV6=y
+CONFIG_CPU_CACHE_V6=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V6=y
+CONFIG_CPU_CACHE_L210=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+
+#
+# Bus support
+#
+CONFIG_ISA=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+CONFIG_PCCARD=m
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=m
+CONFIG_PCMCIA_LOAD_CIS=y
+# CONFIG_PCMCIA_IOCTL is not set
+
+#
+# PC-card bridges
+#
+# CONFIG_I82365 is not set
+# CONFIG_TCIC is not set
+CONFIG_PCMCIA_PROBE=y
+CONFIG_PCMCIA_MX31ADS=m
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+# CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+CONFIG_AEABI=y
+# CONFIG_OABI_COMPAT is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0 root=/dev/mtdblock2 rw ip=off"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_LEGACY is not set
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_IRDA=m
+
+#
+# IrDA protocols
+#
+CONFIG_IRLAN=m
+CONFIG_IRNET=m
+CONFIG_IRCOMM=m
+# CONFIG_IRDA_ULTRA is not set
+
+#
+# IrDA options
+#
+CONFIG_IRDA_CACHE_LAST_LSAP=y
+CONFIG_IRDA_FAST_RR=y
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=m
+
+#
+# Dongle support
+#
+# CONFIG_DONGLE is not set
+
+#
+# Old SIR device drivers
+#
+# CONFIG_IRPORT_SIR is not set
+
+#
+# Old Serial dongle support
+#
+
+#
+# FIR device drivers
+#
+# CONFIG_USB_IRDA is not set
+# CONFIG_SIGMATEL_FIR is not set
+# CONFIG_MCS_FIR is not set
+CONFIG_MXC_FIR=m
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+# CONFIG_IEEE80211_CRYPT_WEP is not set
+# CONFIG_IEEE80211_CRYPT_CCMP is not set
+# CONFIG_IEEE80211_CRYPT_TKIP is not set
+# CONFIG_IEEE80211_SOFTMAC is not set
+CONFIG_WIRELESS_EXT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_RAM=y
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_MXC=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_MXC=y
+# CONFIG_MTD_NAND_MXC_SWECC is not set
+# CONFIG_MTD_NAND_MXC_FORCE_CE is not set
+# CONFIG_MTD_NAND_MXC_ECC_CORRECTION_OPTION2 is not set
+# CONFIG_CONFIG_MXC_NAND_LOW_LEVEL_ERASE is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=m
+CONFIG_BLK_DEV_IDE=m
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=m
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=m
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=m
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDE_MXC=m
+# CONFIG_IDE_CHIPSETS is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+CONFIG_NET_PCI=y
+# CONFIG_AC3200 is not set
+# CONFIG_APRICOT is not set
+CONFIG_CS89x0=y
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_NET_WIRELESS_RTNETLINK is not set
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ARLAN is not set
+# CONFIG_WAVELAN is not set
+# CONFIG_PCMCIA_WAVELAN is not set
+# CONFIG_PCMCIA_NETWAVE is not set
+
+#
+# Wireless 802.11 Frequency Hopping cards support
+#
+# CONFIG_PCMCIA_RAYCS is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+# CONFIG_HERMES is not set
+# CONFIG_ATMEL is not set
+
+#
+# Wireless 802.11b Pcmcia/Cardbus cards support
+#
+# CONFIG_AIRO_CS is not set
+# CONFIG_PCMCIA_WL3501 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# PCMCIA network device support
+#
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+CONFIG_PCMCIA_PCNET=m
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_AXNET is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_KEYBOARD_MXC=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_MXC=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_CS is not set
+CONFIG_SERIAL_8250_NR_UARTS=2
+CONFIG_SERIAL_8250_RUNTIME_UARTS=2
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_MXC_WATCHDOG=y
+
+#
+# ISA-based Watchdog Cards
+#
+# CONFIG_PCWATCHDOG is not set
+# CONFIG_MIXCOMWD is not set
+# CONFIG_WDT is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+CONFIG_MXC_RTC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ELEKTOR is not set
+CONFIG_I2C_MXC=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_MXC=y
+# CONFIG_SPI_MXC_TEST_LOOPBACK is not set
+# CONFIG_SPI_MXC_SELECT1 is not set
+CONFIG_SPI_MXC_SELECT2=y
+# CONFIG_SPI_MXC_SELECT3 is not set
+
+#
+# SPI Protocol Masters
+#
+
+#
+# Dallas's 1-wire bus
+#
+CONFIG_W1=y
+CONFIG_W1_CON=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+CONFIG_W1_MASTER_MXC=y
+
+#
+# 1-wire Slaves
+#
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+CONFIG_W1_SLAVE_DS2433=y
+# CONFIG_W1_SLAVE_DS2433_CRC is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_VIDEO_V4L2=y
+
+#
+# Video Capture Adapters
+#
+
+#
+# Video Capture Adapters
+#
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_PMS is not set
+CONFIG_VIDEO_MXC_CAMERA=y
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_IPU_CAMERA=y
+CONFIG_MXC_CAMERA_MICRON111=y
+CONFIG_MXC_IPU_PRP_VF_SDC=y
+CONFIG_MXC_IPU_PRP_ENC=y
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_IPU_OUTPUT=y
+# CONFIG_VIDEO_MXC_OPL is not set
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_TUNER_3036 is not set
+
+#
+# Encoders and Decoders
+#
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_CX2341X is not set
+# CONFIG_VIDEO_CX25840 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# V4L USB devices
+#
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_W9968CF is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_GEMTEK is not set
+# CONFIG_RADIO_MAESTRO is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_SF16FMR2 is not set
+# CONFIG_RADIO_TERRATEC is not set
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
+# CONFIG_USB_DSBR is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_TVOUT=y
+# CONFIG_FB_MXC_OVERLAY is not set
+# CONFIG_FB_MXC_ASYNC_PANEL is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_MXC_PMIC=y
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# PCMCIA devices
+#
+# CONFIG_SND_VXPOCKET is not set
+# CONFIG_SND_PDAUDIOCF is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ARC=y
+CONFIG_USB_EHCI_ARC_H1=y
+CONFIG_USB_EHCI_ARC_H2=y
+CONFIG_USB_EHCI_ARC_OTG=y
+CONFIG_USB_EHCI_ARC_OTGHS=y
+# CONFIG_USB_EHCI_ARC_OTGFS is not set
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+CONFIG_USB_HIDINPUT=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_TOUCHSCREEN is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_ATI_REMOTE2 is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+CONFIG_USB_GADGET_ARC=y
+CONFIG_USB_ARC=m
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_ARC_OTG=y
+# CONFIG_USB_GADGET_ARC_OTGFS is not set
+CONFIG_USB_GADGET_ARC_OTGHS=y
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_MXC=y
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# MXC support drivers
+#
+
+#
+# MXC IPU
+#
+CONFIG_MXC_IPU=y
+# CONFIG_MXC_IPU_LPMC is not set
+CONFIG_MXC_IPU_PF=y
+
+#
+# MXC SSI support
+#
+CONFIG_MXC_SSI=y
+
+#
+# MXC Digital Audio Multiplexer support
+#
+CONFIG_MXC_DAM=y
+
+#
+# MXC PMIC support
+#
+CONFIG_MXC_SPI_PMIC_CORE=y
+CONFIG_MXC_PMIC=y
+CONFIG_MXC_PMIC_CHARDEV=y
+
+#
+# MXC PMIC Client Drivers
+#
+CONFIG_MXC_PMIC_MC13783=y
+CONFIG_MXC_MC13783_ADC=y
+CONFIG_MXC_MC13783_AUDIO=y
+CONFIG_MXC_MC13783_RTC=y
+CONFIG_MXC_MC13783_LIGHT=y
+CONFIG_MXC_MC13783_BATTERY=y
+CONFIG_MXC_MC13783_CONNECTIVITY=y
+CONFIG_MXC_MC13783_POWER=y
+
+#
+# Advanced Power Management devices
+#
+CONFIG_MXC_DPTC=y
+CONFIG_MXC_DVFS=y
+CONFIG_MXC_DVFS_SDMA=y
+
+#
+# MXC Security Drivers
+#
+CONFIG_MXC_SECURITY_SCC=y
+CONFIG_MXC_SECURITY_RNGA=y
+# CONFIG_MXC_RNGA_TEST_DRIVER is not set
+CONFIG_MXC_SECURITY_RTIC=y
+# CONFIG_MXC_RTIC_TEST_DEBUG is not set
+CONFIG_MXC_SECURITY_CORE=y
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+# CONFIG_MXC_HMP4E is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+CONFIG_PROFILING=y
+CONFIG_OPROFILE=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_UNWIND_INFO is not set
+# CONFIG_DEBUG_USER is not set
+
+#
+# CodeTEST setup
+#
+# CONFIG_CODETEST is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
--- linux-2.6.19.2/arch/arm/mach-mx3/clock.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/clock.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,1127 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file clock.c
+ * @brief API for setting up and retrieving clocks.
+ *
+ * This file contains API for setting up and retrieving clocks.
+ *
+ * @ingroup CLOCKS
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+
+#include "crm_regs.h"
+#include "time_priv.h"
+
+/*
+ * Clock source bit fields for GPT
+ */
+#define CLKSRC_NO_CLK	    	0
+#define CLKSRC_IPG_CLK	    	1
+#define CLKSRC_IPG_CLK_HIGH   	2
+#define CLKSRC_EXT_PAD	    	3
+
+/*
+ * Get Clock errors
+ */
+#define ERR_CLK_NO_SUPPORT	    1
+
+/*!
+ * Spinlock to protect CRM register accesses
+ */
+static DEFINE_SPINLOCK(mxc_crm_lock);
+
+/*
+ * This function returns the clock CKIH clock input value.
+ */
+static unsigned long mxc_clock_ckih(void)
+{
+	static unsigned long g_clk_ckih = 0;
+
+	if (g_clk_ckih == 0) {
+		if ((__raw_readw(PBC_BASE_ADDRESS + PBC_BSTAT) &
+		     CKIH_27MHZ_BIT_SET) != 0) {
+			g_clk_ckih = CKIH_CLK_FREQ_27MHZ;
+		} else {
+			g_clk_ckih = CKIH_CLK_FREQ;
+		}
+		pr_info("Clock input source is %ld\n", g_clk_ckih);
+	}
+
+	return g_clk_ckih;
+}
+
+/*!
+ * This function returns the PLL output value in Hz based on pll.
+ * @param       pll     PLL as defined in enum plls
+ * @return      PLL value in Hz.
+ */
+unsigned long mxc_pll_clock(enum plls pll)
+{
+	unsigned long mfi, mfn, mfd, pdf, ref_clk;
+	unsigned long reg = 0, ccmr;
+	unsigned long long temp;
+	unsigned int prcs;
+
+	ccmr = __raw_readl(MXC_CCM_CCMR);
+	prcs = (ccmr & MXC_CCM_CCMR_PRCS_MASK) >> MXC_CCM_CCMR_PRCS_OFFSET;
+	if (prcs == 0x1) {
+		ref_clk = CKIL_CLK_FREQ * 1024;
+	} else {
+		ref_clk = mxc_clock_ckih();
+	}
+
+	if (pll == MCUPLL) {
+		if ((ccmr & MXC_CCM_CCMR_MPE) == 0) {
+			return ref_clk;
+		}
+		if ((ccmr & MXC_CCM_CCMR_MDS) != 0) {
+			return ref_clk;
+		}
+		reg = __raw_readl(MXC_CCM_MPCTL);
+	} else if (pll == USBPLL) {
+		reg = __raw_readl(MXC_CCM_UPCTL);
+	} else if (pll == SERIALPLL) {
+		reg = __raw_readl(MXC_CCM_SRPCTL);
+	} else {
+		printk(KERN_ERR "\nUnknown pll: %d\n\n", pll);
+		BUG();		/* oops */
+	}
+	pdf = (reg & MXC_CCM_PCTL_PD_MASK) >> MXC_CCM_PCTL_PD_OFFSET;
+	mfd = (reg & MXC_CCM_PCTL_MFD_MASK) >> MXC_CCM_PCTL_MFD_OFFSET;
+	mfi = (reg & MXC_CCM_PCTL_MFI_MASK) >> MXC_CCM_PCTL_MFI_OFFSET;
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfn = reg & MXC_CCM_PCTL_MFN_MASK;
+
+	if (mfn < 0x200) {
+		temp = (unsigned long long)2 *ref_clk * mfn;
+		do_div(temp, mfd + 1);
+		temp = (unsigned long long)2 *ref_clk * mfi + temp;
+		do_div(temp, pdf + 1);
+	} else {
+		temp = (unsigned long long)2 *ref_clk * (0x400 - mfn);
+		do_div(temp, mfd + 1);
+		temp = (unsigned long long)2 *ref_clk * mfi - temp;
+		do_div(temp, pdf + 1);
+	}
+
+	return (unsigned long)temp;
+}
+
+/*!
+ * This function returns the mcu main clock frequency
+ *
+ * @return      mcu main clock value in Hz.
+ */
+static unsigned long mxc_mcu_main_clock(void)
+{
+	unsigned long pmcr0 = __raw_readl(MXC_CCM_PMCR0);
+	unsigned long dfsup1 = pmcr0 & MXC_CCM_PMCR0_DFSUP1;
+
+	if (dfsup1 == 0) {
+		return mxc_pll_clock(SERIALPLL);
+	}
+	return mxc_pll_clock(MCUPLL);
+}
+
+/*!
+ * This function returns the main clock values in Hz.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks(enum mxc_clocks clk)
+{
+	unsigned long pll, ret_val = 0, hclk, gpt_ctrl;
+	unsigned long mcu_pdf, max_pdf, ipg_pdf, nfc_pdf, hsp_pdf, csi_pdf,
+	    usb_pdf;
+	unsigned long ssi1_prepdf, ssi1_pdf, per_pdf;
+	unsigned long ssi2_prepdf, ssi2_pdf, firi_prepdf, firi_pdf, usb_prepdf;
+	unsigned long msti_pdf, epit_offset = 0, pwm_ctrl, epit_ctrl;
+	unsigned long ccmr = __raw_readl(MXC_CCM_CCMR);
+	unsigned long pdr0 = __raw_readl(MXC_CCM_PDR0);
+	unsigned long pdr1 = __raw_readl(MXC_CCM_PDR1);
+	unsigned long pdr2 = __raw_readl(MXC_CCM_PDR2);
+	int clksrc;
+
+	max_pdf =
+	    (pdr0 & MXC_CCM_PDR0_MAX_PODF_MASK) >> MXC_CCM_PDR0_MAX_PODF_OFFSET;
+	ipg_pdf =
+	    (pdr0 & MXC_CCM_PDR0_IPG_PODF_MASK) >> MXC_CCM_PDR0_IPG_PODF_OFFSET;
+	per_pdf =
+	    (pdr0 & MXC_CCM_PDR0_PER_PODF_MASK) >> MXC_CCM_PDR0_PER_PODF_OFFSET;
+
+	switch (clk) {
+	case CKIL_CLK:
+		ret_val = CKIL_CLK_FREQ;
+		break;
+	case CKIH_CLK:
+		ret_val = mxc_clock_ckih();
+		break;
+	case CPU_CLK:
+		pll = mxc_mcu_main_clock();
+		mcu_pdf = pdr0 & MXC_CCM_PDR0_MCU_PODF_MASK;
+		ret_val = pll / (mcu_pdf + 1);
+		break;
+	case AHB_CLK:
+		pll = mxc_mcu_main_clock();
+		ret_val = pll / (max_pdf + 1);
+		break;
+	case CSPI1_CLK:
+	case CSPI2_CLK:
+	case CSPI3_CLK:
+	case IPG_CLK:
+		pll = mxc_mcu_main_clock();
+		hclk = pll / (max_pdf + 1);
+		ret_val = hclk / (ipg_pdf + 1);
+		break;
+	case GPT_CLK:
+		/*
+		 * Three possibilities
+		 * 1. ipg_clk - sourced from mcu_ipg_clk
+		 * 2. ipg_clk_high - same as ipg_clk
+		 * 3. ckil
+		 */
+		gpt_ctrl = __raw_readl(MXC_GPT_GPTCR);
+		clksrc = (gpt_ctrl & GPTCR_CLKSRC_MASK) >> (GPTCR_CLKSRC_SHIFT);
+		switch (clksrc) {
+		case CLKSRC_IPG_CLK_HIGH:
+			if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
+				pll = mxc_pll_clock(USBPLL);
+				ret_val = pll / (per_pdf + 1);
+			} else {
+				pll = mxc_mcu_main_clock();
+				hclk = pll / (max_pdf + 1);
+				ret_val = hclk / (ipg_pdf + 1);
+
+			}
+			break;
+		case CLKSRC_IPG_CLK:
+			pll = mxc_mcu_main_clock();
+			hclk = pll / (max_pdf + 1);
+			ret_val = hclk / (ipg_pdf + 1);
+			break;
+		case CLKSRC_NO_CLK:
+		case CLKSRC_EXT_PAD:
+			printk(KERN_ERR
+			       "Warning: GPT clock source not supported !!!\n");
+			return -ERR_CLK_NO_SUPPORT;
+		default:
+			ret_val = CKIL_CLK_FREQ;
+			break;
+		}
+		break;
+	case PWM_CLK:
+		/*
+		 * Three possibilities
+		 * 1. ipg_clk_high - from perclk
+		 * 1. ipg_clk - sourced from mcu_ipg_clk
+		 * 2. ipg_clk_32k - CKIL
+		 */
+		pwm_ctrl = __raw_readl(MXC_PWM_PWMCTRL);
+		clksrc = (pwm_ctrl & (~PWM_CTRL_MASK)) >> (PWM_CTRL_OFFSET);
+		switch (clksrc) {
+		case CLKSRC_IPG_CLK_HIGH:
+			if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
+				pll = mxc_pll_clock(USBPLL);
+				ret_val = pll / (per_pdf + 1);
+			} else {
+				pll = mxc_mcu_main_clock();
+				hclk = pll / (max_pdf + 1);
+				ret_val = hclk / (ipg_pdf + 1);
+
+			}
+			break;
+		case CLKSRC_IPG_CLK:
+			pll = mxc_mcu_main_clock();
+			ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
+			break;
+		case CLKSRC_NO_CLK:
+			printk(KERN_ERR
+			       "Warning: PWM clock source not is off !!!\n");
+			return -ERR_CLK_NO_SUPPORT;
+		default:
+			ret_val = CKIL_CLK_FREQ;
+			break;
+		}
+		break;
+	case EPIT2_CLK:
+		epit_offset = 0x4000;
+	case EPIT1_CLK:
+		epit_ctrl = __raw_readl(MXC_EPIT_EPITCR + epit_offset);
+		/*
+		 * Three possibilities
+		 * 1. ipg_clk - sourced from mcu_ipg_clk
+		 * 2. ipg_clk_high - same as ipg_clk
+		 * 3. ipg_clk_32k - CKIL
+		 */
+		clksrc =
+		    (epit_ctrl & EPITCR_CLKSRC_MASK) >> (EPITCR_CLKSRC_SHIFT);
+		switch (clksrc) {
+		case CLKSRC_IPG_CLK_HIGH:
+			if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
+				pll = mxc_pll_clock(USBPLL);
+				ret_val = pll / (per_pdf + 1);
+			} else {
+				pll = mxc_mcu_main_clock();
+				hclk = pll / (max_pdf + 1);
+				ret_val = hclk / (ipg_pdf + 1);
+
+			}
+			break;
+		case CLKSRC_IPG_CLK:
+			pll = mxc_mcu_main_clock();
+			ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
+			break;
+		case CLKSRC_NO_CLK:
+			printk(KERN_ERR
+			       "Warning: PWM clock source not is off !!!\n");
+			return -ERR_CLK_NO_SUPPORT;
+		default:
+			ret_val = CKIL_CLK_FREQ;
+			break;
+		}
+		break;
+	case NFC_CLK:
+		pll = mxc_mcu_main_clock();
+		hclk = pll / (max_pdf + 1);
+		nfc_pdf = (pdr0 & MXC_CCM_PDR0_NFC_PODF_MASK) >>
+		    MXC_CCM_PDR0_NFC_PODF_OFFSET;
+		ret_val = hclk / (nfc_pdf + 1);
+		break;
+	case IPU_CLK:
+		pll = mxc_mcu_main_clock();
+		hsp_pdf = (pdr0 & MXC_CCM_PDR0_HSP_PODF_MASK) >>
+		    MXC_CCM_PDR0_HSP_PODF_OFFSET;
+		ret_val = pll / (hsp_pdf + 1);
+		break;
+	case USB_CLK:
+		pll = mxc_pll_clock(USBPLL);
+		usb_pdf = (pdr1 & MXC_CCM_PDR1_USB_PODF_MASK) >>
+		    MXC_CCM_PDR1_USB_PODF_OFFSET;
+		usb_prepdf = (pdr1 & MXC_CCM_PDR1_USB_PRDF_MASK) >>
+		    MXC_CCM_PDR1_USB_PRDF_OFFSET;
+		ret_val = pll / ((usb_prepdf + 1) * (usb_pdf + 1));
+		break;
+	case CSI_BAUD:
+		if ((ccmr & MXC_CCM_CCMR_CSCS) == 0) {
+			pll = mxc_pll_clock(USBPLL);
+		} else {
+			pll = mxc_pll_clock(SERIALPLL);
+		}
+		csi_pdf = (pdr0 & MXC_CCM_PDR0_CSI_PODF_MASK) >>
+		    MXC_CCM_PDR0_CSI_PODF_OFFSET;
+		ret_val = pll / (csi_pdf + 1);
+		break;
+	case UART1_BAUD:
+	case UART2_BAUD:
+	case UART3_BAUD:
+	case UART4_BAUD:
+	case UART5_BAUD:
+	case I2C_CLK:
+	case I2C2_CLK:
+	case I2C3_CLK:
+	case OWIRE_CLK:
+	case SDHC1_CLK:
+	case SDHC2_CLK:
+		if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
+			pll = mxc_pll_clock(USBPLL);
+			ret_val = pll / (per_pdf + 1);
+		} else {
+			pll = mxc_mcu_main_clock();
+			hclk = pll / (max_pdf + 1);
+			ret_val = hclk / (ipg_pdf + 1);
+
+		}
+		break;
+	case SSI1_BAUD:
+		pll = mxc_pll_clock((ccmr & MXC_CCM_CCMR_SSI1S_MASK) >>
+				    MXC_CCM_CCMR_SSI1S_OFFSET);
+		ssi1_pdf = (pdr1 & MXC_CCM_PDR1_SSI1_PODF_MASK) >>
+		    MXC_CCM_PDR1_SSI1_PODF_OFFSET;
+		ssi1_prepdf = (pdr1 & MXC_CCM_PDR1_SSI1_PRE_PODF_MASK) >>
+		    MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET;
+		ret_val = pll / ((ssi1_prepdf + 1) * (ssi1_pdf + 1));
+		break;
+	case SSI2_BAUD:
+		pll = mxc_pll_clock((ccmr & MXC_CCM_CCMR_SSI2S_MASK) >>
+				    MXC_CCM_CCMR_SSI2S_OFFSET);
+		ssi2_pdf = (pdr1 & MXC_CCM_PDR1_SSI2_PODF_MASK) >>
+		    MXC_CCM_PDR1_SSI2_PODF_OFFSET;
+		ssi2_prepdf = (pdr1 & MXC_CCM_PDR1_SSI2_PRE_PODF_MASK) >>
+		    MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET;
+		ret_val = pll / ((ssi2_prepdf + 1) * (ssi2_pdf + 1));
+		break;
+	case FIRI_BAUD:
+		pll = mxc_get_clocks_parent(FIRI_BAUD);
+		firi_pdf = (pdr1 & MXC_CCM_PDR1_FIRI_PODF_MASK) >>
+		    MXC_CCM_PDR1_FIRI_PODF_OFFSET;
+		firi_prepdf = (pdr1 & MXC_CCM_PDR1_FIRI_PRE_PODF_MASK) >>
+		    MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET;
+		ret_val = pll / ((firi_prepdf + 1) * (firi_pdf + 1));
+		break;
+	case MBX_CLK:
+		pll = mxc_mcu_main_clock();
+		ret_val = pll / (max_pdf + 1);
+		ret_val = ret_val / 2;
+		break;
+	case MSTICK1_BAUD:
+		pll = mxc_pll_clock(USBPLL);
+		msti_pdf = (pdr2 & MXC_CCM_PDR2_MST1_PDF_MASK) >>
+		    MXC_CCM_PDR2_MST1_PDF_OFFSET;
+		ret_val = pll / (msti_pdf + 1);
+		break;
+	case MSTICK2_BAUD:
+		pll = mxc_pll_clock(USBPLL);
+		msti_pdf = (pdr2 & MXC_CCM_PDR2_MST2_PDF_MASK) >>
+		    MXC_CCM_PDR2_MST2_PDF_OFFSET;
+		ret_val = pll / (msti_pdf + 1);
+		break;
+	default:
+		ret_val = 66516666;
+		break;
+	}
+	return ret_val;
+}
+
+/*!
+ * This function returns the parent clock values in Hz.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks_parent(enum mxc_clocks clk)
+{
+	unsigned long ret_val = 0;
+	unsigned long ccmr = __raw_readl(MXC_CCM_CCMR);
+
+	switch (clk) {
+	case CSI_BAUD:
+		if ((ccmr & MXC_CCM_CCMR_CSCS) == 0) {
+			ret_val = mxc_pll_clock(USBPLL);
+		} else {
+			ret_val = mxc_pll_clock(SERIALPLL);
+		}
+		break;
+	case FIRI_BAUD:
+		switch ((ccmr & MXC_CCM_CCMR_FIRS_MASK) >>
+			MXC_CCM_CCMR_FIRS_OFFSET) {
+		case 0:
+			ret_val = mxc_pll_clock(MCUPLL);
+			break;
+		case 1:
+			ret_val = mxc_pll_clock(USBPLL);
+			break;
+		case 2:
+			ret_val = mxc_pll_clock(SERIALPLL);
+			break;
+		case 3:
+		default:
+			printk(KERN_ERR
+			       "FIRI clock source select is set to RESERVED\n");
+		}
+		break;
+	default:
+		break;
+	}
+	return ret_val;
+}
+
+/*!
+ * This function calculates the pre and post divider values for a clock
+ *
+ * @param div  divider value passed in
+ * @param div1 returns the pre-divider value
+ * @param div2 returns the post-divider value
+ * @param lim1 limit of divider 1
+ * @param lim2 limit of divider 2
+ */
+void mxc_clk_getdivs(unsigned int div, unsigned int *div1,
+		     unsigned int *div2, int lim1, int lim2)
+{
+	int i;
+
+	if (div <= lim1) {
+		*div1 = div;
+		*div2 = 1;
+		return;
+	}
+	if (div <= lim2) {
+		*div1 = 1;
+		*div2 = div;
+		return;
+	}
+	for (i = 2; i < (lim1 + 1); i++) {
+		if ((div % i) == 0) {
+			*div1 = i;
+			*div2 = div / i;
+			return;
+		}
+	}
+
+	*div1 = 1;
+	*div2 = lim2;
+	return;
+}
+
+/*!
+ * This function sets the PLL source for a clock.
+ *
+ * @param clk     as defined in enum mxc_clocks
+ * @param pll_num the PLL that you wish to use as source for this clock
+ */
+void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num)
+{
+	unsigned long ccmr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	ccmr = __raw_readl(MXC_CCM_CCMR);
+
+	switch (clk) {
+	case CPU_CLK:
+		if (pll_num == MCUPLL) {
+			ccmr &= ~MXC_CCM_CCMR_MDS;
+		} else {
+			ccmr |= MXC_CCM_CCMR_MDS;
+		}
+		break;
+	case CSI_BAUD:
+		if (pll_num == USBPLL) {
+			ccmr &= ~MXC_CCM_CCMR_CSCS;
+		} else {
+			ccmr |= MXC_CCM_CCMR_CSCS;
+		}
+		break;
+	case SSI1_BAUD:
+		ccmr = (ccmr & (~MXC_CCM_CCMR_SSI1S_MASK)) |
+		    (pll_num << MXC_CCM_CCMR_SSI1S_OFFSET);
+		break;
+	case SSI2_BAUD:
+		ccmr = (ccmr & (~MXC_CCM_CCMR_SSI2S_MASK)) |
+		    (pll_num << MXC_CCM_CCMR_SSI2S_OFFSET);
+		break;
+	case FIRI_BAUD:
+		ccmr = (ccmr & (~MXC_CCM_CCMR_FIRS_MASK)) |
+		    (pll_num << MXC_CCM_CCMR_FIRS_OFFSET);
+		break;
+	default:
+		printk(KERN_ERR
+		       "This clock does not have ability to choose its clock source\n");
+		break;
+	}
+	__raw_writel(ccmr, MXC_CCM_CCMR);
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	return;
+}
+
+/*!
+ * This function sets the divider value for a clock.
+ *
+ * @param clk as defined in enum mxc_clocks
+ * @param div the division factor to be used for the clock (For SSI & CSI, pass
+ *            in 2 times the expected division value to account for FP vals on certain
+ *            platforms)
+ */
+void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div)
+{
+	unsigned long reg;
+	unsigned long flags;
+	unsigned int d = 0, div1 = 0, div2 = 0;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	switch (clk) {
+	case AHB_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_MAX_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_MAX_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case CPU_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_MCU_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_MCU_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case IPG_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_IPG_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_IPG_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case NFC_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_NFC_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_NFC_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case CSI_BAUD:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		d = div / 2;
+		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
+		reg = (reg & (~MXC_CCM_PDR0_CSI_PRDF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR0_CSI_PRDF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR0_CSI_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR0_CSI_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case IPU_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_HSP_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_HSP_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case UART1_BAUD:
+	case UART2_BAUD:
+	case UART3_BAUD:
+	case UART4_BAUD:
+	case UART5_BAUD:
+	case I2C_CLK:
+	case I2C2_CLK:
+	case I2C3_CLK:
+		reg = __raw_readl(MXC_CCM_PDR0);
+		reg = (reg & (~MXC_CCM_PDR0_PER_PODF_MASK)) |
+		    ((div - 1) << MXC_CCM_PDR0_PER_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR0);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(MXC_CCM_PDR1);
+		d = div / 2;
+		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
+		reg = (reg & (~MXC_CCM_PDR1_SSI1_PRE_PODF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR1_SSI1_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR1_SSI1_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR1);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(MXC_CCM_PDR1);
+		d = div / 2;
+		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
+		reg = (reg & (~MXC_CCM_PDR1_SSI2_PRE_PODF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR1_SSI2_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR1_SSI2_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR1);
+		break;
+	case FIRI_BAUD:
+		reg = __raw_readl(MXC_CCM_PDR1);
+		mxc_clk_getdivs(div, &div1, &div2, 8, 64);
+		reg = (reg & (~MXC_CCM_PDR1_FIRI_PRE_PODF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR1_FIRI_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR1_FIRI_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR1);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(MXC_CCM_PDR1);
+		mxc_clk_getdivs(d, &div1, &div2, 4, 8);
+		reg = (reg & (~MXC_CCM_PDR1_USB_PRDF_MASK)) |
+		    ((div1 - 1) << MXC_CCM_PDR1_USB_PRDF_OFFSET);
+		reg = (reg & (~MXC_CCM_PDR1_USB_PODF_MASK)) |
+		    ((div2 - 1) << MXC_CCM_PDR1_USB_PODF_OFFSET);
+		__raw_writel(reg, MXC_CCM_PDR1);
+		break;
+	default:
+		break;
+	}
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to enable the individual module clocks
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ */
+void mxc_clks_enable(enum mxc_clocks clk)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	switch (clk) {
+	case UART1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_UART1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case UART2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_UART2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case UART3_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_UART3;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case UART4_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_UART4;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case UART5_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_UART5;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case I2C_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_I2C1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case I2C2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_I2C2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case I2C3_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_I2C3;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_SSI1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_SSI2;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_USBOTG;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case FIRI_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_FIRI;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSI_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_CSI;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case IPU_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_IPU;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case KPP_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_KPP;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case SDHC1_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_SD_MMC1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SDHC2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_SD_MMC2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case CSPI1_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_CSPI1;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSPI2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_CSPI2;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSPI3_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_CSPI3;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case ATA_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_ATA;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case MBX_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_GACC;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case RTIC_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg |= MXC_CCM_CGR2_RTIC;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case RNG_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_RNG;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SDMA_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg |= MXC_CCM_CGR0_SDMA;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case MPEG4_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_HANTRO;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case MSTICK1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_MEMSTICK1;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case MSTICK2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg |= MXC_CCM_CGR1_MEMSTICK2;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to disable the individual module clocks
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ */
+void mxc_clks_disable(enum mxc_clocks clk)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	switch (clk) {
+	case UART1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_UART1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case UART2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_UART2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case UART3_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_UART3;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case UART4_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_UART4;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case UART5_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_UART5;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case I2C_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_I2C1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case I2C2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_I2C2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case I2C3_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_I2C3;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_SSI1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_SSI2;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_USBOTG;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case FIRI_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_FIRI;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSI_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_CSI;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case IPU_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_IPU;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case KPP_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_KPP;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case SDHC1_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_SD_MMC1;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SDHC2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_SD_MMC2;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case CSPI1_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_CSPI1;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSPI2_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_CSPI2;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case CSPI3_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_CSPI3;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case ATA_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_ATA;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case MBX_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_GACC;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case RTIC_CLK:
+		reg = __raw_readl(MXC_CCM_CGR2);
+		reg &= ~MXC_CCM_CGR2_RTIC;
+		__raw_writel(reg, MXC_CCM_CGR2);
+		break;
+	case RNG_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_RNG;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case SDMA_CLK:
+		reg = __raw_readl(MXC_CCM_CGR0);
+		reg &= ~MXC_CCM_CGR0_SDMA;
+		__raw_writel(reg, MXC_CCM_CGR0);
+		break;
+	case MPEG4_CLK:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_HANTRO;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case MSTICK1_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_MEMSTICK1;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	case MSTICK2_BAUD:
+		reg = __raw_readl(MXC_CCM_CGR1);
+		reg &= ~MXC_CCM_CGR1_MEMSTICK2;
+		__raw_writel(reg, MXC_CCM_CGR1);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to read the contents of a CCM register
+ *
+ * @param reg_offset the CCM register that will read
+ *
+ * @return the register contents
+ */
+unsigned long mxc_ccm_get_reg(unsigned int reg_offset)
+{
+	unsigned long reg;
+
+	reg = __raw_readl(reg_offset);
+	return reg;
+}
+
+/*!
+ * This function is called to modify the contents of a CCM register
+ *
+ * @param reg_offset the CCM register that will read
+ * @param mask       the mask to be used to clear the bits that are to be modified
+ * @param data       the data that should be written to the register
+ */
+void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
+			unsigned int data)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	reg = __raw_readl(reg_offset);
+	reg = (reg & (~mask)) | data;
+	__raw_writel(reg, reg_offset);
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is used to modify PLL registers to generate the required
+ * frequency.
+ *
+ * @param  pll_num  the PLL that you wish to modify
+ * @param  mfi      multiplication factor integer part
+ * @param  pdf      pre-division factor
+ * @param  mfd      multiplication factor denominator
+ * @param  mfn      multiplication factor numerator
+ */
+void mxc_pll_set(enum plls pll_num, unsigned int mfi, unsigned int pdf,
+		 unsigned int mfd, unsigned int mfn)
+{
+	unsigned long ccmr;
+	unsigned long flags;
+	unsigned long new_pll = 0;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	if (pll_num == MCUPLL) {
+		/* Swap to reference clock and disable PLL */
+		ccmr = __raw_readl(MXC_CCM_CCMR);
+		ccmr |= MXC_CCM_CCMR_MDS;
+		ccmr &= ~MXC_CCM_CCMR_MPE;
+		__raw_writel(ccmr, MXC_CCM_CCMR);
+	}
+
+	/* Change the Pll value */
+	new_pll = (mfi << MXC_CCM_PCTL_MFI_OFFSET) |
+	    (mfn << MXC_CCM_PCTL_MFN_OFFSET) |
+	    (mfd << MXC_CCM_PCTL_MFD_OFFSET) | (pdf << MXC_CCM_PCTL_PD_OFFSET);
+
+	if (pll_num == MCUPLL) {
+		__raw_writel(new_pll, MXC_CCM_MPCTL);
+	} else if (pll_num == USBPLL) {
+		__raw_writel(new_pll, MXC_CCM_UPCTL);
+	} else if (pll_num == SERIALPLL) {
+		__raw_writel(new_pll, MXC_CCM_SRPCTL);
+	}
+
+	if (pll_num == MCUPLL) {
+		/* Swap to the new value */
+		ccmr = __raw_readl(MXC_CCM_CCMR);
+		ccmr |= MXC_CCM_CCMR_MPE;
+		ccmr &= ~MXC_CCM_CCMR_MDS;
+		__raw_writel(ccmr, MXC_CCM_CCMR);
+	}
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * Configure clock output on CKO pin
+ *
+ * @param       output     as defined in enum mxc_clk_out
+ * @param       clk        as defined in enum mxc_clocks
+ * @param       div        clock output divider value. The possible values
+ *                               for this are 1, 2, 4, 8 and 16
+ *
+ */
+void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk, int div)
+{
+	unsigned long flags;
+	int div_value = 0;
+	u32 reg;
+
+	switch (div) {
+	case 1:
+		div_value = 0;
+		break;
+	case 2:
+		div_value = 1;
+		break;
+	case 4:
+		div_value = 2;
+		break;
+	case 8:
+		div_value = 3;
+		break;
+	case 16:
+		div_value = 4;
+		break;
+	default:
+		/* return error */
+		return;
+	}
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	reg = __raw_readl(MXC_CCM_COSR);
+
+	reg = (reg & ~MXC_CCM_COSR_CLKOUTDIV_MASK) |
+	    (div_value << MXC_CCM_COSR_CLKOUTDIV_OFFSET);
+
+	switch (clk) {
+	case CPU_CLK:
+		/* To select AP clock */
+		reg = (reg & ~MXC_CCM_COSR_CLKOSEL_MASK) | 0x00000006;
+		break;
+	case AHB_CLK:
+		/* To select AHB clock */
+		reg = (reg & ~MXC_CCM_COSR_CLKOSEL_MASK) | 0x00000005;
+		break;
+	case IPG_CLK:
+		/* To select IP clock */
+		reg = (reg & ~MXC_CCM_COSR_CLKOSEL_MASK) | 0x00000001;
+		break;
+	default:
+		goto ret;
+	}
+
+	__raw_writel(reg, MXC_CCM_COSR);
+
+      ret:
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+EXPORT_SYMBOL(mxc_pll_set);
+EXPORT_SYMBOL(mxc_pll_clock);
+EXPORT_SYMBOL(mxc_get_clocks);
+EXPORT_SYMBOL(mxc_get_clocks_parent);
+EXPORT_SYMBOL(mxc_set_clocks_pll);
+EXPORT_SYMBOL(mxc_set_clocks_div);
+EXPORT_SYMBOL(mxc_clks_disable);
+EXPORT_SYMBOL(mxc_clks_enable);
+EXPORT_SYMBOL(mxc_ccm_get_reg);
+EXPORT_SYMBOL(mxc_ccm_modify_reg);
+EXPORT_SYMBOL(mxc_set_clock_output);
--- linux-2.6.19.2/arch/arm/mach-mx3/cpu.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/cpu.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,130 @@
+/*
+ *  Copyright (C) 2001 Deep Blue Solutions Ltd.
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+/*!
+ * @file cpu.c
+ *
+ * @brief This file contains the CPU initialization code.
+ *
+ * @ingroup System
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/cpufreq.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <asm/hardware.h>
+#include <asm/setup.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/cacheflush.h>
+#include <linux/proc_fs.h>
+
+const u32 system_rev_tbl[SYSTEM_REV_NUM][2] = {
+	/* SREV, own defined ver */
+	{0x00, CHIP_REV_1_0},	/* MX31 PASS 1 */
+	{0x10, CHIP_REV_1_1},	/* MX31 PASS 1.1 */
+	{0x20, CHIP_REV_2_0},	/* MX31 PASS 2 FIXME: confirm */
+};
+
+/*!
+ * CPU initialization. It is called by fixup_mxc_board()
+ */
+void __init mxc_cpu_init(void)
+{
+	/* Setup Peripheral Port Remap register for AVIC */
+	asm("ldr r0, =0xC0000015				\n\
+	 mcr p15, 0, r0, c15, c2, 4");
+}
+
+/*!
+ * Post CPU init code
+ *
+ * @return 0 always
+ */
+static int __init post_cpu_init(void)
+{
+	volatile unsigned long aips_reg;
+
+	/*
+	 * S/W workaround: Clear the off platform peripheral modules
+	 * Supervisor Protect bit for SDMA to access them.
+	 */
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS1_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS1_BASE_ADDR + 0x50));
+
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x40));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x44));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x48));
+	__raw_writel(0x0, IO_ADDRESS(AIPS2_BASE_ADDR + 0x4C));
+	aips_reg = __raw_readl(IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+	aips_reg &= 0x00FFFFFF;
+	__raw_writel(aips_reg, IO_ADDRESS(AIPS2_BASE_ADDR + 0x50));
+
+	return 0;
+}
+
+postcore_initcall(post_cpu_init);
+
+static int mxc_clock_read_proc(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	char *p = page;
+	int len;
+
+	p += sprintf(p, "MCUPLL:\t\t%lu\n", mxc_pll_clock(MCUPLL));
+	p += sprintf(p, "USBPLL:\t\t%lu\n", mxc_pll_clock(USBPLL));
+	p += sprintf(p, "SERIALPLL:\t%lu\n", mxc_pll_clock(SERIALPLL));
+	p += sprintf(p, "CPU_CLK:\t%lu\n", mxc_get_clocks(CPU_CLK));
+	p += sprintf(p, "AHB_CLK:\t%lu\n", mxc_get_clocks(AHB_CLK));
+	p += sprintf(p, "IPG_CLK:\t%lu\n", mxc_get_clocks(IPG_CLK));
+	p += sprintf(p, "NFC_CLK:\t%lu\n", mxc_get_clocks(NFC_CLK));
+	p += sprintf(p, "USB_CLK:\t%lu\n", mxc_get_clocks(USB_CLK));
+	p += sprintf(p, "UART1_BAUD:\t%lu\n", mxc_get_clocks(UART1_BAUD));
+	p += sprintf(p, "UART2_BAUD:\t%lu\n", mxc_get_clocks(UART2_BAUD));
+	p += sprintf(p, "UART3_BAUD:\t%lu\n", mxc_get_clocks(UART3_BAUD));
+	p += sprintf(p, "I2C_CLK:\t%lu\n", mxc_get_clocks(I2C_CLK));
+	p += sprintf(p, "IPU_CLK:\t%lu\n", mxc_get_clocks(IPU_CLK));
+	p += sprintf(p, "SDMA_CLK:\t%lu\n", mxc_get_clocks(SDMA_CLK));
+	p += sprintf(p, "SDHC1_CLK:\t%lu\n", mxc_get_clocks(SDHC1_CLK));
+	p += sprintf(p, "SDHC2_CLK:\t%lu\n", mxc_get_clocks(SDHC2_CLK));
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int __init mxc_setup_proc_entry(void)
+{
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *res;
+
+	res = create_proc_read_entry("cpu/clocks", 0, NULL,
+				     mxc_clock_read_proc, NULL);
+	if (!res) {
+		printk(KERN_ERR "Failed to create proc/cpu/clocks\n");
+		return -ENOMEM;
+	}
+#endif
+	return 0;
+}
+
+late_initcall(mxc_setup_proc_entry);
--- linux-2.6.19.2/arch/arm/mach-mx3/crm_regs.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/crm_regs.h	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,273 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __ARCH_ARM_MACH_MX3_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX3_CRM_REGS_H__
+
+#define CKIH_CLK_FREQ           26000000
+#define CKIH_CLK_FREQ_27MHZ     27000000
+#define CKIL_CLK_FREQ           32768
+#define CKIH_27MHZ_BIT_SET      (1 << 4)
+
+#define MXC_CCM_BASE		IO_ADDRESS(CCM_BASE_ADDR)
+
+/* Register addresses */
+#define MXC_CCM_CCMR		(MXC_CCM_BASE + 0x00)
+#define MXC_CCM_PDR0		(MXC_CCM_BASE + 0x04)
+#define MXC_CCM_PDR1		(MXC_CCM_BASE + 0x08)
+#define MXC_CCM_RCSR		(MXC_CCM_BASE + 0x0C)
+#define MXC_CCM_MPCTL		(MXC_CCM_BASE + 0x10)
+#define MXC_CCM_UPCTL		(MXC_CCM_BASE + 0x14)
+#define MXC_CCM_SRPCTL		(MXC_CCM_BASE + 0x18)
+#define MXC_CCM_COSR		(MXC_CCM_BASE + 0x1C)
+#define MXC_CCM_CGR0		(MXC_CCM_BASE + 0x20)
+#define MXC_CCM_CGR1		(MXC_CCM_BASE + 0x24)
+#define MXC_CCM_CGR2		(MXC_CCM_BASE + 0x28)
+#define MXC_CCM_WIMR		(MXC_CCM_BASE + 0x2C)
+#define MXC_CCM_LDC		(MXC_CCM_BASE + 0x30)
+#define MXC_CCM_DCVR0		(MXC_CCM_BASE + 0x34)
+#define MXC_CCM_DCVR1		(MXC_CCM_BASE + 0x38)
+#define MXC_CCM_DCVR2		(MXC_CCM_BASE + 0x3C)
+#define MXC_CCM_DCVR3		(MXC_CCM_BASE + 0x40)
+#define MXC_CCM_LTR0		(MXC_CCM_BASE + 0x44)
+#define MXC_CCM_LTR1		(MXC_CCM_BASE + 0x48)
+#define MXC_CCM_LTR2		(MXC_CCM_BASE + 0x4C)
+#define MXC_CCM_LTR3		(MXC_CCM_BASE + 0x50)
+#define MXC_CCM_LTBR0		(MXC_CCM_BASE + 0x54)
+#define MXC_CCM_LTBR1		(MXC_CCM_BASE + 0x58)
+#define MXC_CCM_PMCR0		(MXC_CCM_BASE + 0x5C)
+#define MXC_CCM_PMCR1		(MXC_CCM_BASE + 0x60)
+#define MXC_CCM_PDR2		(MXC_CCM_BASE + 0x64)
+
+/* Register bit definitions */
+#define MXC_CCM_CCMR_WBEN                       (1 << 27)
+#define MXC_CCM_CCMR_CSCS                       (1 << 25)
+#define MXC_CCM_CCMR_PERCS                      (1 << 24)
+#define MXC_CCM_CCMR_SSI1S_OFFSET               18
+#define MXC_CCM_CCMR_SSI1S_MASK                 (0x3 << 18)
+#define MXC_CCM_CCMR_SSI2S_OFFSET               21
+#define MXC_CCM_CCMR_SSI2S_MASK                 (0x3 << 21)
+#define MXC_CCM_CCMR_LPM_OFFSET                 14
+#define MXC_CCM_CCMR_LPM_MASK                   (0x3 << 14)
+#define MXC_CCM_CCMR_FIRS_OFFSET                11
+#define MXC_CCM_CCMR_FIRS_MASK                  (0x3 << 11)
+#define MXC_CCM_CCMR_MDS                        (1 << 7)
+#define MXC_CCM_CCMR_SBYCS                      (1 << 4)
+#define MXC_CCM_CCMR_MPE                        (1 << 3)
+#define MXC_CCM_CCMR_PRCS_OFFSET                1
+#define MXC_CCM_CCMR_PRCS_MASK                  (0x3 << 1)
+
+#define MXC_CCM_PDR0_CSI_PODF_OFFSET            26
+#define MXC_CCM_PDR0_CSI_PODF_MASK              (0x3F << 26)
+#define MXC_CCM_PDR0_CSI_PRDF_OFFSET            23
+#define MXC_CCM_PDR0_CSI_PRDF_MASK              (0x7 << 23)
+#define MXC_CCM_PDR0_PER_PODF_OFFSET            16
+#define MXC_CCM_PDR0_PER_PODF_MASK              (0x1F << 16)
+#define MXC_CCM_PDR0_HSP_PODF_OFFSET            11
+#define MXC_CCM_PDR0_HSP_PODF_MASK              (0x7 << 11)
+#define MXC_CCM_PDR0_NFC_PODF_OFFSET            8
+#define MXC_CCM_PDR0_NFC_PODF_MASK              (0x7 << 8)
+#define MXC_CCM_PDR0_IPG_PODF_OFFSET            6
+#define MXC_CCM_PDR0_IPG_PODF_MASK              (0x3 << 6)
+#define MXC_CCM_PDR0_MAX_PODF_OFFSET            3
+#define MXC_CCM_PDR0_MAX_PODF_MASK              (0x7 << 3)
+#define MXC_CCM_PDR0_MCU_PODF_OFFSET            0
+#define MXC_CCM_PDR0_MCU_PODF_MASK              0x7
+
+#define MXC_CCM_PDR1_USB_PRDF_OFFSET            30
+#define MXC_CCM_PDR1_USB_PRDF_MASK              (0x3 << 30)
+#define MXC_CCM_PDR1_USB_PODF_OFFSET            27
+#define MXC_CCM_PDR1_USB_PODF_MASK              (0x7 << 27)
+#define MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET       24
+#define MXC_CCM_PDR1_FIRI_PRE_PODF_MASK         (0x7 << 24)
+#define MXC_CCM_PDR1_FIRI_PODF_OFFSET           18
+#define MXC_CCM_PDR1_FIRI_PODF_MASK             (0x3F << 18)
+#define MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET       15
+#define MXC_CCM_PDR1_SSI2_PRE_PODF_MASK         (0x7 << 15)
+#define MXC_CCM_PDR1_SSI2_PODF_OFFSET           9
+#define MXC_CCM_PDR1_SSI2_PODF_MASK             (0x3F << 9)
+#define MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET       6
+#define MXC_CCM_PDR1_SSI1_PRE_PODF_MASK         (0x7 << 6)
+#define MXC_CCM_PDR1_SSI1_PODF_OFFSET           0
+#define MXC_CCM_PDR1_SSI1_PODF_MASK             0x3F
+
+/* Bit definitions for RCSR */
+#define MXC_CCM_RCSR_NF16B			0x80000000
+
+/* Bit definitions for both MCU, USB and SR PLL control registers */
+#define MXC_CCM_PCTL_BRM                        0x80000000
+#define MXC_CCM_PCTL_PD_OFFSET                  26
+#define MXC_CCM_PCTL_PD_MASK                    (0xF << 26)
+#define MXC_CCM_PCTL_MFD_OFFSET                 16
+#define MXC_CCM_PCTL_MFD_MASK                   (0x3FF << 16)
+#define MXC_CCM_PCTL_MFI_OFFSET                 10
+#define MXC_CCM_PCTL_MFI_MASK                   (0xF << 10)
+#define MXC_CCM_PCTL_MFN_OFFSET                 0
+#define MXC_CCM_PCTL_MFN_MASK                   0x3FF
+
+#define MXC_CCM_CGR0_SD_MMC1                    0x3
+#define MXC_CCM_CGR0_SD_MMC2                    (0x3 << 2)
+#define MXC_CCM_CGR0_GPT                        (0x3 << 4)
+#define MXC_CCM_CGR0_EPIT1                      (0x3 << 6)
+#define MXC_CCM_CGR0_EPIT2                      (0x3 << 8)
+#define MXC_CCM_CGR0_IIM                        (0x3 << 10)
+#define MXC_CCM_CGR0_ATA                        (0x3 << 12)
+#define MXC_CCM_CGR0_SDMA                       (0x3 << 14)
+#define MXC_CCM_CGR0_CSPI3                      (0x3 << 16)
+#define MXC_CCM_CGR0_RNG                         (0x3 << 18)
+#define MXC_CCM_CGR0_UART1                      (0x3 << 20)
+#define MXC_CCM_CGR0_UART2                      (0x3 << 22)
+#define MXC_CCM_CGR0_SSI1                       (0x3 << 24)
+#define MXC_CCM_CGR0_I2C1                       (0x3 << 26)
+#define MXC_CCM_CGR0_I2C2                       (0x3 << 28)
+#define MXC_CCM_CGR0_I2C3                       (0x3 << 30)
+
+#define MXC_CCM_CGR1_HANTRO                     0x3
+#define MXC_CCM_CGR1_MEMSTICK1                  (0x3 << 2)
+#define MXC_CCM_CGR1_MEMSTICK2                  (0x3 << 4)
+#define MXC_CCM_CGR1_CSI                        (0x3 << 6)
+#define MXC_CCM_CGR1_RTC                        (0x3 << 8)
+#define MXC_CCM_CGR1_WDOG                       (0x3 << 10)
+#define MXC_CCM_CGR1_PWM                        (0x3 << 12)
+#define MXC_CCM_CGR1_SIM                        (0x3 << 14)
+#define MXC_CCM_CGR1_ECT                        (0x3 << 16)
+#define MXC_CCM_CGR1_USBOTG                     (0x3 << 18)
+#define MXC_CCM_CGR1_KPP                        (0x3 << 20)
+#define MXC_CCM_CGR1_IPU                        (0x3 << 22)
+#define MXC_CCM_CGR1_UART3                      (0x3 << 24)
+#define MXC_CCM_CGR1_UART4                      (0x3 << 26)
+#define MXC_CCM_CGR1_UART5                      (0x3 << 28)
+#define MXC_CCM_CGR1_OWIRE                      (0x3 << 30)
+
+#define MXC_CCM_CGR2_SSI2                       0x3
+#define MXC_CCM_CGR2_CSPI1                      (0x3 << 2)
+#define MXC_CCM_CGR2_CSPI2                      (0x3 << 4)
+#define MXC_CCM_CGR2_GACC                       (0x3 << 6)
+#define MXC_CCM_CGR2_EMI                        (0x3 << 8)
+#define MXC_CCM_CGR2_RTIC                       (0x3 << 10)
+#define MXC_CCM_CGR2_FIRI                       (0x3 << 12)
+#define MXC_CCM_CGR2_IPMUX1                     (0x3 << 14)
+#define MXC_CCM_CGR2_IPMUX2                     (0x3 << 16)
+
+/*
+ * LTR0 register offsets
+ */
+#define MXC_CCM_LTR0_DIV3CK_OFFSET              1
+#define MXC_CCM_LTR0_DIV3CK_MASK                (0x3 << 1)
+#define MXC_CCM_LTR0_DNTHR_OFFSET               16
+#define MXC_CCM_LTR0_DNTHR_MASK                 (0x3F << 16)
+#define MXC_CCM_LTR0_UPTHR_OFFSET               22
+#define MXC_CCM_LTR0_UPTHR_MASK                 (0x3F << 22)
+
+/*
+ * LTR1 register offsets
+ */
+#define MXC_CCM_LTR1_PNCTHR_OFFSET              0
+#define MXC_CCM_LTR1_PNCTHR_MASK                0x3F
+#define MXC_CCM_LTR1_UPCNT_OFFSET               6
+#define MXC_CCM_LTR1_UPCNT_MASK                 (0xFF << 6)
+#define MXC_CCM_LTR1_DNCNT_OFFSET               14
+#define MXC_CCM_LTR1_DNCNT_MASK                 (0xFF << 14)
+#define MXC_CCM_LTR1_LTBRSR                     0x400000
+#define MXC_CCM_LTR1_LTBRSH                     0x800000
+
+/*
+ * LTR2 bit definitions. x ranges from 0 for WSW9 to 6 for WSW15
+ */
+#define MXC_CCM_LTR2_WSW_OFFSET(x)              (11 + (x) * 3)
+#define MXC_CCM_LTR2_WSW_MASK(x)                (0x7 << MXC_CCM_LTR2_WSW_OFFSET((x)))
+#define MXC_CCM_LTR2_EMAC_OFFSET                0
+#define MXC_CCM_LTR2_EMAC_MASK                  0x1FF
+
+/*
+ * LTR3 bit definitions. x ranges from 0 for WSW0 to 8 for WSW8
+ */
+#define MXC_CCM_LTR3_WSW_OFFSET(x)              (5 + (x) * 3)
+#define MXC_CCM_LTR3_WSW_MASK(x)                (0x7 << MXC_CCM_LTR3_WSW_OFFSET((x)))
+
+#define MXC_CCM_PMCR0_DFSUP1                    0x80000000
+#define MXC_CCM_PMCR0_DFSUP0                    0x40000000
+#define MXC_CCM_PMCR0_DVSUP_0                   (0x0 << 28)
+#define MXC_CCM_PMCR0_DVSUP_1                   (0x1 << 28)
+#define MXC_CCM_PMCR0_DVSUP_2                   (0x2 << 28)
+#define MXC_CCM_PMCR0_DVSUP_3                   (0x3 << 28)
+#define MXC_CCM_PMCR0_DVSUP_OFFSET              28
+#define MXC_CCM_PMCR0_DVSUP_MASK                (0x3 << 28)
+#define MXC_CCM_PMCR0_UDSC                      0x08000000
+#define MXC_CCM_PMCR0_VSCNT_1                   (0x0 << 24)
+#define MXC_CCM_PMCR0_VSCNT_2                   (0x1 << 24)
+#define MXC_CCM_PMCR0_VSCNT_3                   (0x2 << 24)
+#define MXC_CCM_PMCR0_VSCNT_4                   (0x3 << 24)
+#define MXC_CCM_PMCR0_VSCNT_5                   (0x4 << 24)
+#define MXC_CCM_PMCR0_VSCNT_6                   (0x5 << 24)
+#define MXC_CCM_PMCR0_VSCNT_7                   (0x6 << 24)
+#define MXC_CCM_PMCR0_VSCNT_8                   (0x7 << 24)
+#define MXC_CCM_PMCR0_VSCNT_OFFSET              24
+#define MXC_CCM_PMCR0_VSCNT_MASK                (0x7 << 24)
+#define MXC_CCM_PMCR0_DVFEV                     0x00800000
+#define MXC_CCM_PMCR0_DVFIS                     0x00400000
+#define MXC_CCM_PMCR0_LBMI                      0x00200000
+#define MXC_CCM_PMCR0_LBFL                      0x00100000
+#define MXC_CCM_PMCR0_LBCF_4                    (0x0 << 18)
+#define MXC_CCM_PMCR0_LBCF_8                    (0x1 << 18)
+#define MXC_CCM_PMCR0_LBCF_12                   (0x2 << 18)
+#define MXC_CCM_PMCR0_LBCF_16                   (0x3 << 18)
+#define MXC_CCM_PMCR0_LBCF_OFFSET               18
+#define MXC_CCM_PMCR0_LBCF_MASK                 (0x3 << 18)
+#define MXC_CCM_PMCR0_PTVIS                     0x00020000
+#define MXC_CCM_PMCR0_UPDTEN                    0x00010000
+#define MXC_CCM_PMCR0_FSVAIM                    0x00008000
+#define MXC_CCM_PMCR0_FSVAI_OFFSET              13
+#define MXC_CCM_PMCR0_FSVAI_MASK                (0x3 << 13)
+#define MXC_CCM_PMCR0_DPVCR                     0x00001000
+#define MXC_CCM_PMCR0_DPVV                      0x00000800
+#define MXC_CCM_PMCR0_WFIM                      0x00000400
+#define MXC_CCM_PMCR0_DRCE3                     0x00000200
+#define MXC_CCM_PMCR0_DRCE2                     0x00000100
+#define MXC_CCM_PMCR0_DRCE1                     0x00000080
+#define MXC_CCM_PMCR0_DRCE0                     0x00000040
+#define MXC_CCM_PMCR0_DCR                       0x00000020
+#define MXC_CCM_PMCR0_DVFEN                     0x00000010
+#define MXC_CCM_PMCR0_PTVAIM                    0x00000008
+#define MXC_CCM_PMCR0_PTVAI_OFFSET              1
+#define MXC_CCM_PMCR0_PTVAI_MASK                (0x3 << 1)
+#define MXC_CCM_PMCR0_DPTEN                     0x00000001
+
+#define MXC_CCM_PMCR1_DVGP_OFFSET               0
+#define MXC_CCM_PMCR1_DVGP_MASK                 (0xF)
+
+#define MXC_CCM_DCVR_ULV_MASK                   (0x3FF << 22)
+#define MXC_CCM_DCVR_ULV_OFFSET                 22
+#define MXC_CCM_DCVR_LLV_MASK                   (0x3FF << 12)
+#define MXC_CCM_DCVR_LLV_OFFSET                 12
+#define MXC_CCM_DCVR_ELV_MASK                   (0x3FF << 2)
+#define MXC_CCM_DCVR_ELV_OFFSET                 2
+
+#define MXC_CCM_PDR2_MST2_PDF_MASK              (0x3F << 7)
+#define MXC_CCM_PDR2_MST2_PDF_OFFSET            7
+#define MXC_CCM_PDR2_MST1_PDF_MASK              0x3F
+#define MXC_CCM_PDR2_MST1_PDF_OFFSET            0
+
+#define MXC_CCM_COSR_CLKOSEL_MASK               0x0F
+#define MXC_CCM_COSR_CLKOSEL_OFFSET             0
+#define MXC_CCM_COSR_CLKOUTDIV_MASK             (0x07 << 6)
+#define MXC_CCM_COSR_CLKOUTDIV_OFFSET           6
+#define MXC_CCM_COSR_CLKOEN                     (1 << 9)
+
+/*
+ * PMCR0 register offsets
+ */
+#define MXC_CCM_PMCR0_LBFL_OFFSET   20
+#define MXC_CCM_PMCR0_DFSUP0_OFFSET 30
+#define MXC_CCM_PMCR0_DFSUP1_OFFSET 31
+
+#endif				/* __ARCH_ARM_MACH_MX3_CRM_REGS_H__ */
--- linux-2.6.19.2/arch/arm/mach-mx3/devices.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/devices.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,617 @@
+/*
+ * Author: MontaVista Software, Inc.
+ *       <source@mvista.com>
+ *
+ * Based on the OMAP devices.c
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mmc.h>
+
+#include <asm/arch/spba.h>
+#include "iomux.h"
+#include <asm/arch/sdma.h>
+#include "sdma_script_code.h"
+#include "sdma_script_code_pass2.h"
+
+#if 0
+int board_device_enable(u32 device_id);
+int board_device_disable(u32 device_id);
+
+int mxc_device_enable(u32 device_id)
+{
+	int ret = 0;
+
+	switch (device_id) {
+	default:
+		ret = board_device_enable(device_id);
+	}
+
+	return ret;
+}
+
+int mxc_device_disable(u32 device_id)
+{
+	int ret = 0;
+
+	switch (device_id) {
+	default:
+		ret = board_device_disable(device_id);
+	}
+	return ret;
+}
+
+EXPORT_SYMBOL(mxc_device_enable);
+EXPORT_SYMBOL(mxc_device_disable);
+#endif
+
+void mxc_sdma_get_script_info(sdma_script_start_addrs * sdma_script_addr)
+{
+	if (system_rev == CHIP_REV_1_0) {
+		sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR;
+		sdma_script_addr->mxc_sdma_ap_2_bp_addr = -1;
+		sdma_script_addr->mxc_sdma_bp_2_ap_addr = -1;
+		sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_start_addr =
+		    (unsigned short *)sdma_code;
+		sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr =
+		    uartsh_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE;
+		sdma_script_addr->mxc_sdma_ram_code_start_addr =
+		    RAM_CODE_START_ADDR;
+		sdma_script_addr->mxc_sdma_dptc_dvfs_addr = dptc_dvfs_ADDR;
+		sdma_script_addr->mxc_sdma_firi_2_mcu_addr = firi_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_firi_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = mshc_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_per_2_app_addr = -1;
+		sdma_script_addr->mxc_sdma_per_2_firi_addr = -1;
+		sdma_script_addr->mxc_sdma_per_2_shp_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_firi_addr = mcu_2_firi_ADDR;
+		sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = mcu_2_mshc_ADDR;
+		sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR;
+		sdma_script_addr->mxc_sdma_uartsh_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_uart_2_per_addr = -1;
+		sdma_script_addr->mxc_sdma_app_2_per_addr = -1;
+	} else {
+		sdma_script_addr->mxc_sdma_app_2_mcu_addr = app_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_ap_2_ap_addr = ap_2_ap_ADDR_2;
+		sdma_script_addr->mxc_sdma_ap_2_bp_addr = ap_2_bp_ADDR_2;
+		sdma_script_addr->mxc_sdma_bp_2_ap_addr = bp_2_ap_ADDR_2;
+		sdma_script_addr->mxc_sdma_loopback_on_dsp_side_addr = -1;
+		sdma_script_addr->mxc_sdma_mcu_2_app_addr = mcu_2_app_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_shp_addr = mcu_2_shp_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_interrupt_only_addr = -1;
+		sdma_script_addr->mxc_sdma_shp_2_mcu_addr = shp_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_start_addr =
+		    (unsigned short *)sdma_code_2;
+		sdma_script_addr->mxc_sdma_uartsh_2_mcu_addr =
+		    uartsh_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_uart_2_mcu_addr = uart_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_ram_code_size = RAM_CODE_SIZE_2;
+		sdma_script_addr->mxc_sdma_ram_code_start_addr =
+		    RAM_CODE_START_ADDR_2;
+		sdma_script_addr->mxc_sdma_dptc_dvfs_addr = dptc_dvfs_ADDR_2;
+		sdma_script_addr->mxc_sdma_firi_2_mcu_addr = firi_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_firi_2_per_addr = firi_2_per_ADDR_2;
+		sdma_script_addr->mxc_sdma_mshc_2_mcu_addr = mshc_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_per_2_app_addr = per_2_app_ADDR_2;
+		sdma_script_addr->mxc_sdma_per_2_firi_addr = per_2_firi_ADDR_2;
+		sdma_script_addr->mxc_sdma_per_2_shp_addr = per_2_shp_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_ata_addr = mcu_2_ata_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_firi_addr = mcu_2_firi_ADDR_2;
+		sdma_script_addr->mxc_sdma_mcu_2_mshc_addr = mcu_2_mshc_ADDR_2;
+		sdma_script_addr->mxc_sdma_ata_2_mcu_addr = ata_2_mcu_ADDR_2;
+		sdma_script_addr->mxc_sdma_uartsh_2_per_addr =
+		    uartsh_2_per_ADDR_2;
+		sdma_script_addr->mxc_sdma_shp_2_per_addr = shp_2_per_ADDR_2;
+		sdma_script_addr->mxc_sdma_uart_2_per_addr = uart_2_per_ADDR_2;
+		sdma_script_addr->mxc_sdma_app_2_per_addr = app_2_per_ADDR_2;
+	}
+}
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
+static struct platform_device mxc_w1_devices = {
+	.name = "mxc_w1",
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.id = 0
+};
+
+static void mxc_init_owire(void)
+{
+	(void)platform_device_register(&mxc_w1_devices);
+}
+#else
+static inline void mxc_init_owire(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_RTC)
+
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+};
+static void mxc_init_rtc(void)
+{
+	(void)platform_device_register(&mxc_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+
+static struct resource wdt_resources[] = {
+	{
+	 .start = WDOG_BASE_ADDR,
+	 .end = WDOG_BASE_ADDR + 0x30,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static void mxc_init_wdt(void)
+{
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_IPU) || defined(CONFIG_MXC_IPU_MODULE)
+static struct mxc_ipu_config mxc_ipu_data = {
+	.rev = 1,
+};
+
+static struct resource ipu_resources[] = {
+	{
+	 .start = IPU_CTRL_BASE_ADDR,
+	 .end = IPU_CTRL_BASE_ADDR + SZ_4K,
+	 .flags = IORESOURCE_MEM,
+	 },
+	{
+	 .start = INT_IPU_SYN,
+	 .flags = IORESOURCE_IRQ,
+	 },
+	{
+	 .start = INT_IPU_ERR,
+	 .flags = IORESOURCE_IRQ,
+	 },
+};
+
+static struct platform_device mxc_ipu_device = {
+	.name = "mxc_ipu",
+	.id = -1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_ipu_data,
+		},
+	.num_resources = ARRAY_SIZE(ipu_resources),
+	.resource = ipu_resources,
+};
+
+static void mxc_init_ipu(void)
+{
+	platform_device_register(&mxc_ipu_device);
+}
+#else
+static inline void mxc_init_ipu(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_FIR) || defined(CONFIG_MXC_FIR_MODULE)
+/*!
+ * Resource definition for the FIR
+ */
+static struct resource mxcir_resources[] = {
+	[0] = {
+	       .start = UART2_BASE_ADDR,
+	       .end = UART2_BASE_ADDR + SZ_16K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_UART2,
+	       .end = INT_UART2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = FIRI_BASE_ADDR,
+	       .end = FIRI_BASE_ADDR + SZ_16K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[3] = {
+	       .start = INT_FIRI,
+	       .end = INT_FIRI,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[4] = {
+	       .start = INT_UART2,
+	       .end = INT_UART2,
+	       .flags = IORESOURCE_IRQ,
+	       }
+};
+
+static struct mxc_ir_platform_data ir_data;
+
+/*! Device Definition for MXC FIR */
+static struct platform_device mxcir_device = {
+	.name = "mxcir",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &ir_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcir_resources),
+	.resource = mxcir_resources,
+};
+
+static inline void mxc_init_ir(void)
+{
+	ir_data.uart_ir_mux = 1;
+	(void)platform_device_register(&mxcir_device);
+}
+#else
+static inline void mxc_init_ir(void)
+{
+}
+#endif
+
+/* MMC device data */
+
+#if defined(CONFIG_MMC_MXC) || defined(CONFIG_MMC_MXC_MODULE)
+
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_init_card_det(int id);
+
+static struct mxc_mmc_platform_data mmc_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_inserted_state = 1,
+	.status = sdhc_get_card_det_status,
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxcsdhc1_resources[] = {
+	[0] = {
+	       .start = MMC_SDHC1_BASE_ADDR,
+	       .end = MMC_SDHC1_BASE_ADDR + SZ_16K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_MMC_SDHC1,
+	       .end = INT_MMC_SDHC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO1_CARD_IRQ,
+	       .end = MXC_SDIO1_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxcsdhc2_resources[] = {
+	[0] = {
+	       .start = MMC_SDHC2_BASE_ADDR,
+	       .end = MMC_SDHC2_BASE_ADDR + SZ_16K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_MMC_SDHC2,
+	       .end = INT_MMC_SDHC2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO2_CARD_IRQ,
+	       .end = MXC_SDIO2_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC1 */
+static struct platform_device mxcsdhc1_device = {
+	.name = "mxcmci",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxcsdhc2_device = {
+	.name = "mxcmci",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+
+static inline void mxc_init_mmc(void)
+{
+	int cd_irq;
+
+	cd_irq = sdhc_init_card_det(0);
+	if (cd_irq) {
+		mxcsdhc1_device.resource[2].start = cd_irq;
+		mxcsdhc1_device.resource[2].end = cd_irq;
+	}
+	cd_irq = 0;
+	/* set cd_irq = 0 here to disable sdhc2 */
+	/* cd_irq = sdhc_init_card_det(1); */
+	if (cd_irq) {
+		mxcsdhc2_device.resource[2].start = cd_irq;
+		mxcsdhc2_device.resource[2].end = cd_irq;
+	}
+
+	spba_take_ownership(SPBA_SDHC1, SPBA_MASTER_A | SPBA_MASTER_C);
+	(void)platform_device_register(&mxcsdhc1_device);
+	spba_take_ownership(SPBA_SDHC2, SPBA_MASTER_A | SPBA_MASTER_C);
+	(void)platform_device_register(&mxcsdhc2_device);
+}
+#else
+static inline void mxc_init_mmc(void)
+{
+}
+#endif
+
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
+	[0] = {
+	       .start = CSPI1_BASE_ADDR,
+	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI1,
+	       .end = INT_CSPI1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxcspi1_data = {
+	.bus_num = 1,
+	.maxchipselect = 4,
+	.spi_version = 4,
+	.clock = CSPI1_CLK,
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+	.name = "mxc_spi",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi1_resources),
+	.resource = mxcspi1_resources,
+};
+
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
+	[0] = {
+	       .start = CSPI2_BASE_ADDR,
+	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI2,
+	       .end = INT_CSPI2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxcspi2_data = {
+	.bus_num = 2,
+	.maxchipselect = 4,
+	.spi_version = 4,
+	.clock = CSPI2_CLK,
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+	.name = "mxc_spi",
+	.id = 2,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi2_resources),
+	.resource = mxcspi2_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+/*!
+ * Resource definition for the CSPI3
+ */
+static struct resource mxcspi3_resources[] = {
+	[0] = {
+	       .start = CSPI3_BASE_ADDR,
+	       .end = CSPI3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI3,
+	       .end = INT_CSPI3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxcspi3_data = {
+	.bus_num = 3,
+	.maxchipselect = 4,
+	.spi_version = 4,
+	.clock = CSPI3_CLK,
+};
+
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxcspi3_device = {
+	.name = "mxc_spi",
+	.id = 3,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi3_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi3_resources),
+	.resource = mxcspi3_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+
+static inline void mxc_init_spi(void)
+{
+	/* SPBA configuration for CSPI2 - MCU is set */
+	spba_take_ownership(SPBA_CSPI2, SPBA_MASTER_A);
+#ifdef CONFIG_SPI_MXC_SELECT1
+	if (platform_device_register(&mxcspi1_device) < 0)
+		printk("Error: Registering the SPI Controller_1\n");
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	if (platform_device_register(&mxcspi2_device) < 0)
+		printk("Error: Registering the SPI Controller_2\n");
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+	if (platform_device_register(&mxcspi3_device) < 0)
+		printk("Error: Registering the SPI Controller_3\n");
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+}
+#else
+static inline void mxc_init_spi(void)
+{
+}
+#endif
+
+struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
+	{
+	 .num = 0,
+	 .base = IO_ADDRESS(GPIO1_BASE_ADDR),
+	 .irq = INT_GPIO1,
+	 .virtual_irq_start = MXC_GPIO_BASE,
+	 },
+	{
+	 .num = 1,
+	 .base = IO_ADDRESS(GPIO2_BASE_ADDR),
+	 .irq = INT_GPIO2,
+	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN,
+	 },
+	{
+	 .num = 2,
+	 .base = IO_ADDRESS(GPIO3_BASE_ADDR),
+	 .irq = INT_GPIO3,
+	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 2,
+	 },
+};
+
+#if defined(CONFIG_PCMCIA_MX31ADS) || defined(CONFIG_PCMCIA_MX31ADS_MODULE)
+
+static struct platform_device mx31ads_device = {
+	.name = "Mx31ads pcmcia socket",
+	.id = 0,
+	.dev.release = mxc_nop_release,
+};
+static inline void mxc_init_pcmcia(void)
+{
+	platform_device_register(&mx31ads_device);
+}
+#else
+static inline void mxc_init_pcmcia(void)
+{
+}
+#endif
+
+static int __init mxc_init_devices(void)
+{
+	mxc_init_wdt();
+	mxc_init_ipu();
+	mxc_init_mmc();
+	mxc_init_ir();
+	mxc_init_spi();
+	mxc_init_rtc();
+	mxc_init_owire();
+	mxc_init_pcmcia();
+
+	/* SPBA configuration for SSI2 - SDMA and MCU are set */
+	spba_take_ownership(SPBA_SSI2, SPBA_MASTER_C | SPBA_MASTER_A);
+	return 0;
+}
+
+arch_initcall(mxc_init_devices);
--- linux-2.6.19.2/arch/arm/mach-mx3/dma.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/dma.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,678 @@
+/*
+ *  Copyright 2004 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#include <linux/init.h>
+#include <asm/dma.h>
+#include <asm/arch/hardware.h>
+
+#include <linux/device.h>
+#include "serial.h"
+
+#define MXC_MMC_BUFFER_ACCESS     0x38
+#define MXC_SSI_TX0_REG           0x0
+#define MXC_SSI_TX1_REG           0x4
+#define MXC_SSI_RX0_REG           0x8
+#define MXC_SSI_RX1_REG           0xC
+#define MXC_FIRI_TXFIFO           0x14
+#define MXC_SDHC_MMC_WML          16
+#define MXC_SDHC_SD_WML           64
+#define MXC_SSI_TXFIFO_WML        0x4
+#define MXC_SSI_RXFIFO_WML        0x6
+#define MXC_FIRI_WML              16
+
+typedef struct mxc_sdma_info_entry_s {
+	mxc_dma_device_t device;
+	mxc_sdma_channel_params_t *chnl_info;
+} mxc_sdma_info_entry_t;
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_RXTL,
+			.per_address = UART1_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART1_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart1_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART1_UFCR_TXTL,
+			.per_address = UART1_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART1_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART1_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_RXTL,
+			.per_address = UART2_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART2_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart2_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART2_UFCR_TXTL,
+			.per_address = UART2_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART2_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART2_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_RXTL,
+			.per_address = UART3_BASE_ADDR,
+			.peripheral_type = UART_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART3_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart3_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART3_UFCR_TXTL,
+			.per_address = UART3_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART3_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART3_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_RXTL,
+			.per_address = UART4_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART4_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart4_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART4_UFCR_TXTL,
+			.per_address = UART4_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART4_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART4_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_rx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_RXTL,
+			.per_address = UART5_BASE_ADDR,
+			.peripheral_type = UART,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_UART5_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_uart5_tx_params = {
+	.chnl_params = {
+			.watermark_level = UART5_UFCR_TXTL,
+			.per_address = UART5_BASE_ADDR + MXC_UARTUTXD,
+			.peripheral_type = UART,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_UART5_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_UART5_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc1_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC1_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC1,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_MMC_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_mmc2_width4_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SDHC_SD_WML,
+			.per_address =
+			MMC_SDHC2_BASE_ADDR + MXC_MMC_BUFFER_ACCESS,
+			.peripheral_type = MMC,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SDHC2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MMC2,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI1_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi1_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI1_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI1_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI1_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx0_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX0_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX1,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_8bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_16bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_16BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_rx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_RXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_RX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_SSI2_RX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ssi2_24bit_tx1_params = {
+	.chnl_params = {
+			.watermark_level = MXC_SSI_TXFIFO_WML,
+			.per_address = SSI2_BASE_ADDR + MXC_SSI_TX1_REG,
+			.peripheral_type = SSI_SP,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_SSI2_TX2,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_SSI2_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_FIRI_WML,
+			.per_address = FIRI_BASE_ADDR,
+			.peripheral_type = FIRI,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_FIRI_RX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_FIR_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_fir_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_FIRI_WML,
+			.per_address = FIRI_BASE_ADDR + MXC_FIRI_TXFIFO,
+			.peripheral_type = FIRI,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_FIRI_TX,
+			.bd_number = 32,
+			.word_size = TRANSFER_8BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_FIR_TX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_memory_params = {
+	.chnl_params = {
+			.peripheral_type = MEMORY,
+			.transfer_type = emi_2_emi,
+			.bd_number = 32,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_MEMORY,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_rx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR,
+			.peripheral_type = ATA,
+			.transfer_type = per_2_emi,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_RX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_RX,
+};
+
+static mxc_sdma_channel_params_t mxc_sdma_ata_tx_params = {
+	.chnl_params = {
+			.watermark_level = MXC_IDE_DMA_WATERMARK,
+			.per_address = ATA_DMA_BASE_ADDR + 0x18,
+			.peripheral_type = ATA,
+			.transfer_type = emi_2_per,
+			.event_id = DMA_REQ_ATA_TX_END,
+			.event_id2 = DMA_REQ_ATA_TX,
+			.bd_number = MXC_IDE_DMA_BD_NR,
+			.word_size = TRANSFER_32BIT,
+			},
+	.channel_num = MXC_DMA_CHANNEL_ATA_TX,
+};
+static mxc_sdma_info_entry_t mxc_sdma_active_dma_info[] = {
+	{MXC_DMA_UART1_RX, &mxc_sdma_uart1_rx_params},
+	{MXC_DMA_UART1_TX, &mxc_sdma_uart1_tx_params},
+	{MXC_DMA_UART2_RX, &mxc_sdma_uart2_rx_params},
+	{MXC_DMA_UART2_TX, &mxc_sdma_uart2_tx_params},
+	{MXC_DMA_UART3_RX, &mxc_sdma_uart3_rx_params},
+	{MXC_DMA_UART3_TX, &mxc_sdma_uart3_tx_params},
+	{MXC_DMA_UART4_RX, &mxc_sdma_uart4_rx_params},
+	{MXC_DMA_UART4_TX, &mxc_sdma_uart4_tx_params},
+	{MXC_DMA_UART5_RX, &mxc_sdma_uart5_rx_params},
+	{MXC_DMA_UART5_TX, &mxc_sdma_uart5_tx_params},
+	{MXC_DMA_MMC1_WIDTH_1, &mxc_sdma_mmc1_width1_params},
+	{MXC_DMA_MMC1_WIDTH_4, &mxc_sdma_mmc1_width4_params},
+	{MXC_DMA_MMC2_WIDTH_1, &mxc_sdma_mmc2_width1_params},
+	{MXC_DMA_MMC2_WIDTH_4, &mxc_sdma_mmc2_width4_params},
+	{MXC_DMA_SSI1_8BIT_RX0, &mxc_sdma_ssi1_8bit_rx0_params},
+	{MXC_DMA_SSI1_8BIT_TX0, &mxc_sdma_ssi1_8bit_tx0_params},
+	{MXC_DMA_SSI1_16BIT_RX0, &mxc_sdma_ssi1_16bit_rx0_params},
+	{MXC_DMA_SSI1_16BIT_TX0, &mxc_sdma_ssi1_16bit_tx0_params},
+	{MXC_DMA_SSI1_24BIT_RX0, &mxc_sdma_ssi1_24bit_rx0_params},
+	{MXC_DMA_SSI1_24BIT_TX0, &mxc_sdma_ssi1_24bit_tx0_params},
+	{MXC_DMA_SSI1_8BIT_RX1, &mxc_sdma_ssi1_8bit_rx1_params},
+	{MXC_DMA_SSI1_8BIT_TX1, &mxc_sdma_ssi1_8bit_tx1_params},
+	{MXC_DMA_SSI1_16BIT_RX1, &mxc_sdma_ssi1_16bit_rx1_params},
+	{MXC_DMA_SSI1_16BIT_TX1, &mxc_sdma_ssi1_16bit_tx1_params},
+	{MXC_DMA_SSI1_24BIT_RX1, &mxc_sdma_ssi1_24bit_rx1_params},
+	{MXC_DMA_SSI1_24BIT_TX1, &mxc_sdma_ssi1_24bit_tx1_params},
+	{MXC_DMA_SSI2_8BIT_RX0, &mxc_sdma_ssi2_8bit_rx0_params},
+	{MXC_DMA_SSI2_8BIT_TX0, &mxc_sdma_ssi2_8bit_tx0_params},
+	{MXC_DMA_SSI2_16BIT_RX0, &mxc_sdma_ssi2_16bit_rx0_params},
+	{MXC_DMA_SSI2_16BIT_TX0, &mxc_sdma_ssi2_16bit_tx0_params},
+	{MXC_DMA_SSI2_24BIT_RX0, &mxc_sdma_ssi2_24bit_rx0_params},
+	{MXC_DMA_SSI2_24BIT_TX0, &mxc_sdma_ssi2_24bit_tx0_params},
+	{MXC_DMA_SSI2_8BIT_RX1, &mxc_sdma_ssi2_8bit_rx1_params},
+	{MXC_DMA_SSI2_8BIT_TX1, &mxc_sdma_ssi2_8bit_tx1_params},
+	{MXC_DMA_SSI2_16BIT_RX1, &mxc_sdma_ssi2_16bit_rx1_params},
+	{MXC_DMA_SSI2_16BIT_TX1, &mxc_sdma_ssi2_16bit_tx1_params},
+	{MXC_DMA_SSI2_24BIT_RX1, &mxc_sdma_ssi2_24bit_rx1_params},
+	{MXC_DMA_SSI2_24BIT_TX1, &mxc_sdma_ssi2_24bit_tx1_params},
+	{MXC_DMA_FIR_RX, &mxc_sdma_fir_rx_params},
+	{MXC_DMA_FIR_TX, &mxc_sdma_fir_tx_params},
+	{MXC_DMA_MEMORY, &mxc_sdma_memory_params},
+	{MXC_DMA_ATA_RX, &mxc_sdma_ata_rx_params},
+	{MXC_DMA_ATA_TX, &mxc_sdma_ata_tx_params},
+};
+
+static int mxc_sdma_info_entrys =
+    sizeof(mxc_sdma_active_dma_info) / sizeof(mxc_sdma_active_dma_info[0]);
+
+/*!
+ * This functions Returns the SDMA paramaters associated for a module
+ *
+ * @param channel_id the ID of the module requesting DMA
+ * @return returns the sdma parameters structure for the device
+ */
+mxc_sdma_channel_params_t *mxc_sdma_get_channel_params(mxc_dma_device_t
+						       channel_id)
+{
+	mxc_sdma_info_entry_t *p = mxc_sdma_active_dma_info;
+	int i;
+
+	for (i = 0; i < mxc_sdma_info_entrys; i++, p++) {
+		if (p->device == channel_id) {
+			return p->chnl_info;
+		}
+	}
+	return NULL;
+}
+
+/*!
+ * This functions marks the SDMA channels that are statically allocated
+ * 
+ * @param chnl the channel array used to store channel information
+ */
+void mxc_get_static_channels(mxc_dma_channel_t * chnl)
+{
+	/* No channels statically allocated for MX31 */
+}
+
+EXPORT_SYMBOL(mxc_sdma_get_channel_params);
+EXPORT_SYMBOL(mxc_get_static_channels);
--- linux-2.6.19.2/arch/arm/mach-mx3/dpm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/dpm.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,405 @@
+/* REVISIT Doxygen fixups */
+/*
+ * DPM support for Freescale i.MX31
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, 2004 MontaVista Software <source@mvista.com>.
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Based on code by Matthew Locke, Dmitry Chigirev, and Bishop Brock.
+ */
+
+/*!
+ * @file dpm.c
+ *
+ * @brief This file provides DPM support hooks for the Freescale i.MX31
+ *
+ * @ingroup DPM
+ */
+
+#include <linux/dpm.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/device.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+
+#include <asm/hardirq.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mxc_pm.h>
+#include <asm/arch/clock.h>
+
+static unsigned saved_cpu_freq;
+static unsigned long saved_loops_per_jiffy;
+static unsigned int curr_mode = DPM_MODE_RUN;
+
+extern void (*pm_idle) (void);
+
+static int mxc_dpm_set_opt(struct dpm_opt *cur, struct dpm_opt *new)
+{
+	struct dpm_md_opt *md_cur, *md_new;
+	unsigned long flags;
+
+	md_cur = &cur->md_opt;
+	md_new = &new->md_opt;
+
+	if (md_new->cpu == -1)
+		md_new->cpu = md_cur->cpu;
+	if (md_new->ahb == -1)
+		md_new->ahb = md_cur->ahb;
+	if (md_new->ip == -1)
+		md_new->ip = md_cur->ip;
+	if (md_new->mode == -1)
+		md_new->mode = md_cur->mode;
+
+	if (md_new->cpu == 0 || md_new->mode == DPM_MODE_SLEEP) {
+
+#ifdef CONFIG_PM
+		pm_suspend(PM_SUSPEND_MEM);
+
+		/* Here when we wake up.  Recursive call to switch back to
+		 * to task state.
+		 */
+		dpm_set_os(DPM_TASK_STATE);
+#endif
+		return 0;
+	}
+
+	if (md_new->mode == DPM_MODE_WAIT) {
+#ifdef CONFIG_PM
+		pm_suspend(PM_SUSPEND_STANDBY);
+
+		/* Here when we wake up.  Recursive call to switch back to
+		 * to task state.
+		 */
+		dpm_set_os(DPM_TASK_STATE);
+#endif
+		return 0;
+	}
+
+	if (md_new->mode == DPM_MODE_STOP) {
+#ifdef CONFIG_PM
+		pm_suspend(PM_SUSPEND_STOP);
+
+		/* Here when we wake up.  Recursive call to switch back to
+		 * to task state.
+		 */
+		dpm_set_os(DPM_TASK_STATE);
+#endif
+		return 0;
+	}
+
+	local_irq_save(flags);
+
+	if (md_new->cpu) {
+		loops_per_jiffy =
+		    dpm_compute_lpj(saved_loops_per_jiffy, saved_cpu_freq,
+				    md_new->cpu / 1000);
+	}
+#ifdef CONFIG_PM
+	mxc_pm_dvfs(md_new->cpu, md_new->ahb, md_new->ip);
+	curr_mode = md_new->mode;
+#endif
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int mxc_dpm_init_opt(struct dpm_opt *opt)
+{
+	int core = opt->pp[DPM_CORE_FREQ];
+	int ahb = opt->pp[DPM_AHB_FREQ];
+	int ip = opt->pp[DPM_IP_FREQ];
+	int mode = opt->pp[DPM_MODE];
+	struct dpm_md_opt *md_opt = &opt->md_opt;
+
+	if (mode != DPM_MODE_SLEEP &&
+	    mode != DPM_MODE_RUN &&
+	    mode != DPM_MODE_WAIT && mode != DPM_MODE_STOP && mode != -1) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "MCU mode is out of range. "
+		       "Possible settings: 0 - sleep,  1 - run, 2 - wait, 3 - stop\n");
+		return -EINVAL;
+	}
+
+	if (mode == DPM_MODE_SLEEP || core == 0) {
+		md_opt->cpu = 0;
+		md_opt->ahb = 0;
+		md_opt->ip = 0;
+		md_opt->mode = mode;
+		return 0;
+	}
+
+	if (ahb != -1 && (ahb > AHB_MAX || ahb < AHB_MIN)) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "AHB frequency setting %u is out of range for opt "
+		       "named %s. Possible settings: %d .. %d.\n",
+		       ahb, opt->name, AHB_MIN, AHB_MAX);
+		return -EINVAL;
+	}
+
+	if (ahb != -1 && ahb % AHB_MIN != 0) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "AHB frequency setting %u is out of range for opt "
+		       "named %s. AHB frequency should be multiple of %d.\n",
+		       ahb, opt->name, AHB_MIN);
+		return -EINVAL;
+	}
+
+	if (ip != -1 && (ip > IPG_MAX || ip < IPG_MIN)) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "IPG frequency setting %u is out of range for opt "
+		       "named %s. Possible settings: %d .. %d.\n",
+		       ip, opt->name, IPG_MIN, IPG_MAX);
+		return -EINVAL;
+	}
+
+	if (ip != -1 && ip % IPG_MIN != 0) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "IP frequency setting %u is out of range for opt "
+		       "named %s. IP frequency should be multiple of %d.\n",
+		       ip, opt->name, IPG_MIN);
+		return -EINVAL;
+	}
+
+	if (core != -1 && (core > ARM_MAX || core < ARM_MIN) && core != 0) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "ARM frequency setting %u is out of range for opt "
+		       "named %s. Possible settings: %d .. %d.\n",
+		       core, opt->name, ARM_MIN, ARM_MAX);
+		return -EINVAL;
+	}
+
+	if (core != -1 && core % ARM_MIN != 0) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "ARM frequency setting %u is out of range for opt "
+		       "named %s. ARM frequency should be multiple of %d.\n",
+		       core, opt->name, ARM_MIN);
+		return -EINVAL;
+	}
+
+	md_opt->cpu = core;
+	md_opt->ahb = ahb;
+	md_opt->ip = ip;
+	md_opt->mode = mode;
+	return 0;
+}
+
+/*!
+ * Fully determine the current machine-dependent operating point, and fill in a
+ * structure presented by the caller. This should only be called when the
+ * dpm_sem is held. This call can return an error if the system is currently at
+ * an operating point that could not be constructed by dpm_md_init_opt().
+ */
+static int mxc_dpm_get_opt(struct dpm_opt *opt)
+{
+	struct dpm_md_opt *md_opt;
+
+	md_opt = &opt->md_opt;
+
+	md_opt->cpu = mxc_get_clocks(CPU_CLK);
+	md_opt->ahb = mxc_get_clocks(AHB_CLK);
+	md_opt->ip = mxc_get_clocks(IPG_CLK);
+	md_opt->mode = curr_mode;
+
+	return 0;
+}
+
+/****************************************************************************
+ * Machine-dependent /proc/driver/dpm/md entries
+ ****************************************************************************/
+
+static inline int p5d(char *buf, unsigned mhz)
+{
+	return sprintf(buf, "%5d", mhz);	/* Round */
+}
+
+int dpm_proc_print_opt(char *buf, struct dpm_opt *opt)
+{
+	int len = 0;
+	struct dpm_md_opt *md_opt;
+
+	md_opt = &opt->md_opt;
+
+	len += sprintf(buf + len, "%12s %9lu", opt->name, opt->stats.count);
+	len += sprintf(buf + len, "\t%d\t%d\t%d\n",
+		       md_opt->cpu, md_opt->ahb, md_opt->ip);
+	/* Add MODE string later */
+	return len;
+}
+
+int
+read_proc_dpm_md_opts(char *page, char **start, off_t offset,
+		      int count, int *eof, void *data)
+{
+	int len = 0;
+	int limit = offset + count;
+	struct dpm_opt *opt;
+	struct list_head *opt_list;
+
+	/* FIXME: For now we assume that the complete table,
+	 * formatted, fits within one page */
+	if (offset >= PAGE_SIZE)
+		return 0;
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	if (!dpm_initialized)
+		len += sprintf(page + len, "DPM is not initialized\n");
+	else if (!dpm_enabled)
+		len += sprintf(page + len, "DPM is disabled\n");
+	else {
+		len += sprintf(page + len,
+			       "The active DPM policy is \"%s\"\n",
+			       dpm_active_policy->name);
+		len += sprintf(page + len,
+			       "The current operating point is \"%s\"\n",
+			       dpm_active_opt->name);
+	}
+
+	if (dpm_initialized) {
+		len += sprintf(page + len,
+			       "Table of all defined operating points, "
+			       "frequencies in MHz:\n");
+
+		len += sprintf(page + len,
+			       " Name           Count  DPLL  CPU  TC  PER  DSP  DSPMMU   LCD\n");
+
+		list_for_each(opt_list, &dpm_opts) {
+			opt = list_entry(opt_list, struct dpm_opt, list);
+			if (len >= PAGE_SIZE)
+				BUG();
+			if (len >= limit)
+				break;
+			len += dpm_proc_print_opt(page + len, opt);
+		}
+	}
+	dpm_unlock();
+	*eof = 1;
+	if (offset >= len)
+		return 0;
+	*start = page + offset;
+	return min(count, len - (int)offset);
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ *
+ * /proc/driver/dpm/md/cmd (Write-only)
+ *
+ *  This is a catch-all, simple command processor for the MX31 DPM
+ *  implementation. These commands are for experimentation and development
+ *  _only_, and may leave the system in an unstable state.
+ *
+ *  No commands defined now.
+ *
+ ****************************************************************************/
+
+int
+write_proc_dpm_md_cmd(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	char *buf, *tok, *s;
+	static const char *whitespace = " \t\r\n";
+	int ret = 0;
+
+	if (current->uid != 0)
+		return -EACCES;
+	if (count == 0)
+		return 0;
+	if (!(buf = kmalloc(count + 1, GFP_KERNEL)))
+		return -ENOMEM;
+	if (copy_from_user(buf, buffer, count)) {
+		kfree(buf);
+		return -EFAULT;
+	}
+	buf[count] = '\0';
+	s = buf + strspn(buf, whitespace);
+	tok = strsep(&s, whitespace);
+
+	if (strcmp(tok, "define-me") == 0) {
+		;
+	} else {
+		ret = -EINVAL;
+	}
+	kfree(buf);
+	if (ret == 0)
+		return count;
+	else
+		return ret;
+}
+
+/****************************************************************************
+ *  DPM Idle Handler
+ ****************************************************************************/
+
+static void (*orig_idle) (void);
+
+static void mxc_dpm_idle(void)
+{
+	extern void default_idle(void);
+
+	if (orig_idle)
+		orig_idle();
+	else
+		default_idle();
+}
+
+/****************************************************************************
+ * Initialization/Exit
+ ****************************************************************************/
+
+static void mxc_dpm_startup(void)
+{
+	if (!saved_loops_per_jiffy) {
+		saved_loops_per_jiffy = loops_per_jiffy;
+		saved_cpu_freq = mxc_get_clocks(CPU_CLK) / 1000;
+	}
+	orig_idle = pm_idle;
+	pm_idle = dpm_idle;
+}
+
+static void mxc_dpm_cleanup(void)
+{
+	pm_idle = orig_idle;
+}
+
+static int __init mxc_dpm_init(void)
+{
+	printk("Freescale i.MX31 Dynamic Power Management.\n");
+
+	dpm_md.init_opt = mxc_dpm_init_opt;
+	dpm_md.set_opt = mxc_dpm_set_opt;
+	dpm_md.get_opt = mxc_dpm_get_opt;
+	dpm_md.check_constraint = dpm_default_check_constraint;
+	dpm_md.idle = mxc_dpm_idle;
+	dpm_md.startup = mxc_dpm_startup;
+	dpm_md.cleanup = mxc_dpm_cleanup;
+
+	return 0;
+}
+
+__initcall(mxc_dpm_init);
--- linux-2.6.19.2/arch/arm/mach-mx3/dvfs.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/dvfs.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,902 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file dvfs.c
+ *
+ * @brief Driver for the Freescale Semiconductor MXC DVFS module.
+ *
+ * The DVFS driver
+ * driver is designed as a character driver which interacts with the MXC DVFS
+ * hardware. Upon initialization, the DVFS driver initializes the DVFS hardware
+ * sets up driver nodes attaches to the DVFS interrupt and initializes internal
+ * data structures. When the DVFS interrupt occurs the driver checks the cause
+ * of the interrupt (lower frequency, increase frequency or emergency) and changes
+ * the CPU voltage according to translation table that is loaded into the driver.
+ * The driver read method is used to read the log buffer.
+ * Driver ioctls are used to change driver parameters and enable/disable the
+ * DVFS operation.
+ *
+ * @ingroup PM
+ */
+
+/* Define to enable debug messages */
+#undef DEBUG
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <asm/uaccess.h>
+#include <linux/workqueue.h>
+#include <linux/proc_fs.h>
+#include <asm/semaphore.h>
+#include <linux/jiffies.h>
+#include <linux/device.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/sdma.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/arch/dvfs.h>
+
+#include "iomux.h"
+#include "crm_regs.h"
+
+/*!
+ * Read the LBFL bits from the CCM
+ */
+#define GET_LBFL(pmcr0)	\
+(pmcr0 & MXC_CCM_PMCR0_LBFL) >> MXC_CCM_PMCR0_LBFL_OFFSET
+
+/*!
+ * Read the LBCF bits from the CCM
+ */
+#define GET_LBCF(pmcr0)	\
+(pmcr0 & MXC_CCM_PMCR0_LBCF_MASK) >> MXC_CCM_PMCR0_LBCF_OFFSET
+
+/*!
+ * Set DVSUP bits
+ */
+#define SET_DVSUP(pmcr0, x) \
+pmcr0 = ((pmcr0 & ~MXC_CCM_PMCR0_DVSUP_MASK) | x << MXC_CCM_PMCR0_DVSUP_OFFSET)
+
+/*!
+ * Set DFSUP0 bits
+ */
+#define SET_DFSUP0(pmcr0, x) \
+pmcr0 = ((pmcr0 & ~MXC_CCM_PMCR0_DFSUP0) | x << MXC_CCM_PMCR0_DFSUP0_OFFSET)
+
+/*!
+ * Set DFSUP1 bits
+ */
+#define SET_DFSUP1(pmcr0, x) \
+pmcr0 = ((pmcr0 & ~MXC_CCM_PMCR0_DFSUP1) | x << MXC_CCM_PMCR0_DFSUP1_OFFSET)
+
+/*
+ * Set UDSC bit
+ */
+#define SET_UDSC(pmcr0) pmcr0 |= MXC_CCM_PMCR0_UDSC
+
+/*
+ * Clear UDSC bit
+ */
+#define CLEAR_UDSC(pmcr0) pmcr0 &= ~MXC_CCM_PMCR0_UDSC
+
+#define SET_VSCNT(pmcr0, x) \
+pmcr0 = ((pmcr0 & ~MXC_CCM_PMCR0_VSCNT_MASK) | x << MXC_CCM_PMCR0_VSCNT_OFFSET)
+
+dvfs_states_table *dvfs_states_tbl;
+
+/*!
+ * The dvfs_dptc_params structure holds all the internal DPTC driver parameters
+ * (current working point, current frequency, translation table and DPTC
+ * log buffer).
+ */
+static dvfs_dptc_params_s *dvfs_dptc_params;
+
+/*!
+ * Set the div_3_clk clock to maximum.
+ * With the ARM clocked at 532, this setting yields
+ * a DIV_3_CLK of 2.03 kHz.
+ *
+ * @param val   div3ck value
+ */
+static void dvfs_set_div3ck(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR0, MXC_CCM_LTR0_DIV3CK_MASK,
+			   val << MXC_CCM_LTR0_DIV3CK_OFFSET);
+}
+
+/*!
+ * Sets frequency decrease threshold. Decrease frequency change request
+ * will be sent if DVFS counter value will be less than this value.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_dnthr(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR0, MXC_CCM_LTR0_DNTHR_MASK,
+			   val << MXC_CCM_LTR0_DNTHR_OFFSET);
+}
+
+/*!
+ * Set frequency increase threshold. Increase frequency change request
+ * will be sent if DVFS counter value will be more than this value.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_upthr(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR0, MXC_CCM_LTR0_UPTHR_MASK,
+			   val << MXC_CCM_LTR0_UPTHR_OFFSET);
+}
+
+/*!
+ * Set panic threshold. Panic frequency change request
+ * will be sent if DVFS counter value will be more than this value.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_pncthr(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1, MXC_CCM_LTR1_PNCTHR_MASK,
+			   val << MXC_CCM_LTR1_PNCTHR_OFFSET);
+}
+
+/*!
+ * Set UPCNT value.
+ * UPCNT defines the amount of times the up threshold should be exceeded
+ * before DVFS will trigger frequency increase request.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_upcnt(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1, MXC_CCM_LTR1_UPCNT_MASK,
+			   val << MXC_CCM_LTR1_UPCNT_OFFSET);
+}
+
+/*!
+ * Set DNCNT value.
+ * DNCNT defines the amount of times the up threshold should be exceeded
+ * before DVFS will trigger frequency decrease request.
+ *
+ * @param val   threshold value
+ */
+static void dvfs_set_dncnt(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1, MXC_CCM_LTR1_DNCNT_MASK,
+			   val << MXC_CCM_LTR1_DNCNT_OFFSET);
+}
+
+/*!
+ * Set load tracking buffer source to ld_add
+ */
+static void dvfs_set_ltbrsr(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1, MXC_CCM_LTR1_LTBRSR,
+			   MXC_CCM_LTR1_LTBRSR);
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*!
+ * Take the original MSB of ld_add - ld_add[5:2] for load tracking register
+ */
+static void dvfs_clear_ltbrsh(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR1, MXC_CCM_LTR1_LTBRSH, 0);
+}
+#endif
+
+/*!
+ * Set EMAC value.
+ * EMAC defines how many samples are included in EMA calculation
+ *
+ * @param val   EMAC value
+ */
+static void dvfs_set_emac(unsigned long val)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR2, MXC_CCM_LTR2_EMAC_MASK,
+			   val << MXC_CCM_LTR2_EMAC_OFFSET);
+}
+
+/*!
+ * Set general purpose weights of LTR2 register
+ *
+ * @param x   general purpose bit number
+ * @param w   weight value
+ */
+static void dvfs_set_ltr2_wsw(unsigned long x, unsigned long w)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR2, MXC_CCM_LTR2_WSW_MASK(x),
+			   w << MXC_CCM_LTR2_WSW_OFFSET(x));
+}
+
+/*!
+ * Set general purpose weights of LTR3 register
+ *
+ * @param x   general purpose bit number
+ * @param w   weight value
+ */
+static void dvfs_set_ltr3_wsw(unsigned long x, unsigned long w)
+{
+	mxc_ccm_modify_reg(MXC_CCM_LTR3, MXC_CCM_LTR3_WSW_MASK(x),
+			   w << MXC_CCM_LTR3_WSW_OFFSET(x));
+}
+
+/*!
+ * Unmask DVFS interrupt
+ */
+static void dvfs_unmask_dvfs_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_FSVAIM, 0);
+}
+
+/*!
+ * Mask DVFS interrupt
+ */
+static void dvfs_mask_dvfs_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_FSVAIM,
+			   MXC_CCM_PMCR0_FSVAIM);
+}
+
+/*!
+ * Mask DVFS log buffer interrupt
+ */
+static void dvfs_mask_dvfs_lb_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_LBMI,
+			   MXC_CCM_PMCR0_LBMI);
+}
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+/*!
+ * Unmask DVFS log buffer interrupt
+ */
+static void dvfs_unmask_dvfs_lb_int(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_LBMI, 0);
+}
+#endif
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * Sets DVFIS bit. MCU will get DVFS interrupt
+ */
+static void dvfs_set_dvfis(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DVFIS,
+			   MXC_CCM_PMCR0_DVFIS);
+}
+#endif
+
+/*!
+ * Enable DVFS hardware
+ */
+static void dvfs_enable_dvfs(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DVFEN,
+			   MXC_CCM_PMCR0_DVFEN);
+}
+
+/*!
+ * Disable DVFS hardware
+ */
+static void dvfs_disable_dvfs(void)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_DVFEN, 0);
+}
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * Read the FSVAI bits from the CCM.
+ *
+ * @return  FSVAI bits value
+ */
+static unsigned long dvfs_get_fsvai(void)
+{
+	return ((mxc_ccm_get_reg(MXC_CCM_PMCR0) & MXC_CCM_PMCR0_FSVAI_MASK)
+		>> MXC_CCM_PMCR0_FSVAI_OFFSET);
+}
+#endif
+
+/*!
+ * Read the DFSUP0 bit from the CCM
+ *
+ * @return  DFSUP0 bit value
+ */
+static unsigned long dvfs_get_dfsup0(void)
+{
+	return ((mxc_ccm_get_reg(MXC_CCM_PMCR0) & MXC_CCM_PMCR0_DFSUP0)
+		>> MXC_CCM_PMCR0_DFSUP0_OFFSET);
+}
+
+/*!
+ * Read the DFSUP1 bits from the CCM
+ *
+ * @return  DFSUP1 bit value
+ */
+static unsigned long dvfs_get_dfsup1(void)
+{
+	return ((mxc_ccm_get_reg(MXC_CCM_PMCR0) & MXC_CCM_PMCR0_DFSUP1)
+		>> MXC_CCM_PMCR0_DFSUP1_OFFSET);
+}
+
+/*!
+ * Read the DVSUP bits from the CCM
+ *
+ * @return  DVFSUP bits value
+ */
+unsigned long dvfs_get_dvsup(void)
+{
+	return ((mxc_ccm_get_reg(MXC_CCM_PMCR0) & MXC_CCM_PMCR0_DVSUP_MASK)
+		>> MXC_CCM_PMCR0_DVSUP_OFFSET);
+}
+
+/*!
+ * Set SW general purpose SW bits.
+ *
+ * @param x    status bits. Each of 4 LSB's corresponds to
+ *             1 SW general purpose bit status (on/off).
+ */
+void dvfs_set_dvgp(unsigned long x)
+{
+	mxc_ccm_modify_reg(MXC_CCM_PMCR1, MXC_CCM_PMCR1_DVGP_MASK, x & 0xf);
+}
+
+/*!
+ * This function sets the weight of general purpose signals
+ * @param   gp_id   number of general purpose bit
+ * @param   weight  the weight of the general purpose bit
+ */
+static void set_gp_weight(int gp_id, unsigned char weight)
+{
+	if (gp_id < 9) {
+		dvfs_set_ltr3_wsw(gp_id, weight & 0x7);
+	} else if (gp_id < 16) {
+		dvfs_set_ltr2_wsw(gp_id, weight & 0x7);
+	}
+}
+
+/*!
+ * This function returns the ARM clock value in Hz.
+ *
+ * @param       reg     pll value
+ * @param       pdr0     post-divider 0 value
+ *
+ * @return      clock value in Hz
+ */
+unsigned long dvfs_get_clock(unsigned long reg, unsigned long pdr0)
+{
+	unsigned long pll, ret_val = 0;
+	signed long mcu_pdf;
+	signed long pdf, mfd, mfi, mfn, ref_clk;
+
+	volatile unsigned long ccmr;
+	unsigned int prcs;
+
+	ccmr = mxc_ccm_get_reg(MXC_CCM_CCMR);
+	prcs = (ccmr & MXC_CCM_CCMR_PRCS_MASK) >> MXC_CCM_CCMR_PRCS_OFFSET;
+	if (prcs == 0x1) {
+		ref_clk = mxc_get_clocks(CKIL_CLK) * 1024;
+	} else {
+		ref_clk = mxc_get_clocks(CKIH_CLK);
+	}
+
+	pdf = (signed long)
+	    ((reg & MXC_CCM_PCTL_PD_MASK) >> MXC_CCM_PCTL_PD_OFFSET);
+	mfd = (signed long)
+	    ((reg & MXC_CCM_PCTL_MFD_MASK) >> MXC_CCM_PCTL_MFD_OFFSET);
+
+	mfi = (signed long)((reg & MXC_CCM_PCTL_MFI_MASK) >>
+			    MXC_CCM_PCTL_MFI_OFFSET);
+	mfi = (mfi <= 5) ? 5 : mfi;
+	mfn = (signed long)(reg & MXC_CCM_PCTL_MFN_MASK);
+	mfn = (mfn < 0x200) ? mfn : (mfn - 0x400);
+
+	pll = (2 * ref_clk * mfi + ((2 * ref_clk / (mfd + 1)) * mfn)) /
+	    (pdf + 1);
+
+	mcu_pdf = pdr0 & MXC_CCM_PDR0_MCU_PODF_MASK;
+	ret_val = pll / (mcu_pdf + 1);
+
+	return ret_val;
+}
+
+/*!
+ * This function is called for module initialization.
+ * It initializes the driver data structures and sets up the DVFS hardware.
+ * It sets default values for DVFS thresholds and counters. The default
+ * values was chosen from a set of different reasonable values. They was tested
+ * and the default values in the driver gave the best results.
+ * More work should be done to find optimal values.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return   0 to indicate success else returns a negative number.
+ *
+ */
+int __init init_dvfs_controller(dvfs_dptc_params_s * params)
+{
+	int i;
+	int res = 0;
+
+	/* Configure 2 MC13783 DVFS pins */
+	mxc_request_iomux(MX31_PIN_DVFS0, OUTPUTCONFIG_FUNC, INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_DVFS1, OUTPUTCONFIG_FUNC, INPUTCONFIG_NONE);
+
+	/* Configure MC13783 voltage ready input pin */
+	mxc_request_iomux(MX31_PIN_GPIO1_5, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_FUNC);
+
+	/* Mask DVFS interrupts */
+	dvfs_mask_dvfs_int();
+	dvfs_mask_dvfs_lb_int();
+
+	params->dvfs_log_buffer = (char *)
+	    dma_alloc_coherent(NULL, DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8,
+			       &params->dvfs_log_buffer_phys, GFP_KERNEL);
+
+	if (params->dvfs_log_buffer <= 0) {
+		printk(KERN_ERR "DVFS failed allocating log buffer\n");
+		res = -ENOMEM;
+	} else {
+		memset(params->dvfs_log_buffer, 0,
+		       DVFS_LB_SIZE * DVFS_LB_SAMPLE_SIZE / 8);
+	}
+
+	/* Set general purpose weights to 0 */
+	for (i = 0; i < 16; i++) {
+		set_gp_weight(i, 0);
+	}
+
+	/*
+	 * Set the div_3_clk clock to maximum.
+	 * With the ARM clocked at 532, this setting yields
+	 * a DIV_3_CLK of 2.03 kHz.
+	 */
+	dvfs_set_div3ck(3);
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+	/*
+	 * ARM will get DVFS interrupt
+	 */
+	dvfs_set_dvfis();
+#endif
+
+	/*
+	 * UPCNT defines the amount of times the up threshold should be exceeded
+	 * before DVFS will trigger frequency increase request.
+	 */
+	dvfs_set_upcnt(0x33);
+
+	/*
+	 * DNCNT defines the amount of times the up threshold should be exceeded
+	 * before DVFS will trigger frequency decrease request.
+	 */
+	dvfs_set_dncnt(0x33);
+
+	/* EMAC defines how many samples are included in EMA calculation */
+	dvfs_set_emac(0x20);
+
+	/* Initialize frequencies tables for DPM usage */
+	dvfs_states_tbl = kmalloc(sizeof(dvfs_states_table), GFP_KERNEL);
+	memset(dvfs_states_tbl, 0, sizeof(dvfs_states_table));
+
+	params->dvfs_mode = DVFS_HW_MODE;
+
+	dvfs_dptc_params = params;
+
+	if (res == 0) {
+		printk(KERN_INFO "DVFS controller initialized\n");
+	}
+
+	return res;
+}
+
+/*!
+ * Update tables of frequencies for DPM usage
+ *
+ * @param    dvfs_dptc_tables_ptr    pointer to the DVFS &
+ *                                   DPTC translation table.
+ */
+void dvfs_update_freqs_table(dvfs_dptc_tables_s * dvfs_dptc_tables_ptr)
+{
+	int freq;
+	dvfs_state *table;
+	unsigned long pll, pdr0;
+	int i;
+
+	if (dvfs_states_tbl->freqs != 0) {
+		kfree(dvfs_states_tbl->freqs);
+	}
+
+	dvfs_states_tbl->freqs = kmalloc(sizeof(unsigned int) *
+					 dvfs_dptc_tables_ptr->dvfs_state_num,
+					 GFP_KERNEL);
+
+	dvfs_states_tbl->num_of_states = dvfs_dptc_tables_ptr->dvfs_state_num;
+
+	table = dvfs_dptc_tables_ptr->table;
+
+	/* State 0 */
+	pll = table[0].pll_up;
+	pdr0 = table[0].pdr0_up;
+	freq = dvfs_get_clock(table[0].pll_up, table[0].pdr0_up);
+	dvfs_states_tbl->freqs[0] = 1000000 * (freq / 1000000);
+
+	for (i = 0; i < dvfs_dptc_tables_ptr->dvfs_state_num - 1; i++) {
+		if (table[i].pll_sw_down == 1) {
+			pll = table[i].pll_down;
+		}
+		pdr0 = table[i].pdr0_down;
+
+		freq = dvfs_get_clock(pll, pdr0);
+		dvfs_states_tbl->freqs[i + 1] = 1000000 * (freq / 1000000);
+	}
+
+	for (i = 0; i < dvfs_dptc_tables_ptr->dvfs_state_num; i++) {
+		printk(KERN_INFO "DVFS frequency #%d: %d\n", i,
+		       dvfs_states_tbl->freqs[i]);
+	}
+}
+
+/*!
+ * This function enables the DVFS module. this function updates the DVFS
+ * thresholds, updates the MC13783, unmasks the DVFS interrupt and enables
+ * the DVFS module
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DVFS module was enabled else returns -EINVAL.
+ *
+ */
+int start_dvfs(dvfs_dptc_params_s * params)
+{
+	int i;
+	int dnthr, upthr, pncthr;
+
+	/* Check if DVFS module isn't already active */
+	if (params->dvfs_is_active == FALSE) {
+
+		for (i = 12; i <= 15; i++) {
+			set_gp_weight(i, 7);
+		}
+
+		if (params->dvfs_mode == DVFS_HW_MODE) {
+			dnthr = DVFS_DNTHR;
+			upthr = DVFS_UPTHR;
+			pncthr = DVFS_PNCTHR;
+		} else {
+			dnthr = 0;
+			upthr = 63;
+			pncthr = 63;
+		}
+
+		/*
+		 * Frequency decrease threshold. Decrease frequency change request
+		 * will be sent if DVFS counter value will be less than this value.
+		 */
+		dvfs_set_dnthr(dnthr);
+		/*
+		 * Frequency increase threshold. Increase frequency change request
+		 * will be sent if DVFS counter value will be more than this value.
+		 */
+		dvfs_set_upthr(upthr);
+		/*
+		 * Panic threshold. Panic frequency change request
+		 * will be sent if DVFS counter value will be more than this value.
+		 */
+		dvfs_set_pncthr(pncthr);
+
+		dvfs_unmask_dvfs_int();
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+		if (params->dvfs_mode == DVFS_PRED_MODE) {
+			params->chars_in_buffer = 0;
+			init_waitqueue_head(&params->dvfs_pred_wait);
+			params->read_ptr = params->dvfs_log_buffer;
+			dvfs_unmask_dvfs_lb_int();
+			dvfs_clear_ltbrsh();
+		}
+#endif
+
+		dvfs_set_ltbrsr();
+
+		dvfs_enable_dvfs();
+
+		params->dvfs_is_active = TRUE;
+
+		return 0;
+	}
+
+	/* DVFS module already active return error */
+	return -EINVAL;
+}
+
+/*!
+ * This function sets frequency according to fsvai bits (increase/decrease).
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ * @param    fsvai     value of fsvai bits (increase/decrease/emergency)
+ */
+void set_freq(dvfs_dptc_params_s * params, int fsvai)
+{
+	int dvsup;
+	unsigned long pdr0;
+	unsigned long pll;
+	int curr_freq_index;
+	int pll_switch;
+	int dfsup0, dfsup1;
+	dvfs_state *table;
+	unsigned long pmcr0;
+
+	pmcr0 = mxc_ccm_get_reg(MXC_CCM_PMCR0);
+
+	/* Read DVSUP - current frequency index */
+	dvsup = dvfs_get_dvsup();
+	curr_freq_index = dvsup;
+
+	table = params->dvfs_dptc_tables_ptr->table;
+
+#ifdef CONFIG_MXC_DVFS_SDMA
+	table = sdma_phys_to_virt((unsigned long)table);
+#endif
+
+	if (fsvai == DVFS_DECREASE) {
+		/* On DVFS_DECREASE event the frequency will be changed according
+		 * to the next state setting
+		 */
+		CLEAR_UDSC(pmcr0);
+		if (params->dvfs_dptc_tables_ptr->use_four_freq) {
+			dvsup++;
+		} else {
+			dvsup = 0x3;
+		}
+		SET_VSCNT(pmcr0, 1);
+		pll_switch = table[curr_freq_index].pll_sw_down;
+		pdr0 = table[curr_freq_index].pdr0_down;
+		pll = table[curr_freq_index].pll_down;
+
+	} else {
+		/* On DVFS_INCREASE and on DVFS_PANIC event the highest
+		 * frequency will be set
+		 */
+		SET_UDSC(pmcr0);
+		dvsup = 0;
+		SET_VSCNT(pmcr0, table[curr_freq_index].vscnt);
+		pll_switch = table[curr_freq_index].pll_sw_up;
+		pdr0 = table[curr_freq_index].pdr0_up;
+		pll = table[curr_freq_index].pll_up;
+	}
+
+	/* DVSUP (new frequency index) setup */
+	SET_DVSUP(pmcr0, dvsup);
+
+	/* DFSUP defines if PLL switch is required and which PLL source
+	 * will be used after the switch.
+	 */
+	dfsup0 = dvfs_get_dfsup0();
+	dfsup1 = dvfs_get_dfsup1();
+
+	if (pll_switch == 0) {
+		/* Update only pdr0 */
+		dfsup0 = 1;
+	}
+
+	if (pll_switch == 1) {
+		/* Update pll and pdr0 */
+		dfsup1 = (~dfsup1) & 0x1;
+		dfsup0 = 0;
+	}
+
+	SET_DFSUP0(pmcr0, dfsup0);
+	SET_DFSUP1(pmcr0, dfsup1);
+
+	mxc_ccm_modify_reg(MXC_CCM_PMCR0, 0xffffffff, pmcr0);
+	mxc_ccm_modify_reg(MXC_CCM_PDR0, 0xffffffff, pdr0);
+
+	if (pll_switch == 1) {
+		if (dfsup1 == 1) {
+			/* MPCTL will be updated */
+			mxc_ccm_modify_reg(MXC_CCM_MPCTL, 0xffffffff, pll);
+		} else {
+			/* SRPCTL will be updated */
+			mxc_ccm_modify_reg(MXC_CCM_SRPCTL, 0xffffffff, pll);
+		}
+	}
+
+	pr_debug(KERN_INFO "ARM frequency: %dMHz CKIH frequency: %dMHz(%d)\n",
+		 (int)mxc_get_clocks(CPU_CLK) / 1000000,
+		 (int)mxc_get_clocks(CKIH_CLK) / 1000000, (int)jiffies);
+}
+
+/*!
+ * This function disables the DVFS module.
+ *
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ *
+ * @return      0 if DVFS module was enabled else returns -EINVAL.
+ */
+int stop_dvfs(dvfs_dptc_params_s * params)
+{
+	unsigned long dvsup;
+	unsigned long dfsup1;
+	/* Check if DPTC module isn't already disabled */
+	if (params->dvfs_is_active != FALSE) {
+		/* Mask interrupts */
+		dvfs_mask_dvfs_int();
+		dvfs_mask_dvfs_lb_int();
+
+		params->dvfs_is_active = FALSE;
+
+		/* Set maximal frequency */
+		dvsup = dvfs_get_dvsup();
+		if (dvsup != 0) {
+			set_freq(params, DVFS_INCREASE);
+		}
+
+		/* If current PLL is SRPCTL, move to MPCTL */
+		dfsup1 = dvfs_get_dfsup1();
+		if (dfsup1 != 1) {
+			set_freq(params, DVFS_INCREASE);
+		}
+
+		/* Disable DVFS */
+		dvfs_disable_dvfs();
+
+		return 0;
+	}
+
+	/* DVFS module already disabled return error */
+	return -EINVAL;
+}
+
+/*!
+ * This function turns on/off SW general purpose bits.
+ * The argument's 4 LSBs represent the status of the bits.
+ *
+ * @param   arg  status of the SW general purpose bits
+ *
+ * @return 0 on success
+ */
+int set_sw_gp(unsigned char arg)
+{
+	/* Clear upper 4 bits */
+	arg &= 0xf;
+	dvfs_set_dvgp(arg);
+
+	return 0;
+}
+
+#ifndef CONFIG_MXC_DVFS_SDMA
+/*!
+ * This function is the DVFS Interrupt handler.
+ * @param    params    pointer to the DVFS & DPTC driver parameters structure.
+ */
+void dvfs_irq(dvfs_dptc_params_s * params)
+{
+	int fsvai;
+	unsigned long pmcr0;
+
+	fsvai = dvfs_get_fsvai();
+	pmcr0 = mxc_ccm_get_reg(MXC_CCM_PMCR0);
+
+	if (pmcr0 & MXC_CCM_PMCR0_FSVAIM) {
+		/* Do nothing. DVFS interrupt is masked */
+		return;
+	}
+
+	if (fsvai == 0) {
+		/* Do nothing. Freq change is not required */
+		return;
+	}
+
+	if (!(pmcr0 & MXC_CCM_PMCR0_UPDTEN)) {
+		/* Do nothing. DVFS didn't finish previous flow update */
+		return;
+	}
+
+	if (((dvfs_get_dvsup() == 3) && (fsvai == DVFS_DECREASE)) ||
+	    ((dvfs_get_dvsup() == 0) && ((fsvai == DVFS_INCREASE) ||
+					 (fsvai == DVFS_EMERG)))) {
+		/* Do nothing. DVFS is already at lowest (highest) state */
+		return;
+	}
+
+	set_freq(params, fsvai);
+
+}
+#endif				/* CONFIG_MXC_DVFS_SDMA */
+
+/*!
+ * This function sets DVFS to monitor WFI signal
+ *
+ * @param   arg  0 - turn WFI off, 1 - turn WFI on
+ * @return  0 on success, error code on fail
+ */
+int set_wfi(unsigned char arg)
+{
+	int res;
+
+	if (arg == 0) {
+		/* Disable */
+		mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_WFIM,
+				   MXC_CCM_PMCR0_WFIM);
+		res = 0;
+	} else if (arg == 1) {
+		/* Enable */
+		mxc_ccm_modify_reg(MXC_CCM_PMCR0, MXC_CCM_PMCR0_WFIM, 0);
+		res = 0;
+	} else {
+		res = -EINVAL;
+	}
+
+	return res;
+}
+
+/*!
+ * This function changes the frequency if DVFS HW is disabled.
+ * It gets id of the required state supported by DVFS table and
+ * updates CCM.
+ *
+ * @param    dvfs_state_id  id of the DVFS state.
+ * @return   0 on success, error code on fail
+ */
+int dvfs_set_state(int dvfs_state_id)
+{
+	int curr_freq_index;
+
+	if (dvfs_dptc_params->dvfs_is_active != FALSE &&
+	    dvfs_dptc_params->dvfs_mode != DVFS_PRED_MODE) {
+		/* Frequency change is impossible when DVFS HW is enabled */
+		return -EINVAL;
+	}
+
+	if (dvfs_state_id >= 0 &&
+	    dvfs_state_id <
+	    dvfs_dptc_params->dvfs_dptc_tables_ptr->dvfs_state_num) {
+		curr_freq_index = dvfs_get_dvsup();
+		if (curr_freq_index > dvfs_state_id) {
+			/* printk("Increasing frequency to %d\n", dvfs_state_id); */
+			if (dvfs_dptc_params->dvfs_is_active == FALSE) {
+				dvfs_enable_dvfs();
+			}
+			set_freq(dvfs_dptc_params, DVFS_INCREASE);
+			if (dvfs_dptc_params->dvfs_is_active == FALSE) {
+				dvfs_disable_dvfs();
+			}
+			return dvfs_set_state(dvfs_state_id);
+		} else if (curr_freq_index < dvfs_state_id) {
+			/* printk("Decreasing frequency to %d\n", dvfs_state_id); */
+			if (dvfs_dptc_params->dvfs_is_active == FALSE) {
+				dvfs_enable_dvfs();
+			}
+			set_freq(dvfs_dptc_params, DVFS_DECREASE);
+			if (dvfs_dptc_params->dvfs_is_active == FALSE) {
+				dvfs_disable_dvfs();
+			}
+			return dvfs_set_state(dvfs_state_id);
+		} else {
+			return 0;
+		}
+	}
+
+	return -EINVAL;
+}
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("DVFS driver");
+MODULE_LICENSE("GPL");
--- linux-2.6.19.2/arch/arm/mach-mx3/iomux.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/iomux.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,247 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "iomux.h"
+
+/*!
+ * 4 control fields per MUX register
+ */
+#define MUX_CTL_FIELDS          4
+
+/*!
+ * 3 control fields per PAD register
+ */
+#define PAD_CTL_FIELDS          3
+
+/*!
+ * Maximum number of MUX pins
+ * Number of pins = (highest iomux reg - lowest iomux reg + 1) * (4 pins/reg)
+ */
+#define MUX_PIN_NUM_MAX \
+        (((u32 *)IOMUXSW_MUX_END - (u32 *)IOMUXSW_MUX_CTL + 1) * MUX_CTL_FIELDS)
+
+/*!
+ * Number of pad controls =
+ *               (highest pad ctl reg - lowest pad ctl reg + 1) * (3 pins/reg)
+ */
+#define PAD_CTL_NUM_MAX \
+        (((u32 *)IOMUXSW_PAD_END - (u32 *)IOMUXSW_PAD_CTL + 1) * PAD_CTL_FIELDS)
+
+#define PIN_TO_IOMUX_INDEX(pin) ((pin >> MUX_I) & ((1 << (MUX_F - MUX_I)) - 1))
+#define PIN_TO_IOMUX_FIELD(pin) ((pin >> MUX_F) & ((1 << (PAD_I - MUX_F)) - 1))
+
+/*!
+ * 8 bits for each MUX control field
+ */
+#define MUX_CTL_BIT_LEN         8
+
+/*!
+ * 10 bits for each PAD control field
+ */
+#define MUX_PAD_BIT_LEN         10
+
+/*!
+ * IOMUX register (base) addresses
+ */
+enum iomux_reg_addr {
+	IOMUXGPR = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x008,	/*!< General purpose */
+	IOMUXSW_MUX_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x00C,	/*!< MUX control */
+	IOMUXSW_MUX_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x150,	/*!< last MUX control register */
+	IOMUXSW_PAD_CTL = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x154,	/*!< Pad control */
+	IOMUXSW_PAD_END = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x308,	/*!< last Pad control register */
+	IOMUXINT_OBS1 = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x000,	/*!< Observe interrupts 1 */
+	IOMUXINT_OBS2 = IO_ADDRESS(IOMUXC_BASE_ADDR) + 0x004,	/*!< Observe interrupts 2 */
+};
+
+/* len - mask bit length; fld - mask bit field. Example, to have the mask:
+ * 0xFF000000, use GET_FIELD_MASK(8, 3). Translate in plain language:
+ * "set the 3rd (0-based) 8-bit-long field to all 1's */
+#define GET_FIELD_MASK(len, fld)    (((1 << len) - 1) << (len * fld))
+static DEFINE_SPINLOCK(gpio_mux_lock);
+static u8 iomux_pin_res_table[MUX_PIN_NUM_MAX];
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ * FIXED ME: for backward compatible. Will be static function!
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return 		0 if successful; Non-zero otherwise
+ */
+int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		     iomux_pin_icfg_t in)
+{
+	u32 reg, l, ret = 0;
+	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_field = PIN_TO_IOMUX_FIELD(pin);
+	u32 mux_mask = GET_FIELD_MASK(MUX_CTL_BIT_LEN, mux_field);
+	u8 *rp;
+
+	MXC_ERR_CHK((mux_index > (MUX_PIN_NUM_MAX / MUX_CTL_FIELDS - 1)) ||
+		    (mux_field >= MUX_CTL_FIELDS));
+
+	reg = IOMUXSW_MUX_CTL + (mux_index * 4);
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(reg);
+	l = (l & (~mux_mask)) |
+	    (((out << 4) | in) << (mux_field * MUX_CTL_BIT_LEN));
+	__raw_writel(l, reg);
+	/*
+	 * Log a warning if a pin changes ownership
+	 */
+	rp = iomux_pin_res_table + mux_index * MUX_CTL_FIELDS + mux_field;
+	if (out & *rp && *rp != ((out << 4) | in)) {
+		/*
+		 * Don't call printk if we're tweaking the console uart or
+		 * we'll deadlock.
+		 */
+		if (pin != MX31_PIN_CTS1 &&
+		    pin != MX31_PIN_RTS1 &&
+		    pin != MX31_PIN_DCD_DCE1 &&
+		    pin != MX31_PIN_DSR_DTE1 &&
+		    pin != MX31_PIN_DTR_DTE1 &&
+		    pin != MX31_PIN_RI_DCE1 &&
+		    pin != MX31_PIN_DSR_DCE1 &&
+		    pin != MX31_PIN_DTR_DCE1 &&
+		    pin != MX31_PIN_RXD1 && pin != MX31_PIN_TXD1) {
+			printk(KERN_ERR "iomux_config_mux: Warning: iomux pin"
+			       " config changed, index=%d field=%d, "
+			       " prev=0x%x new=0x%x\n", mux_index, mux_field,
+			       *rp, (out << 4) | in);
+		}
+		ret = -EINVAL;
+	}
+	*rp = (out << 4) | in;
+	spin_unlock(&gpio_mux_lock);
+
+	return ret;
+}
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		      iomux_pin_icfg_t in)
+{
+	int ret = iomux_config_mux(pin, out, in);
+	if (out == OUTPUTCONFIG_GPIO && in == INPUTCONFIG_GPIO) {
+		ret |= mxc_request_gpio(pin);
+	}
+	return ret;
+}
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		    iomux_pin_icfg_t in)
+{
+	u32 mux_index = PIN_TO_IOMUX_INDEX(pin);
+	u32 mux_field = PIN_TO_IOMUX_FIELD(pin);
+	u8 *rp = iomux_pin_res_table + mux_index * MUX_CTL_FIELDS + mux_field;
+
+	MXC_ERR_CHK((mux_index > (MUX_PIN_NUM_MAX / MUX_CTL_FIELDS - 1)) ||
+		    (mux_field >= MUX_CTL_FIELDS));
+
+	*rp = 0;
+	if (out == OUTPUTCONFIG_GPIO && in == INPUTCONFIG_GPIO) {
+		mxc_free_gpio(pin);
+	}
+}
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config)
+{
+	u32 reg, l;
+	u32 pad_index = (pin >> PAD_I) & ((1 << (PAD_F - PAD_I)) - 1);
+	u32 pad_field = (pin >> PAD_F) & ((1 << (MUX_IO_I - PAD_F)) - 1);
+	u32 pad_mask = GET_FIELD_MASK(MUX_PAD_BIT_LEN, pad_field);
+
+	MXC_ERR_CHK((pad_index > (PAD_CTL_NUM_MAX / PAD_CTL_FIELDS - 1)) ||
+		    (pad_field >= PAD_CTL_FIELDS));
+
+	reg = IOMUXSW_PAD_CTL + (pad_index * 4);
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(reg);
+	l = (l & (~pad_mask)) | (config << (pad_field * MUX_PAD_BIT_LEN));
+	__raw_writel(l, reg);
+	spin_unlock(&gpio_mux_lock);
+}
+
+/*
+ * FIXED ME: for backward compatible. to be removed!
+ */
+void iomux_config_pad(iomux_pin_name_t pin, u32 config)
+{
+	mxc_iomux_set_pad(pin, config);
+}
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en)
+{
+	u32 l;
+
+	spin_lock(&gpio_mux_lock);
+	l = __raw_readl(IOMUXGPR);
+	if (en) {
+		l |= gp;
+	} else {
+		l &= ~gp;
+	}
+	__raw_writel(l, IOMUXGPR);
+	spin_unlock(&gpio_mux_lock);
+}
+
+/*!
+ * FIXED ME: for backward compatible. to be removed!
+ */
+void iomux_config_gpr(iomux_gp_func_t gp, bool en)
+{
+	mxc_iomux_set_gpr(gp, en);
+}
+
+EXPORT_SYMBOL(mxc_request_iomux);
+EXPORT_SYMBOL(mxc_free_iomux);
+EXPORT_SYMBOL(mxc_iomux_set_pad);
+EXPORT_SYMBOL(mxc_iomux_set_gpr);
+EXPORT_SYMBOL(iomux_config_pad);
+EXPORT_SYMBOL(iomux_config_gpr);
+EXPORT_SYMBOL(iomux_config_mux);
--- linux-2.6.19.2/arch/arm/mach-mx3/iomux.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/iomux.h	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,175 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX31_IOMUX_H__
+#define __MACH_MX31_IOMUX_H__
+
+#include <linux/types.h>
+
+/*!
+ * various IOMUX output functions
+ */
+typedef enum iomux_output_config {
+	OUTPUTCONFIG_GPIO = 0,	/*!< used as GPIO */
+	OUTPUTCONFIG_FUNC,	/*!< used as function */
+	OUTPUTCONFIG_ALT1,	/*!< used as alternate function 1 */
+	OUTPUTCONFIG_ALT2,	/*!< used as alternate function 2 */
+	OUTPUTCONFIG_ALT3,	/*!< used as alternate function 3 */
+	OUTPUTCONFIG_ALT4,	/*!< used as alternate function 4 */
+	OUTPUTCONFIG_ALT5,	/*!< used as alternate function 5 */
+	OUTPUTCONFIG_ALT6	/*!< used as alternate function 6 */
+} iomux_pin_ocfg_t;
+
+/*!
+ * various IOMUX input functions
+ */
+typedef enum iomux_input_config {
+	INPUTCONFIG_NONE = 0,	/*!< not configured for input */
+	INPUTCONFIG_GPIO = 1 << 0,	/*!< used as GPIO */
+	INPUTCONFIG_FUNC = 1 << 1,	/*!< used as function */
+	INPUTCONFIG_ALT1 = 1 << 2,	/*!< used as alternate function 1 */
+	INPUTCONFIG_ALT2 = 1 << 3	/*!< used as alternate function 2 */
+} iomux_pin_icfg_t;
+
+/*!
+ * various IOMUX pad functions
+ */
+typedef enum iomux_pad_config {
+	PAD_CTL_NOLOOPBACK = 0x0 << 9,
+	PAD_CTL_LOOPBACK = 0x1 << 9,
+	PAD_CTL_PKE_NONE = 0x0 << 8,
+	PAD_CTL_PKE_ENABLE = 0x1 << 8,
+	PAD_CTL_PUE_KEEPER = 0x0 << 7,
+	PAD_CTL_PUE_PUD = 0x1 << 7,
+	PAD_CTL_100K_PD = 0x0 << 5,
+	PAD_CTL_100K_PU = 0x1 << 5,
+	PAD_CTL_47K_PU = 0x2 << 5,
+	PAD_CTL_22K_PU = 0x3 << 5,
+	PAD_CTL_HYS_CMOS = 0x0 << 4,
+	PAD_CTL_HYS_SCHMITZ = 0x1 << 4,
+	PAD_CTL_ODE_CMOS = 0x0 << 3,
+	PAD_CTL_ODE_OpenDrain = 0x1 << 3,
+	PAD_CTL_DRV_NORMAL = 0x0 << 1,
+	PAD_CTL_DRV_HIGH = 0x1 << 1,
+	PAD_CTL_DRV_MAX = 0x2 << 1,
+	PAD_CTL_SRE_SLOW = 0x0 << 0,
+	PAD_CTL_SRE_FAST = 0x1 << 0
+} iomux_pad_config_t;
+
+/*!
+ * various IOMUX general purpose functions
+ */
+typedef enum iomux_gp_func {
+	MUX_PGP_FIRI = 0x1 << 0,
+	MUX_DDR_MODE = 0x1 << 1,
+	MUX_PGP_CSPI_BB = 0x1 << 2,
+	MUX_PGP_ATA_1 = 0x1 << 3,
+	MUX_PGP_ATA_2 = 0x1 << 4,
+	MUX_PGP_ATA_3 = 0x1 << 5,
+	MUX_PGP_ATA_4 = 0x1 << 6,
+	MUX_PGP_ATA_5 = 0x1 << 7,
+	MUX_PGP_ATA_6 = 0x1 << 8,
+	MUX_PGP_ATA_7 = 0x1 << 9,
+	MUX_PGP_ATA_8 = 0x1 << 10,
+	MUX_PGP_UH2 = 0x1 << 11,
+	MUX_SDCTL_CSD0_SEL = 0x1 << 12,
+	MUX_SDCTL_CSD1_SEL = 0x1 << 13,
+	MUX_CSPI1_UART3 = 0x1 << 14,
+	MUX_EXTDMAREQ2_MBX_SEL = 0x1 << 15,
+	MUX_TAMPER_DETECT_EN = 0x1 << 16,
+	MUX_PGP_USB_4WIRE = 0x1 << 17,
+	MUX_PGB_USB_COMMON = 0x1 << 18,
+	MUX_SDHC_MEMSTICK1 = 0x1 << 19,
+	MUX_SDHC_MEMSTICK2 = 0x1 << 20,
+	MUX_PGP_SPLL_BYP = 0x1 << 21,
+	MUX_PGP_UPLL_BYP = 0x1 << 22,
+	MUX_PGP_MSHC1_CLK_SEL = 0x1 << 23,
+	MUX_PGP_MSHC2_CLK_SEL = 0x1 << 24,
+	MUX_CSPI3_UART5_SEL = 0x1 << 25,
+	MUX_PGP_ATA_9 = 0x1 << 26,
+	MUX_PGP_USB_SUSPEND = 0x1 << 27,
+	MUX_PGP_USB_OTG_LOOPBACK = 0x1 << 28,
+	MUX_PGP_USB_HS1_LOOPBACK = 0x1 << 29,
+	MUX_PGP_USB_HS2_LOOPBACK = 0x1 << 30,
+	MUX_CLKO_DDR_MODE = 0x1 << 31,
+} iomux_gp_func_t;
+
+/*!
+ * This function is used to configure a pin through the IOMUX module.
+ *
+ * @param  pin		a pin number as defined in \b #iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ * @return 		0 if successful; Non-zero otherwise
+ */
+int iomux_config_mux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		     iomux_pin_icfg_t in);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pins
+ * @param  config       ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void iomux_config_pad(iomux_pin_name_t pin, __u32 config);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void iomux_config_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * Request ownership for an IO pin. This function has to be the first one
+ * being called before that pin is used. The caller has to check the
+ * return value to make sure it returns 0.
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ *
+ * @return		0 if successful; Non-zero otherwise
+ */
+int mxc_request_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		      iomux_pin_icfg_t in);
+
+/*!
+ * Release ownership for an IO pin
+ *
+ * @param  pin		a name defined by \b iomux_pin_name_t
+ * @param  out		an output function as defined in \b #iomux_pin_ocfg_t
+ * @param  in		an input function as defined in \b #iomux_pin_icfg_t
+ */
+void mxc_free_iomux(iomux_pin_name_t pin, iomux_pin_ocfg_t out,
+		    iomux_pin_icfg_t in);
+
+/*!
+ * This function enables/disables the general purpose function for a particular
+ * signal.
+ *
+ * @param  gp   one signal as defined in \b #iomux_gp_func_t
+ * @param  en   \b #true to enable; \b #false to disable
+ */
+void mxc_iomux_set_gpr(iomux_gp_func_t gp, bool en);
+
+/*!
+ * This function configures the pad value for a IOMUX pin.
+ *
+ * @param  pin          a pin number as defined in \b #iomux_pin_name_t
+ * @param  config       the ORed value of elements defined in \b #iomux_pad_config_t
+ */
+void mxc_iomux_set_pad(iomux_pin_name_t pin, u32 config);
+
+#endif
--- linux-2.6.19.2/arch/arm/mach-mx3/Kconfig	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/Kconfig	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,40 @@
+menu "MX3 Options"
+	depends on ARCH_MX3
+
+config MACH_MX31ADS
+	bool "Support MX31ADS platforms"
+	default y
+	help
+	  Include support for MX31ADS platform. This includes specific
+	  configurations for the board and its peripherals.
+
+config MX3_DOZE_DURING_IDLE
+	bool "Enter Doze mode during idle"
+	help
+	  Turning on this option will put the CPU into Doze mode during idle.
+	  The default is to enter Wait mode during idle. Doze mode during
+	  idle will save additional power over Wait mode.
+
+config ISP1504_MXC
+	tristate "ISP1540 transceiver support"
+	select ISP1504_MXC_OTG if USB_GADGET && USB_EHCI_HCD && USB_OTG
+	help
+	  Support for the ISP1504 USB transceiver on MXC platforms.
+
+config ISP1504_MXC_OTG
+	tristate
+	help
+	  Support for USB OTG using the ISP1504 transceiver on MXC platforms.
+
+config ISP1301_MXC
+	bool
+	select I2C_MXC
+
+config MXC_SDMA_API
+        bool "Use SDMA API"
+        default y
+        help
+           This selects the Freescale MXC SDMA API.
+           If unsure, say N.
+endmenu
+
--- linux-2.6.19.2/arch/arm/mach-mx3/Makefile.boot	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/Makefile.boot	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0x80008000
+params_phys-y	:= 0x80000100
+initrd_phys-y	:= 0x80800000
--- linux-2.6.19.2/arch/arm/mach-mx3/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/Makefile	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,13 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y			:= system.o iomux.o cpu.o mm.o time.o clock.o usb.o devices.o serial.o dma.o
+obj-$(CONFIG_MACH_MX31ADS)	+= mx31ads.o mx31ads_gpio.o mxc_pm.o
+
+# power management
+obj-$(CONFIG_MXC_DVFS)  += dvfs.o
+obj-$(CONFIG_PM) 		+= pm.o
+obj-$(CONFIG_DPM)		+= dpm.o
--- linux-2.6.19.2/arch/arm/mach-mx3/mm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/mm.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,96 @@
+/*
+ *  Copyright (C) 1999,2000 Arm Limited
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *  Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *    - add MX31 specific definitions
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <asm/hardware.h>
+#include <asm/pgtable.h>
+#include <asm/mach/map.h>
+
+/*!
+ * @file mm.c
+ *
+ * @brief This file creates static mapping between physical to virtual memory.
+ *
+ * @ingroup Memory
+ */
+
+/*!
+ * This structure defines the MX31 memory map.
+ */
+static struct map_desc mxc_io_desc[] __initdata = {
+	{
+	 .virtual = IRAM_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(IRAM_BASE_ADDR),
+	 .length = IRAM_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = L2CC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(L2CC_BASE_ADDR),
+	 .length = L2CC_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = X_MEMC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(X_MEMC_BASE_ADDR),
+	 .length = X_MEMC_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = ROMP_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(ROMP_BASE_ADDR),
+	 .length = ROMP_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AVIC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AVIC_BASE_ADDR),
+	 .length = AVIC_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AIPS1_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS1_BASE_ADDR),
+	 .length = AIPS1_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = SPBA0_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(SPBA0_BASE_ADDR),
+	 .length = SPBA0_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = AIPS2_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPS2_BASE_ADDR),
+	 .length = AIPS2_SIZE,
+	 .type = MT_NONSHARED_DEVICE},
+	{
+	 .virtual = CS4_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(CS4_BASE_ADDR),
+	 .length = CS4_SIZE,
+	 .type = MT_DEVICE},
+};
+
+/*!
+ * This function initializes the memory map. It is called during the
+ * system startup to create static physical to virtual memory map for
+ * the IO modules.
+ */
+void __init mxc_map_io(void)
+{
+	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
+}
--- linux-2.6.19.2/arch/arm/mach-mx3/mx31ads.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/mx31ads.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,557 @@
+/*
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *  Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/serial_8250.h>
+#ifdef CONFIG_KGDB_8250
+#include <linux/kgdb.h>
+#endif
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/spi/spi.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/mach/keypad.h>
+#include <asm/arch/memory.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/clock.h>
+
+#include "crm_regs.h"
+#include "iomux.h"
+/*!
+ * @file mx31ads.c
+ *
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup System
+ */
+
+extern void mxc_map_io(void);
+extern void mxc_init_irq(void);
+extern void mxc_cpu_init(void) __init;
+extern void mx31ads_gpio_init(void) __init;
+extern struct sys_timer mxc_timer;
+extern void mxc_cpu_common_init(void);
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_KEYBOARD_MXC) || defined(CONFIG_KEYBOARD_MXC_MODULE)
+
+/* Keypad keycodes for the EVB 8x8
+ * keypad.  POWER and PTT keys don't generate
+ * any interrupts via this driver so they are
+ * not support. Change any keys as u like!
+ */
+static u16 keymapping[64] = {
+	KEY_SELECT, KEY_LEFT, KEY_DOWN, KEY_RIGHT,
+	KEY_UP, KEY_F12, KEY_END, KEY_BACK,
+	KEY_F1, KEY_SENDFILE, KEY_HOME, KEY_F6,
+	KEY_VOLUMEUP, KEY_F8, KEY_F9, KEY_F10,
+	KEY_3, KEY_2, KEY_1, KEY_4,
+	KEY_VOLUMEDOWN, KEY_7, KEY_5, KEY_6,
+	KEY_9, KEY_LEFTSHIFT, KEY_8, KEY_0,
+	KEY_KPASTERISK, KEY_RECORD, KEY_Q, KEY_W,
+	KEY_A, KEY_S, KEY_D, KEY_E,
+	KEY_F, KEY_R, KEY_T, KEY_Y,
+	KEY_TAB, KEY_F7, KEY_CAPSLOCK, KEY_Z,
+	KEY_X, KEY_C, KEY_V, KEY_G,
+	KEY_B, KEY_H, KEY_N, KEY_M,
+	KEY_J, KEY_K, KEY_U, KEY_I,
+	KEY_SPACE, KEY_F2, KEY_DOT, KEY_ENTER,
+	KEY_L, KEY_BACKSPACE, KEY_P, KEY_O,
+};
+
+static struct resource mxc_kpp_resources[] = {
+	[0] = {
+	       .start = INT_KPP,
+	       .end = INT_KPP,
+	       .flags = IORESOURCE_IRQ,
+	       }
+};
+
+static struct keypad_data evb_8_by_8_keypad = {
+	.rowmax = 8,
+	.colmax = 8,
+	.irq = INT_KPP,
+	.learning = 0,
+	.delay = 2,
+	.matrix = keymapping,
+};
+
+/* mxc keypad driver */
+static struct platform_device mxc_keypad_device = {
+	.name = "mxc_keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
+	.resource = mxc_kpp_resources,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &evb_8_by_8_keypad,
+		},
+};
+
+static void mxc_init_keypad(void)
+{
+	(void)platform_device_register(&mxc_keypad_device);
+}
+#else
+static inline void mxc_init_keypad(void)
+{
+}
+#endif
+
+#if defined(CONFIG_SERIAL_8250) || defined(CONFIG_SERIAL_8250_MODULE)
+/*!
+ * The serial port definition structure. The fields contain:
+ * {UART, CLK, PORT, IRQ, FLAGS}
+ */
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+	 .membase = (void __iomem *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTA),
+	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTA),
+	 .irq = EXPIO_INT_XUART_INTA,
+	 .uartclk = 14745600,
+	 .regshift = 0,
+	 .iotype = UPIO_MEM,
+	 .flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,
+	 },
+	{
+	 .membase = (void __iomem *)(PBC_BASE_ADDRESS + PBC_SC16C652_UARTB),
+	 .mapbase = (unsigned long)(CS4_BASE_ADDR + PBC_SC16C652_UARTB),
+	 .irq = EXPIO_INT_XUART_INTB,
+	 .uartclk = 14745600,
+	 .regshift = 0,
+	 .iotype = UPIO_MEM,
+	 .flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,
+	 },
+	{},
+};
+
+/*!
+ * REVISIT: document me
+ */
+static struct platform_device serial_device = {
+	.name = "serial8250",
+	.id = 0,
+	.dev = {
+		.platform_data = serial_platform_data,
+		},
+};
+
+/*!
+ * REVISIT: document me
+ */
+static int __init mxc_init_extuart(void)
+{
+	return platform_device_register(&serial_device);
+}
+#else
+static inline int mxc_init_extuart(void)
+{
+	return 0;
+}
+#endif
+/* MTD NOR flash */
+
+#if defined(CONFIG_MTD_MXC) || defined(CONFIG_MTD_MXC_MODULE)
+
+static struct mtd_partition mxc_nor_partitions[] = {
+	{
+	 .name = "Bootloader",
+	 .size = 512 * 1024,
+	 .offset = 0x00000000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "Kernel",
+	 .size = 2 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "userfs",
+	 .size = 14 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "rootfs",
+	 .size = 12 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = MTD_WRITEABLE},
+	{
+	 .name = "FIS directory",
+	 .size = 12 * 1024,
+	 .offset = 0x01FE0000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "Redboot config",
+	 .size = MTDPART_SIZ_FULL,
+	 .offset = 0x01FFF000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+};
+
+static struct flash_platform_data mxc_flash_data = {
+	.map_name = "cfi_probe",
+	.width = 2,
+	.parts = mxc_nor_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nor_partitions),
+};
+
+static struct resource mxc_flash_resource = {
+	.start = 0xa0000000,
+	.end = 0xa0000000 + 0x02000000 - 1,
+	.flags = IORESOURCE_MEM,
+
+};
+
+static struct platform_device mxc_nor_mtd_device = {
+	.name = "mxc_nor_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_flash_data,
+		},
+	.num_resources = 1,
+	.resource = &mxc_flash_resource,
+};
+
+static void mxc_init_nor_mtd(void)
+{
+	(void)platform_device_register(&mxc_nor_mtd_device);
+}
+#else
+static void mxc_init_nor_mtd(void)
+{
+}
+#endif
+
+/* MTD NAND flash */
+
+#if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE)
+
+static struct mtd_partition mxc_nand_partitions[4] = {
+	{
+	 .name = "IPL-SPL",
+	 .offset = 0,
+	 .size = 128 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 4 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 22 * 1024 * 1024},
+	{
+	 .name = "nand.userfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nand_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	if (__raw_readl(MXC_CCM_RCSR) & MXC_CCM_RCSR_NF16B) {
+		mxc_nand_data.width = 2;
+	}
+	(void)platform_device_register(&mxc_nand_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+static struct spi_board_info mxc_spi_board_info[] __initdata = {
+	{
+	 .modalias = "pmic_spi",
+	 .irq = IOMUX_TO_IRQ(MX31_PIN_GPIO1_3),
+	 .max_speed_hz = 4000000,
+	 .bus_num = 2,
+	 .chip_select = 0,
+	 },
+};
+
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+static const char fb_default_mode[] = "Sharp-QVGA";
+
+/* mxc lcd driver */
+static struct platform_device mxc_fb_device = {
+	.name = "mxc_sdc_fb",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &fb_default_mode,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		},
+};
+
+static void mxc_init_fb(void)
+{
+	(void)platform_device_register(&mxc_fb_device);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
+static void mxc_expio_irq_handler(u32 irq, struct irqdesc *desc,
+				  struct pt_regs *regs)
+{
+	u32 imr_val;
+	u32 int_valid;
+	u32 expio_irq;
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	imr_val = __raw_readw(PBC_INTMASK_SET_REG);
+	int_valid = __raw_readw(PBC_INTSTATUS_REG) & imr_val;
+
+	if (unlikely(!int_valid)) {
+		printk(KERN_ERR "\nEXPIO: Spurious interrupt:0x%0x\n\n",
+		       int_valid);
+		goto out;
+	}
+
+	expio_irq = MXC_EXP_IO_BASE;
+	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
+		struct irqdesc *d;
+		if ((int_valid & 1) == 0)
+			continue;
+		d = irq_desc + expio_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nEXPIO irq: %d unhandeled\n",
+			       expio_irq);
+			BUG();	/* oops */
+		}
+		d->handle_irq(expio_irq, d, regs);
+	}
+
+      out:
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* mask the interrupt */
+	__raw_writew(1 << expio, PBC_INTMASK_CLEAR_REG);
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* clear the interrupt status */
+	__raw_writew(1 << expio, PBC_INTSTATUS_REG);
+	/* mask the interrupt */
+	expio_mask_irq(irq);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		a expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* unmask the interrupt */
+	__raw_writew(1 << expio, PBC_INTMASK_SET_REG);
+}
+
+static struct irqchip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int initialized = 0;
+
+static int __init _mxc_expio_init(void)
+{
+	int i;
+
+	initialized = 1;
+
+	printk(KERN_INFO "MX31ADS EXPIO(CPLD) hardware\n");
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	mxc_request_iomux(MX31_PIN_GPIO1_4, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_set_gpio_direction(MX31_PIN_GPIO1_4, 1);
+
+	/* disable the interrupt and clear the status */
+	__raw_writew(0xFFFF, PBC_INTMASK_CLEAR_REG);
+	__raw_writew(0xFFFF, PBC_INTSTATUS_REG);
+	for (i = MXC_EXP_IO_BASE; i < (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, do_level_IRQ);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(EXPIO_PARENT_INT, IRQT_HIGH);
+	set_irq_chained_handler(EXPIO_PARENT_INT, mxc_expio_irq_handler);
+
+	return 0;
+}
+
+/*
+ * This may get called early from board specific init
+ */
+int mxc_expio_init(void)
+{
+	if (!initialized)
+		return _mxc_expio_init();
+	else
+		return 0;
+}
+
+/*!
+ * Board specific fixup function. It is called by \b setup_arch() in
+ * setup.c file very early on during kernel starts. It allows the user to
+ * statically fill in the proper values for the passed-in parameters. None of
+ * the parameters is used currently.
+ *
+ * @param  desc         pointer to \b struct \b machine_desc
+ * @param  tags         pointer to \b struct \b tag
+ * @param  cmdline      pointer to the command line
+ * @param  mi           pointer to \b struct \b meminfo
+ */
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+	struct tag *t;
+#ifdef CONFIG_KGDB_8250
+	int i;
+	for (i = 0;
+	     i <
+	     (sizeof(serial_platform_data) / sizeof(serial_platform_data[0]));
+	     i += 1)
+		kgdb8250_add_platform_port(i, &serial_platform_data[i]);
+#endif
+
+	mxc_cpu_init();
+	for_each_tag(t, tags) {
+		if (t->hdr.tag == ATAG_MEM) {
+			t->u.mem.size = MEM_SIZE;
+			break;
+		}
+	}
+	if (t->hdr.size == 0) {
+		printk("%s: no mem tag found\n", __FUNCTION__);
+	}
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++) {
+			SET_NODE(mi, nid);
+		}
+	} while (0);
+#endif
+}
+
+/*!
+ * Board specific initialization.
+ */
+static void __init mxc_board_init(void)
+{
+	mxc_cpu_common_init();
+
+	/* Enable 26 mhz clock on CKO1 for PMIC audio */
+	mxc_ccm_modify_reg(MXC_CCM_COSR, 0x00000fff, 0x00000208);
+
+	mxc_gpio_init();
+	mx31ads_gpio_init();
+	mxc_expio_init();
+	mxc_init_keypad();
+	mxc_init_extuart();
+	mxc_init_nor_mtd();
+	mxc_init_nand_mtd();
+
+	/* Assign USBPLL to be used by SSI1/2 */
+	mxc_set_clocks_pll(SSI1_BAUD, USBPLL);
+	mxc_set_clocks_pll(SSI2_BAUD, USBPLL);
+
+	spi_register_board_info(mxc_spi_board_info,
+				ARRAY_SIZE(mxc_spi_board_info));
+
+	mxc_init_fb();
+}
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX31ADS data structure.
+ */
+MACHINE_START(MX31ADS, "Freescale MX31ADS")
+    /* Maintainer: Freescale Semiconductor, Inc. */
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+    .phys_io = CS4_BASE_ADDR,.io_pg_offst =
+    ((CS4_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+#else
+    .phys_io = AIPS1_BASE_ADDR,.io_pg_offst =
+    ((AIPS1_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+#endif
+    .boot_params = PHYS_OFFSET_ASM + 0x100,.fixup = fixup_mxc_board,.map_io =
+    mxc_map_io,.init_irq = mxc_init_irq,.init_machine = mxc_board_init,.timer =
+    &mxc_timer, MACHINE_END
--- linux-2.6.19.2/arch/arm/mach-mx3/mx31ads_gpio.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/mx31ads_gpio.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,1773 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio.h>
+#include "iomux.h"
+
+/*!
+ * @file mx31ads_gpio.c
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
+ * @ingroup GPIO
+ */
+
+void gpio_activate_audio_ports(void);
+
+/*!
+ * This system-wise GPIO function initializes the pins during system startup.
+ * All the statically linked device drivers should put the proper GPIO initialization
+ * code inside this function. It is called by \b fixup_mx31ads() during
+ * system startup. This function is board specific.
+ */
+void mx31ads_gpio_init(void)
+{
+	/* config CS4 */
+	mxc_request_iomux(MX31_PIN_CS4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	/*Connect DAM ports 4 & 5 to enable audio I/O */
+	gpio_activate_audio_ports();
+}
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	unsigned int pbc_bctrl1_clr = 0, pbc_bctrl2_set = 0, pbc_bctrl2_clr = 0;
+	/*
+	 * Configure the IOMUX control registers for the UART signals
+	 */
+	switch (port) {
+		/* UART 1 IOMUX Configs */
+	case 0:
+		mxc_request_iomux(MX31_PIN_RXD1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_TXD1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_RTS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CTS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_DTR_DCE1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_DSR_DCE1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_RI_DCE1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_DCD_DCE1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+
+		/* Enable the transceiver */
+		pbc_bctrl1_clr |= PBC_BCTRL1_UENCE;
+		pbc_bctrl2_set |= PBC_BCTRL2_USELC;
+		break;
+		/* UART 2 IOMUX Configs */
+	case 1:
+		mxc_request_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+
+		if (no_irda == 1) {
+			mxc_request_iomux(MX31_PIN_RTS2, OUTPUTCONFIG_FUNC,
+					  INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_CTS2, OUTPUTCONFIG_FUNC,
+					  INPUTCONFIG_FUNC);
+			mxc_request_iomux(MX31_PIN_DTR_DCE2, OUTPUTCONFIG_FUNC,
+					  INPUTCONFIG_FUNC);
+			pbc_bctrl1_clr |= PBC_BCTRL1_UENCE;
+			pbc_bctrl2_clr |= PBC_BCTRL2_USELC;
+		} else {
+			pbc_bctrl1_clr |= PBC_BCTRL1_IREN;
+			pbc_bctrl2_clr |= PBC_BCTRL2_IRDA_MOD;
+		}
+		break;
+		/* UART 3 IOMUX Configs */
+	case 2:
+		mxc_request_iomux(MX31_PIN_CSPI3_MOSI, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI3_MISO, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI3_SCLK, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI3_SPI_RDY, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+
+		pbc_bctrl1_clr |= PBC_BCTRL1_UENB;
+		pbc_bctrl2_clr |= PBC_BCTRL2_USELB;
+		break;
+		/* UART 4 IOMUX Configs */
+	case 3:
+		mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+
+		pbc_bctrl1_clr |= PBC_BCTRL1_UENB;
+		pbc_bctrl2_set |= PBC_BCTRL2_USELB;
+		break;
+		/* UART 5 IOMUX Configs */
+	case 4:
+		mxc_request_iomux(MX31_PIN_PC_VS2, OUTPUTCONFIG_ALT2,
+				  INPUTCONFIG_ALT2);
+		mxc_request_iomux(MX31_PIN_PC_RST, OUTPUTCONFIG_ALT2,
+				  INPUTCONFIG_ALT2);
+		mxc_request_iomux(MX31_PIN_PC_BVD1, OUTPUTCONFIG_ALT2,
+				  INPUTCONFIG_ALT2);
+		mxc_request_iomux(MX31_PIN_PC_BVD2, OUTPUTCONFIG_ALT2,
+				  INPUTCONFIG_ALT2);
+
+		pbc_bctrl1_clr |= PBC_BCTRL1_UENA;
+		pbc_bctrl2_set |= PBC_BCTRL2_USELA;
+		break;
+	default:
+		break;
+	}
+
+	__raw_writew(pbc_bctrl1_clr, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+	__raw_writew(pbc_bctrl2_set, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+	/*
+	 * TODO: Configure the Pad registers for the UART pins
+	 */
+}
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	unsigned int pbc_bctrl1_set = 0;
+
+	switch (port) {
+	case 0:
+		mxc_request_gpio(MX31_PIN_RXD1);
+		mxc_request_gpio(MX31_PIN_TXD1);
+		mxc_request_gpio(MX31_PIN_RTS1);
+		mxc_request_gpio(MX31_PIN_CTS1);
+		mxc_request_gpio(MX31_PIN_DTR_DCE1);
+		mxc_request_gpio(MX31_PIN_DSR_DCE1);
+		mxc_request_gpio(MX31_PIN_RI_DCE1);
+		mxc_request_gpio(MX31_PIN_DCD_DCE1);
+
+		mxc_free_iomux(MX31_PIN_RXD1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_TXD1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_RTS1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_CTS1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_DTR_DCE1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_DSR_DCE1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_RI_DCE1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_DCD_DCE1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+
+		pbc_bctrl1_set |= PBC_BCTRL1_UENCE;
+		break;
+	case 1:
+		mxc_request_gpio(MX31_PIN_TXD2);
+		mxc_request_gpio(MX31_PIN_RXD2);
+
+		mxc_free_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+
+		if (no_irda == 1) {
+			mxc_request_gpio(MX31_PIN_DTR_DCE2);
+			mxc_free_iomux(MX31_PIN_DTR_DCE2, OUTPUTCONFIG_GPIO,
+				       INPUTCONFIG_GPIO);
+
+			pbc_bctrl1_set |= PBC_BCTRL1_UENCE;
+		} else {
+			pbc_bctrl1_set |= PBC_BCTRL1_IREN;
+		}
+		break;
+	case 2:
+		pbc_bctrl1_set |= PBC_BCTRL1_UENB;
+		break;
+	case 3:
+		mxc_request_gpio(MX31_PIN_ATA_CS0);
+		mxc_request_gpio(MX31_PIN_ATA_CS1);
+		mxc_request_gpio(MX31_PIN_ATA_DIOR);
+		mxc_request_gpio(MX31_PIN_ATA_DIOW);
+
+		mxc_free_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+		mxc_free_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_GPIO,
+			       INPUTCONFIG_GPIO);
+
+		pbc_bctrl1_set |= PBC_BCTRL1_UENB;
+		break;
+	case 4:
+		pbc_bctrl1_set |= PBC_BCTRL1_UENA;
+		break;
+	default:
+		break;
+	}
+	__raw_writew(pbc_bctrl1_set, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+}
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+	switch (port) {
+	case 1:
+		/* Configure to receive UART 2 SDMA events */
+		mxc_iomux_set_gpr(MUX_PGP_FIRI, false);
+		break;
+	case 2:
+		/* Configure to receive UART 3 SDMA events */
+		mxc_iomux_set_gpr(MUX_CSPI1_UART3, true);
+		break;
+	case 4:
+		/* Configure to receive UART 5 SDMA events */
+		mxc_iomux_set_gpr(MUX_CSPI3_UART5_SEL, true);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_uart_active);
+EXPORT_SYMBOL(gpio_uart_inactive);
+EXPORT_SYMBOL(config_uartdma_event);
+
+/*!
+ * Setup GPIO for Keypad  to be active
+ *
+ */
+void gpio_keypad_active(void)
+{
+	/*
+	 * Configure the IOMUX control register for keypad signals.
+	 */
+	mxc_request_iomux(MX31_PIN_KEY_COL0, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL1, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL2, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL3, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL4, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL5, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL6, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_COL7, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW0, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW1, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW2, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW3, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW4, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW5, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW6, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_KEY_ROW7, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+}
+
+EXPORT_SYMBOL(gpio_keypad_active);
+
+/*!
+ * Setup GPIO for Keypad to be inactive
+ *
+ */
+void gpio_keypad_inactive(void)
+{
+	mxc_request_iomux(MX31_PIN_KEY_COL0, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL1, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL2, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL3, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL4, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL5, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL6, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_COL7, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW0, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW1, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW2, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW3, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW4, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW5, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW6, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_request_iomux(MX31_PIN_KEY_ROW7, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+}
+
+EXPORT_SYMBOL(gpio_keypad_inactive);
+
+/*!
+ * Setup GPIO for a CSPI device to be active
+ *
+ * @param  cspi_mod         an CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_iomux(MX31_PIN_CSPI1_MISO, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_MOSI, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SCLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS0, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 1:
+		/* SPI2 */
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 2:
+		/* SPI3 */
+		/*
+		   mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+		 */
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup 1-Wire to be active
+ */
+void gpio_owire_active(void)
+{
+	/*
+	 * Configure the IOMUX control register for 1-wire signals.
+	 */
+	iomux_config_mux(MX31_PIN_BATT_LINE, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_pad(MX31_PIN_BATT_LINE, PAD_CTL_LOOPBACK);
+}
+
+/*!
+ * Setup 1-Wire to be active
+ */
+void gpio_owire_inactive(void)
+{
+	/*
+	 * Configure the IOMUX control register for 1-wire signals.
+	 */
+	iomux_config_mux(MX31_PIN_BATT_LINE, OUTPUTCONFIG_GPIO,
+			 INPUTCONFIG_GPIO);
+}
+
+EXPORT_SYMBOL(gpio_owire_active);
+EXPORT_SYMBOL(gpio_owire_inactive);
+
+/*!
+ * Setup GPIO for a CSPI device to be inactive
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		mxc_request_iomux(MX31_PIN_CSPI1_MISO, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI1_MOSI, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI1_SCLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS0, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS1, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI1_SS2, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		break;
+	case 1:
+		/* SPI2 */
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS1, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_GPIO);
+		break;
+	case 2:
+		/* SPI3 */
+		/*
+		   mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SPI_RDY, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS0, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS1, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		   mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_GPIO, INPUTCONFIG_GPIO);
+		 */
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for an I2C device to be active
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_active(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_I2C_CLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_I2C_DAT, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 1:
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	case 2:
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+
+}
+
+/*!
+ * Setup GPIO for an I2C device to be inactive
+ *
+ * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_I2C_CLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_I2C_DAT, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_FUNC);
+		break;
+	case 1:
+		mxc_request_iomux(MX31_PIN_CSPI2_MOSI, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_MISO, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_ALT1);
+		break;
+	case 2:
+		mxc_request_iomux(MX31_PIN_CSPI2_SS2, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_CSPI2_SCLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * This function configures the IOMux block for PMIC standard operations.
+ *
+ */
+void gpio_pmic_active(void)
+{
+	mxc_request_iomux(MX31_PIN_GPIO1_3, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_GPIO);
+	mxc_set_gpio_direction(MX31_PIN_GPIO1_3, 1);
+//      mxc_set_gpio_edge_ctrl(MX31_PIN_GPIO1_3, GPIO_INT_RISE_EDGE);
+}
+
+EXPORT_SYMBOL(gpio_pmic_active);
+
+/*!
+ * This function activates DAM ports 4 & 5 to enable
+ * audio I/O. Thsi function is called from mx31ads_gpio_init
+ * function, which is board-specific.
+ */
+void gpio_activate_audio_ports(void)
+{
+	/* config Audio ports (4 & 5) */
+	mxc_request_iomux(MX31_PIN_SCK4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SRXD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_STXD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SFS4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SCK5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SRXD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_STXD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SFS5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+}
+
+/*!
+ * Setup GPIO for SDHC to be active
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+	switch (module) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_SD1_CLK, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_CMD, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA0, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA1, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA2, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+		mxc_request_iomux(MX31_PIN_SD1_DATA3, OUTPUTCONFIG_FUNC,
+				  INPUTCONFIG_FUNC);
+
+		mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+				  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+		break;
+	case 1:
+		mxc_request_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		mxc_request_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_ALT1,
+				  INPUTCONFIG_ALT1);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_sdhc_active);
+
+/*!
+ * Setup GPIO for SDHC1 to be inactive
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		mxc_request_iomux(MX31_PIN_SD1_CLK, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_CMD, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_DATA0, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_DATA1, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_DATA2, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_SD1_DATA3, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+
+		mxc_iomux_set_pad(MX31_PIN_SD1_CLK,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_CMD,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA0,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA1,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA2,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		mxc_iomux_set_pad(MX31_PIN_SD1_DATA3,
+				  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+		break;
+	case 1:
+		/* TODO:what are the pins for SDHC2? */
+		mxc_request_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		mxc_request_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_GPIO,
+				  INPUTCONFIG_NONE);
+		break;
+	default:
+		break;
+	}
+}
+
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+int sdhc_get_card_det_status(struct device *dev)
+{
+	if (to_platform_device(dev)->id == 0) {
+		return mxc_get_gpio_datain(MX31_PIN_GPIO1_1);
+	} else {
+		return mxc_get_gpio_datain(MX31_PIN_GPIO1_2);
+	}
+}
+
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+
+/*
+ * Return the card detect pin.
+ */
+int sdhc_init_card_det(int id)
+{
+	if (id == 0) {
+		iomux_config_mux(MX31_PIN_GPIO1_1, OUTPUTCONFIG_GPIO,
+				 INPUTCONFIG_GPIO);
+		return IOMUX_TO_IRQ(MX31_PIN_GPIO1_1);
+	} else {
+		iomux_config_mux(MX31_PIN_GPIO1_2, OUTPUTCONFIG_GPIO,
+				 INPUTCONFIG_GPIO);
+		return IOMUX_TO_IRQ(MX31_PIN_GPIO1_2);
+
+	}
+}
+
+EXPORT_SYMBOL(sdhc_init_card_det);
+
+/*!
+ * Setup GPIO for LCD to be active
+ *
+ */
+void gpio_lcd_active(void)
+{
+	u16 temp;
+
+	mxc_request_iomux(MX31_PIN_LD0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD10, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD11, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD12, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD13, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD14, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD15, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD16, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// LD16
+	mxc_request_iomux(MX31_PIN_LD17, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// LD17
+	mxc_request_iomux(MX31_PIN_VSYNC3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// VSYNC
+	mxc_request_iomux(MX31_PIN_HSYNC, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// HSYNC
+	mxc_request_iomux(MX31_PIN_FPSHIFT, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// CLK
+	mxc_request_iomux(MX31_PIN_DRDY0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// DRDY
+	mxc_request_iomux(MX31_PIN_D3_REV, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// REV
+	mxc_request_iomux(MX31_PIN_CONTRAST, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// CONTR
+	mxc_request_iomux(MX31_PIN_D3_SPL, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// SPL
+	mxc_request_iomux(MX31_PIN_D3_CLS, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// CLS
+
+	temp = PBC_BCTRL1_LCDON;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+}
+
+/*!
+ * Setup GPIO for LCD to be inactive
+ *
+ */
+void gpio_lcd_inactive(void)
+{
+	u16 pbc_bctrl1_set = 0;
+
+	pbc_bctrl1_set = (u16) PBC_BCTRL1_LCDON;
+	__raw_writew(pbc_bctrl1_set, PBC_BASE_ADDRESS + PBC_BCTRL1_SET + 2);
+}
+
+/*!
+ * Setup pins for SLCD to be active
+ *
+ */
+void slcd_gpio_config(void)
+{
+	u16 temp;
+
+	/* Reset smart lcd */
+	temp = PBC_BCTRL2_LDC_RST0;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+	msleep(2);
+	/* Bring out of reset */
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+	msleep(2);
+
+	mxc_request_iomux(MX31_PIN_LD0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD10, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD11, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD12, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD13, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD14, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD15, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD16, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_LD17, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	mxc_request_iomux(MX31_PIN_READ, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* read */
+	mxc_request_iomux(MX31_PIN_WRITE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* write */
+	mxc_request_iomux(MX31_PIN_PAR_RS, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* RS */
+	mxc_request_iomux(MX31_PIN_LCS0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	/* chip select */
+
+	/* Enable smart lcd interface */
+	temp = PBC_BCTRL2_LDCIO_EN;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+}
+
+/*!
+ * Switch to the specified sensor - MX31 ADS has two
+ *
+ */
+void gpio_sensor_select(int sensor)
+{
+	u16 temp;
+
+	switch (sensor) {
+	case 0:
+		temp = PBC_BCTRL1_SENSOR2_ON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+		temp = PBC_BCTRL1_SENSOR1_ON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+		break;
+	case 1:
+		temp = PBC_BCTRL1_SENSOR1_ON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_CLEAR);
+		temp = PBC_BCTRL1_SENSOR2_ON;
+		__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL1_SET);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for sensor to be active
+ *
+ */
+void gpio_sensor_active(void)
+{
+	gpio_sensor_select(0);
+
+	/*
+	 * Configure the iomuxen for the CSI.
+	 */
+
+	mxc_request_iomux(MX31_PIN_CSI_D4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D10, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D11, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D12, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D13, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D14, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_D15, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_HSYNC, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_MCLK, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_PIXCLK, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_CSI_VSYNC, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+
+#ifdef CONFIG_MXC_IPU_CAMERA_16BIT
+	/*
+	 * The other 4 data bits are multiplexed on MX31.
+	 */
+	mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_ALT2,
+			  INPUTCONFIG_ALT2);
+	mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_ALT2,
+			  INPUTCONFIG_ALT2);
+	mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_ALT2,
+			  INPUTCONFIG_ALT2);
+	mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_ALT2,
+			  INPUTCONFIG_ALT2);
+#endif
+
+	/*
+	 * Now enable the CSI buffers
+	 */
+
+	__raw_writew(PBC_BCTRL2_CSI_EN, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+#ifdef CONFIG_MXC_IPU_CAMERA_16BIT
+	/*
+	 * Enable the other buffer for the additional 4 data bits.
+	 */
+	__raw_writew(PBC_BCTRL4_CSI_MSB_EN,
+		     PBC_BASE_ADDRESS + PBC_BCTRL4_CLEAR);
+#endif
+}
+
+EXPORT_SYMBOL(gpio_sensor_active);
+
+/*!
+ * Setup GPIO for sensor to be inactive
+ *
+ */
+void gpio_sensor_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_CSI_D4, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D5, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D7, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D8, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D9, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D10, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D11, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D12, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D13, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D14, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_D15, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_HSYNC, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_MCLK, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_PIXCLK, OUTPUTCONFIG_FUNC,
+		       INPUTCONFIG_FUNC);
+	mxc_free_iomux(MX31_PIN_CSI_VSYNC, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+}
+
+EXPORT_SYMBOL(gpio_sensor_inactive);
+
+/*!
+ * Setup GPIO for ATA interface
+ *
+ */
+void gpio_ata_active(void)
+{
+	/*
+	 * Configure the GPR for ATA group B signals
+	 */
+
+	mxc_iomux_set_gpr(MUX_PGP_ATA_7 | MUX_PGP_ATA_6 | MUX_PGP_ATA_2 |
+			  MUX_PGP_ATA_1, true);
+
+	/*
+	 * Configure the IOMUX for ATA group B signals
+	 */
+
+	mxc_request_iomux(MX31_PIN_CSPI1_MOSI, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D0
+	mxc_request_iomux(MX31_PIN_CSPI1_MISO, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D1
+	mxc_request_iomux(MX31_PIN_CSPI1_SS0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D2
+	mxc_request_iomux(MX31_PIN_CSPI1_SS1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D3
+	mxc_request_iomux(MX31_PIN_CSPI1_SS2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D4
+	mxc_request_iomux(MX31_PIN_CSPI1_SCLK, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D5
+	mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D6
+	mxc_request_iomux(MX31_PIN_STXD3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D7
+	mxc_request_iomux(MX31_PIN_SRXD3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D8
+	mxc_request_iomux(MX31_PIN_SCK3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D9
+	mxc_request_iomux(MX31_PIN_SFS3, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D10
+	mxc_request_iomux(MX31_PIN_STXD6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D11
+	mxc_request_iomux(MX31_PIN_SRXD6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D12
+	mxc_request_iomux(MX31_PIN_SCK6, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D13
+	mxc_request_iomux(MX31_PIN_CAPTURE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D14
+	mxc_request_iomux(MX31_PIN_COMPARE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_D15
+
+	mxc_request_iomux(MX31_PIN_USBH2_STP, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_DMARQ_B
+	mxc_request_iomux(MX31_PIN_USBH2_CLK, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_INTRQ_B
+	mxc_request_iomux(MX31_PIN_USBH2_NXT, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_DA0
+	mxc_request_iomux(MX31_PIN_USBH2_DATA0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_DA1
+	mxc_request_iomux(MX31_PIN_USBH2_DATA1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_DA2
+	mxc_request_iomux(MX31_PIN_USBH2_DIR, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);	// ATA_BUFFER_DIR
+
+	/* These ATA pins are common to Group A and Group B */
+
+	mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_DMACK, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_ATA_RESET_B, OUTPUTCONFIG_FUNC,
+			  INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_PWMO, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	/* Need fast slew rate for UDMA mode */
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 0
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 1
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 2
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 3
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 4
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 5
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 6
+	mxc_iomux_set_pad(MX31_PIN_STXD3, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 7
+	mxc_iomux_set_pad(MX31_PIN_SRXD3, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 8
+	mxc_iomux_set_pad(MX31_PIN_SCK3, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 9
+	mxc_iomux_set_pad(MX31_PIN_SFS3, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 10
+	mxc_iomux_set_pad(MX31_PIN_STXD6, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 11
+	mxc_iomux_set_pad(MX31_PIN_SRXD6, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 12
+	mxc_iomux_set_pad(MX31_PIN_SCK6, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 13
+	mxc_iomux_set_pad(MX31_PIN_CAPTURE, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 14
+	mxc_iomux_set_pad(MX31_PIN_COMPARE, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 12
+
+	/* 
+	 * Turn off default pullups on high asserted control signals.
+	 * These are pulled down externally, so it will just waste 
+	 * power and create voltage divider action to pull them up
+	 * on chip.
+	 */
+	mxc_iomux_set_pad(MX31_PIN_USBH2_STP, PAD_CTL_PKE_NONE);	// ATA_DMARQ
+	mxc_iomux_set_pad(MX31_PIN_USBH2_CLK, PAD_CTL_PKE_NONE);	// ATA_INTRQ
+}
+
+EXPORT_SYMBOL(gpio_ata_active);
+
+/*!
+ * Restore ATA interface pins to reset values
+ *
+ */
+void gpio_ata_inactive(void)
+{
+	/*
+	 * Turn off ATA group B signals
+	 */
+	mxc_request_iomux(MX31_PIN_CSPI1_MOSI, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D0
+	mxc_request_iomux(MX31_PIN_CSPI1_MISO, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D1
+	mxc_request_iomux(MX31_PIN_CSPI1_SS0, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D2
+	mxc_request_iomux(MX31_PIN_CSPI1_SS1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D3
+	mxc_request_iomux(MX31_PIN_CSPI1_SS2, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D4
+	mxc_request_iomux(MX31_PIN_CSPI1_SCLK, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D5
+	mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D6
+	mxc_request_iomux(MX31_PIN_STXD3, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D7
+	mxc_request_iomux(MX31_PIN_SRXD3, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D8
+	mxc_request_iomux(MX31_PIN_SCK3, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D9
+	mxc_request_iomux(MX31_PIN_SFS3, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D10
+	mxc_request_iomux(MX31_PIN_STXD6, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D11
+	mxc_request_iomux(MX31_PIN_SRXD6, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D12
+	mxc_request_iomux(MX31_PIN_SCK6, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D13
+	mxc_request_iomux(MX31_PIN_CAPTURE, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D14
+	mxc_request_iomux(MX31_PIN_COMPARE, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_D15
+
+	mxc_request_iomux(MX31_PIN_USBH2_STP, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_DMARQ_B
+	mxc_request_iomux(MX31_PIN_USBH2_CLK, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_INTRQ_B
+	mxc_request_iomux(MX31_PIN_USBH2_NXT, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_DA0
+	mxc_request_iomux(MX31_PIN_USBH2_DATA0, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_DA1
+	mxc_request_iomux(MX31_PIN_USBH2_DATA1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_DA2
+	mxc_request_iomux(MX31_PIN_USBH2_DIR, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);	// ATA_BUFFER_DIR
+
+	/* These ATA pins are common to Group A and Group B */
+
+	mxc_request_iomux(MX31_PIN_ATA_CS0, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_CS1, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_DIOR, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_DIOW, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_DMACK, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+	mxc_request_iomux(MX31_PIN_ATA_RESET_B, OUTPUTCONFIG_GPIO,
+			  INPUTCONFIG_NONE);
+
+	/* Needed fast slew rate for UDMA mode */
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 0
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 1
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 2
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 3
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 4
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 5
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 6
+	mxc_iomux_set_pad(MX31_PIN_STXD3, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 7
+	mxc_iomux_set_pad(MX31_PIN_SRXD3, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 8
+	mxc_iomux_set_pad(MX31_PIN_SCK3, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 9
+	mxc_iomux_set_pad(MX31_PIN_SFS3, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 10
+	mxc_iomux_set_pad(MX31_PIN_STXD3, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 11
+	mxc_iomux_set_pad(MX31_PIN_SRXD6, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 12
+	mxc_iomux_set_pad(MX31_PIN_SCK6, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 13
+	mxc_iomux_set_pad(MX31_PIN_CAPTURE, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 14
+	mxc_iomux_set_pad(MX31_PIN_COMPARE, PAD_CTL_SRE_SLOW | PAD_CTL_PKE_NONE);	// data 12
+}
+
+EXPORT_SYMBOL(gpio_ata_inactive);
+
+/*!
+ * Setup EDIO/IOMUX for external UART.
+ *
+ * @param port UART port
+ * @param irq Interrupt line to allocate
+ * @param handler Function to be called when the IRQ occurs
+ * @param irq_flags Interrupt type flags
+ * @param devname An ascii name for the claiming device
+ * @param dev_id A cookie passed back to the handler function
+ * @return  Returns 0 if the interrupt was successfully requested,
+ *          otherwise returns an error code.
+ */
+int extuart_intr_setup(unsigned int port, unsigned int irq,
+		       irqreturn_t(*handler) (int, void *, struct pt_regs *),
+		       unsigned long irq_flags, const char *devname,
+		       void *dev_id)
+{
+	return 0;
+}
+
+/*!
+ * Get the EDIO interrupt, clear if set.
+ *
+ * @param port UART port
+ */
+void extuart_intr_clear(unsigned int port)
+{
+}
+
+/*!
+ * Do IOMUX configs required to put the
+ * pin back in low power mode.
+ *
+ * @param port UART port
+ * @param irq Interrupt line to free
+ * @param dev_id Device identity to free
+ * @return  Returns 0 if the interrupt was successfully freed,
+ *          otherwise returns an error code.
+ */
+int extuart_intr_cleanup(unsigned int port, unsigned int irq, void *dev_id)
+{
+	return 0;
+}
+
+/* *INDENT-OFF* */
+/*
+ * USB Host 1
+ * pins conflict with SPI1, ATA, UART3
+ */
+int gpio_usbh1_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_CSPI1_MOSI,	/* USBH1_RXDM */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_MISO,	/* USBH1_RXDP */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SS0,	/* USBH1_TXDM */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SS1,	/* USBH1_TXDP */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SS2,	/* USBH1_RCV  */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SCLK,	/* USBH1_OEB (_TXOE) */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1) ||
+	    mxc_request_iomux(MX31_PIN_CSPI1_SPI_RDY,	/* USBH1_FS   */
+			      OUTPUTCONFIG_ALT1, INPUTCONFIG_ALT1)) {
+		return -EINVAL;
+	}
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI,		/* USBH1_RXDM */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO,		/* USBH1_RXDP */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0,		/* USBH1_TXDM */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1,		/* USBH1_TXDP */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2,		/* USBH1_RCV  */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK,		/* USBH1_OEB (_TXOE) */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY,	/* USBH1_FS   */
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+
+	mxc_iomux_set_gpr(MUX_PGP_USB_SUSPEND, true);
+	return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbh1_active);
+
+void gpio_usbh1_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_CSPI1_MOSI,		/* USBH1_RXDM */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_MISO,		/* USBH1_RXDP */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SS0,		/* USBH1_TXDM */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SS1,		/* USBH1_TXDP */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SS2,		/* USBH1_RCV  */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SCLK,		/* USBH1_OEB (_TXOE) */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_CSPI1_SPI_RDY,		/* USBH1_FS   */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MOSI,		/* USBH1_RXDM */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_MISO,		/* USBH1_RXDP */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS0,		/* USBH1_TXDM */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS1,		/* USBH1_TXDP */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SS2,		/* USBH1_RCV  */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SCLK,		/* USBH1_OEB (_TXOE) */
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_CSPI1_SPI_RDY	/* USBH1_FS   */,
+		       (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+}
+
+EXPORT_SYMBOL(gpio_usbh1_inactive);
+
+/*
+ * USB Host 2
+ * pins conflict with UART5, PCMCIA
+ */
+int gpio_usbh2_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBH2_CLK,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_DIR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_NXT,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_STP,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_DATA0,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBH2_DATA1,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_PC_VS2,		/* USBH2_DATA2 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_PC_BVD1,		/* USBH2_DATA3 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_PC_BVD2,		/* USBH2_DATA4 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_PC_RST,		/* USBH2_DATA5 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_IOIS16,		/* USBH2_DATA6 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_PC_RW_B,		/* USBH2_DATA7 */
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFWE_B,
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFRE_B,
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFALE,
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFCLE,
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFWP_B,
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE) ||
+	    mxc_request_iomux(MX31_PIN_NFCE_B,
+			      OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE)) {
+		return -EINVAL;
+	}
+
+#define H2_PAD_CFG (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST | PAD_CTL_HYS_CMOS | PAD_CTL_ODE_CMOS | PAD_CTL_100K_PU)
+	mxc_iomux_set_pad(MX31_PIN_USBH2_CLK, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DIR, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_NXT, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_STP, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA0, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_USBH2_DATA1, H2_PAD_CFG);
+	mxc_iomux_set_pad(MX31_PIN_SRXD6, H2_PAD_CFG);	/* USBH2_DATA2 */
+	mxc_iomux_set_pad(MX31_PIN_STXD6, H2_PAD_CFG);	/* USBH2_DATA3 */
+	mxc_iomux_set_pad(MX31_PIN_SFS3, H2_PAD_CFG);	/* USBH2_DATA4 */
+	mxc_iomux_set_pad(MX31_PIN_SCK3, H2_PAD_CFG);	/* USBH2_DATA5 */
+	mxc_iomux_set_pad(MX31_PIN_SRXD3, H2_PAD_CFG);	/* USBH2_DATA6 */
+	mxc_iomux_set_pad(MX31_PIN_STXD3, H2_PAD_CFG);	/* USBH2_DATA7 */
+#undef H2_PAD_CFG
+
+	mxc_iomux_set_gpr(MUX_PGP_UH2, true);
+	return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbh2_active);
+
+void gpio_usbh2_inactive(void)
+{
+	iomux_config_gpr(MUX_PGP_UH2, false);
+
+	iomux_config_pad(MX31_PIN_USBH2_CLK,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_DIR,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_NXT,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_STP,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_DATA0,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_USBH2_DATA1,
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SRXD6,		/* USBH2_DATA2 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_STXD6,		/* USBH2_DATA3 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SFS3,			/* USBH2_DATA4 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SCK3,			/* USBH2_DATA5 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_SRXD3,		/* USBH2_DATA6 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+	iomux_config_pad(MX31_PIN_STXD3,		/* USBH2_DATA7 */
+			 (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_FAST));
+
+	mxc_free_iomux(MX31_PIN_USBH2_CLK,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DIR,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_NXT,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_STP,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DATA0,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBH2_DATA1,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_PC_VS2,			/* USBH2_DATA2 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD1,		/* USBH2_DATA3 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD2,		/* USBH2_DATA4 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RST,			/* USBH2_DATA5 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_IOIS16,			/* USBH2_DATA6 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RW_B,		/* USBH2_DATA7 */
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_NFWE_B,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFRE_B,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFALE,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFCLE,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFWP_B,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_NFCE_B,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+}
+
+EXPORT_SYMBOL(gpio_usbh2_inactive);
+
+/*
+ * USB OTG HS port
+ */
+int gpio_usbotg_hs_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBOTG_DATA0,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA1,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA2,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA3,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA4,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA5,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA6,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA7,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_CLK,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DIR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_NXT,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_STP,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC)) {
+		return -EINVAL;
+	}
+
+
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA0,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA1,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA2,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA3,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA4,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA5,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA6,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA7,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_CLK,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DIR,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_NXT,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_STP,
+			  (PAD_CTL_DRV_MAX | PAD_CTL_SRE_FAST));
+	return 0;
+}
+
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+
+void gpio_usbotg_hs_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA0,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA1,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA2,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA3,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA4,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA5,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA6,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA7,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_CLK,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DIR,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_NXT,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_STP,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA0,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA1,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA2,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA3,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA4,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA5,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA6,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DATA7,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_CLK,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_DIR,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_NXT,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+	mxc_iomux_set_pad(MX31_PIN_USBOTG_STP,
+			  (PAD_CTL_DRV_NORMAL | PAD_CTL_SRE_SLOW));
+}
+
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+
+/*
+ * USB OTG FS port
+ */
+int gpio_usbotg_fs_active(void)
+{
+	if (mxc_request_iomux(MX31_PIN_USBOTG_DATA0,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA1,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA2,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA3,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA4,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA5,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA6,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DATA7,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_CLK,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_DIR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_NXT,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USBOTG_STP,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC) ||
+	    mxc_request_iomux(MX31_PIN_USB_PWR,
+			      OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC)) {
+		return -EINVAL;
+	}
+	return 0;
+
+}
+
+EXPORT_SYMBOL(gpio_usbotg_fs_active);
+
+void gpio_usbotg_fs_inactive(void)
+{
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA0,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA1,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA2,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA3,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA4,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA5,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA6,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DATA7,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_CLK,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_DIR,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_NXT,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USBOTG_STP,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_USB_PWR,
+		       OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+}
+
+EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
+/* *INDENT-ON* */
+
+/*!
+ * Setup GPIO for PCMCIA interface
+ *
+ */
+void gpio_pcmcia_active(void)
+{
+	u16 temp;
+
+	mxc_request_iomux(MX31_PIN_SDBA0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_SDBA1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	iomux_config_mux(MX31_PIN_LBA, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_RW, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_EB0, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_EB1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_OE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	iomux_config_mux(MX31_PIN_IOIS16, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_BVD1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_BVD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_POE, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_READY, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_RST, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_RW_B, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_VS1, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_VS2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	iomux_config_mux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_FUNC,
+			 INPUTCONFIG_FUNC);
+
+	/* PCMCIA VPP, VCC Enable, 1 = power on */
+	temp = PBC_BCTRL2_VPP_EN | PBC_BCTRL2_VCC_EN;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+	/* Set up Card2 Select pin for PCMCIA, 0 = PCMCIA & SD2 */
+	temp = PBC_BCTRL3_CARD2_SEL;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL3_CLEAR);
+
+	/* PCMCIA Enable, 0 = enable */
+	temp = PBC_BCTRL4_PCMCIA_EN;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL4_CLEAR);
+	mdelay(1);
+}
+
+EXPORT_SYMBOL(gpio_pcmcia_active);
+
+/*!
+ * Setup GPIO for pcmcia to be inactive
+ */
+void gpio_pcmcia_inactive(void)
+{
+	u16 temp;
+
+	/* PCMCIA Enable, 0 = enable */
+	temp = PBC_BCTRL4_PCMCIA_EN;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL4_SET);
+
+	/* Set up Card2 Select pin for PCMCIA, 0 = PCMCIA & SD2 */
+	temp = PBC_BCTRL3_CARD2_SEL;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL3_SET);
+
+	/* PCMCIA VPP, VCC Enable, 1 = power on */
+	temp = PBC_BCTRL2_VPP_EN | PBC_BCTRL2_VCC_EN;
+	__raw_writew(temp, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+	mxc_free_iomux(MX31_PIN_SDBA0, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_SDBA1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_LBA, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_RW, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_EB0, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_EB1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_OE, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+
+	mxc_free_iomux(MX31_PIN_IOIS16, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_BVD2, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_CD1_B, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_CD2_B, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_POE, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_PWRON, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_READY, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RST, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_RW_B, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_VS1, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_VS2, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+	mxc_free_iomux(MX31_PIN_PC_WAIT_B, OUTPUTCONFIG_GPIO, INPUTCONFIG_NONE);
+}
+
+EXPORT_SYMBOL(gpio_pcmcia_inactive);
+/*!
+ * Setup IR to be used by UART and FIRI
+ */
+void gpio_firi_init(void)
+{
+	unsigned long clk;
+	gpio_uart_active(1, 0);
+
+	clk = mxc_get_clocks_parent(FIRI_BAUD);
+	/* 
+	 * FIRI module needs a clock which is a multiple of 8 Mhz..
+	 * We are giving it 48 Mhz in this case.
+	 */
+	mxc_set_clocks_div(FIRI_BAUD, (clk / 48000000));
+}
+
+EXPORT_SYMBOL(gpio_firi_init);
+
+/*!
+ * Setup IR to be used by UART
+ */
+void gpio_firi_inactive(void)
+{
+	unsigned int pbc_bctrl2_set = 0, pbc_bctrl2_clr = 0;
+
+	iomux_config_gpr(MUX_PGP_FIRI, false);
+	mxc_request_iomux(MX31_PIN_TXD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+	mxc_request_iomux(MX31_PIN_RXD2, OUTPUTCONFIG_FUNC, INPUTCONFIG_FUNC);
+
+	pbc_bctrl2_set |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_set, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+	pbc_bctrl2_clr |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+}
+
+EXPORT_SYMBOL(gpio_firi_inactive);
+
+/*!
+ * Setup IR to be used by FIRI
+ */
+void gpio_firi_active(void *fir_cong_reg_base, unsigned int tpp_mask)
+{
+	unsigned int pbc_bctrl2_set = 0, pbc_bctrl2_clr = 0;
+	unsigned int cr;
+
+	iomux_config_gpr(MUX_PGP_FIRI, true);
+
+	cr = readl(fir_cong_reg_base);
+	cr &= ~tpp_mask;
+	writel(cr, fir_cong_reg_base);
+
+	pbc_bctrl2_clr |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+	pbc_bctrl2_set |= PBC_BCTRL2_IRDA_MOD;
+	__raw_writew(pbc_bctrl2_set, PBC_BASE_ADDRESS + PBC_BCTRL2_SET);
+
+	cr = readl(fir_cong_reg_base);
+	cr |= tpp_mask;
+	writel(cr, fir_cong_reg_base);
+
+	__raw_writew(pbc_bctrl2_clr, PBC_BASE_ADDRESS + PBC_BCTRL2_CLEAR);
+
+	cr = readl(fir_cong_reg_base);
+	cr &= ~tpp_mask;
+	writel(cr, fir_cong_reg_base);
+}
+
+EXPORT_SYMBOL(gpio_firi_active);
+
+/*!
+ * Find clock for FIRI
+ */
+unsigned int firi_get_clocks(void)
+{
+	return (mxc_get_clocks(UART2_BAUD));
+}
+
+EXPORT_SYMBOL(firi_get_clocks);
+
+void firi_disable_uart_clock(void)
+{
+	mxc_clks_disable(UART2_BAUD);
+}
+
+EXPORT_SYMBOL(firi_disable_uart_clock);
+
+void firi_enable_uart_clock(void)
+{
+	mxc_clks_enable(UART2_BAUD);
+}
+
+EXPORT_SYMBOL(firi_enable_uart_clock);
--- linux-2.6.19.2/arch/arm/mach-mx3/mxc_pm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/mxc_pm.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,454 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_pm.c
+ *
+ * @brief This file provides all the kernel level and user level API
+ * definitions for the CRM_MCU and DPLL in mx3.
+ *
+ * @ingroup LPMD
+ */
+
+/*
+ * Include Files
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <asm/hardware.h>
+#include <asm/arch/system.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mxc_pm.h>
+#include <asm/irq.h>
+#include <asm/arch/dvfs_dptc_struct.h>
+#include <asm/arch/dvfs.h>
+
+#include "crm_regs.h"
+
+/* Local defines */
+#define FREQ_COMP_TOLERANCE      200	/* tolerance percentage times 100 */
+#define MCU_PLL_MAX_FREQ   600000000	/* Maximum frequency MCU PLL clock */
+#define MCU_PLL_MIN_FREQ   160000000	/* Minimum frequency MCU PLL clock */
+#define NFC_MAX_FREQ        20000000	/* Maximum frequency NFC clock */
+#define PRE_DIV_MIN_FREQ    10000000	/* Minimum Frequency after Predivider */
+
+static void print_frequencies(void)
+{
+	pr_debug("MCUPLL       %9lu\n", mxc_pll_clock(MCUPLL));
+	pr_debug("SERIALPLL    %9lu\n", mxc_pll_clock(SERIALPLL));
+	pr_debug("USBPLL       %9lu\n", mxc_pll_clock(USBPLL));
+	pr_debug("\n");
+	pr_debug("CPU_CLK      %9lu\n", mxc_get_clocks(CPU_CLK));
+	pr_debug("AHB_CLK      %9lu\n", mxc_get_clocks(AHB_CLK));
+	pr_debug("IPG_CLK      %9lu\n", mxc_get_clocks(IPG_CLK));
+	pr_debug("NFC_CLK      %9lu\n", mxc_get_clocks(NFC_CLK));
+	pr_debug("IPU_CLK      %9lu\n", mxc_get_clocks(IPU_CLK));
+	pr_debug("USB_CLK      %9lu\n", mxc_get_clocks(USB_CLK));
+	pr_debug("CSI_BAUD     %9lu\n", mxc_get_clocks(CSI_BAUD));
+	pr_debug("UART1_BAUD   %9lu\n", mxc_get_clocks(UART1_BAUD));
+	pr_debug("SSI1_BAUD    %9lu\n", mxc_get_clocks(SSI1_BAUD));
+	pr_debug("SSI2_BAUD    %9lu\n", mxc_get_clocks(SSI2_BAUD));
+	pr_debug("FIRI_BAUD    %9lu\n", mxc_get_clocks(FIRI_BAUD));
+	pr_debug("MSTICK1_BAUD %9lu\n", mxc_get_clocks(MSTICK1_BAUD));
+	pr_debug("MSTICK2_BAUD %9lu\n", mxc_get_clocks(MSTICK2_BAUD));
+	pr_debug("\n");
+}
+
+/*!
+ * Compare two frequences using allowable tolerance
+ *
+ * The MX3 PLL can generate many frequencies. This function
+ * compares the generated frequency to the requested frequency
+ * and determines it they are within and acceptable tolerance.
+ *
+ * @param   freq1  desired frequency
+ * @param   freq2  generated frequency
+ *
+ * @return       Returns 0 is frequencies are within talerance
+ *               and non-zero is they are not.
+ */
+static int freq_equal(unsigned long freq1, unsigned long freq2)
+{
+	if (freq1 > freq2) {
+		return (freq1 - freq2) <= (freq1 / FREQ_COMP_TOLERANCE);
+	}
+	return (freq2 - freq1) <= (freq1 / FREQ_COMP_TOLERANCE);
+}
+
+/*!
+ * Calculate new MCU clock dividers for the PDR0 regiser.
+ *
+ * @param   mcu_main_clk PLL output frequency (Hz)
+ * @param   arm_freq     desired ARM frequency (Hz)
+ * @param   max_freq     desired MAX frequency (Hz)
+ * @param   ip_freq      desired IP frequency (Hz)
+ * @param   mask         were to return PDR0 mask
+ * @param   value        were to return PDR0 value
+ *
+ * @return             Returns 0 on success or
+ *                     Returns non zero if error
+ *                       PLL_LESS_ARM_ERR if pll frequency is less than
+ *                       desired core frequency
+ *                       FREQ_OUT_OF_RANGE if desided frequencies ar not
+ *                       possible with the current mcu pll frequency.
+ */
+static int
+cal_pdr0_value(unsigned long mcu_main_clk,
+	       long arm_freq,
+	       long max_freq,
+	       long ip_freq, unsigned long *mask, unsigned long *value)
+{
+	unsigned long arm_div;	/* ARM core clock divider */
+	unsigned long max_div;	/* MAX clock divider */
+	unsigned long ipg_div;	/* IPG clock divider */
+	unsigned long nfc_div;	/* NFC (Nand Flash Controller) clock divider */
+	unsigned long hsp_div;	/* HSP clock divider */
+
+	if (arm_freq > mcu_main_clk) {
+		return -PLL_LESS_ARM_ERR;
+	}
+
+	arm_div = mcu_main_clk / arm_freq;
+	if ((arm_div == 0) || !freq_equal(arm_freq, mcu_main_clk / arm_div)) {
+		return FREQ_OUT_OF_RANGE;
+	}
+	max_div = mcu_main_clk / max_freq;
+	if ((max_div == 0) || !freq_equal(max_freq, mcu_main_clk / max_div)) {
+		return FREQ_OUT_OF_RANGE;
+	}
+	hsp_div = max_div;
+
+	ipg_div = max_freq / ip_freq;
+	if ((ipg_div == 0) || !freq_equal(ip_freq, max_freq / ipg_div)) {
+		return FREQ_OUT_OF_RANGE;
+	}
+
+	nfc_div = ((max_freq - 1000000) / NFC_MAX_FREQ) + 1;
+
+	/* All of the divider values have been calculated.
+	 * Now change the hardware register. */
+
+	*mask = MXC_CCM_PDR0_HSP_PODF_MASK |
+	    MXC_CCM_PDR0_NFC_PODF_MASK |
+	    MXC_CCM_PDR0_IPG_PODF_MASK |
+	    MXC_CCM_PDR0_MAX_PODF_MASK | MXC_CCM_PDR0_MCU_PODF_MASK;
+
+	*value = ((hsp_div - 1) << MXC_CCM_PDR0_HSP_PODF_OFFSET) |
+	    ((nfc_div - 1) << MXC_CCM_PDR0_NFC_PODF_OFFSET) |
+	    ((ipg_div - 1) << MXC_CCM_PDR0_IPG_PODF_OFFSET) |
+	    ((max_div - 1) << MXC_CCM_PDR0_MAX_PODF_OFFSET) |
+	    ((arm_div - 1) << MXC_CCM_PDR0_MCU_PODF_OFFSET);
+
+	return 0;
+}
+
+/*!
+ * Integer clock scaling
+ *
+ * Change main arm clock frequencies without changing the PLL.
+ * The integer dividers are changed to produce the desired
+ * frequencies. The number of valid frequency are limited and
+ * are determined by the current MCU PLL frequency
+ *
+ * @param   arm_freq    desired ARM frequency (Hz)
+ * @param   max_freq    desired MAX frequency (Hz)
+ * @param   ip_freq     desired IP frequency (Hz)
+ *
+ * @return             Returns 0 on success or
+ *                     Returns non zero if error
+ *                       PLL_LESS_ARM_ERR if pll frequency is less than
+ *                       desired core frequency
+ *                       FREQ_OUT_OF_RANGE if desided frequencies ar not
+ *                       possible with the current mcu pll frequency.
+ */
+int mxc_pm_intscale(long arm_freq, long max_freq, long ip_freq)
+{
+	unsigned long mcu_main_clk;	/* mcu clock domain main clock */
+	unsigned long mask;
+	unsigned long value;
+	int ret_value;
+
+	printk(KERN_INFO "arm_freq=%ld, max_freq=%ld, ip_freq=%ld\n",
+	       arm_freq, max_freq, ip_freq);
+	print_frequencies();	/* debug */
+
+	mcu_main_clk = mxc_pll_clock(MCUPLL);
+	ret_value = cal_pdr0_value(mcu_main_clk, arm_freq, max_freq, ip_freq,
+				   &mask, &value);
+
+	if (ret_value == 0) {
+		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
+	}
+
+	print_frequencies();
+	return ret_value;
+}
+
+/*!
+ * PLL clock scaling
+ *
+ * Change MCU PLL frequency and adjust derived clocks. Integer
+ * dividers are used generate the derived clocks so changed to produce
+ * the desired the valid frequencies are limited by the desired ARM
+ * frequency.
+ *
+ * The clock source for the MCU is set to the MCU PLL.
+ *
+ * @param   arm_freq    desired ARM frequency (Hz)
+ * @param   max_freq    desired MAX frequency (Hz)
+ * @param   ip_freq     desired IP frequency (Hz)
+ *
+ * @return             Returns 0 on success or
+ *                     Returns non zero if error
+ *                       PLL_LESS_ARM_ERR if pll frequency is less than
+ *                       desired core frequency
+ *                       FREQ_OUT_OF_RANGE if desided frequencies ar not
+ *                       possible with the current mcu pll frequency.
+ */
+int mxc_pm_pllscale(long arm_freq, long max_freq, long ip_freq)
+{
+	unsigned long ccmr;	/* clock control register */
+	unsigned long prcs;	/* PLL reference clock select bits. */
+	signed long ref_freq;	/* reference frequency */
+	signed long pll_freq;	/* target pll frequency */
+	signed long pd;		/* Pre-divider */
+	signed long mfi;	/* Multiplication Factor (Integer part) */
+	signed long mfn;	/* Multiplication Factor (Integer part) */
+	signed long mfd;	/* Multiplication Factor (Denominator Part) */
+	signed long old_pll;	/* old pll frequency */
+	signed long tmp;
+	unsigned long mask;
+	unsigned long value;
+	int ret_value;
+
+	printk(KERN_INFO "arm_freq=%ld, max_freq=%ld, ip_freq=%ld\n",
+	       arm_freq, max_freq, ip_freq);
+	print_frequencies();
+
+	ccmr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + MXC_CCM_CCMR);
+	prcs = (ccmr & MXC_CCM_CCMR_PRCS_MASK) >> MXC_CCM_CCMR_PRCS_OFFSET;
+	if (prcs == 0x1) {
+		ref_freq = mxc_get_clocks(CKIL_CLK) * 1024;
+	} else {
+		ref_freq = mxc_get_clocks(CKIH_CLK);
+	}
+	/*
+	 * MCU PLL output frequency equation
+	 *
+	 *                           mfn
+	 *                    mfi + -----
+	 *                           mfd
+	 *    ref_freq * 2 * ------------- =  pll_freq
+	 *                        pd
+	 *
+	 *   mfi must be >= 5 and <= 15
+	 *   mfd range 1 to 1024
+	 *   mfn range -512 to 511
+	 *   The absolute value of mfn/mfd must be smaller than 1.
+	 *   pd range 1 to 16
+	 *
+	 */
+
+	pd = 1;
+	pll_freq = arm_freq;
+
+	do {
+		if ((pll_freq > MCU_PLL_MAX_FREQ) || (pll_freq / 8 > arm_freq)) {
+			return FREQ_OUT_OF_RANGE;
+		}
+		if (pll_freq < MCU_PLL_MIN_FREQ) {
+			ret_value = 111;
+		} else {
+			ret_value =
+			    cal_pdr0_value(pll_freq, arm_freq, max_freq,
+					   ip_freq, &mask, &value);
+		}
+		if (ret_value != 0) {
+			pll_freq += arm_freq;
+		}
+	} while (ret_value != 0);
+
+	while (((ref_freq / pd) * 10) > pll_freq) {
+		pd++;
+	}
+
+	if ((ref_freq / pd) < PRE_DIV_MIN_FREQ) {
+		return FREQ_OUT_OF_RANGE;
+	}
+
+	/* the ref_freq/2 in the following is to round up */
+	mfi = (((pll_freq / 2) * pd) + (ref_freq / 2)) / ref_freq;
+	if (mfi < 5 || mfi > 15) {
+		return FREQ_OUT_OF_RANGE;
+	}
+
+	/* pick a mfd value that will work
+	 * then solve for mfn */
+	mfd = ref_freq / 50000;
+
+	/*
+	 *          pll_freq * pd * mfd
+	 *   mfn = --------------------  -  (mfi * mfd)
+	 *           2 * ref_freq
+	 */
+	/* the tmp/2 is for rounding */
+	tmp = ref_freq / 10000;
+	mfn =
+	    ((((((pll_freq / 2) + (tmp / 2)) / tmp) * pd) * mfd) / 10000) -
+	    (mfi * mfd);
+
+	mfn = mfn & 0x3ff;
+
+	old_pll = mxc_pll_clock(MCUPLL);
+	if (pll_freq > old_pll) {
+		/* if pll freq is increasing then change dividers first */
+		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
+		mxc_pll_set(MCUPLL, mfi, pd - 1, mfd - 1, mfn);
+	} else {
+		/* if pll freq is decreasing then change pll first */
+		mxc_pll_set(MCUPLL, mfi, pd - 1, mfd - 1, mfn);
+		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
+	}
+	print_frequencies();
+	return 0;
+}
+
+/*!
+ * Implementing steps required to transition to low-power modes
+ *
+ * @param   mode    The desired low-power mode. Possible values are,
+ *                  WAIT_MODE, DOZE_MODE, STOP_MODE or DSM_MODE
+ *
+ */
+void mxc_pm_lowpower(int mode)
+{
+	unsigned int lpm;
+	int enable_flag;
+	unsigned long reg;
+
+	local_irq_disable();
+	enable_flag = 0;
+
+	switch (mode) {
+	case DOZE_MODE:
+		lpm = 1;
+		break;
+
+	case STOP_MODE:
+		/* State Retention mode */
+		lpm = 2;
+		/* Disable timer interrupt */
+		disable_irq(INT_GPT);
+		enable_flag = 1;
+		break;
+
+	case DSM_MODE:
+		/* Deep Sleep Mode */
+		lpm = 3;
+		/* Disable timer interrupt */
+		disable_irq(INT_GPT);
+		enable_flag = 1;
+		/* Enabled Well Bias
+		 * SBYCS = 0, MCU clock source is disabled*/
+		mxc_ccm_modify_reg(MXC_CCM_CCMR,
+				   MXC_CCM_CCMR_WBEN | MXC_CCM_CCMR_SBYCS,
+				   MXC_CCM_CCMR_WBEN);
+		break;
+
+	default:
+	case WAIT_MODE:
+		/* Wait is the default mode used when idle. */
+		lpm = 0;
+		break;
+	}
+	reg = __raw_readl(MXC_CCM_CCMR);
+	reg = (reg & (~MXC_CCM_CCMR_LPM_MASK)) | lpm << MXC_CCM_CCMR_LPM_OFFSET;
+	__raw_writel(reg, MXC_CCM_CCMR);
+	/* Executing CP15 (Wait-for-Interrupt) Instruction */
+	/* wait for interrupt */
+	__asm__ __volatile__("mcr	p15, 0, r1, c7, c0, 4\n"
+			     "nop\n" "nop\n" "nop\n" "nop\n" "nop\n"::);
+
+	if (enable_flag) {
+		/* Enable timer interrupt */
+		enable_irq(INT_GPT);
+	}
+	local_irq_enable();
+}
+
+#ifdef CONFIG_MXC_DVFS
+/*!
+ * Changes MCU frequencies using dvfs.
+ *
+ * @param       armfreq       desired ARM frequency in Hz
+ * @param       ahbfreq       desired AHB frequency in Hz
+ * @param       ipfreq        desired IP frequency in Hz
+ *
+ * @return             Returns 0 on success, non-zero on error
+ */
+int mxc_pm_dvfs(unsigned long armfreq, long ahbfreq, long ipfreq)
+{
+	int ret_value;
+	int i;
+
+	if (ahbfreq != 133000000) {
+		return FREQ_OUT_OF_RANGE;
+	}
+	if (ipfreq != 66500000) {
+		return FREQ_OUT_OF_RANGE;
+	}
+	ret_value = FREQ_OUT_OF_RANGE;
+	for (i = 0; i < dvfs_states_tbl->num_of_states; i++) {
+		if (dvfs_states_tbl->freqs[i] == armfreq) {
+			ret_value = dvfs_set_state(i);
+			break;
+		}
+	}
+
+	return ret_value;
+}
+#endif				/* CONFIG_MXC_DVFS */
+
+/*!
+ * This function is used to load the module.
+ *
+ * @return   Returns an Integer on success
+ */
+static int __init mxc_pm_init_module(void)
+{
+	printk(KERN_INFO "Low-Level PM Driver module loaded\n");
+	return 0;
+}
+
+/*!
+ * This function is used to unload the module
+ */
+static void __exit mxc_pm_cleanup_module(void)
+{
+	printk(KERN_INFO "Low-Level PM Driver module Unloaded\n");
+}
+
+module_init(mxc_pm_init_module);
+module_exit(mxc_pm_cleanup_module);
+
+EXPORT_SYMBOL(mxc_pm_intscale);
+EXPORT_SYMBOL(mxc_pm_pllscale);
+EXPORT_SYMBOL(mxc_pm_lowpower);
+#ifdef CONFIG_MXC_DVFS
+EXPORT_SYMBOL(mxc_pm_dvfs);
+#endif
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("MX3 Low-level Power Management Driver");
+MODULE_LICENSE("GPL");
--- linux-2.6.19.2/arch/arm/mach-mx3/pm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/pm.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,113 @@
+/*
+ * linux/arch/arm/mach-mx3/pm.c
+ *
+ * MX3 Power Management Routines
+ *
+ * Original code for the SA11x0:
+ * Copyright (c) 2001 Cliff Brake <cbrake@accelent.com>
+ *
+ * Modified for the PXA250 by Nicolas Pitre:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Modified for the OMAP1510 by David Singleton:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Cleanup 2004 for OMAP1510/1610 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * Modified for the MX31
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/pm.h>
+
+#include <asm/io.h>
+#include <asm/arch/mxc_pm.h>
+
+#define HAC_GRP  5
+#define GEMK_GRP 5
+#define GPIO_GRP 4
+#define WDOG_GRP 4
+#define GPT_GRP  2
+#define UART_GRP 0
+
+/*
+ * TODO: whatta save?
+ */
+
+static int mx31_pm_enter(suspend_state_t state)
+{
+	printk("Hi, from mx31_pm_enter\n");
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_pm_lowpower(STOP_MODE);
+		break;
+
+	case PM_SUSPEND_STANDBY:
+		mxc_pm_lowpower(WAIT_MODE);
+		break;
+
+	case PM_SUSPEND_STOP:
+		mxc_pm_lowpower(DSM_MODE);
+		break;
+
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx31_pm_prepare(suspend_state_t state)
+{
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static int mx31_pm_finish(suspend_state_t state)
+{
+	return 0;
+}
+
+struct pm_ops mx31_pm_ops = {
+	.pm_disk_mode = 0,
+	.prepare = mx31_pm_prepare,
+	.enter = mx31_pm_enter,
+	.finish = mx31_pm_finish,
+};
+
+static int __init mx31_pm_init(void)
+{
+	printk("Power Management for Freescale MX31\n");
+	pm_set_ops(&mx31_pm_ops);
+
+	return 0;
+}
+
+late_initcall(mx31_pm_init);
--- linux-2.6.19.2/arch/arm/mach-mx3/sdma_script_code.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/sdma_script_code.h	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,583 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+
+#ifndef __SDMA_SCRIPT_CODE_H__
+#define __SDMA_SCRIPT_CODE_H__
+
+/*!
+* Following define start address of start script
+*/
+#define start_ADDR	0
+/*!
+* Following define size of start script
+*/
+#define start_SIZE	21
+
+/*!
+* Following define start address of core script
+*/
+#define core_ADDR	80
+/*!
+* Following define size of core script
+*/
+#define core_SIZE	152
+
+/*!
+* Following define start address of common script
+*/
+#define common_ADDR	232
+/*!
+* Following define size of common script
+*/
+#define common_SIZE	191
+
+/*!
+* Following define start address of burst_copy script
+*/
+#define burst_copy_ADDR	423
+/*!
+* Following define size of burst_copy script
+*/
+#define burst_copy_SIZE	87
+
+/*!
+* Following define start address of dsp_2_burst script
+*/
+#define dsp_2_burst_ADDR	510
+/*!
+* Following define size of dsp_2_burst script
+*/
+#define dsp_2_burst_SIZE	24
+
+/*!
+* Following define start address of burst_2_dsp script
+*/
+#define burst_2_dsp_ADDR	534
+/*!
+* Following define size of burst_2_dsp script
+*/
+#define burst_2_dsp_SIZE	24
+
+/*!
+* Following define start address of dsp_copy script
+*/
+#define dsp_copy_ADDR	558
+/*!
+* Following define size of dsp_copy script
+*/
+#define dsp_copy_SIZE	86
+
+/*!
+* Following define start address of mcu_2_mcu script
+*/
+#define mcu_2_mcu_ADDR	644
+/*!
+* Following define size of mcu_2_mcu script
+*/
+#define mcu_2_mcu_SIZE	79
+
+/*!
+* Following define start address of mcu_2_per script
+*/
+#define mcu_2_per_ADDR	723
+/*!
+* Following define size of mcu_2_per script
+*/
+#define mcu_2_per_SIZE	88
+
+/*!
+* Following define start address of test script
+*/
+#define test_ADDR	811
+/*!
+* Following define size of test script
+*/
+#define test_SIZE	63
+
+/*!
+* Following define start address of mcu_2_dsp script
+*/
+#define mcu_2_dsp_ADDR	874
+/*!
+* Following define size of mcu_2_dsp script
+*/
+#define mcu_2_dsp_SIZE	30
+
+/*!
+* Following define start address of mcu_2_dsp_2buf script
+*/
+#define mcu_2_dsp_2buf_ADDR	904
+/*!
+* Following define size of mcu_2_dsp_2buf script
+*/
+#define mcu_2_dsp_2buf_SIZE	113
+
+/*!
+* Following define start address of dsp_2_mcu script
+*/
+#define dsp_2_mcu_ADDR	1017
+/*!
+* Following define size of dsp_2_mcu script
+*/
+#define dsp_2_mcu_SIZE	30
+
+/*!
+* Following define start address of dsp_2_mcu_2buf script
+*/
+#define dsp_2_mcu_2buf_ADDR	1047
+/*!
+* Following define size of dsp_2_mcu_2buf script
+*/
+#define dsp_2_mcu_2buf_SIZE	113
+
+/*!
+* Following define start address of dsp_2_dsp script
+*/
+#define dsp_2_dsp_ADDR	1160
+/*!
+* Following define size of dsp_2_dsp script
+*/
+#define dsp_2_dsp_SIZE	64
+
+/*!
+* Following define start address of per_2_mcu script
+*/
+#define per_2_mcu_ADDR	1224
+/*!
+* Following define size of per_2_mcu script
+*/
+#define per_2_mcu_SIZE	121
+
+/*!
+* Following define start address of dsp_2_per_2buf script
+*/
+#define dsp_2_per_2buf_ADDR	1345
+/*!
+* Following define size of dsp_2_per_2buf script
+*/
+#define dsp_2_per_2buf_SIZE	164
+
+/*!
+* Following define start address of per_2_dsp_2buf script
+*/
+#define per_2_dsp_2buf_ADDR	1509
+/*!
+* Following define size of per_2_dsp_2buf script
+*/
+#define per_2_dsp_2buf_SIZE	168
+
+/*!
+* Following define start address of per_2_per script
+*/
+#define per_2_per_ADDR	1677
+/*!
+* Following define size of per_2_per script
+*/
+#define per_2_per_SIZE	67
+
+/*!
+* Following define start address of error_dsp script
+*/
+#define error_dsp_ADDR	1744
+/*!
+* Following define size of error_dsp script
+*/
+#define error_dsp_SIZE	34
+
+/*!
+* Following define start address of ap_2_ap script
+*/
+#define ap_2_ap_ADDR	6144
+/*!
+* Following define size of ap_2_ap script
+*/
+#define ap_2_ap_SIZE	294
+
+/*!
+* Following define start address of app_2_mcu script
+*/
+#define app_2_mcu_ADDR	6438
+/*!
+* Following define size of app_2_mcu script
+*/
+#define app_2_mcu_SIZE	101
+
+/*!
+* Following define start address of ata_2_mcu script
+*/
+#define ata_2_mcu_ADDR	6539
+/*!
+* Following define size of ata_2_mcu script
+*/
+#define ata_2_mcu_SIZE	110
+
+/*!
+* Following define start address of dptc_dvfs script
+*/
+#define dptc_dvfs_ADDR	6649
+/*!
+* Following define size of dptc_dvfs script
+*/
+#define dptc_dvfs_SIZE	274
+
+/*!
+* Following define start address of error script
+*/
+#define error_ADDR	6923
+/*!
+* Following define size of error script
+*/
+#define error_SIZE	73
+
+/*!
+* Following define start address of firi_2_mcu script
+*/
+#define firi_2_mcu_ADDR	6996
+/*!
+* Following define size of firi_2_mcu script
+*/
+#define firi_2_mcu_SIZE	114
+
+/*!
+* Following define start address of mcu_2_app script
+*/
+#define mcu_2_app_ADDR	7110
+/*!
+* Following define size of mcu_2_app script
+*/
+#define mcu_2_app_SIZE	127
+
+/*!
+* Following define start address of mcu_2_ata script
+*/
+#define mcu_2_ata_ADDR	7237
+/*!
+* Following define size of mcu_2_ata script
+*/
+#define mcu_2_ata_SIZE	87
+
+/*!
+* Following define start address of mcu_2_firi script
+*/
+#define mcu_2_firi_ADDR	7324
+/*!
+* Following define size of mcu_2_firi script
+*/
+#define mcu_2_firi_SIZE	74
+
+/*!
+* Following define start address of mcu_2_mshc script
+*/
+#define mcu_2_mshc_ADDR	7398
+/*!
+* Following define size of mcu_2_mshc script
+*/
+#define mcu_2_mshc_SIZE	48
+
+/*!
+* Following define start address of mcu_2_shp script
+*/
+#define mcu_2_shp_ADDR	7446
+/*!
+* Following define size of mcu_2_shp script
+*/
+#define mcu_2_shp_SIZE	123
+
+/*!
+* Following define start address of mshc_2_mcu script
+*/
+#define mshc_2_mcu_ADDR	7569
+/*!
+* Following define size of mshc_2_mcu script
+*/
+#define mshc_2_mcu_SIZE	60
+
+/*!
+* Following define start address of shp_2_mcu script
+*/
+#define shp_2_mcu_ADDR	7629
+/*!
+* Following define size of shp_2_mcu script
+*/
+#define shp_2_mcu_SIZE	101
+
+/*!
+* Following define start address of uart_2_mcu script
+*/
+#define uart_2_mcu_ADDR	7730
+/*!
+* Following define size of uart_2_mcu script
+*/
+#define uart_2_mcu_SIZE	105
+
+/*!
+* Following define start address of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_ADDR	7835
+/*!
+* Following define size of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_SIZE	98
+
+/*!
+* Following define the start address of sdma ram
+*/
+
+#define RAM_CODE_START_ADDR	6144
+/*!
+* Following define the size of sdma ram
+*/
+#define RAM_CODE_SIZE	1789
+
+/*!
+* This function returns buffer that holds the image of SDMA RAM
+*
+* @return pointer to buffer that holds the image of SDMA RAM
+*/
+
+static const short sdma_code[] = {
+	0xc0ec, 0x7d59, 0x0970, 0x0111, 0x5111, 0x5ad1, 0x5bd9, 0xc0fe,
+	0x5ce1, 0x7d02, 0x0200, 0x9806, 0x08ff, 0x0011, 0x28ff, 0x00bc,
+	0x05df, 0x7d4b, 0x06df, 0x7d2f, 0x6dc5, 0x6ed5, 0x5ef1, 0x0288,
+	0xd81a, 0x9854, 0x0b04, 0x00d3, 0x7d20, 0x06a5, 0x3e03, 0x3d03,
+	0x03a5, 0x3b03, 0x008b, 0x058b, 0x7802, 0x63d8, 0x0000, 0x7e72,
+	0x63ff, 0x7e70, 0x02a5, 0x008a, 0x4e00, 0x7d01, 0x983d, 0x6dcf,
+	0x6edf, 0x0015, 0x0015, 0x7802, 0x63d8, 0x0000, 0x7e63, 0x63ff,
+	0x7e61, 0x3a03, 0x008a, 0x6dcd, 0x6edd, 0x7801, 0x63d8, 0x7e5a,
+	0x63ff, 0x7e58, 0x0006, 0x6dc5, 0x6e07, 0x5ef1, 0x0288, 0xd8f7,
+	0x7e02, 0x7f04, 0x9854, 0x0007, 0x68cc, 0x6b28, 0x54e1, 0x0089,
+	0xdb13, 0x0188, 0x5ce1, 0x9854, 0x52d1, 0x53d9, 0x54e1, 0xc10d,
+	0x7dad, 0x0200, 0x9800, 0x0200, 0x9800, 0x06df, 0x7d06, 0x6d23,
+	0x6ed5, 0x5ef1, 0x0288, 0xd8cd, 0x9854, 0x5ef1, 0x6e07, 0x6d03,
+	0x0b04, 0x00d3, 0x7d59, 0x06a5, 0x3e03, 0x3d03, 0x4d00, 0x7d09,
+	0x03a5, 0x00a3, 0x0588, 0x008b, 0xd8c9, 0x7ed8, 0x620c, 0x7ed6,
+	0x008d, 0x4e00, 0x7c25, 0x0a20, 0x00da, 0x7c22, 0x6503, 0x3d1f,
+	0x02a5, 0x00a2, 0x0215, 0x0215, 0x6a18, 0x6a28, 0x7fc7, 0x0a20,
+	0x0b08, 0x00da, 0x7c06, 0x6b18, 0x6b28, 0x7fc0, 0x0000, 0x2020,
+	0x9889, 0x0688, 0x0015, 0x0015, 0x6818, 0x6828, 0x7fb7, 0x98c2,
+	0x0007, 0x6a0c, 0x54e1, 0x0089, 0xdb0f, 0x0188, 0x5ce1, 0x9854,
+	0x0b04, 0x00d3, 0x7d21, 0x0389, 0x1b12, 0x048b, 0x0688, 0x0015,
+	0x0015, 0x0588, 0x038c, 0x0a08, 0x05da, 0x008d, 0x7c01, 0x008a,
+	0x05a0, 0x7803, 0x620b, 0x5a03, 0x1b01, 0x7e98, 0x008b, 0x00a4,
+	0x038c, 0x7803, 0x5203, 0x6a0b, 0x1b01, 0x6a28, 0x7f8f, 0x0000,
+	0x4d00, 0x7ce8, 0x008e, 0x3803, 0xd8c9, 0x7e88, 0x620c, 0x7e86,
+	0x9854, 0x7802, 0x6209, 0x6a29, 0x0006, 0x3e03, 0x4e00, 0x7d11,
+	0x0b04, 0x03a6, 0x02db, 0x7d01, 0x038a, 0x02a3, 0x048a, 0x008b,
+	0x7802, 0x6329, 0x6bc8, 0x7ebc, 0x63c8, 0x7ebc, 0x008c, 0x4800,
+	0x7d15, 0x0488, 0x0015, 0x0015, 0x6edf, 0x7803, 0x632b, 0x6bc8,
+	0x0000, 0x7eae, 0x63c8, 0x7eae, 0x008c, 0x3803, 0x6edd, 0x7803,
+	0x6329, 0x6bc8, 0x0000, 0x7ea4, 0x63c8, 0x7ea4, 0x0006, 0x3d03,
+	0x4d00, 0x7d0e, 0x0b04, 0x03a5, 0x02db, 0x7d01, 0x038a, 0x02a3,
+	0x048a, 0x008b, 0x7802, 0x63c8, 0x6b09, 0x7e1e, 0x7f1e, 0x008c,
+	0x0488, 0x0015, 0x0015, 0x6dcf, 0x0288, 0x008a, 0x0d08, 0x02dd,
+	0x7c01, 0x008d, 0x7802, 0x63c8, 0x6b0b, 0x7e0e, 0x6b28, 0x7f0d,
+	0x0000, 0x02dd, 0x7c02, 0x2208, 0x990d, 0x008c, 0x3803, 0x65c0,
+	0x6dc5, 0x7802, 0x63c8, 0x6b09, 0x6b28, 0x0006, 0x0870, 0x0011,
+	0x5010, 0xc0ec, 0x7d5e, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x992c, 0x6ec3, 0x6d07, 0x5df0, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x4d00, 0x7d44, 0x0b70, 0x0311, 0x522b, 0x5313,
+	0x02b9, 0x4a00, 0x7c04, 0x6a28, 0x7f3a, 0x0400, 0x993c, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x0a03, 0x0212, 0x02bc, 0x0210,
+	0x4a00, 0x7d1c, 0x4a02, 0x7d20, 0x4a01, 0x7d23, 0x0b70, 0x0311,
+	0x53eb, 0x62c8, 0x7e24, 0x0360, 0x7d02, 0x0210, 0x0212, 0x6a09,
+	0x7f1e, 0x0212, 0x6a09, 0x7f1b, 0x0212, 0x6a09, 0x7f18, 0x2003,
+	0x4800, 0x7cef, 0x0b70, 0x0311, 0x5313, 0x997d, 0x0015, 0x0015,
+	0x7802, 0x62c8, 0x6a0b, 0x997c, 0x0015, 0x7802, 0x62c8, 0x6a0a,
+	0x997c, 0x7802, 0x62c8, 0x6a09, 0x7c02, 0x0000, 0x993a, 0xdb13,
+	0x6a28, 0x7ffd, 0x008b, 0x52c3, 0x53cb, 0xc10d, 0x7da5, 0x0200,
+	0x992c, 0x0200, 0x9929, 0xc19d, 0xc0ec, 0x7d69, 0x0c70, 0x0411,
+	0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe, 0x56fa, 0x7d02,
+	0x0200, 0x9994, 0x6d07, 0x5bca, 0x5cd2, 0x0bff, 0x0311, 0x1bff,
+	0x04bb, 0x0415, 0x53da, 0x4c00, 0x7d47, 0x0a70, 0x0211, 0x552a,
+	0x5212, 0x008d, 0x00bb, 0x4800, 0x7c07, 0x05b9, 0x4d00, 0x7c13,
+	0x6928, 0x7f2d, 0x0400, 0x99a5, 0x008f, 0x0015, 0x04d8, 0x7d01,
+	0x008c, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e29, 0x6d28,
+	0x7f1e, 0x0000, 0x99a3, 0x1e20, 0x5506, 0x2620, 0x008d, 0x0560,
+	0x7c08, 0x065f, 0x55c6, 0x063f, 0x7e1b, 0x6d0a, 0x7f10, 0x4c00,
+	0x7d1b, 0x04d8, 0x7d02, 0x008c, 0x0020, 0x04a0, 0x0015, 0x7802,
+	0x55c6, 0x6d0b, 0x7e0d, 0x6d28, 0x7f02, 0x0000, 0x99ec, 0x0007,
+	0x680c, 0x6d0c, 0x6507, 0x6d07, 0x6d2b, 0x6d28, 0x0007, 0x680c,
+	0x0007, 0x54d2, 0x0454, 0x99ef, 0x6928, 0x7ff1, 0x54d2, 0x008a,
+	0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7d9f, 0x0200, 0x9994, 0x0200,
+	0x998c, 0xc0ec, 0x7d72, 0x0800, 0x0970, 0x0111, 0x5111, 0x5ac1,
+	0x5bc9, 0x028e, 0xc0fe, 0x068a, 0x7c6a, 0x5dd9, 0x5ce1, 0x0bff,
+	0x0311, 0x1bff, 0x03bc, 0x5bd1, 0x1a5c, 0x6ac3, 0x63c8, 0x0363,
+	0x7c05, 0x036f, 0x7d27, 0x0374, 0x7c7a, 0x9a71, 0xdb04, 0x3c06,
+	0x4c00, 0x7df7, 0x028f, 0x1a04, 0x6a23, 0x620b, 0x6f23, 0x301f,
+	0x00aa, 0x0462, 0x7c04, 0x4a00, 0x7d0b, 0x2001, 0x9a30, 0x048a,
+	0x620b, 0x2201, 0x1c01, 0x1801, 0x02dc, 0x7d02, 0x301f, 0x00aa,
+	0x048f, 0x1c04, 0x6c07, 0x0488, 0x3c1f, 0x6c2b, 0x0045, 0x028e,
+	0x1a5c, 0x9a11, 0x058f, 0x1d0c, 0x6d23, 0x650b, 0x007d, 0x7c01,
+	0x1d08, 0x007c, 0x7c01, 0x1d04, 0x6d23, 0x650b, 0x0488, 0x3c1f,
+	0x0417, 0x0417, 0x0417, 0x0417, 0x059c, 0x6d23, 0x028e, 0x1a34,
+	0x6ad7, 0x0488, 0x0804, 0x7802, 0x650b, 0x6dc8, 0x008c, 0x1a28,
+	0x6ad7, 0x63c8, 0x034c, 0x6bc8, 0x54d1, 0x4c00, 0x7d06, 0x0065,
+	0x7c02, 0x0101, 0x0025, 0x0400, 0x9a0d, 0x52c1, 0x53c9, 0x54e1,
+	0x0453, 0xc10d, 0x7d95, 0x0200, 0x9a00, 0x0200, 0x99f9, 0x0200,
+	0x9a00, 0x55d9, 0x6d07, 0x54d1, 0x058a, 0x2508, 0x6dc7, 0x0373,
+	0x7c03, 0x65c8, 0x6d0b, 0x2408, 0x0372, 0x7c04, 0x65c8, 0x6d0b,
+	0x2408, 0x9a86, 0x6cce, 0x65c8, 0x6d0a, 0x2404, 0x6d28, 0x6507,
+	0x5dd9, 0x5cd1, 0x6ad7, 0x6ae3, 0x63c8, 0x0334, 0x6bc8, 0x0370,
+	0x7ca9, 0x0c60, 0x0411, 0x04bb, 0x4c00, 0x7da4, 0x0410, 0x1c30,
+	0x0410, 0x04bb, 0x046d, 0x7d0a, 0x047d, 0x7c03, 0x047c, 0x7c01,
+	0x9a3a, 0x003b, 0x003a, 0x0039, 0x0058, 0x9ab5, 0x047d, 0x7d03,
+	0x047c, 0x7d01, 0x9a3a, 0x005b, 0xdaf9, 0x1d18, 0x6d23, 0x650b,
+	0x0510, 0x003a, 0x0039, 0x0038, 0x00ad, 0xdb04, 0x0c30, 0x0410,
+	0x04bb, 0x003c, 0x003d, 0x00ac, 0xdaf9, 0x007b, 0x7c04, 0x003d,
+	0x003c, 0x1d0c, 0x9ad6, 0x048f, 0x1c14, 0x6c23, 0x640b, 0x4401,
+	0x7d04, 0x005d, 0x005c, 0x1d0c, 0x9ad6, 0x0310, 0x3b30, 0x4b30,
+	0x7d01, 0x1b10, 0x0310, 0x003d, 0x003c, 0x00ab, 0x6ad7, 0x63c8,
+	0x6d23, 0x650b, 0x0560, 0x7d03, 0x005e, 0xdaed, 0x9a3a, 0x003e,
+	0x0c80, 0x0410, 0x0394, 0xdaed, 0x640b, 0x037f, 0x7d02, 0x1a14,
+	0x9aea, 0x1a0c, 0x6ad7, 0x6cc8, 0x9a3a, 0x0c7f, 0x0410, 0x03b4,
+	0x04b8, 0x03ac, 0x640b, 0x6bc8, 0x028e, 0x1a04, 0x6ad7, 0x6cc8,
+	0x0006, 0x058f, 0x1d08, 0x6d23, 0x650b, 0x007d, 0x7c01, 0x1d38,
+	0x007c, 0x7c01, 0x1d1c, 0x0006, 0x048b, 0x042c, 0x0454, 0x042b,
+	0x6ad7, 0x6cc8, 0x0006, 0x0007, 0x684c, 0x6144, 0x9b1c, 0x0007,
+	0x68cc, 0x61d0, 0x9b1c, 0x0007, 0x680c, 0x680c, 0x6107, 0x6907,
+	0x692b, 0x6928, 0x0007, 0x680c, 0x0d70, 0x0511, 0x5515, 0x55f5,
+	0x01a5, 0x0dff, 0x0512, 0x1dff, 0x0512, 0x04bd, 0x0499, 0x0454,
+	0x0006, 0x08ff, 0x0011, 0x28ff, 0x0006, 0x038c, 0x0eff, 0x0611,
+	0x2eff, 0x03b6, 0x0006, 0x53d6, 0x0398, 0x5bd6, 0x53ee, 0x0398,
+	0x5bee, 0x0006, 0x52de, 0x53e6, 0x54ee, 0x0498, 0x0454, 0x0006,
+	0x50f6, 0x52c6, 0x53ce, 0x54d6, 0x0498, 0x0454, 0x0006, 0x6207,
+	0x0b70, 0x0311, 0x5013, 0x55f0, 0x02a5, 0x0bff, 0x0312, 0x1bff,
+	0x0312, 0x04bb, 0x049a, 0x0006, 0x1e10, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d39, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9b5b, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d17, 0x6ec3, 0x62c8, 0x7e28, 0x0264, 0x7d08, 0x0b70,
+	0x0311, 0x522b, 0x02b9, 0x4a00, 0x7c18, 0x0400, 0x9b6a, 0x0212,
+	0x3aff, 0x008a, 0x05d8, 0x7d01, 0x008d, 0x0a10, 0x6ed3, 0x6ac8,
+	0xdba5, 0x6a28, 0x7f17, 0x0b70, 0x0311, 0x5013, 0xdbbd, 0x52c0,
+	0x53c8, 0xc10d, 0x7dd0, 0x0200, 0x9b5b, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0xdba5, 0x9b68, 0x0200, 0x9b58, 0x0007, 0x68cc, 0x6a28,
+	0x7f01, 0x9ba3, 0x0007, 0x6a0c, 0x6a0c, 0x6207, 0x6a07, 0x6a2b,
+	0x6a28, 0x0007, 0x680c, 0x0454, 0x9b81, 0x05a0, 0x1e08, 0x6ec3,
+	0x0388, 0x3b03, 0x0015, 0x0015, 0x7802, 0x62c8, 0x6a0b, 0x7ee5,
+	0x6a28, 0x7fe8, 0x0000, 0x6ec1, 0x008b, 0x7802, 0x62c8, 0x6a09,
+	0x7edc, 0x6a28, 0x7fdf, 0x2608, 0x0006, 0x55f0, 0x6207, 0x02a5,
+	0x0dff, 0x0511, 0x1dff, 0x04b5, 0x049a, 0x0006, 0x0870, 0x0011,
+	0x5010, 0xc0ec, 0x7d78, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x9bcc, 0x6d03, 0x6ed3, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x5df8, 0x4d00, 0x7d5e, 0x0b70, 0x0311, 0x522b, 0x5313,
+	0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3f, 0x0400, 0x9bdc, 0x008f,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03, 0x0512, 0x05bc,
+	0x0510, 0x5dd3, 0x4d00, 0x7d27, 0x4d02, 0x7d20, 0x4d01, 0x7d1a,
+	0x0b70, 0x0311, 0x53eb, 0x0360, 0x7d05, 0x6509, 0x7e25, 0x620a,
+	0x7e23, 0x9c06, 0x620a, 0x7e20, 0x6509, 0x7e1e, 0x0512, 0x0512,
+	0x02ad, 0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7ced, 0x0b70, 0x0311,
+	0x5313, 0x9c21, 0x7802, 0x6209, 0x6ac8, 0x9c20, 0x0015, 0x7802,
+	0x620a, 0x6ac8, 0x9c20, 0x0015, 0x0015, 0x7802, 0x620b, 0x6ac8,
+	0x7c03, 0x0000, 0x55db, 0x9bda, 0x0007, 0x68cc, 0x680c, 0x55d3,
+	0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9c2f, 0x0017, 0x0017, 0x55db,
+	0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8,
+	0x04ad, 0x0454, 0x62ff, 0x7ee8, 0x008b, 0x52c0, 0x53c8, 0xc10d,
+	0x7d8b, 0x0200, 0x9bcc, 0x0200, 0x9bc9, 0xc19d, 0xc0ec, 0x7d52,
+	0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa, 0xc0fe,
+	0x56fa, 0x7d02, 0x0200, 0x9c4e, 0x6d03, 0x5bca, 0x5cd2, 0x0bff,
+	0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x0a70, 0x0211, 0x4c00,
+	0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02, 0x0400, 0x9c61, 0x4c01,
+	0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01, 0x008c, 0x0020, 0x04a0,
+	0x0015, 0x7802, 0x650b, 0x5d06, 0x0000, 0x7e0c, 0x7f0d, 0x9c5f,
+	0x650a, 0x7e08, 0x008d, 0x0011, 0x0010, 0x05a8, 0x065f, 0x5d06,
+	0x063f, 0x7f02, 0x0007, 0x680c, 0x0007, 0x5012, 0x54d0, 0x0454,
+	0x9c8b, 0x5012, 0x54d0, 0x0473, 0x7c06, 0x552a, 0x05b9, 0x4d00,
+	0x7c02, 0x0400, 0x9c8d, 0x52c0, 0x53c8, 0xc10d, 0x0288, 0x7db6,
+	0x0200, 0x9c4e, 0x0200, 0x9c46, 0x0870, 0x0011, 0x5010, 0xc0ec,
+	0x7d43, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9ca2, 0x0b70, 0x0311, 0x6ed3, 0x6d03, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x4d00, 0x7d28, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x62c8,
+	0x7e1c, 0x0400, 0x9cb3, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0,
+	0x0060, 0x7c04, 0x6209, 0x7e14, 0x6ac8, 0x7f0f, 0x0015, 0x0060,
+	0x7c04, 0x620a, 0x7e0d, 0x6ac8, 0x7f08, 0x0015, 0x7802, 0x620b,
+	0x6ac8, 0x0000, 0x7e05, 0x7f01, 0x9cb1, 0x0007, 0x68cc, 0x9cda,
+	0x0007, 0x6a0c, 0x0454, 0x62c8, 0x7ef8, 0x5013, 0x52c0, 0x53c8,
+	0xc10d, 0x7dc0, 0x0200, 0x9ca2, 0x0200, 0x9c9f, 0xc19d, 0x0870,
+	0x0011, 0xc0ec, 0x7d29, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x9ced, 0x0870, 0x0011, 0x6d03, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x4d00, 0x7d12, 0x5228, 0x02b9, 0x4a00, 0x7c02,
+	0x0400, 0x9cfc, 0x620b, 0x7e06, 0x5a06, 0x7f06, 0x0000, 0x2504,
+	0x7d05, 0x9cfc, 0x0007, 0x680c, 0x0007, 0x0454, 0x5010, 0x52c0,
+	0xc10d, 0x7ddb, 0x0200, 0x9ced, 0x0200, 0x9ce9, 0xc19d, 0x0870,
+	0x0011, 0xc0ec, 0x7d74, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9d1d, 0x6d03, 0x0d03, 0x0512, 0x05bc,
+	0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x5df8, 0x4d00,
+	0x7d57, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c02,
+	0x0400, 0x9d31, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x5dda,
+	0x55d2, 0x4d00, 0x7d27, 0x4d02, 0x7d20, 0x4d01, 0x7d1a, 0x0a70,
+	0x0211, 0x52ea, 0x0260, 0x7d05, 0x6509, 0x7e25, 0x630a, 0x7e23,
+	0x9d55, 0x630a, 0x7e20, 0x6509, 0x7e1e, 0x0512, 0x0512, 0x03ad,
+	0x5b06, 0x7f19, 0x2003, 0x4800, 0x7ced, 0x0a70, 0x0211, 0x5212,
+	0x9d70, 0x7802, 0x6309, 0x5b06, 0x9d6f, 0x0015, 0x7802, 0x630a,
+	0x5b06, 0x9d6f, 0x0015, 0x0015, 0x7802, 0x630b, 0x5b06, 0x7c03,
+	0x55da, 0x0000, 0x9d2f, 0x0007, 0x680c, 0x55d2, 0x4d00, 0x7d03,
+	0x4d02, 0x7d02, 0x9d7d, 0x0017, 0x0017, 0x55da, 0x009d, 0x55fa,
+	0x05a0, 0x08ff, 0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454,
+	0x008a, 0x52c0, 0x53c8, 0xc10d, 0x7d90, 0x0200, 0x9d1d, 0x0200,
+	0x9d19, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d35, 0x5010, 0x5ac0,
+	0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9d98, 0x0870, 0x0011,
+	0x6d07, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d1c, 0x5228,
+	0x02b9, 0x4a00, 0x7c04, 0x6928, 0x7f0b, 0x0400, 0x9da7, 0x5206,
+	0x7e10, 0x6a0b, 0x6928, 0x7f04, 0x0000, 0x2504, 0x7d0c, 0x9da7,
+	0x0007, 0x680c, 0x680c, 0x6207, 0x6a07, 0x6a2b, 0x6a28, 0x0007,
+	0x680c, 0x0007, 0x0454, 0x6928, 0x7ff3, 0x5010, 0x52c0, 0xc10d,
+	0x7dcf, 0x0200, 0x9d98, 0x0200, 0x9d94, 0xc19d, 0x0870, 0x0011,
+	0xc0ec, 0x7d5e, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x9dd4, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x4d00, 0x7d44, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9,
+	0x4b00, 0x7c04, 0x6a28, 0x7f3a, 0x0400, 0x9de3, 0x008f, 0x05d8,
+	0x7d01, 0x008d, 0x05a0, 0x0b03, 0x0312, 0x03bc, 0x0310, 0x4b00,
+	0x7d1c, 0x4b02, 0x7d20, 0x4b01, 0x7d23, 0x0a70, 0x0211, 0x52ea,
+	0x5306, 0x7e24, 0x0260, 0x7d02, 0x0310, 0x0312, 0x6b09, 0x7f1e,
+	0x0312, 0x6b09, 0x7f1b, 0x0312, 0x6b09, 0x7f18, 0x2003, 0x4800,
+	0x7cef, 0x0a70, 0x0211, 0x5212, 0x9e24, 0x0015, 0x0015, 0x7802,
+	0x5306, 0x6b0b, 0x9e23, 0x0015, 0x7802, 0x5306, 0x6b0a, 0x9e23,
+	0x7802, 0x5306, 0x6b09, 0x7c02, 0x0000, 0x9de1, 0xdb13, 0x6928,
+	0x7ffd, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x7da6, 0x0200, 0x9dd4,
+	0x0200, 0x9dd0, 0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d5b, 0x5ac0,
+	0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9e38, 0x0b70,
+	0x0311, 0x6ec3, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d3d, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x6a28, 0x7f33,
+	0x0400, 0x9e4a, 0x028e, 0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d1b,
+	0x1e94, 0x6ec3, 0x6ed3, 0x62c8, 0x0248, 0x6ac8, 0x2694, 0x6ec3,
+	0x62c8, 0x026e, 0x7d31, 0x6a09, 0x7f1e, 0x2501, 0x4d00, 0x7d1f,
+	0x028e, 0x1a98, 0x6ac3, 0x62c8, 0x6ec3, 0x0260, 0x7df1, 0x6a28,
+	0x7f12, 0xdb47, 0x9e89, 0x6ee3, 0x008f, 0x2001, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d17, 0x6a09, 0x7f04, 0x2001,
+	0x7cf9, 0x0000, 0x9e48, 0x0289, 0xdb13, 0x018a, 0x9e98, 0x6a28,
+	0x7ffa, 0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8, 0xc10d, 0x7da8,
+	0x0200, 0x9e38, 0x0200, 0x9e35, 0x6a28, 0x7fed, 0xdb47, 0x9e98,
+	0x0458, 0x0454, 0x9e89, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d54,
+	0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9ea2, 0x0b70, 0x0311, 0x6d07, 0x5df0, 0x0dff, 0x0511, 0x1dff,
+	0x05bc, 0x4d00, 0x7d36, 0x522b, 0x02b9, 0x4a00, 0x7c04, 0x6928,
+	0x7f2c, 0x0400, 0x9eb3, 0x028e, 0x1a94, 0x5202, 0x0269, 0x7d16,
+	0x1e94, 0x5206, 0x0248, 0x5a06, 0x2694, 0x5206, 0x026e, 0x7d2e,
+	0x6a09, 0x7f1b, 0x2501, 0x4d00, 0x7d1c, 0x028e, 0x1a98, 0x5202,
+	0x0260, 0x7df3, 0x6a28, 0x7f11, 0xdb47, 0x9eeb, 0x008f, 0x2001,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x5206, 0x026e, 0x7d17, 0x6a09,
+	0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9eb1, 0x0289, 0xdb13, 0x018a,
+	0x9efa, 0x6928, 0x7ffa, 0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8,
+	0xc10d, 0x7db0, 0x0200, 0x9ea2, 0x0200, 0x9e9e, 0x6a28, 0x7fed,
+	0xdb47, 0x9efa, 0x0458, 0x0454, 0x9eeb, 0x9eeb
+};
+#endif
--- linux-2.6.19.2/arch/arm/mach-mx3/sdma_script_code_pass2.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/sdma_script_code_pass2.h	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,567 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file sdma_script_code.h
+ * @brief This file contains functions of SDMA scripts code initialization
+ *
+ * The file was generated automatically. Based on sdma scripts library.
+ *
+ * @ingroup SDMA
+ */
+
+#ifndef __SDMA_SCRIPT_CODE_PASS2_H__
+#define __SDMA_SCRIPT_CODE_PASS2_H__
+
+/*!
+* Following define start address of signature script
+*/
+#define signature_ADDR_2	1023
+/*!
+* Following define size of signature script
+*/
+#define signature_SIZE_2	1
+
+/*!
+* Following define start address of start script
+*/
+#define start_ADDR_2	0
+/*!
+* Following define size of start script
+*/
+#define start_SIZE_2	20
+
+/*!
+* Following define start address of core script
+*/
+#define core_ADDR_2	80
+/*!
+* Following define size of core script
+*/
+#define core_SIZE_2	152
+
+/*!
+* Following define start address of common script
+*/
+#define common_ADDR_2	232
+/*!
+* Following define size of common script
+*/
+#define common_SIZE_2	191
+
+/*!
+* Following define start address of ap_2_ap script
+*/
+#define ap_2_ap_ADDR_2	423
+/*!
+* Following define size of ap_2_ap script
+*/
+#define ap_2_ap_SIZE_2	294
+
+/*!
+* Following define start address of bp_2_bp script
+*/
+#define bp_2_bp_ADDR_2	717
+/*!
+* Following define size of bp_2_bp script
+*/
+#define bp_2_bp_SIZE_2	112
+
+/*!
+* Following define start address of ap_2_bp script
+*/
+#define ap_2_bp_ADDR_2	829
+/*!
+* Following define size of ap_2_bp script
+*/
+#define ap_2_bp_SIZE_2	200
+
+/*!
+* Following define start address of bp_2_ap script
+*/
+#define bp_2_ap_ADDR_2	1029
+/*!
+* Following define size of bp_2_ap script
+*/
+#define bp_2_ap_SIZE_2	223
+
+/*!
+* Following define start address of app_2_mcu script
+*/
+#define app_2_mcu_ADDR_2	1252
+/*!
+* Following define size of app_2_mcu script
+*/
+#define app_2_mcu_SIZE_2	101
+
+/*!
+* Following define start address of mcu_2_app script
+*/
+#define mcu_2_app_ADDR_2	1353
+/*!
+* Following define size of mcu_2_app script
+*/
+#define mcu_2_app_SIZE_2	127
+
+/*!
+* Following define start address of uart_2_mcu script
+*/
+#define uart_2_mcu_ADDR_2	1480
+/*!
+* Following define size of uart_2_mcu script
+*/
+#define uart_2_mcu_SIZE_2	105
+
+/*!
+* Following define start address of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_ADDR_2	1585
+/*!
+* Following define size of uartsh_2_mcu script
+*/
+#define uartsh_2_mcu_SIZE_2	98
+
+/*!
+* Following define start address of mcu_2_shp script
+*/
+#define mcu_2_shp_ADDR_2	1683
+/*!
+* Following define size of mcu_2_shp script
+*/
+#define mcu_2_shp_SIZE_2	123
+
+/*!
+* Following define start address of shp_2_mcu script
+*/
+#define shp_2_mcu_ADDR_2	1806
+/*!
+* Following define size of shp_2_mcu script
+*/
+#define shp_2_mcu_SIZE_2	101
+
+/*!
+* Following define start address of error script
+*/
+#define error_ADDR_2	1907
+/*!
+* Following define size of error script
+*/
+#define error_SIZE_2	73
+
+/*!
+* Following define start address of test script
+*/
+#define test_ADDR_2	1980
+/*!
+* Following define size of test script
+*/
+#define test_SIZE_2	63
+
+/*!
+* Following define start address of app_2_per script
+*/
+#define app_2_per_ADDR_2	6144
+/*!
+* Following define size of app_2_per script
+*/
+#define app_2_per_SIZE_2	103
+
+/*!
+* Following define start address of ata_2_mcu script
+*/
+#define ata_2_mcu_ADDR_2	6247
+/*!
+* Following define size of ata_2_mcu script
+*/
+#define ata_2_mcu_SIZE_2	110
+
+/*!
+* Following define start address of dptc_dvfs script
+*/
+#define dptc_dvfs_ADDR_2	6357
+/*!
+* Following define size of dptc_dvfs script
+*/
+#define dptc_dvfs_SIZE_2	274
+
+/*!
+* Following define start address of firi_2_mcu script
+*/
+#define firi_2_mcu_ADDR_2	6631
+/*!
+* Following define size of firi_2_mcu script
+*/
+#define firi_2_mcu_SIZE_2	114
+
+/*!
+* Following define start address of firi_2_per script
+*/
+#define firi_2_per_ADDR_2	6745
+/*!
+* Following define size of firi_2_per script
+*/
+#define firi_2_per_SIZE_2	173
+
+/*!
+* Following define start address of mcu_2_ata script
+*/
+#define mcu_2_ata_ADDR_2	6918
+/*!
+* Following define size of mcu_2_ata script
+*/
+#define mcu_2_ata_SIZE_2	87
+
+/*!
+* Following define start address of mcu_2_firi script
+*/
+#define mcu_2_firi_ADDR_2	7005
+/*!
+* Following define size of mcu_2_firi script
+*/
+#define mcu_2_firi_SIZE_2	74
+
+/*!
+* Following define start address of mcu_2_mshc script
+*/
+#define mcu_2_mshc_ADDR_2	7079
+/*!
+* Following define size of mcu_2_mshc script
+*/
+#define mcu_2_mshc_SIZE_2	48
+
+/*!
+* Following define start address of mshc_2_mcu script
+*/
+#define mshc_2_mcu_ADDR_2	7127
+/*!
+* Following define size of mshc_2_mcu script
+*/
+#define mshc_2_mcu_SIZE_2	60
+
+/*!
+* Following define start address of mshc_2_per script
+*/
+#define mshc_2_per_ADDR_2	7187
+/*!
+* Following define size of mshc_2_per script
+*/
+#define mshc_2_per_SIZE_2	52
+
+/*!
+* Following define start address of per_2_app script
+*/
+#define per_2_app_ADDR_2	7239
+/*!
+* Following define size of per_2_app script
+*/
+#define per_2_app_SIZE_2	129
+
+/*!
+* Following define start address of per_2_firi script
+*/
+#define per_2_firi_ADDR_2	7368
+/*!
+* Following define size of per_2_firi script
+*/
+#define per_2_firi_SIZE_2	70
+
+/*!
+* Following define start address of per_2_mshc script
+*/
+#define per_2_mshc_ADDR_2	7438
+/*!
+* Following define size of per_2_mshc script
+*/
+#define per_2_mshc_SIZE_2	48
+
+/*!
+* Following define start address of per_2_shp script
+*/
+#define per_2_shp_ADDR_2	7486
+/*!
+* Following define size of per_2_shp script
+*/
+#define per_2_shp_SIZE_2	129
+
+/*!
+* Following define start address of shp_2_per script
+*/
+#define shp_2_per_ADDR_2	7615
+/*!
+* Following define size of shp_2_per script
+*/
+#define shp_2_per_SIZE_2	104
+
+/*!
+* Following define start address of uart_2_per script
+*/
+#define uart_2_per_ADDR_2	7719
+/*!
+* Following define size of uart_2_per script
+*/
+#define uart_2_per_SIZE_2	123
+
+/*!
+* Following define start address of uartsh_2_per script
+*/
+#define uartsh_2_per_ADDR_2	7842
+/*!
+* Following define size of uartsh_2_per script
+*/
+#define uartsh_2_per_SIZE_2	109
+
+/*!
+* Following define the start address of sdma ram
+*/
+
+#define RAM_CODE_START_ADDR_2	6144
+/*!
+* Following define the size of sdma ram
+*/
+#define RAM_CODE_SIZE_2	1807
+
+/*!
+* This function returns buffer that holds the image of SDMA RAM
+*
+* @return pointer to buffer that holds the image of SDMA RAM
+*/
+
+static const short sdma_code_2[] = {
+	0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d60, 0x5ac0, 0x5bc8, 0x5ef8,
+	0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9806, 0x6ec3, 0x6dd7, 0x5df0,
+	0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d46, 0x0b70, 0x0311,
+	0x522b, 0x5313, 0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e3c, 0x0400,
+	0x9816, 0x008f, 0x00d5, 0x7d01, 0x008d, 0x05a0, 0x0a03, 0x0212,
+	0x02bc, 0x0210, 0x4a00, 0x7d28, 0x4a02, 0x7d20, 0x4a01, 0x7d19,
+	0x6ddd, 0x0b70, 0x0311, 0x53eb, 0x62c8, 0x7e25, 0x0360, 0x7d02,
+	0x0210, 0x0212, 0x6ac8, 0x7f1f, 0x0212, 0x6ac8, 0x7f1c, 0x0212,
+	0x6ac8, 0x7f19, 0x2003, 0x4800, 0x7cef, 0x0b70, 0x0311, 0x5313,
+	0x9859, 0x6ddd, 0x7802, 0x62c8, 0x6ac8, 0x9858, 0x6dde, 0x0015,
+	0x7802, 0x62c8, 0x6ac8, 0x9858, 0x0015, 0x0015, 0x7801, 0x62d8,
+	0x7c02, 0x0000, 0x9814, 0xc777, 0x62ff, 0x7efd, 0x008b, 0x52c3,
+	0x53cb, 0xc10d, 0x7da3, 0x0200, 0x9806, 0x0200, 0x9803, 0xc19d,
+	0xc0ec, 0x7d69, 0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da,
+	0x5efa, 0xc0fe, 0x56fa, 0x7d02, 0x0200, 0x9870, 0x6d07, 0x5bca,
+	0x5cd2, 0x0bff, 0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x4c00,
+	0x7d47, 0x0a70, 0x0211, 0x552a, 0x5212, 0x008d, 0x00bb, 0x4800,
+	0x7c07, 0x05b9, 0x4d00, 0x7c13, 0x6928, 0x7f2d, 0x0400, 0x9881,
+	0x008f, 0x0015, 0x04d8, 0x7d01, 0x008c, 0x04a0, 0x0015, 0x7802,
+	0x55c6, 0x6d0b, 0x7e29, 0x6d28, 0x7f1e, 0x0000, 0x987f, 0x1e20,
+	0x5506, 0x2620, 0x008d, 0x0560, 0x7c08, 0x065f, 0x55c6, 0x063f,
+	0x7e1b, 0x6d0a, 0x7f10, 0x4c00, 0x7d1b, 0x04d8, 0x7d02, 0x008c,
+	0x0020, 0x04a0, 0x0015, 0x7802, 0x55c6, 0x6d0b, 0x7e0d, 0x6d28,
+	0x7f02, 0x0000, 0x98c8, 0x0007, 0x680c, 0x6d0c, 0x6507, 0x6d07,
+	0x6d2b, 0x6d28, 0x0007, 0x680c, 0x0007, 0x54d2, 0x0454, 0x98cb,
+	0x6928, 0x7ff1, 0x54d2, 0x008a, 0x52c0, 0x53c8, 0xc10d, 0x0288,
+	0x7d9f, 0x0200, 0x9870, 0x0200, 0x9868, 0xc0ec, 0x7d72, 0x0800,
+	0x0970, 0x0111, 0x5111, 0x5ac1, 0x5bc9, 0x028e, 0xc0fe, 0x068a,
+	0x7c6a, 0x5dd9, 0x5ce1, 0x0bff, 0x0311, 0x1bff, 0x03bc, 0x5bd1,
+	0x1a5c, 0x6ac3, 0x63c8, 0x0363, 0x7c05, 0x036f, 0x7d27, 0x0374,
+	0x7c7a, 0x994d, 0xd9e0, 0x3c06, 0x4c00, 0x7df7, 0x028f, 0x1a04,
+	0x6a23, 0x620b, 0x6f23, 0x301f, 0x00aa, 0x0462, 0x7c04, 0x4a00,
+	0x7d0b, 0x2001, 0x990c, 0x048a, 0x620b, 0x2201, 0x1c01, 0x1801,
+	0x02dc, 0x7d02, 0x301f, 0x00aa, 0x048f, 0x1c04, 0x6c07, 0x0488,
+	0x3c1f, 0x6c2b, 0x0045, 0x028e, 0x1a5c, 0x98ed, 0x058f, 0x1d0c,
+	0x6d23, 0x650b, 0x007d, 0x7c01, 0x1d08, 0x007c, 0x7c01, 0x1d04,
+	0x6d23, 0x650b, 0x0488, 0x3c1f, 0x0417, 0x0417, 0x0417, 0x0417,
+	0x059c, 0x6d23, 0x028e, 0x1a34, 0x6ad7, 0x0488, 0x0804, 0x7802,
+	0x650b, 0x6dc8, 0x008c, 0x1a28, 0x6ad7, 0x63c8, 0x034c, 0x6bc8,
+	0x54d1, 0x4c00, 0x7d06, 0x0065, 0x7c02, 0x0101, 0x0025, 0x0400,
+	0x98e9, 0x52c1, 0x53c9, 0x54e1, 0x0453, 0xc10d, 0x7d95, 0x0200,
+	0x98dc, 0x0200, 0x98d5, 0x0200, 0x98dc, 0x55d9, 0x6d07, 0x54d1,
+	0x058a, 0x2508, 0x6dc7, 0x0373, 0x7c03, 0x65c8, 0x6d0b, 0x2408,
+	0x0372, 0x7c04, 0x65c8, 0x6d0b, 0x2408, 0x9962, 0x6cce, 0x65c8,
+	0x6d0a, 0x2404, 0x6d28, 0x6507, 0x5dd9, 0x5cd1, 0x6ad7, 0x6ae3,
+	0x63c8, 0x0334, 0x6bc8, 0x0370, 0x7ca9, 0x0c60, 0x0411, 0x04bb,
+	0x4c00, 0x7da4, 0x0410, 0x1c30, 0x0410, 0x04bb, 0x046d, 0x7d0a,
+	0x047d, 0x7c03, 0x047c, 0x7c01, 0x9916, 0x003b, 0x003a, 0x0039,
+	0x0058, 0x9991, 0x047d, 0x7d03, 0x047c, 0x7d01, 0x9916, 0x005b,
+	0xd9d5, 0x1d18, 0x6d23, 0x650b, 0x0510, 0x003a, 0x0039, 0x0038,
+	0x00ad, 0xd9e0, 0x0c30, 0x0410, 0x04bb, 0x003c, 0x003d, 0x00ac,
+	0xd9d5, 0x007b, 0x7c04, 0x003d, 0x003c, 0x1d0c, 0x99b2, 0x048f,
+	0x1c14, 0x6c23, 0x640b, 0x4401, 0x7d04, 0x005d, 0x005c, 0x1d0c,
+	0x99b2, 0x0310, 0x3b30, 0x4b30, 0x7d01, 0x1b10, 0x0310, 0x003d,
+	0x003c, 0x00ab, 0x6ad7, 0x63c8, 0x6d23, 0x650b, 0x0560, 0x7d03,
+	0x005e, 0xd9c9, 0x9916, 0x003e, 0x0c80, 0x0410, 0x0394, 0xd9c9,
+	0x640b, 0x037f, 0x7d02, 0x1a14, 0x99c6, 0x1a0c, 0x6ad7, 0x6cc8,
+	0x9916, 0x0c7f, 0x0410, 0x03b4, 0x04b8, 0x03ac, 0x640b, 0x6bc8,
+	0x028e, 0x1a04, 0x6ad7, 0x6cc8, 0x0006, 0x058f, 0x1d08, 0x6d23,
+	0x650b, 0x007d, 0x7c01, 0x1d38, 0x007c, 0x7c01, 0x1d1c, 0x0006,
+	0x048b, 0x042c, 0x0454, 0x042b, 0x6ad7, 0x6cc8, 0x0006, 0x1e10,
+	0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d39, 0x5ac0, 0x5bc8, 0x5ef8,
+	0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x99ee, 0x6d07, 0x5df0, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d17, 0x6ec3, 0x62c8, 0x7e28,
+	0x0264, 0x7d08, 0x0b70, 0x0311, 0x522b, 0x02b9, 0x4a00, 0x7c18,
+	0x0400, 0x99fd, 0x0212, 0x3aff, 0x008a, 0x05d8, 0x7d01, 0x008d,
+	0x0a10, 0x6ed3, 0x6ac8, 0xda38, 0x6a28, 0x7f17, 0x0b70, 0x0311,
+	0x5013, 0xda50, 0x52c0, 0x53c8, 0xc10d, 0x7dd0, 0x0200, 0x99ee,
+	0x008f, 0x00d5, 0x7d01, 0x008d, 0xda38, 0x99fb, 0x0200, 0x99eb,
+	0x0007, 0x68cc, 0x6a28, 0x7f01, 0x9a36, 0x0007, 0x6a0c, 0x6a0c,
+	0x6207, 0x6a07, 0x6a2b, 0x6a28, 0x0007, 0x680c, 0x0454, 0x9a14,
+	0x05a0, 0x1e08, 0x6ec3, 0x0388, 0x3b03, 0x0015, 0x0015, 0x7802,
+	0x62c8, 0x6a0b, 0x7ee5, 0x6a28, 0x7fe8, 0x0000, 0x6ec1, 0x008b,
+	0x7802, 0x62c8, 0x6a09, 0x7edc, 0x6a28, 0x7fdf, 0x2608, 0x0006,
+	0x55f0, 0x6207, 0x02a5, 0x0dff, 0x0511, 0x1dff, 0x04b5, 0x049a,
+	0x0006, 0x1e10, 0x0870, 0x0011, 0x5010, 0xc0ec, 0x7c02, 0x0200,
+	0x9a5d, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200,
+	0x9a62, 0x6dd7, 0x0b70, 0x0311, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d65, 0x6ec3, 0x522b, 0x02b9, 0x4a00, 0x7d2c, 0x62c8,
+	0x7e6c, 0x0264, 0x7c46, 0x0212, 0x3aff, 0x008a, 0x05d8, 0x7d03,
+	0x008d, 0x0b01, 0x9a89, 0x0a10, 0x63d0, 0x6ed3, 0x6ac8, 0x6bd7,
+	0x0b00, 0xdaee, 0x4b00, 0x0b70, 0x0311, 0x7c49, 0x0478, 0x7d28,
+	0x522b, 0x02b9, 0x4a00, 0x7cdc, 0x62ff, 0x7e4f, 0x4d00, 0x7c09,
+	0x5013, 0x52c0, 0x53c8, 0x04a5, 0xc10d, 0x7d01, 0x0201, 0x0400,
+	0x9a62, 0x0400, 0x9a70, 0x62c8, 0x7e40, 0x0212, 0x3aff, 0x008a,
+	0x0b00, 0x00d5, 0x7d07, 0x008d, 0x0a10, 0x63d0, 0x6ed3, 0x6ac8,
+	0x6bd7, 0x0b01, 0xdaee, 0x4b00, 0x0b70, 0x0311, 0x7d01, 0x9ad7,
+	0x62ff, 0x7e2b, 0x5013, 0x52c0, 0x53c8, 0x04a5, 0xc10d, 0x0200,
+	0x9a62, 0x008f, 0x00d5, 0x7d01, 0x008d, 0xdaee, 0x522b, 0x02b9,
+	0x4a00, 0x7ca6, 0x62ff, 0x7e19, 0x4d00, 0x7c15, 0x5013, 0x52c0,
+	0x53c8, 0x04a5, 0xc10d, 0x7d01, 0x0201, 0x0400, 0x9a62, 0x62ff,
+	0x7e0c, 0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8, 0x04a5, 0xc10d,
+	0x7d81, 0x0200, 0x9a62, 0x0400, 0x9a70, 0x0007, 0x6aff, 0x0454,
+	0x5013, 0x52c0, 0x53c8, 0xc10d, 0x0200, 0x9a62, 0x05a0, 0x1e08,
+	0x6ec1, 0x0060, 0x7c03, 0x6edd, 0x62d8, 0x7eef, 0x0015, 0x0060,
+	0x7c04, 0x6ece, 0x6ede, 0x62d8, 0x7ee8, 0x6ecf, 0x6edf, 0x0015,
+	0x7801, 0x62d8, 0x0000, 0x7ee1, 0x2608, 0x0006, 0xc19d, 0xc0ec,
+	0x7d52, 0x0c70, 0x0411, 0x5414, 0x5ac4, 0x028c, 0x58da, 0x5efa,
+	0xc0fe, 0x56fa, 0x7d02, 0x0200, 0x9b0f, 0x6d03, 0x5bca, 0x5cd2,
+	0x0bff, 0x0311, 0x1bff, 0x04bb, 0x0415, 0x53da, 0x0a70, 0x0211,
+	0x4c00, 0x7d28, 0x552a, 0x05bb, 0x4d00, 0x7c02, 0x0400, 0x9b22,
+	0x4c01, 0x7d0f, 0x008f, 0x0015, 0x04d8, 0x7d01, 0x008c, 0x0020,
+	0x04a0, 0x0015, 0x7802, 0x650b, 0x5d06, 0x0000, 0x7e0c, 0x7f0d,
+	0x9b20, 0x650a, 0x7e08, 0x008d, 0x0011, 0x0010, 0x05a8, 0x065f,
+	0x5d06, 0x063f, 0x7f02, 0x0007, 0x680c, 0x0007, 0x5012, 0x54d0,
+	0x0454, 0x9b4c, 0x5012, 0x54d0, 0x0473, 0x7c06, 0x552a, 0x05b9,
+	0x4d00, 0x7c02, 0x0400, 0x9b4e, 0x52c0, 0x53c8, 0xc10d, 0x0288,
+	0x7db6, 0x0200, 0x9b0f, 0x0200, 0x9b07, 0x0870, 0x0011, 0x5010,
+	0xc0ec, 0x7d43, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02,
+	0x0200, 0x9b63, 0x0b70, 0x0311, 0x6ed3, 0x6d03, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x4d00, 0x7d28, 0x522b, 0x02b9, 0x4a00, 0x7c04,
+	0x62c8, 0x7e1c, 0x0400, 0x9b74, 0x008f, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x0060, 0x7c04, 0x6209, 0x7e14, 0x6ac8, 0x7f0f, 0x0015,
+	0x0060, 0x7c04, 0x620a, 0x7e0d, 0x6ac8, 0x7f08, 0x0015, 0x7802,
+	0x620b, 0x6ac8, 0x0000, 0x7e05, 0x7f01, 0x9b72, 0x0007, 0x68cc,
+	0x9b9b, 0x0007, 0x6a0c, 0x0454, 0x62c8, 0x7ef8, 0x5013, 0x52c0,
+	0x53c8, 0xc10d, 0x7dc0, 0x0200, 0x9b63, 0x0200, 0x9b60, 0xc19d,
+	0x0870, 0x0011, 0xc0ec, 0x7d29, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9bae, 0x0870, 0x0011, 0x6d03, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d12, 0x5228, 0x02b9, 0x4a00,
+	0x7c02, 0x0400, 0x9bbd, 0x620b, 0x7e06, 0x5a06, 0x7f06, 0x0000,
+	0x2504, 0x7d05, 0x9bbd, 0x0007, 0x680c, 0x0007, 0x0454, 0x5010,
+	0x52c0, 0xc10d, 0x7ddb, 0x0200, 0x9bae, 0x0200, 0x9baa, 0xc19d,
+	0x0870, 0x0011, 0xc0ec, 0x7d35, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9bde, 0x0870, 0x0011, 0x6d07, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d1c, 0x5228, 0x02b9, 0x4a00,
+	0x7c04, 0x6928, 0x7f0b, 0x0400, 0x9bed, 0x5206, 0x7e10, 0x6a0b,
+	0x6928, 0x7f04, 0x0000, 0x2504, 0x7d0c, 0x9bed, 0x0007, 0x680c,
+	0x680c, 0x6207, 0x6a07, 0x6a2b, 0x6a28, 0x0007, 0x680c, 0x0007,
+	0x0454, 0x6928, 0x7ff3, 0x5010, 0x52c0, 0xc10d, 0x7dcf, 0x0200,
+	0x9bde, 0x0200, 0x9bda, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d2d,
+	0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9c1a,
+	0x0870, 0x0011, 0x6dd7, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00,
+	0x7d14, 0x5228, 0x02b9, 0x4b00, 0x7c04, 0x62c8, 0x7e0a, 0x0400,
+	0x9c29, 0x5206, 0x7e08, 0x6ac8, 0x7f04, 0x0000, 0x2504, 0x7d05,
+	0x9c29, 0x0007, 0x68ff, 0x0007, 0x0454, 0x62c8, 0x7efa, 0x5010,
+	0x52c0, 0xc10d, 0x7dd7, 0x0200, 0x9c1a, 0x0200, 0x9c16, 0x0870,
+	0x0011, 0x5010, 0xc0ec, 0x7d7a, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9c4d, 0x6ed3, 0x6dc5, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x5df8, 0x4d00, 0x7d60, 0x0b70, 0x0311, 0x522b,
+	0x5313, 0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9c5d, 0x008f, 0x00d5,
+	0x7d01, 0x008d, 0x05a0, 0x5ddb, 0x0d03, 0x0512, 0x05bc, 0x0510,
+	0x5dd3, 0x4d00, 0x7d2c, 0x4d02, 0x7d24, 0x4d01, 0x7d1e, 0x59e3,
+	0x0b70, 0x0311, 0x53eb, 0x61c8, 0x7e2b, 0x62c8, 0x7e29, 0x65c8,
+	0x7e27, 0x0360, 0x7d03, 0x0112, 0x0112, 0x9c88, 0x0512, 0x0512,
+	0x0211, 0x02a9, 0x02ad, 0x6ac8, 0x7f1b, 0x2003, 0x4800, 0x7ceb,
+	0x0b70, 0x0311, 0x5313, 0x51e3, 0x9ca5, 0x7802, 0x62c8, 0x6ac8,
+	0x9ca4, 0x6dce, 0x0015, 0x7802, 0x62c8, 0x6ac8, 0x9ca4, 0x6dcf,
+	0x0015, 0x0015, 0x7801, 0x62d8, 0x7c03, 0x0000, 0x55db, 0x9c5b,
+	0x0007, 0x68ff, 0x55d3, 0x4d00, 0x7d03, 0x4d02, 0x7d02, 0x9cb2,
+	0x0017, 0x0017, 0x55db, 0x009d, 0x55fb, 0x05a0, 0x08ff, 0x0011,
+	0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454, 0x62c8, 0x7ee9, 0x008b,
+	0x52c3, 0x53cb, 0xc10d, 0x7d89, 0x0200, 0x9c4d, 0x0200, 0x9c4a,
+	0x0870, 0x0011, 0x5010, 0xc0ec, 0x7d3f, 0x5ac0, 0x5bc8, 0x5ef8,
+	0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9cce, 0x0b70, 0x0311, 0x6ed3,
+	0x6dc7, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d24, 0x522b,
+	0x02b9, 0x4a00, 0x7c02, 0x0400, 0x9cdf, 0x008f, 0x00d5, 0x7d01,
+	0x008d, 0x05a0, 0x6ecd, 0x0060, 0x7c04, 0x62c8, 0x7e11, 0x6ac8,
+	0x7f0f, 0x0015, 0x0060, 0x7c05, 0x6ece, 0x62c8, 0x7e09, 0x6ac8,
+	0x7f07, 0x6ecf, 0x0015, 0x7801, 0x62d8, 0x0000, 0x7e01, 0x9cdd,
+	0x0007, 0x68cc, 0x0454, 0x62ff, 0x7efb, 0x5013, 0x52c0, 0x53c8,
+	0xc10d, 0x7dc4, 0x0200, 0x9cce, 0x0200, 0x9ccb, 0xc19d, 0x0870,
+	0x0011, 0xc0ec, 0x7d29, 0x5010, 0x5ac0, 0x5ef8, 0xc0fe, 0x56f8,
+	0x7d02, 0x0200, 0x9d15, 0x0870, 0x0011, 0x6dc7, 0x0dff, 0x0511,
+	0x1dff, 0x05bc, 0x4d00, 0x7d12, 0x5228, 0x02b9, 0x4a00, 0x7c02,
+	0x0400, 0x9d24, 0x62c8, 0x7e06, 0x5a06, 0x7f06, 0x0000, 0x2504,
+	0x7d05, 0x9d24, 0x0007, 0x68ff, 0x0007, 0x0454, 0x5010, 0x52c0,
+	0xc10d, 0x7ddb, 0x0200, 0x9d15, 0x0200, 0x9d11, 0xc19d, 0x0870,
+	0x0011, 0xc0ec, 0x7d7a, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9d45, 0x6dc5, 0x0d03, 0x0512, 0x05bc,
+	0x0510, 0x5dd0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x5df8, 0x4d00,
+	0x7d5d, 0x0a70, 0x0211, 0x532a, 0x5212, 0x03b9, 0x4b00, 0x7c02,
+	0x0400, 0x9d59, 0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x5dda,
+	0x55d2, 0x4d00, 0x7d2c, 0x4d02, 0x7d24, 0x4d01, 0x7d1e, 0x59e2,
+	0x0a70, 0x0211, 0x52ea, 0x61c8, 0x7e2c, 0x63c8, 0x7e2a, 0x65c8,
+	0x7e28, 0x0260, 0x7d03, 0x0112, 0x0112, 0x9d80, 0x0512, 0x0512,
+	0x0311, 0x03a9, 0x03ad, 0x5b06, 0x7f1c, 0x2003, 0x4800, 0x7ceb,
+	0x0a70, 0x0211, 0x5212, 0x51e2, 0x9d9e, 0x7802, 0x63c8, 0x5b06,
+	0x9d9d, 0x6dce, 0x0015, 0x7802, 0x63c8, 0x5b06, 0x9d9d, 0x6dcf,
+	0x0015, 0x0015, 0x7802, 0x63c8, 0x5b06, 0x7c03, 0x55da, 0x0000,
+	0x9d57, 0x0007, 0x68ff, 0x55d2, 0x4d00, 0x7d03, 0x4d02, 0x7d02,
+	0x9dab, 0x0017, 0x0017, 0x55da, 0x009d, 0x55fa, 0x05a0, 0x08ff,
+	0x0011, 0x18ff, 0x0010, 0x04b8, 0x04ad, 0x0454, 0x008a, 0x52c0,
+	0x53c8, 0xc10d, 0x7d8a, 0x0200, 0x9d45, 0x0200, 0x9d41, 0xc19d,
+	0x0870, 0x0011, 0xc0ec, 0x7d61, 0x5010, 0x5ac0, 0x5bc8, 0x5ef8,
+	0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9dc6, 0x6dd7, 0x5df0, 0x0dff,
+	0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d47, 0x0a70, 0x0211, 0x532a,
+	0x5212, 0x03b9, 0x4b00, 0x7c04, 0x63c8, 0x7e3d, 0x0400, 0x9dd5,
+	0x008f, 0x05d8, 0x7d01, 0x008d, 0x05a0, 0x0b03, 0x0312, 0x03bc,
+	0x0310, 0x4b00, 0x7d28, 0x4b02, 0x7d20, 0x4b01, 0x7d19, 0x6ddd,
+	0x0a70, 0x0211, 0x52ea, 0x5306, 0x7e26, 0x0260, 0x7d02, 0x0310,
+	0x0312, 0x6bc8, 0x7f20, 0x0312, 0x6bc8, 0x7f1d, 0x0312, 0x6bc8,
+	0x7f1a, 0x2003, 0x4800, 0x7cef, 0x0a70, 0x0211, 0x5212, 0x9e19,
+	0x6ddd, 0x7802, 0x5306, 0x6bc8, 0x9e18, 0x6dde, 0x0015, 0x7802,
+	0x5306, 0x6bc8, 0x9e18, 0x0015, 0x0015, 0x7802, 0x5306, 0x6bc8,
+	0x7c02, 0x0000, 0x9dd3, 0xc777, 0x63c8, 0x7efd, 0x008a, 0x52c0,
+	0x53c8, 0xc10d, 0x7da3, 0x0200, 0x9dc6, 0x0200, 0x9dc2, 0x0870,
+	0x0011, 0x5010, 0xc0ec, 0x7d60, 0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe,
+	0x56f8, 0x7d02, 0x0200, 0x9e2d, 0x0b70, 0x0311, 0x6ec3, 0x6dd5,
+	0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc, 0x4d00, 0x7d42, 0x522b,
+	0x02b9, 0x4a00, 0x7c04, 0x62ff, 0x7e38, 0x0400, 0x9e3f, 0x028e,
+	0x1a94, 0x6ac3, 0x62c8, 0x0269, 0x7d20, 0x1e94, 0x6ee3, 0x5313,
+	0x62d0, 0x5aeb, 0x62c8, 0x0248, 0x6ed3, 0x6ac8, 0x2694, 0x52eb,
+	0x6ad5, 0x6ee3, 0x0b70, 0x0311, 0x62c8, 0x026e, 0x7d2f, 0x6ac8,
+	0x7f1c, 0x2501, 0x4d00, 0x7d1d, 0x028e, 0x1a98, 0x6ac3, 0x62c8,
+	0x6ec3, 0x0260, 0x7df1, 0xde90, 0x9e83, 0x6ee3, 0x008f, 0x2001,
+	0x00d5, 0x7d01, 0x008d, 0x05a0, 0x62c8, 0x026e, 0x7d17, 0x6ac8,
+	0x7f04, 0x2001, 0x7cf9, 0x0000, 0x9e3d, 0x0007, 0x6aff, 0xde92,
+	0x9e9f, 0x62ff, 0x7efa, 0x0b70, 0x0311, 0x5013, 0x52c0, 0x53c8,
+	0xc10d, 0x7da3, 0x0200, 0x9e2d, 0x0200, 0x9e2a, 0xde90, 0x9e9f,
+	0x62ff, 0x7eeb, 0x62d0, 0x0b70, 0x0311, 0x5013, 0x55f0, 0x02a5,
+	0x0bff, 0x0312, 0x1bff, 0x0312, 0x04bb, 0x049a, 0x0006, 0x0458,
+	0x0454, 0x9e83, 0xc19d, 0x0870, 0x0011, 0xc0ec, 0x7d52, 0x5010,
+	0x5ac0, 0x5bc8, 0x5ef8, 0xc0fe, 0x56f8, 0x7d02, 0x0200, 0x9ea9,
+	0x0a70, 0x0211, 0x6dd5, 0x5df0, 0x0dff, 0x0511, 0x1dff, 0x05bc,
+	0x4d00, 0x7d34, 0x532a, 0x03b9, 0x4b00, 0x7c04, 0x63c8, 0x7e2a,
+	0x0400, 0x9eba, 0x038e, 0x1b94, 0x5303, 0x0369, 0x7d14, 0x1e94,
+	0x5306, 0x0348, 0x5b06, 0x2694, 0x5306, 0x036e, 0x7d2c, 0x6bc8,
+	0x7f19, 0x2501, 0x4d00, 0x7d1a, 0x038e, 0x1b98, 0x5303, 0x0360,
+	0x7df3, 0xdefd, 0x9ef0, 0x008f, 0x2001, 0x00d5, 0x7d01, 0x008d,
+	0x05a0, 0x5306, 0x036e, 0x7d17, 0x6bc8, 0x7f04, 0x2001, 0x7cf9,
+	0x0000, 0x9eb8, 0x0007, 0x6bff, 0xdeff, 0x9f0c, 0x63c8, 0x7efa,
+	0x0a70, 0x0211, 0x5012, 0x52c0, 0x53c8, 0xc10d, 0x7db2, 0x0200,
+	0x9ea9, 0x0200, 0x9ea5, 0xdefd, 0x9f0c, 0x63c8, 0x7eeb, 0x63d0,
+	0x0a70, 0x0211, 0x5012, 0x55f0, 0x03a5, 0x0aff, 0x0212, 0x1aff,
+	0x0212, 0x04ba, 0x049b, 0x0006, 0x0458, 0x0454, 0x9ef0, 0x9ef0
+};
+#endif
--- linux-2.6.19.2/arch/arm/mach-mx3/serial.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/serial.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,252 @@
+/*
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file serial.c
+ *
+ * @brief This file contains the UART initiliazation.
+ *
+ * @ingroup System
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <asm/hardware.h>
+#include <asm/arch/mxc_uart.h>
+#include <asm/arch/spba.h>
+#include "serial.h"
+
+#if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
+
+/*!
+ * This is an array where each element holds information about a UART port,
+ * like base address of the UART, interrupt numbers etc. This structure is
+ * passed to the serial_core.c file. Based on which UART is used, the core file
+ * passes back the appropriate port structure as an argument to the control
+ * functions.
+ */
+static uart_mxc_port mxc_ports[] = {
+	[0] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART1_BASE_ADDR),
+			.mapbase = UART1_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART1_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 0,
+			},
+	       .ints_muxed = UART1_MUX_INTS,
+	       .irqs = {UART1_INT2, UART1_INT3},
+	       .mode = UART1_MODE,
+	       .ir_mode = UART1_IR,
+	       .enabled = UART1_ENABLED,
+	       .hardware_flow = UART1_HW_FLOW,
+	       .cts_threshold = UART1_UCR4_CTSTL,
+	       .dma_enabled = UART1_DMA_ENABLE,
+	       .dma_rxbuf_size = UART1_DMA_RXBUFSIZE,
+	       .rx_threshold = UART1_UFCR_RXTL,
+	       .tx_threshold = UART1_UFCR_TXTL,
+	       .shared = UART1_SHARED_PERI,
+	       .clock_id = UART1_BAUD,
+	       .dma_tx_id = MXC_DMA_UART1_TX,
+	       .dma_rx_id = MXC_DMA_UART1_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[1] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART2_BASE_ADDR),
+			.mapbase = UART2_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART2_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 1,
+			},
+	       .ints_muxed = UART2_MUX_INTS,
+	       .irqs = {UART2_INT2, UART2_INT3},
+	       .mode = UART2_MODE,
+	       .ir_mode = UART2_IR,
+	       .enabled = UART2_ENABLED,
+	       .hardware_flow = UART2_HW_FLOW,
+	       .cts_threshold = UART2_UCR4_CTSTL,
+	       .dma_enabled = UART2_DMA_ENABLE,
+	       .dma_rxbuf_size = UART2_DMA_RXBUFSIZE,
+	       .rx_threshold = UART2_UFCR_RXTL,
+	       .tx_threshold = UART2_UFCR_TXTL,
+	       .shared = UART2_SHARED_PERI,
+	       .clock_id = UART2_BAUD,
+	       .dma_tx_id = MXC_DMA_UART2_TX,
+	       .dma_rx_id = MXC_DMA_UART2_RX,
+	       .rxd_mux = MXC_UART_IR_RXDMUX,
+	       },
+	[2] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART3_BASE_ADDR),
+			.mapbase = UART3_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART3_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 2,
+			},
+	       .ints_muxed = UART3_MUX_INTS,
+	       .irqs = {UART3_INT2, UART3_INT3},
+	       .mode = UART3_MODE,
+	       .ir_mode = UART3_IR,
+	       .enabled = UART3_ENABLED,
+	       .hardware_flow = UART3_HW_FLOW,
+	       .cts_threshold = UART3_UCR4_CTSTL,
+	       .dma_enabled = UART3_DMA_ENABLE,
+	       .dma_rxbuf_size = UART3_DMA_RXBUFSIZE,
+	       .rx_threshold = UART3_UFCR_RXTL,
+	       .tx_threshold = UART3_UFCR_TXTL,
+	       .shared = UART3_SHARED_PERI,
+	       .clock_id = UART3_BAUD,
+	       .dma_tx_id = MXC_DMA_UART3_TX,
+	       .dma_rx_id = MXC_DMA_UART3_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+#if UART4_ENABLED == 1
+	[3] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART4_BASE_ADDR),
+			.mapbase = UART4_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART4_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 3,
+			},
+	       .ints_muxed = UART4_MUX_INTS,
+	       .irqs = {UART4_INT2, UART4_INT3},
+	       .mode = UART4_MODE,
+	       .ir_mode = UART4_IR,
+	       .enabled = UART4_ENABLED,
+	       .hardware_flow = UART4_HW_FLOW,
+	       .cts_threshold = UART4_UCR4_CTSTL,
+	       .dma_enabled = UART4_DMA_ENABLE,
+	       .dma_rxbuf_size = UART4_DMA_RXBUFSIZE,
+	       .rx_threshold = UART4_UFCR_RXTL,
+	       .tx_threshold = UART4_UFCR_TXTL,
+	       .shared = UART4_SHARED_PERI,
+	       .clock_id = UART4_BAUD,
+	       .dma_tx_id = MXC_DMA_UART4_TX,
+	       .dma_rx_id = MXC_DMA_UART4_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+#endif
+	[4] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART5_BASE_ADDR),
+			.mapbase = UART5_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART5_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 4,
+			},
+	       .ints_muxed = UART5_MUX_INTS,
+	       .irqs = {UART5_INT2, UART5_INT3},
+	       .mode = UART5_MODE,
+	       .ir_mode = UART5_IR,
+	       .enabled = UART5_ENABLED,
+	       .hardware_flow = UART5_HW_FLOW,
+	       .cts_threshold = UART5_UCR4_CTSTL,
+	       .dma_enabled = UART5_DMA_ENABLE,
+	       .dma_rxbuf_size = UART5_DMA_RXBUFSIZE,
+	       .rx_threshold = UART5_UFCR_RXTL,
+	       .tx_threshold = UART5_UFCR_TXTL,
+	       .shared = UART5_SHARED_PERI,
+	       .clock_id = UART5_BAUD,
+	       .dma_tx_id = MXC_DMA_UART5_TX,
+	       .dma_rx_id = MXC_DMA_UART5_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "mxcintuart",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_ports[0],
+		},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "mxcintuart",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxc_ports[1],
+		},
+};
+
+static struct platform_device mxc_uart_device3 = {
+	.name = "mxcintuart",
+	.id = 2,
+	.dev = {
+		.platform_data = &mxc_ports[2],
+		},
+};
+
+#if UART4_ENABLED == 1
+static struct platform_device mxc_uart_device4 = {
+	.name = "mxcintuart",
+	.id = 3,
+	.dev = {
+		.platform_data = &mxc_ports[3],
+		},
+};
+#endif
+
+static struct platform_device mxc_uart_device5 = {
+	.name = "mxcintuart",
+	.id = 4,
+	.dev = {
+		.platform_data = &mxc_ports[4],
+		},
+};
+
+static int __init mxc_init_uart(void)
+{
+	/* Register all the MXC UART platform device structures */
+	platform_device_register(&mxc_uart_device1);
+	platform_device_register(&mxc_uart_device2);
+
+	/* Grab ownership of shared UARTs 3 and 4, only when enabled */
+#if UART3_ENABLED == 1
+#if UART3_DMA_ENABLE == 1
+	spba_take_ownership(UART3_SHARED_PERI, (SPBA_MASTER_A | SPBA_MASTER_C));
+#else
+	spba_take_ownership(UART3_SHARED_PERI, SPBA_MASTER_A);
+#endif				/* UART3_DMA_ENABLE */
+	platform_device_register(&mxc_uart_device3);
+#endif				/* UART3_ENABLED */
+
+#if UART4_ENABLED == 1
+	platform_device_register(&mxc_uart_device4);
+#endif				/* UART4_ENABLED */
+
+#if UART5_ENABLED == 1
+	platform_device_register(&mxc_uart_device5);
+#endif				/* UART5_ENABLED */
+	return 0;
+}
+
+#else
+static int __init mxc_init_uart(void)
+{
+	return 0;
+}
+#endif
+
+arch_initcall(mxc_init_uart);
--- linux-2.6.19.2/arch/arm/mach-mx3/serial.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/serial.h	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,152 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX3_SERIAL_H__
+#define __ARCH_ARM_MACH_MX3_SERIAL_H__
+
+#include <asm/arch/mxc_uart.h>
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+#define UART1_HW_FLOW           1
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The minimum buffer size is 512
+ * bytes. The buffer size should be a multiple of 256.
+ */
+#define UART1_DMA_RXBUFSIZE     1024
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           0
+#define UART2_UCR4_CTSTL        -1
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           1
+#define UART3_UCR4_CTSTL        16
+#define UART3_DMA_ENABLE        1
+#define UART3_DMA_RXBUFSIZE     1024
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+/* UART 4 configuration */
+#define UART4_HW_FLOW           1
+#define UART4_UCR4_CTSTL        16
+#define UART4_DMA_ENABLE        0
+#define UART4_DMA_RXBUFSIZE     512
+#define UART4_UFCR_RXTL         16
+#define UART4_UFCR_TXTL         16
+/* UART 5 configuration */
+#define UART5_HW_FLOW           1
+#define UART5_UCR4_CTSTL        16
+#define UART5_DMA_ENABLE        0
+#define UART5_DMA_RXBUFSIZE     512
+#define UART5_UFCR_RXTL         16
+#define UART5_UFCR_TXTL         16
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              -1
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              -1
+/*!
+ * This specifies if the UART is a shared peripheral. It holds the shared
+ * peripheral number if it is shared or -1 if it is not shared. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_SHARED_PERI       -1
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              INT_UART2
+#define UART2_INT2              -1
+#define UART2_INT3              -1
+#define UART2_SHARED_PERI       -1
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              INT_UART3
+#define UART3_INT2              -1
+#define UART3_INT3              -1
+#define UART3_SHARED_PERI       SPBA_UART3
+/* UART 4 configuration */
+#define UART4_MUX_INTS          INTS_MUXED
+#define UART4_INT1              INT_UART4
+#define UART4_INT2              -1
+#define UART4_INT3              -1
+#define UART4_SHARED_PERI       -1
+/* UART 5 configuration */
+#define UART5_MUX_INTS          INTS_MUXED
+#define UART5_INT1              INT_UART5
+#define UART5_INT2              -1
+#define UART5_INT3              -1
+#define UART5_SHARED_PERI       -1
+
+#endif				/* __ARCH_ARM_MACH_MX3_SERIAL_H__ */
--- linux-2.6.19.2/arch/arm/mach-mx3/system.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/system.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2000 Deep Blue Solutions Ltd
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include "crm_regs.h"
+
+/*!
+ * @defgroup MSL Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @defgroup System System-wide Misc Files for MSL
+ * @ingroup MSL
+ */
+
+/*!
+ * @file system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup System
+ */
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	unsigned int reg, v;
+
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	if ((__raw_readl(AVIC_VECTOR) & MXC_WFI_ENABLE) != 0) {
+		/*
+		 * workaround ARM11 Platform defect TLSbo64855.
+		 * Also see TLSbo78761.
+		 */
+		reg = __raw_readl(MXC_CCM_PDR0);
+		v = (reg & MXC_CCM_PDR0_MAX_PODF_MASK) >>
+		    MXC_CCM_PDR0_MAX_PODF_OFFSET;
+
+		/* make sure ARM:AHB clock ratio is 1:1 */
+		__raw_writel((reg & ~MXC_CCM_PDR0_MCU_PODF_MASK) | v,
+			     MXC_CCM_PDR0);
+		__raw_readl(MXC_CCM_PDR0);
+		__raw_readl(MXC_CCM_PDR0);
+
+		cpu_do_idle();
+
+		/* restore original clock dividers */
+		__raw_writel(reg, MXC_CCM_PDR0);
+	}
+}
+
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+void arch_reset(char mode)
+{
+	if ((__raw_readw(IO_ADDRESS(WDOG_BASE_ADDR)) & 0x4) != 0) {
+		/* If WDOG enabled, wait till it's timed out */
+		asm("cpsid iaf");
+		while (1) {
+		}
+	} else {
+		__raw_writew(__raw_readw(IO_ADDRESS(WDOG_BASE_ADDR)) | 0x4,
+			     IO_ADDRESS(WDOG_BASE_ADDR));
+	}
+}
--- linux-2.6.19.2/arch/arm/mach-mx3/time.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/time.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,285 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* System Timer Interrupt reconfigured to run in free-run mode.
+ * Author: Vitaly Wool
+ * Copyright 2004 MontaVista Software Inc.
+ */
+
+/*!
+ * @file time.c
+ * @brief This file contains OS tick and wdog timer implementations.
+ *
+ * This file contains OS tick and wdog timer implementations.
+ *
+ * @ingroup Timers
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/mach/time.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include "time_priv.h"
+#include <linux/irq.h>
+
+/*!
+ * This function converts system timer ticks to microseconds
+ *
+ * @param  x	system timer ticks
+ *
+ * @return elapsed microseconds
+ */
+unsigned long __noinstrument clock_to_usecs(unsigned long x)
+{
+	return (unsigned long)(x * (tick_nsec / 1000)) / LATCH;
+}
+
+#ifdef CONFIG_KFI
+/*!
+ * OS timer state flag
+ */
+static int os_timer_initialized = 0;
+
+/*!
+ * This function is needed by KFI to convert machine cycles to microseconds
+ *
+ * @param mputicks	number of machine cycles
+ *
+ * @return elapsed microseconds
+ */
+unsigned long __noinstrument machinecycles_to_usecs(unsigned long mputicks)
+{
+	return clock_to_usecs(mputicks);
+}
+
+/*!
+ * This function is needed by KFI to obtain current number of machine cycles elapsed
+ *
+ * @return elapsed machine cycles, or 0 if GPT timer is not initialized
+ */
+unsigned long __noinstrument do_getmachinecycles(void)
+{
+	return os_timer_initialized ? __raw_readl(MXC_GPT_GPTCNT) : 0;
+}
+#endif
+
+/*
+ * WatchDog
+ */
+typedef struct {
+	volatile __u16 WDOG_WCR;	/* 16bit watchdog control reg */
+	volatile __u16 WDOG_WSR;	/* 16bit watchdog service reg */
+	volatile __u16 WDOG_WRSR;	/* 16bit watchdog reset status reg */
+} wdog_reg_t;
+
+/*!
+ * The base addresses for the WDOG module
+ */
+static volatile wdog_reg_t *wdog_base[1] = {
+	(volatile wdog_reg_t *)IO_ADDRESS(WDOG_BASE_ADDR),
+};
+
+/*!
+ * The corresponding WDOG won't be serviced unless the corresponding global
+ * variable is set to a non-zero value.
+ */
+volatile unsigned short g_wdog1_enabled;
+
+/* WDOG WCR register's WT value */
+static int wdog_tmout[1] = { WDOG1_TIMEOUT };
+
+/*!
+ * This function provides the required service for the watchdog to avoid
+ * the timeout.
+ */
+static inline void kick_wd(void)
+{
+	if (g_wdog1_enabled) {
+		/* issue the service sequence instructions */
+		wdog_base[0]->WDOG_WSR = 0x5555;
+		wdog_base[0]->WDOG_WSR = 0xAAAA;
+	}
+}
+
+/*!
+ * This is the watchdog initialization routine to setup the timeout
+ * value and enable it.
+ */
+void mxc_wd_init(int port)
+{
+	unsigned volatile short timeout =
+	    ((wdog_tmout[port] / 1000) * 2) << WDOG_WT;
+
+	if (port == 0) {
+		/* enable WD, suspend WD in DEBUG mode */
+		wdog_base[port]->WDOG_WCR = timeout | WCR_WOE_BIT |
+		    WCR_SRS_BIT | WCR_WDA_BIT | WCR_WDE_BIT | WCR_WDBG_BIT;
+	}
+}
+
+#ifdef WDOG_SERVICE_PERIOD
+static int g_wdog_count = 0;
+#endif
+
+/*!
+ * This is the timer interrupt service routine to do required tasks.
+ * It also services the WDOG timer at the frequency of twice per WDOG
+ * timeout value. For example, if the WDOG's timeout value is 4 (2
+ * seconds since the WDOG runs at 0.5Hz), it will be serviced once
+ * every 2/2=1 second.
+ *
+ * @param  irq          GPT interrupt source number (not used)
+ * @param  dev_id       this parameter is not used
+ * @param  regs         pointer to a structure containing the processor
+ *                      registers and state prior to servicing the interrupt
+ * @return always returns \b IRQ_HANDLED as defined in
+ *         include/linux/interrupt.h.
+ */
+static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id,
+				       struct pt_regs *regs)
+{
+	unsigned int next_match;
+
+	write_seqlock(&xtime_lock);
+
+	if (__raw_readl(MXC_GPT_GPTSR) & GPTSR_OF1)
+		do {
+#ifdef WDOG_SERVICE_PERIOD
+			if (g_wdog1_enabled &&
+			    (++g_wdog_count >=
+			     ((WDOG_SERVICE_PERIOD / 1000) * HZ))) {
+				kick_wd();
+				g_wdog_count = 0;	/* reset */
+			}
+#else
+			kick_wd();
+#endif				/* WDOG_SERVICE_PERIOD */
+			timer_tick(regs);
+			next_match = __raw_readl(MXC_GPT_GPTOCR1) + LATCH;
+			__raw_writel(GPTSR_OF1, MXC_GPT_GPTSR);
+			__raw_writel(next_match, MXC_GPT_GPTOCR1);
+		} while ((signed long)(next_match -
+				       __raw_readl(MXC_GPT_GPTCNT)) <= 0);
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is used to obtain the number of microseconds since the last
+ * timer interrupt. Note that interrupts is disabled by do_gettimeofday().
+ *
+ * @return the number of microseconds since the last timer interrupt.
+ */
+static unsigned long __noinstrument mxc_gettimeoffset(void)
+{
+	unsigned long ticks_to_match, elapsed, usec, tick_usec, i;
+
+	/* Get ticks before next timer match */
+	ticks_to_match =
+	    __raw_readl(MXC_GPT_GPTOCR1) - __raw_readl(MXC_GPT_GPTCNT);
+
+	/* We need elapsed ticks since last match */
+	elapsed = LATCH - ticks_to_match;
+
+	/* Now convert them to usec */
+	/* Insure no overflow when calculating the usec below */
+	for (i = 1, tick_usec = tick_nsec / 1000;; i *= 2) {
+		tick_usec /= i;
+		if ((0xFFFFFFFF / tick_usec) > elapsed)
+			break;
+	}
+	usec = (unsigned long)(elapsed * tick_usec) / (LATCH / i);
+
+	return usec;
+}
+
+/*!
+ * The OS tick timer interrupt structure.
+ */
+static struct irqaction timer_irq = {
+	.name = "MXC Timer Tick",
+	.flags = IRQF_DISABLED | IRQF_TIMER,
+	.handler = mxc_timer_interrupt
+};
+
+/*!
+ * This function is used to initialize the GPT to produce an interrupt
+ * every 10 msec. It is called by the start_kernel() during system startup.
+ */
+void __init mxc_init_time(void)
+{
+	u32 reg, v;
+	reg = __raw_readl(MXC_GPT_GPTCR);
+	reg &= ~GPTCR_ENABLE;
+	__raw_writel(reg, MXC_GPT_GPTCR);
+	reg |= GPTCR_SWR;
+	__raw_writel(reg, MXC_GPT_GPTCR);
+
+	while ((__raw_readl(MXC_GPT_GPTCR) & GPTCR_SWR) != 0)
+		mb();
+
+	reg = __raw_readl(MXC_GPT_GPTCR);
+
+	reg = 0 * GPTCR_OM3_CLEAR | GPTCR_FRR | GPTCR_CLKSRC_HIGHFREQ;
+
+	__raw_writel(reg, MXC_GPT_GPTCR);
+
+	v = mxc_get_clocks(GPT_CLK);
+	__raw_writel((v / CLOCK_TICK_RATE) - 1, MXC_GPT_GPTPR);
+
+	if ((v % CLOCK_TICK_RATE) != 0) {
+		pr_info("\nWARNING: Can't generate CLOCK_TICK_RATE at %d Hz\n",
+			CLOCK_TICK_RATE);
+	}
+	pr_info("Actual CLOCK_TICK_RATE is %d Hz\n",
+		v / ((__raw_readl(MXC_GPT_GPTPR) & 0xFFF) + 1));
+
+	reg = __raw_readl(MXC_GPT_GPTCNT);
+	reg += LATCH;
+	__raw_writel(reg, MXC_GPT_GPTOCR1);
+
+	setup_irq(INT_GPT, &timer_irq);
+
+	reg = __raw_readl(MXC_GPT_GPTCR);
+	reg = GPTCR_FRR | GPTCR_CLKSRC_HIGHFREQ |
+	    GPTCR_STOPEN |
+	    GPTCR_DOZEN | GPTCR_WAITEN | GPTCR_ENMOD | GPTCR_ENABLE;
+	__raw_writel(reg, MXC_GPT_GPTCR);
+
+	__raw_writel(GPTIR_OF1IE, MXC_GPT_GPTIR);
+
+#ifdef WDOG1_ENABLE
+	mxc_wd_init(0);
+	g_wdog1_enabled = 1;
+#else
+	g_wdog1_enabled = (wdog_base[0]->WDOG_WCR) & WCR_WDE_BIT;
+#endif
+
+	kick_wd();
+
+#ifdef CONFIG_KFI
+	os_timer_initialized = 1;
+#endif
+}
+
+EXPORT_SYMBOL(g_wdog1_enabled);
+EXPORT_SYMBOL(mxc_wd_init);
+
+struct sys_timer mxc_timer = {
+	.init = mxc_init_time,
+	.offset = mxc_gettimeoffset,
+};
--- linux-2.6.19.2/arch/arm/mach-mx3/time_priv.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/time_priv.h	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,167 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+#ifndef __MACH_MX31_TIME_PRIV_H__
+#define __MACH_MX31_TIME_PRIV_H__
+/*!
+ * @file time_priv.h
+ * @brief This file contains OS tick and wdog timer register definitions.
+ *
+ * This file contains OS tick and wdog timer register definitions.
+ *
+ * @ingroup Timers
+ */
+
+#include <asm/hardware.h>
+
+/*
+ * EPIT Control register bit definitions
+ */
+#define EPITCR_CLKSRC_SHIFT		24
+#define EPITCR_CLKSRC_MASK		0x03000000
+#define EPITCR_CLKSRC_OFF		0x00000000
+#define EPITCR_CLKSRC_HIGHFREQ		0x02000000
+#define EPITCR_CLKSRC_32K		0x03000000
+
+#define EPITCR_OM_DISCONNECTED		0x00000000
+#define EPITCR_OM_TOGGLE		0x00400000
+#define EPITCR_OM_CLEAR			0x00800000
+#define EPITCR_OM_SET			0x00C00000
+
+#define EPITCR_STOPEN_ENABLE		0x00200000
+#define EPITCR_WAITEN_ENABLE		0x00080000
+#define EPITCR_DBGEN_ENABLE		0x00040000
+#define EPITCR_IOVW_ENABLE		0x00020000
+#define EPITCR_SWR			0x00010000
+
+#define EPITCR_PRESCALER_MASK		0x0000FFF0
+#define EPITCR_PRESCALER_SHIFT		0x00000004
+
+#define EPITCR_RLD			0x00000008
+#define EPITCR_OCIEN			0x00000004
+#define EPITCR_ENMOD			0x00000002
+#define EPITCR_EN			0x00000001
+
+/*!
+ * GPT Control register bit definitions
+ */
+#define GPTCR_FO3			(1 << 31)
+#define GPTCR_FO2			(1 << 30)
+#define GPTCR_FO1			(1 << 29)
+
+#define GPTCR_OM3_SHIFT			26
+#define GPTCR_OM3_MASK			(7 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_DISCONNECTED		(0 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_TOGGLE		(1 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_CLEAR			(2 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_SET			(3 << GPTCR_OM3_SHIFT)
+#define GPTCR_OM3_GENERATE_LOW		(7 << GPTCR_OM3_SHIFT)
+
+#define GPTCR_OM2_SHIFT			23
+#define GPTCR_OM2_MASK			(7 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_DISCONNECTED		(0 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_TOGGLE		(1 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_CLEAR			(2 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_SET			(3 << GPTCR_OM2_SHIFT)
+#define GPTCR_OM2_GENERATE_LOW		(7 << GPTCR_OM2_SHIFT)
+
+#define GPTCR_OM1_SHIFT			20
+#define GPTCR_OM1_MASK			(7 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_DISCONNECTED		(0 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_TOGGLE		(1 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_CLEAR			(2 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_SET			(3 << GPTCR_OM1_SHIFT)
+#define GPTCR_OM1_GENERATE_LOW		(7 << GPTCR_OM1_SHIFT)
+
+#define GPTCR_IM2_SHIFT			18
+#define GPTCR_IM2_MASK			(3 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_DISABLE	(0 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_RISING	(1 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_FALLING	(2 << GPTCR_IM2_SHIFT)
+#define GPTCR_IM2_CAPTURE_BOTH		(3 << GPTCR_IM2_SHIFT)
+
+#define GPTCR_IM1_SHIFT			16
+#define GPTCR_IM1_MASK			(3 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_DISABLE	(0 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_RISING	(1 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_FALLING	(2 << GPTCR_IM1_SHIFT)
+#define GPTCR_IM1_CAPTURE_BOTH		(3 << GPTCR_IM1_SHIFT)
+
+#define GPTCR_SWR			(1 << 15)
+#define GPTCR_FRR			(1 << 9)
+
+#define GPTCR_CLKSRC_SHIFT		6
+#define GPTCR_CLKSRC_MASK		(7 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_NOCLOCK		(0 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_HIGHFREQ		(2 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_CLKIN		(3 << GPTCR_CLKSRC_SHIFT)
+#define GPTCR_CLKSRC_CLK32K		(7 << GPTCR_CLKSRC_SHIFT)
+
+#define GPTCR_STOPEN			(1 << 5)
+#define GPTCR_DOZEN			(1 << 4)
+#define GPTCR_WAITEN			(1 << 3)
+#define GPTCR_DBGEN			(1 << 2)
+
+#define GPTCR_ENMOD			(1 << 1)
+#define GPTCR_ENABLE			(1 << 0)
+
+#define	GPTSR_OF1			(1 << 0)
+#define	GPTSR_OF2			(1 << 1)
+#define	GPTSR_OF3			(1 << 2)
+#define	GPTSR_IF1			(1 << 3)
+#define	GPTSR_IF2			(1 << 4)
+#define	GPTSR_ROV			(1 << 5)
+
+#define	GPTIR_OF1IE			GPTSR_OF1
+#define	GPTIR_OF2IE			GPTSR_OF2
+#define	GPTIR_OF3IE			GPTSR_OF3
+#define	GPTIR_IF1IE			GPTSR_IF1
+#define	GPTIR_IF2IE			GPTSR_IF2
+#define	GPTIR_ROVIE			GPTSR_ROV
+
+#ifndef	__noinstrument
+#	define	__noinstrument
+#endif
+
+/*
+ * This implements the OS tick timer to generate interrupts every 10ms
+ */
+
+#if !defined(HZ) || (HZ != 100)
+#error HZ is not defined or not equal to 100
+#endif
+
+#if 0				/* not enabled the two wdogs by default */
+#define WDOG1_ENABLE		/* not defined by default */
+#endif
+#define WDOG1_TIMEOUT           4000	/* WDOG1 timeout in ms */
+#define WDOG_SERVICE_PERIOD     (WDOG1_TIMEOUT / 2)	/* time interval in ms to service WDOGs */
+
+#if (WDOG_SERVICE_PERIOD >= (WDOG1_TIMEOUT - 1000 / HZ))
+#error WDOG_SERVICE_PERIOD is too large!
+#endif
+
+/* maximum timeout is 128s based on 2Hz clock */
+#if ((WDOG1_TIMEOUT/1000) > 128)
+#error WDOG time out has to be less than 128 seconds!
+#endif
+
+#define WDOG_WT                 0x8	/* WDOG WT starting bit inside WCR */
+#define WCR_WOE_BIT             (1 << 6)
+#define WCR_WDA_BIT             (1 << 5)
+#define WCR_SRS_BIT             (1 << 4)
+#define WCR_WRE_BIT             (1 << 3)
+#define WCR_WDE_BIT             (1 << 2)
+#define WCR_WDBG_BIT            (1 << 1)
+#define WCR_WDZST_BIT           (1 << 0)
+
+#endif				/* __MACH_MX31_TIME_PRIV_H__ */
--- linux-2.6.19.2/arch/arm/mach-mx3/usb.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx3/usb.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,833 @@
+/*
+ * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *	otg_{get,set}_transceiver() are from arm/plat-omap/usb.c.
+ *	which is Copyright (C) 2004 Texas Instruments, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@defgroup USB ARC OTG USB Driver
+ */
+
+/*!
+ * @file usb.c
+ *
+ * @brief platform related part of usb driver.
+ * @ingroup USB
+ */
+
+/*!
+ *Include files
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb_otg.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/arc_otg.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/isp1504.h>
+#include <asm/arch/isp1301.h>
+
+#define PBC3_CLEAR	(PBC_BASE_ADDRESS + PBC_BCTRL3_CLEAR)
+#define PBC3_SET	(PBC_BASE_ADDRESS + PBC_BCTRL3_SET)
+
+#undef DEBUG
+#undef VERBOSE
+
+#ifdef DEBUG
+#define dbg(fmt, args...)	printk("%s: " fmt "\n", __FUNCTION__, ## args)
+#else
+#define dbg(fmt, args...)	do {} while (0)
+#endif
+
+#ifdef VERBOSE
+#define vdbg	dbg
+#else
+#define vdbg(fmt, args...)	do {} while (0)
+#endif
+
+extern int gpio_usbh1_active(void);
+extern void gpio_usbh1_inactive(void);
+extern int gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+extern int gpio_usbotg_hs_active(void);
+extern void gpio_usbotg_hs_inactive(void);
+extern int gpio_usbotg_fs_active(void);
+extern void gpio_usbotg_fs_inactive(void);
+
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+/*
+ * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
+ */
+static int check_usbclk(void)
+{
+	unsigned long clk;
+
+	clk = mxc_get_clocks(USB_CLK);
+	if ((clk < 59999000) || (clk > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", clk);
+		return -1;
+	}
+	return 0;
+}
+
+#if defined(CONFIG_ISP1504_MXC) || defined(CONFIG_ISP1504_MXC_MODULE)
+/*!
+ * read ULPI register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       reg   register to read
+ * @param       view  the ULPI VIEWPORT register address
+ * @return	return isp1504 register value
+ */
+u8 isp1504_read(int reg, volatile u32 * view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	/* read the register */
+	__raw_writel((ULPIVW_RUN | (reg << ULPIVW_ADDR_SHIFT)), view);
+
+	do {			/* wait for completion */
+		data = __raw_readl(view);
+	} while (data & ULPIVW_RUN);
+
+	return (u8) (data >> ULPIVW_RDATA_SHIFT) & ULPIVW_RDATA_MASK;
+}
+
+EXPORT_SYMBOL(isp1504_read);
+
+/*!
+ * set bits into OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  set value
+ * @param	reg   which register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+void isp1504_set(u8 bits, int reg, volatile u32 * view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		printk("\nSS=0\n");
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_SET) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+EXPORT_SYMBOL(isp1504_set);
+
+/*!
+ * clear bits in OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  bits to clear
+ * @param	reg   in this register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+void isp1504_clear(u8 bits, int reg, volatile u32 * view)
+{
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_CLEAR) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+EXPORT_SYMBOL(isp1504_clear);
+
+/*!
+ * set vbus power
+ *
+ * @param       on    power on or off
+ * @param       view  the ULPI view register address
+ */
+static void ulpi_set_vbus_power(int on, volatile u32 * view)
+{
+	dbg("on=%d  view=0x%p", on, view);
+
+	vdbg("ULPI Vendor ID 0x%x    Product ID 0x%x",
+	     (isp1504_read(ISP1504_VID_HIGH, view) << 8) |
+	     isp1504_read(ISP1504_VID_LOW, view),
+	     (isp1504_read(ISP1504_PID_HIGH, view) << 8) |
+	     isp1504_read(ISP1504_PID_LOW, view));
+
+	vdbg("OTG Control before = 0x%x", isp1504_read(ISP1504_OTGCTL, view));
+
+	if (on) {
+		isp1504_set(DRV_VBUS_EXT |	/* enable external Vbus */
+			    DRV_VBUS |	/* enable internal Vbus */
+			    USE_EXT_VBUS_IND |	/* use external indicator */
+			    CHRG_VBUS,	/* charge Vbus */
+			    ISP1504_OTGCTL, view);
+
+	} else {
+		isp1504_clear(DRV_VBUS_EXT |	/* disable external Vbus */
+			      DRV_VBUS,	/* disable internal Vbus */
+			      ISP1504_OTGCTL, view);
+
+		isp1504_set(USE_EXT_VBUS_IND |	/* use external indicator */
+			    DISCHRG_VBUS,	/* discharge Vbus */
+			    ISP1504_OTGCTL, view);
+	}
+
+	vdbg("OTG Control after = 0x%x\n", isp1504_read(ISP1504_OTGCTL, view));
+}
+#endif
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGHS) || defined(CONFIG_USB_GADGET_ARC_OTGHS)
+static int otg_used = 0;	/* OTG use-count */
+
+static void otg_hs_set_xcvr(void)
+{
+	u32 tmp;
+
+	/* set ULPI xcvr */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UOG_PORTSC1 = tmp;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	UOG_USBCMD |= UCMD_RESET;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	mdelay(10);
+}
+
+static int otg_hs_init(void)
+{
+	if (!otg_used) {
+		if (check_usbclk() != 0)
+			return -EINVAL;
+
+		dbg("grab OTG-HS pins");
+		if (gpio_usbotg_hs_active())	/* grab our pins */
+			return -EINVAL;
+
+		/* enable OTG/HS */
+		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_CLEAR);
+
+		/* disable OTG/FS */
+		__raw_writew(PBC_BCTRL3_OTG_FS_EN, PBC3_SET);
+
+		USBCTRL &= ~UCTRL_BPE;	/* disable bypass mode */
+		USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+		    UCTRL_OWIE |	/* OTG wakeup intr enable */
+		    UCTRL_OPM;	/* power mask */
+
+		otg_hs_set_xcvr();	/* set transciever type */
+	}
+
+	otg_used++;
+	return 0;
+}
+
+static void otg_hs_uninit(void)
+{
+	dbg();
+
+	otg_used--;
+	if (!otg_used) {
+		/* disable  OTG/HS */
+		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_SET);
+
+		dbg("free OTG-HS pins");
+		gpio_usbotg_hs_inactive();	/* release our pins */
+	}
+}
+
+static void otg_hs_set_vbus_power(int on)
+{
+	dbg("on=%d", on);
+	ulpi_set_vbus_power(on, &UOG_ULPIVIEW);
+}
+
+/*!
+ * OTG HS host config
+ */
+#ifdef CONFIG_USB_EHCI_ARC_OTGHS
+/* *INDENT-OFF* */
+static struct arc_usb_config otg_hs_host_config = {
+	.name            = "OTG HS Host",
+	.platform_init   = otg_hs_init,
+	.platform_uninit = otg_hs_uninit,
+	.set_vbus_power  = otg_hs_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.does_otg        = 1,
+	.power_budget    = 150,		/* 150 mA max power */
+};
+/* *INDENT-ON* */
+
+static struct platform_device *otg_hs_host_device;
+#endif				/* CONFIG_USB_EHCI_ARC_OTGHS */
+#endif				/* CONFIG_USB_EHCI_ARC_OTGHS || CONFIG_USB_GADGET_ARC_OTGHS */
+
+/* *INDENT-OFF* */
+static struct resource otg_resources[] = {
+	{
+		.start = (u32) (USB_OTGREGS_BASE),
+		.end   = (u32) (USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+/* *INDENT-ON* */
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGFS) || defined(CONFIG_USB_GADGET_ARC_OTGFS)
+static void otg_fs_set_xcvr(void)
+{
+	u32 tmp;
+
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_SERIAL;
+	UOG_PORTSC1 = tmp;
+}
+#endif				/* CONFIG_USB_EHCI_ARC_OTGFS || CONFIG_USB_GADGET_ARC_OTGFS */
+
+#ifdef CONFIG_USB_EHCI_ARC_OTGFS
+static int otg_fs_host_init(void)
+{
+	dbg("grab OTG-FS pins");
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	isp1301_init();
+
+	isp1301_set_serial_host();
+	if (gpio_usbotg_fs_active())	/* grab our pins */
+		return -EINVAL;
+	mdelay(1);
+
+	/* enable OTG VBUS */
+	mxc_clks_disable(USB_CLK);
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_CLEAR);
+	mxc_clks_enable(USB_CLK);
+
+	otg_fs_set_xcvr();	/* set transceiver type */
+
+	USBCTRL &= ~(UCTRL_OSIC_MASK | UCTRL_BPE);	/* disable bypass mode */
+	USBCTRL |= UCTRL_OSIC_SU6 |	/* single-ended, unidir, 6 wire */
+	    UCTRL_OWIE |	/* OTG wakeup intr enable */
+	    UCTRL_OPM;		/* power mask */
+
+	/* need reset */
+	UOG_USBCMD |= UCMD_RESET;
+	mdelay(10);
+
+	return 0;
+}
+
+static void otg_fs_host_uninit(void)
+{
+	dbg();
+
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);	/* disable OTG VBUS */
+
+	isp1301_uninit();
+
+	gpio_usbotg_fs_inactive();	/* release our pins */
+}
+
+/*!
+ * OTG FS host config
+ */
+/* *INDENT-OFF* */
+static struct arc_usb_config otg_fs_host_config = {
+	.name            = "OTG FS Host",
+	.platform_init   = otg_fs_host_init,
+	.platform_uninit = otg_fs_host_uninit,
+	.set_vbus_power  = isp1301_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.does_otg        = 1,
+	.power_budget    = 150,		/* 150 mA max power */ // DDD check!!
+};
+/* *INDENT-ON* */
+
+static struct platform_device *otg_fs_host_device;
+#endif				/* CONFIG_USB_EHCI_ARC_OTGFS */
+
+/* Host 1 */
+#ifdef CONFIG_USB_EHCI_ARC_H1
+static void usbh1_set_xcvr(void)
+{
+	UH1_PORTSC1 &= ~PORTSC_PTS_MASK;
+	UH1_PORTSC1 |= PORTSC_PTS_SERIAL;
+}
+
+static int usbh1_init(void)
+{
+	dbg("grab H1 pins");
+
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	if (gpio_usbh1_active())
+		return -EINVAL;
+
+	__raw_writew(PBC_BCTRL3_FSH_EN, PBC3_CLEAR);	/* enable FSH */
+	__raw_writew(PBC_BCTRL3_FSH_SEL, PBC3_SET);	/* Group B */
+	__raw_writew(PBC_BCTRL3_FSH_MOD, PBC3_CLEAR);	/* single ended */
+	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_CLEAR);	/* enable FSH VBUS */
+
+	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE);	/* disable bypass mode */
+	USBCTRL |= UCTRL_H1SIC_SU6 |	/* single-ended / unidir. */
+	    UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
+	    UCTRL_H1PM;		/* power mask */
+
+	usbh1_set_xcvr();
+	return 0;
+}
+
+static void usbh1_uninit(void)
+{
+	dbg();
+
+	__raw_writew(PBC_BCTRL3_FSH_EN, PBC3_SET);	/* disable FSH */
+	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_SET);	/* disable FSH VBUS */
+
+	gpio_usbh1_inactive();	/* release our pins */
+}
+
+/* *INDENT-OFF* */
+static struct arc_usb_config usbh1_config = {
+	.name            = "Host 1",
+	.platform_init   = usbh1_init,
+	.platform_uninit = usbh1_uninit,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UH1_USBMODE,
+	.power_budget    = 150,		/* 150 mA max power */
+};
+
+static struct resource usbh1_resources[] = {
+	{
+		.start = (u32) (USB_H1REGS_BASE),
+		.end   = (u32) (USB_H1REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = INT_USB1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+/* *INDENT-ON* */
+
+static struct platform_device *usbh1_device;
+#endif				/* CONFIG_USB_EHCI_ARC_H1 */
+
+#ifdef CONFIG_USB_EHCI_ARC_H2
+static void usbh2_set_xcvr(void)
+{
+	UH2_PORTSC1 &= ~PORTSC_PTS_MASK;	/* set ULPI xcvr */
+	UH2_PORTSC1 |= PORTSC_PTS_ULPI;
+}
+
+static int usbh2_init(void)
+{
+	dbg("grab H2 pins");
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	/* abort the init if NAND card is present */
+	if ((__raw_readw(PBC_BASE_ADDRESS + PBC_BSTAT1) &
+	     PBC_BSTAT1_NF_DET) == 0) {
+		printk(KERN_ERR "USBH2 port not configured: "
+		       "pin conflict with NAND flash.\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * If the ATA interface is enabled, turning on
+	 * PBC_BCTRL3_HSH_SEL will make it unusable.
+	 * To avoid that, abort now if ATA is enabled.
+	 */
+	if ((__raw_readw(PBC_BASE_ADDRESS + PBC_BCTRL2_SET) &
+	     PBC_BCTRL2_ATA_EN) == 0) {
+		printk(KERN_ERR "USBH2 port not configured: "
+		       "pin conflict with ATA.\n");
+		return -EINVAL;
+	}
+
+	if (gpio_usbh2_active())	/* grab our pins */
+		return -EINVAL;
+
+	__raw_writew(PBC_BCTRL3_HSH_SEL, PBC3_SET);	/* enable HSH select */
+	__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_CLEAR);	/* enable HSH */
+
+	USBCTRL &= ~(UCTRL_H2SIC_MASK | UCTRL_BPE);	/* disable bypass mode */
+	USBCTRL |= UCTRL_H2WIE |	/* wakeup intr enable */
+	    UCTRL_H2UIE |	/* ULPI intr enable */
+	    UCTRL_H2DT |	/* disable H2 TLL */
+	    UCTRL_H2PM;		/* power mask */
+
+	dbg("success");
+	usbh2_set_xcvr();	/* set transceiver type */
+	return 0;
+}
+
+static void usbh2_uninit(void)
+{
+	dbg();
+
+	__raw_writew(PBC_BCTRL3_HSH_SEL, PBC3_CLEAR);	/* disable HSH select */
+	__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_SET);	/* disable HSH */
+
+	gpio_usbh2_inactive();	/* release our pins */
+}
+
+static void usbh2_set_vbus_power(int on)
+{
+	dbg("on=%d", on);
+	ulpi_set_vbus_power(on, &UH2_ULPIVIEW);
+}
+
+/* *INDENT-OFF* */
+static struct arc_usb_config usbh2_config = {
+	.name            = "Host 2",
+	.platform_init   = usbh2_init,
+	.platform_uninit = usbh2_uninit,
+	.set_vbus_power  = usbh2_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UH2_USBMODE,
+	.power_budget    = 150,		/* 150 mA max power */
+};
+
+static struct resource usbh2_resources[] = {
+	{
+		.start = (u32) (USB_H2REGS_BASE),
+		.end   = (u32) (USB_H2REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = INT_USB2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+/* *INDENT-ON* */
+
+static struct platform_device *usbh2_device;
+#endif				/* CONFIG_USB_EHCI_ARC_H2 */
+
+#ifdef CONFIG_USB_GADGET_ARC
+#ifdef CONFIG_USB_GADGET_ARC_OTGHS
+/* *INDENT-OFF* */
+static struct arc_usb_config udc_hs_config = {
+	.name            = "OTG HS Gadget",
+	.platform_init   = otg_hs_init,
+	.platform_uninit = otg_hs_uninit,
+	.set_vbus_power  = otg_hs_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UOG_USBMODE,
+};
+/* *INDENT-ON* */
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC_OTGFS
+int otg_fs_dev_init(void)
+{
+	dbg("grab OTG-FS pins");
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	isp1301_init();
+
+	isp1301_set_serial_dev();
+	gpio_usbotg_fs_active();	/* grab our pins */
+	mdelay(1);
+
+	/* disable OTG VBUS */
+	// DDD need this?? mxc_clks_disable(USB_CLK);
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);
+	// DDD need this?? mxc_clks_enable(USB_CLK);
+
+	otg_fs_set_xcvr();	/* set transceiver type */
+
+	USBCTRL &= ~(UCTRL_OSIC_MASK | UCTRL_BPE);	/* disable bypass */
+	USBCTRL |= UCTRL_OSIC_DU6 |	/* differential, unidir, 6 wire */
+	    UCTRL_OWIE |	/* OTG wakeup intr enable */
+	    UCTRL_OPM;		/* power mask */
+
+	USB_OTG_MIRROR = 0xd;
+	return 0;
+}
+
+static void otg_fs_dev_uninit(void)
+{
+	dbg();
+
+	/* disable OTG VBUS */
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);
+
+	isp1301_uninit();
+
+	gpio_usbotg_fs_inactive();	/* release our pins */
+}
+
+/* *INDENT-OFF* */
+static struct arc_usb_config udc_fs_config = {
+	.name            = "OTG FS Gadget",
+	.platform_init   = otg_fs_dev_init,
+	.platform_uninit = otg_fs_dev_uninit,
+	.set_vbus_power  = isp1301_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UOG_USBMODE,
+};
+/* *INDENT-ON* */
+#endif				/* CONFIG_USB_GADGET_ARC_OTGFS */
+
+/*!
+ * OTG HS/FS gadget device
+ */
+
+static void usb_release(struct device *dev)
+{
+	/* normally not freed */
+}
+
+static u64 udc_dmamask = ~(u32) 0;
+/* *INDENT-OFF* */
+static struct platform_device udc_device = {
+	.name = "arc_udc",
+	.id   = -1,
+	.dev  = {
+		.release           = usb_release,
+		.dma_mask          = &udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+#if   defined CONFIG_USB_GADGET_ARC_OTGHS
+		.platform_data     = &udc_hs_config,
+#elif defined CONFIG_USB_GADGET_ARC_OTGFS
+		.platform_data     = &udc_fs_config,
+#else
+#error "No OTG port configured."
+#endif
+		},
+	.num_resources = ARRAY_SIZE(otg_resources),
+	.resource      = otg_resources,
+};
+/* *INDENT-ON* */
+#endif				/* CONFIG_USB_GADGET_ARC */
+
+#if defined(CONFIG_USB_OTG)
+static struct otg_transceiver *xceiv;
+
+/**
+ * otg_get_transceiver - find the (single) OTG transceiver driver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * releasing that count.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	dbg("%s xceiv=0x%p\n", __FUNCTION__, xceiv);
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+
+EXPORT_SYMBOL(otg_get_transceiver);
+
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	dbg("%s xceiv=0x%p  x=0x%p\n", __FUNCTION__, xceiv, x);
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+
+EXPORT_SYMBOL(otg_set_transceiver);
+
+static void isp1504_release(struct device *dev)
+{
+	/* normally not freed */
+}
+
+/* *INDENT-OFF* */
+static struct arc_xcvr_config isp1504_config = {
+	.name            = "isp1504",
+	.platform_init   = otg_hs_init,
+	.platform_uninit = otg_hs_uninit,
+	.regs            = (void *)&UOG_ID,
+};
+
+static struct resource isp1504_resources[] = {
+	{
+		.start = INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*!
+ * ISP1504 device
+ */
+static u64 isp1504_dmamask = ~(u32) 0;
+static struct platform_device isp1504_device = {
+	.name = "isp1504_arc",
+	.id   = -1,
+	.dev  = {
+		.release           = isp1504_release,
+		.dma_mask          = &isp1504_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data     = &isp1504_config,
+		},
+	.num_resources = ARRAY_SIZE(isp1504_resources),
+	.resource      = isp1504_resources,
+};
+/* *INDENT-ON* */
+#endif				/* CONFIG_USB_OTG */
+
+/*!
+ * Register an instance of a USB host platform device.
+ *
+ * @param	res:	resource pointer
+ * @param       n_res:	number of resources
+ * @param       config: config pointer
+ *
+ * @return      newly-registered platform_device
+ *
+ * The USB controller supports 3 host interfaces, and the
+ * kernel can be configured to support some number of them.
+ * Each supported host interface is registered as an instance
+ * of the "fsl-ehci" device.  Call this function multiple times
+ * to register each host interface.
+ */
+static int instance_id = 0;
+static struct platform_device *host_pdev_register(struct resource *res,
+						  int n_res,
+						  struct arc_usb_config *config)
+{
+	int rc;
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_simple("fsl-ehci",
+					       instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		pr_debug("can't register %s Host, %d\n",
+			 config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+	rc = platform_device_add_data(pdev, config,
+				      sizeof(struct arc_usb_config));
+	if (rc) {
+		platform_device_unregister(pdev);
+		return NULL;
+	}
+
+	printk(KERN_INFO "usb: %s registered\n", config->name);
+	dbg("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p",
+	    pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
+	instance_id++;
+
+	return pdev;
+}
+
+static int __init mx3_usb_init(void)
+{
+	int rc __attribute((unused));
+
+	dbg();
+
+#if defined(CONFIG_USB_OTG)
+	rc = platform_device_register(&isp1504_device);
+	if (rc) {
+		pr_debug("can't register isp1504 dvc, %d\n", rc);
+	} else {
+		printk(KERN_INFO "usb: isp1504 registered\n");
+		dbg("isp1504: platform_device_register succeeded.");
+		dbg("isp1504_device=0x%p  resources=0x%p.",
+		    &isp1504_device, isp1504_device.resource);
+	}
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_H1
+	usbh1_device = host_pdev_register(usbh1_resources,
+					  ARRAY_SIZE(usbh1_resources),
+					  &usbh1_config);
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_H2
+	usbh2_device = host_pdev_register(usbh2_resources,
+					  ARRAY_SIZE(usbh2_resources),
+					  &usbh2_config);
+#endif
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGHS)
+	otg_hs_host_device = host_pdev_register(otg_resources,
+						ARRAY_SIZE(otg_resources),
+						&otg_hs_host_config);
+#elif defined(CONFIG_USB_EHCI_ARC_OTGFS)
+	otg_fs_host_device = host_pdev_register(otg_resources,
+						ARRAY_SIZE(otg_resources),
+						&otg_fs_host_config);
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+	rc = platform_device_register(&udc_device);
+	if (rc)
+		pr_debug("can't register OTG Gadget, %d\n", rc);
+	else
+		printk(KERN_INFO "usb: %s registered\n",
+		       ((struct arc_usb_config *)udc_device.dev.platform_data)->
+		       name);
+#endif
+	return 0;
+}
+
+subsys_initcall(mx3_usb_init);
