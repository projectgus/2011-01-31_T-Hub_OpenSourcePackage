TLSbo86671_support_standard_clk_api.patch

This patch replaces MXC clock API with standard linux clk_xxx API.
All chips and drivers are updated for the new API.
===================================================================
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/clock.c linux-2.6.19.2/arch/arm/mach-mx27/clock.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/clock.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/clock.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -22,1302 +22,1356 @@
 
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <linux/clk.h>
 #include <asm/io.h>
 #include <asm/arch/clock.h>
 #include "crm_regs.h"
-/*!
- * Spinlock to protect CRM register accesses
- */
-static DEFINE_SPINLOCK(mxc_crm_lock);
 
-/*!
- * define a variable & macro to control the perclk2.
- */
-#define MXC_CLK_PCLK2_CSPI1	0
-#define MXC_CLK_PCLK2_CSPI2	1
-#define MXC_CLK_PCLK2_CSPI3	2
-#define MXC_CLK_PCLK2_SDHC1	3
-#define MXC_CLK_PCLK2_SDHC2	4
-static int g_perclk2_map = 0;
+#define CKIH_CLK_FREQ           26000000	/* 26M reference clk */
+#define CKIH_CLK_FREQ_27MHZ     27000000
+#define CKIL_CLK_FREQ           32768	/* 32.768k oscillator in */
+#define CKIH_27MHZ_BIT_SET      (1 << 3)
+
+static struct clk ckil_clk;
+static struct clk mpll_clk;
+static struct clk spll_clk;
 
-/*!
- * g_emma_clock_map is defined to control the emma_clock .
- * emma_clock will be disabled until emma_prp_clk and emma_pp_clk are closed.
- */
-#define MXC_CLK_EMMA_PRP	0
-#define MXC_CLK_EMMA_PP		1
-static int g_emma_clock_map = 0;
+static int _clk_enable(struct clk *clk)
+{
+	unsigned long reg;
 
-/*
- * Bit fields
- */
-#define CLKSRC_NO_CLK	    	0
-#define CLKSRC_PERCLK	    	1
-#define CLKSRC_PERCLK_4   	2
-#define CLKSRC_EXT_PAD	    	3
+	reg = __raw_readl(clk->enable_reg);
+	reg |= 1 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
 
-/*
- * Get Clock errors
- */
-#define ERR_CLK_NO_SUPPORT	1
+	return 0;
+}
 
-/*!
- * This function enables the perclk2.
- * @param	source each bit of source indicate the clock status of mdoule
- *		which is using emma clk
- * @return      none.
- */
-static void inline __enable_perclk2(unsigned long source)
+static void _clk_disable(struct clk *clk)
 {
 	unsigned long reg;
 
-	BUG_ON(source > 31);
-	if (g_perclk2_map == 0) {
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_PERCLK2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-	}
-	g_perclk2_map |= (1 << source);
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(1 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
 }
 
-/*!
- * This function disables the perclk2.
- * @param	source each bit of source indicate the clock status of mdoule
- *		which is using emma clk
- * @return      none.
- */
-static void inline __disable_perclk2(unsigned long source)
+static void _clk_pccr01_enable(unsigned long mask0, unsigned long mask1)
 {
 	unsigned long reg;
 
-	BUG_ON(source > 31);
-	g_perclk2_map &= ~(1 << source);
-	if (g_perclk2_map == 0) {
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_PERCLK2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-	}
+	reg = __raw_readl(CCM_PCCR0);
+	reg |= mask0;
+	__raw_writel(reg, CCM_PCCR0);
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg |= mask1;
+	__raw_writel(reg, CCM_PCCR1);
+
 }
 
-/*!
- * This function enables the emma clock.
- * @param	source each bit of source indicate the clock status of mdoule
- *		which is using emma clk
- * @return 	none
- */
-static void inline __enable_emma_clk(unsigned long source)
+static void _clk_pccr01_disable(unsigned long mask0, unsigned long mask1)
 {
 	unsigned long reg;
 
-	if (g_emma_clock_map == 0) {
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_EMMA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_EMMA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-	}
-	g_emma_clock_map |= (1 << source);
+	reg = __raw_readl(CCM_PCCR0);
+	reg &= ~mask0;
+	__raw_writel(reg, CCM_PCCR0);
+
+	reg = __raw_readl(CCM_PCCR1);
+	reg &= ~mask1;
+	__raw_writel(reg, CCM_PCCR1);
 }
 
-/*!
- * This function disables the emma clock.
- * @param	source each bit of source indicate the clock status of mdoule
- *		which is using emma clk
- * @return 	none
- */
-static void inline __disable_emma_clk(unsigned long source)
+static void _clk_pccr10_enable(unsigned long mask1, unsigned long mask0)
 {
 	unsigned long reg;
 
-	g_emma_clock_map &= ~(1 << source);
-	if (g_emma_clock_map == 0) {
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_EMMA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_EMMA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-	}
+	reg = __raw_readl(CCM_PCCR1);
+	reg |= mask1;
+	__raw_writel(reg, CCM_PCCR1);
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg |= mask0;
+	__raw_writel(reg, CCM_PCCR0);
 }
 
-/*
- * This function returns the clock CKIH clock input value.
- */
-static unsigned long mxc_clock_ckih(void)
+static void _clk_pccr10_disable(unsigned long mask1, unsigned long mask0)
 {
-	static unsigned long g_clk_ckih = 0;
+	unsigned long reg;
 
-	if (g_clk_ckih == 0) {
-		if ((__raw_readw(PBC_VERSION_REG) & CKIH_27MHZ_BIT_SET) == 0) {
-			g_clk_ckih = CKIH_CLK_FREQ_27MHZ;
-		} else {
-			g_clk_ckih = CKIH_CLK_FREQ;
-		}
-		pr_info("Clock input source is %ld\n", g_clk_ckih);
-	}
+	reg = __raw_readl(CCM_PCCR1);
+	reg &= ~mask1;
+	__raw_writel(reg, CCM_PCCR1);
+
+	reg = __raw_readl(CCM_PCCR0);
+	reg &= ~mask0;
+	__raw_writel(reg, CCM_PCCR0);
+}
+
+static int _clk_dma_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_DMA_MASK, CCM_PCCR1_HCLK_DMA_MASK);
 
-	return g_clk_ckih;
+	return 0;
 }
 
-/*!
- * This function returns the PLL output value in Hz based on pll.
- * @param       pll     PLL as defined in enum plls
- * @return      PLL value in Hz.
- */
-unsigned long mxc_pll_clock(enum plls pll)
+static void _clk_dma_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_DMA_MASK, CCM_PCCR1_HCLK_DMA_MASK);
+}
+
+static int _clk_rtic_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_RTIC_MASK, CCM_PCCR1_HCLK_RTIC_MASK);
+
+	return 0;
+}
+
+static void _clk_rtic_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_RTIC_MASK, CCM_PCCR1_HCLK_RTIC_MASK);
+}
+
+static int _clk_emma_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_EMMA_MASK, CCM_PCCR1_HCLK_EMMA_MASK);
+
+	return 0;
+}
+
+static void _clk_emma_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_EMMA_MASK, CCM_PCCR1_HCLK_EMMA_MASK);
+}
+
+static int _clk_slcdc_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_SLCDC_MASK, CCM_PCCR1_HCLK_SLCDC_MASK);
+
+	return 0;
+}
+
+static void _clk_slcdc_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_SLCDC_MASK, CCM_PCCR1_HCLK_SLCDC_MASK);
+}
+
+static int _clk_fec_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_FEC_MASK, CCM_PCCR1_HCLK_FEC_MASK);
+
+	return 0;
+}
+
+static void _clk_fec_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_FEC_MASK, CCM_PCCR1_HCLK_FEC_MASK);
+}
+
+static int _clk_vpu_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR1_VPU_BAUD_MASK, CCM_PCCR1_HCLK_VPU_MASK);
+
+	return 0;
+}
+
+static void _clk_vpu_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR1_VPU_BAUD_MASK, CCM_PCCR1_HCLK_VPU_MASK);
+}
+
+static int _clk_sahara2_enable(struct clk *clk)
+{
+	_clk_pccr01_enable(CCM_PCCR0_SAHARA_MASK, CCM_PCCR1_HCLK_SAHARA_MASK);
+
+	return 0;
+}
+
+static void _clk_sahara2_disable(struct clk *clk)
+{
+	_clk_pccr01_disable(CCM_PCCR0_SAHARA_MASK, CCM_PCCR1_HCLK_SAHARA_MASK);
+}
+
+static int _clk_mstick1_enable(struct clk *clk)
+{
+	_clk_pccr10_enable(CCM_PCCR1_MSHC_BAUD_MASK, CCM_PCCR0_MSHC_MASK);
+
+	return 0;
+}
+
+static void _clk_mstick1_disable(struct clk *clk)
+{
+	_clk_pccr10_disable(CCM_PCCR1_MSHC_BAUD_MASK, CCM_PCCR0_MSHC_MASK);
+}
+
+#define CSCR() (__raw_readl(CCM_CSCR))
+#define PCDR0() (__raw_readl(CCM_PCDR0))
+#define PCDR1() (__raw_readl(CCM_PCDR1))
+
+static void _clk_pll_recalc(struct clk *clk)
 {
 	unsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;
-	unsigned long ref_clk = 0, prcs = 0;
-	unsigned long reg, cscr;
+	unsigned long ref_clk;
+	unsigned long reg;
 	unsigned long long temp;
 
-	cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-	if (pll == MCUPLL) {
-		prcs = (cscr & CCM_CSCR_MCU);
-		if (prcs == CCM_CSCR_MCU) {
-			ref_clk = mxc_clock_ckih();
-		} else {
-			ref_clk = CKIL_CLK_FREQ;
-		}
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_MPCTL0);
+	ref_clk = clk->parent->rate;
+	if (clk->parent == &ckil_clk) {
+		ref_clk *= 1024;
+	}
+
+	if (clk == &mpll_clk) {
+		reg = __raw_readl(CCM_MPCTL0);
 		pdf = (reg & CCM_MPCTL0_PD_MASK) >> CCM_MPCTL0_PD_OFFSET;
 		mfd = (reg & CCM_MPCTL0_MFD_MASK) >> CCM_MPCTL0_MFD_OFFSET;
 		mfi = (reg & CCM_MPCTL0_MFI_MASK) >> CCM_MPCTL0_MFI_OFFSET;
 		mfn = (reg & CCM_MPCTL0_MFN_MASK) >> CCM_MPCTL0_MFN_OFFSET;
-	} else if (pll == SERIALPLL) {
-		prcs = (cscr & CCM_CSCR_SP);
-		if (prcs == CCM_CSCR_SP) {
-			ref_clk = mxc_clock_ckih();
-		} else {
-			ref_clk = CKIL_CLK_FREQ;
-		}
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_SPCTL0);
+	} else if (clk == &spll_clk) {
+		reg = __raw_readl(CCM_SPCTL0);
 		pdf = (reg & CCM_SPCTL0_PD_MASK) >> CCM_SPCTL0_PD_OFFSET;
 		mfd = (reg & CCM_SPCTL0_MFD_MASK) >> CCM_SPCTL0_MFD_OFFSET;
 		mfi = (reg & CCM_SPCTL0_MFI_MASK) >> CCM_SPCTL0_MFI_OFFSET;
 		mfn = (reg & CCM_SPCTL0_MFN_MASK) >> CCM_SPCTL0_MFN_OFFSET;
 	} else {
-		printk(KERN_ERR "\nUnknown pll: %d\n\n", pll);
 		BUG();		/* oops */
 	}
 
 	mfi = (mfi <= 5) ? 5 : mfi;
-	temp = (unsigned long long)2 *ref_clk * mfn;
+	temp = 2LL * ref_clk * mfn;
 	do_div(temp, mfd + 1);
-	temp = (unsigned long long)2 *ref_clk * mfi + temp;
+	temp = 2LL * ref_clk * mfi + temp;
 	do_div(temp, pdf + 1);
 
-	return (unsigned long)temp;
+	clk->rate = temp;
 }
 
-/*!
- * This function returns the mcu main clock frequency
- *
- * @return      mcu main clock value in Hz.
- */
-static unsigned long mxc_mcu_main_clock(void)
+static void _clk_cpu_recalc(struct clk *clk)
 {
-	return mxc_pll_clock(MCUPLL);
+	unsigned long presc_pdf;
+
+	presc_pdf = (CSCR() & CCM_CSCR_PRESC_MASK) >> CCM_CSCR_PRESC_OFFSET;
+
+	clk->rate = clk->parent->rate / (presc_pdf + 1);
 }
 
-/*!
- * This function returns the GPT module clock frequency
- *
- * @param       gpt_ctrl     GPT control register value
- * @param       perclk       PERCLK1 frequency in Hz
- *
- * @return      GPT clock frequency value in Hz.
- */
-static unsigned long mxc_get_gpt_clk(unsigned long gpt_ctrl,
-				     unsigned long perclk)
+static void _clk_ahb_recalc(struct clk *clk)
 {
-	unsigned long ret_val = 0;
-	int clksrc;
+	unsigned long bclk_pdf;
 
-	/*
-	 * Three possibilities
-	 */
-	clksrc = (gpt_ctrl & (~GPT_CTRL_MASK)) >> (GPT_CTRL_OFFSET);
-	switch (clksrc) {
-	case CLKSRC_PERCLK:
-		ret_val = perclk;
-		break;
-	case CLKSRC_PERCLK_4:
-		ret_val = (perclk / 4);
-		break;
-	case CLKSRC_NO_CLK:
-	case CLKSRC_EXT_PAD:
-		printk(KERN_ERR
-		       "Warning: GPT clock source not supported !!!\n");
-		return -ERR_CLK_NO_SUPPORT;
-	default:
-		ret_val = CKIL_CLK_FREQ;
-		break;
-	}
+	bclk_pdf = (CSCR() & CCM_CSCR_BCLK_MASK) >> CCM_CSCR_BCLK_OFFSET;
 
-	return ret_val;
+	clk->rate = clk->parent->rate / (bclk_pdf + 1);
 }
 
-/*!
- * This function returns the main clock values in Hz.
- *
- * @param       clk     as defined in enum mxc_clocks
- *
- * @return      clock value in Hz
- */
-unsigned long mxc_get_clocks(enum mxc_clocks clk)
+static void _clk_perclk1_recalc(struct clk *clk)
 {
-	unsigned long pll, spll, ret_val = 0, hclk, gpt_ctrl;
-	unsigned long presc_pdf, ipg_pdf, nfc_pdf, usb_pdf;
-	unsigned long cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-	unsigned long pcdr0 =
-	    __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-	unsigned long pcdr1 =
-	    __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+	unsigned long perclk1_pdf;
 
-	unsigned long fclk, ipgclk, perclk1, perclk2, perclk3, perclk4;
-	unsigned long bclk_pdf;
-	unsigned long perclk1_pdf, perclk2_pdf, perclk3_pdf, perclk4_pdf;
-	unsigned long clk_src;
-	unsigned long ssi1_pdf = 0;
-	unsigned long ssi2_pdf = 0;
-	unsigned long vpu_pdf = 0;
-	presc_pdf = (cscr & CCM_CSCR_PRESC_MASK) >> CCM_CSCR_PRESC_OFFSET;
-	bclk_pdf = (cscr & CCM_CSCR_BCLK_MASK) >> CCM_CSCR_BCLK_OFFSET;
-	ipg_pdf = (cscr & CCM_CSCR_IPDIV) >> CCM_CSCR_IPDIV_OFFSET;
 	perclk1_pdf =
-	    (pcdr1 & CCM_PCDR1_PERDIV1_MASK) >> CCM_PCDR1_PERDIV1_OFFSET;
+	    (PCDR1() & CCM_PCDR1_PERDIV1_MASK) >> CCM_PCDR1_PERDIV1_OFFSET;
+
+	clk->rate = clk->parent->rate / (perclk1_pdf + 1);
+}
+
+static void _clk_perclk2_recalc(struct clk *clk)
+{
+	unsigned long perclk2_pdf;
+
 	perclk2_pdf =
-	    (pcdr1 & CCM_PCDR1_PERDIV2_MASK) >> CCM_PCDR1_PERDIV2_OFFSET;
+	    (PCDR1() & CCM_PCDR1_PERDIV2_MASK) >> CCM_PCDR1_PERDIV2_OFFSET;
+
+	clk->rate = clk->parent->rate / (perclk2_pdf + 1);
+}
+
+static void _clk_perclk3_recalc(struct clk *clk)
+{
+	unsigned long perclk3_pdf;
+
 	perclk3_pdf =
-	    (pcdr1 & CCM_PCDR1_PERDIV3_MASK) >> CCM_PCDR1_PERDIV3_OFFSET;
-	perclk4_pdf =
-	    (pcdr1 & CCM_PCDR1_PERDIV4_MASK) >> CCM_PCDR1_PERDIV4_OFFSET;
+	    (PCDR1() & CCM_PCDR1_PERDIV3_MASK) >> CCM_PCDR1_PERDIV3_OFFSET;
 
-	pll = mxc_mcu_main_clock();
-	spll = mxc_pll_clock(SERIALPLL);
-	fclk = pll / (presc_pdf + 1);
-	hclk = fclk / (bclk_pdf + 1);
-	ipgclk = hclk / (ipg_pdf + 1);
-	perclk1 = pll / (perclk1_pdf + 1);
-	perclk2 = pll / (perclk2_pdf + 1);
-	perclk3 = pll / (perclk3_pdf + 1);
-	perclk4 = pll / (perclk4_pdf + 1);
-	switch (clk) {
-	case CKIL_CLK:
-		ret_val = CKIL_CLK_FREQ;
-		break;
-	case CKIH_CLK:
-		ret_val = mxc_clock_ckih();
-		break;
-	case CPU_CLK:
-		ret_val = fclk;
-		break;
-	case AHB_CLK:
-		ret_val = hclk;
-		break;
-	case PERCLK1:
-	case UART6_BAUD:
-	case UART5_BAUD:
-	case UART4_BAUD:
-	case UART3_BAUD:
-	case UART2_BAUD:
-	case UART1_BAUD:
-		ret_val = perclk1;
-		break;
-	case GPT6_CLK:
-		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(6));
-		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
-		break;
-	case GPT5_CLK:
-		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(5));
-		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
-		break;
-	case GPT4_CLK:
-		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(4));
-		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
-		break;
-	case GPT3_CLK:
-		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(3));
-		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
-		break;
-	case GPT2_CLK:
-		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(2));
-		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
-		break;
-	case GPT1_CLK:
-		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(1));
-		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
-		break;
-	case PWM_CLK:
-		ret_val = perclk1;
-		break;
-	case PERCLK2:
-	case SDHC2_CLK:
-	case SDHC1_CLK:
-	case CSPI3_CLK:
-	case CSPI2_CLK:
-	case CSPI1_CLK:
-		ret_val = perclk2;
-		break;
-	case PERCLK3:
-	case LCDC_CLK:
-		ret_val = perclk3;
-		break;
-	case PERCLK4:
-	case CSI_BAUD:
-		ret_val = perclk4;
-		break;
-	case USB_CLK:
-		usb_pdf = (cscr & CCM_CSCR_USB_MASK) >> CCM_CSCR_USB_OFFSET;
-		ret_val = spll / (usb_pdf + 1);
-		break;
-	case SSI1_BAUD:
-		ssi1_pdf = (pcdr0 & CCM_PCDR0_SSI1BAUDDIV_MASK) >>
-		    CCM_PCDR0_SSI1BAUDDIV_OFFSET;
-		clk_src = (cscr & CCM_CSCR_SSI1) >> CCM_CSCR_SSI1_OFFSET;
-		if (clk_src)
-			ret_val = pll / (ssi1_pdf + 1);
-		else
-			ret_val = spll / (ssi1_pdf + 1);
-		break;
-	case SSI2_BAUD:
-		ssi1_pdf = (pcdr0 & CCM_PCDR0_SSI2BAUDDIV_MASK) >>
-		    CCM_PCDR0_SSI2BAUDDIV_OFFSET;
-		clk_src = (cscr & CCM_CSCR_SSI2) >> CCM_CSCR_SSI2_OFFSET;
-		if (clk_src)
-			ret_val = pll / (ssi2_pdf + 1);
-		else
-			ret_val = spll / (ssi2_pdf + 1);
-		break;
-	case NFC_CLK:
-		nfc_pdf = (pcdr0 & CCM_PCDR0_NFCDIV_MASK) >>
-		    CCM_PCDR0_NFCDIV_OFFSET;
-		ret_val = hclk / (nfc_pdf + 1);
-		break;
-	case VPU_BAUD:
-		vpu_pdf = (pcdr0 & CCM_PCDR0_VPUDIV_MASK) >>
-		    CCM_PCDR0_VPUDIV_OFFSET;
-		clk_src = (cscr & CCM_CSCR_VPU) >> CCM_CSCR_VPU_OFFSET;
-		if (clk_src)
-			ret_val = pll / (vpu_pdf + 1);
-		else
-			ret_val = spll / (vpu_pdf + 1);
-		break;
-	case OWIRE_CLK:
-	default:
-		ret_val = ipgclk;
-		break;
-	}
-	return ret_val;
+	clk->rate = clk->parent->rate / (perclk3_pdf + 1);
 }
 
-/*!
- * This function returns the parent clock values in Hz.
- *
- * @param       clk     as defined in enum mxc_clocks
- *
- * @return      clock value in Hz
- */
-unsigned long mxc_get_clocks_parent(enum mxc_clocks clk)
+static unsigned long _clk_perclkx_round_rate(struct clk *clk,
+					     unsigned long rate)
 {
-	unsigned long ret_val = 0;
+	u32 div;
 
-	switch (clk) {
-	case CSI_BAUD:
-		ret_val = mxc_mcu_main_clock();
-		break;
-	default:
-		break;
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 64) {
+		div = 64;
 	}
-	return ret_val;
+
+	return clk->parent->rate / div;
 }
 
-/*!
- * This function sets the PLL source for a clock.
- *
- * @param clk     as defined in enum mxc_clocks
- * @param pll_num the PLL that you wish to use as source for this clock
- */
-void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num)
+static int _clk_perclk3_set_rate(struct clk *clk, unsigned long rate)
 {
-	unsigned long cscr;
-	unsigned long flags;
+	u32 reg;
+	u32 div;
 
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	div = clk->parent->rate / rate;
 
-	switch (clk) {
-	case SSI1_BAUD:
-		cscr = (cscr & (~CCM_CSCR_SSI1)) |
-		    (pll_num << CCM_CSCR_SSI1_OFFSET);
-		break;
-	case SSI2_BAUD:
-		cscr = (cscr & (~CCM_CSCR_SSI2)) |
-		    (pll_num << CCM_CSCR_SSI2_OFFSET);
-		break;
-	case VPU_BAUD:
-		cscr = (cscr & (~CCM_CSCR_VPU)) |
-		    (pll_num << CCM_CSCR_VPU_OFFSET);
-		break;
-	default:
-		printk(KERN_ERR
-		       "This clock does not have ability to choose its clock source\n");
-		break;
+	if (div > 64 || div < 1 || ((clk->parent->rate / div) != rate)) {
+		return -EINVAL;
 	}
-	__raw_writel(cscr, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-	return;
+	div--;
+
+	reg = __raw_readl(CCM_PCDR1) & ~CCM_PCDR1_PERDIV3_MASK;
+	reg |= div << CCM_PCDR1_PERDIV3_OFFSET;
+	__raw_writel(reg, CCM_PCDR1);
+
+	clk->rate = rate;
+
+	return 0;
 }
 
-/*!
- * This function sets the divider value for a clock.
- *
- * @param clk as defined in enum mxc_clocks
- * @param div the division factor to be used for the clock (For SSI & CSI, pass
- *            in 2 times the expected division value to account for FP vals on certain
- *            platforms)
- */
-void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div)
+static void _clk_perclk4_recalc(struct clk *clk)
 {
-	unsigned long reg;
-	unsigned long flags;
+	unsigned long perclk4_pdf;
+
+	perclk4_pdf =
+	    (PCDR1() & CCM_PCDR1_PERDIV4_MASK) >> CCM_PCDR1_PERDIV4_OFFSET;
+
+	clk->rate = clk->parent->rate / (perclk4_pdf + 1);
+}
+
+static int _clk_perclk4_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
 
-	spin_lock_irqsave(&mxc_crm_lock, flags);
+	div = clk->parent->rate / rate;
 
-	switch (clk) {
-	case SSI2_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-		reg = (reg & (~CCM_PCDR0_SSI2BAUDDIV_MASK)) |
-		    ((div - 1) << CCM_PCDR0_SSI2BAUDDIV_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-		break;
-	case SSI1_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-		reg = (reg & (~CCM_PCDR0_SSI1BAUDDIV_MASK)) |
-		    ((div - 1) << CCM_PCDR0_SSI1BAUDDIV_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-		break;
-	case NFC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-		reg = (reg & (~CCM_PCDR0_NFCDIV_MASK)) |
-		    ((div - 1) << CCM_PCDR0_NFCDIV_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-		break;
-	case VPU_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-		reg = (reg & (~CCM_PCDR0_VPUDIV_MASK)) |
-		    ((div - 1) << CCM_PCDR0_VPUDIV_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-		break;
-	case PERCLK1:
-	case UART6_BAUD:
-	case UART5_BAUD:
-	case UART4_BAUD:
-	case UART3_BAUD:
-	case UART2_BAUD:
-	case UART1_BAUD:
-	case GPT6_CLK:
-	case GPT5_CLK:
-	case GPT4_CLK:
-	case GPT3_CLK:
-	case GPT2_CLK:
-	case GPT1_CLK:
-	case PWM_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
-		reg = (reg & (~CCM_PCDR1_PERDIV1_MASK)) |
-		    ((div - 1) << CCM_PCDR1_PERDIV1_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
-		break;
-	case PERCLK2:
-	case SDHC2_CLK:
-	case SDHC1_CLK:
-	case CSPI3_CLK:
-	case CSPI2_CLK:
-	case CSPI1_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
-		reg = (reg & (~CCM_PCDR1_PERDIV2_MASK)) |
-		    ((div - 1) << CCM_PCDR1_PERDIV2_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
-		break;
-	case PERCLK3:
-	case LCDC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
-		reg = (reg & (~CCM_PCDR1_PERDIV3_MASK)) |
-		    ((div - 1) << CCM_PCDR1_PERDIV3_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
-		break;
-	case PERCLK4:
-	case CSI_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
-		reg = (reg & (~CCM_PCDR1_PERDIV4_MASK)) |
-		    ((div - 1) << CCM_PCDR1_PERDIV4_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
-		break;
-	case USB_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		reg = (reg & (~CCM_CSCR_USB_MASK)) |
-		    ((div - 1) << CCM_CSCR_USB_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		break;
-	case IPG_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		reg = (reg & (~CCM_CSCR_IPDIV)) |
-		    ((div - 1) << CCM_CSCR_IPDIV_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		break;
-	case CPU_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		reg = (reg & (~CCM_CSCR_PRESC_MASK)) |
-		    ((div - 1) << CCM_CSCR_PRESC_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		break;
-	case AHB_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		reg = (reg & (~CCM_CSCR_BCLK_MASK)) |
-		    ((div - 1) << CCM_CSCR_BCLK_OFFSET);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		break;
-	default:
-		break;
+	if (div > 64 || div < 1 || ((clk->parent->rate / div) != rate)) {
+		return -EINVAL;
 	}
+	div--;
+
+	reg = __raw_readl(CCM_PCDR1) & ~CCM_PCDR1_PERDIV4_MASK;
+	reg |= div << CCM_PCDR1_PERDIV4_OFFSET;
+	__raw_writel(reg, CCM_PCDR1);
 
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	clk->rate = rate;
+
+	return 0;
 }
 
-/*!
- * This function is called to enable the individual module clocks
- *
- * @param       clk     as defined in enum mxc_clocks
- */
-void mxc_clks_enable(enum mxc_clocks clk)
+static void _clk_usb_recalc(struct clk *clk)
 {
-	unsigned long flags;
-	unsigned long reg;
+	unsigned long usb_pdf;
 
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	switch (clk) {
-	case CSI_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_PERCLK4;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_CSI;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case DMA_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_DMA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_DMA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case RTIC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_RTIC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_RTIC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case BROM_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_BROM;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case EMMA_PRP_CLK:
-		__enable_emma_clk(MXC_CLK_EMMA_PRP);
-		break;
-	case EMMA_PP_CLK:
-		__enable_emma_clk(MXC_CLK_EMMA_PP);
-		break;
-	case LCDC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_PERCLK3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_LCDC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_LCDC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case SLCDC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_SLCDC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_SLCDC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case USB_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_USBOTG;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_USBOTG;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case FEC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_FEC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_FEC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case EMI_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_EMI;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case ATA_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_ATA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case VPU_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_VPU_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_VPU;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case SAHARA2_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_SAHARA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_HCLK_SAHARA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case SSI1_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_SSI1_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_SSI1_IPG;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SSI2_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_SSI2_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_SSI2_IPG;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case NFC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_NFC_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case MSTICK1_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_MSHC_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_MSHC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case UART1_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_UART1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART2_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_UART2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART3_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_UART3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART4_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_UART4;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART5_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_UART5;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART6_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_UART6;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case WDOG_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg |= CCM_PCCR1_WDT;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-
-	case CSPI3_CLK:
-		__enable_perclk2(MXC_CLK_PCLK2_CSPI3);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_CSPI3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case CSPI2_CLK:
-		__enable_perclk2(MXC_CLK_PCLK2_CSPI2);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_CSPI2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case CSPI1_CLK:
-		__enable_perclk2(MXC_CLK_PCLK2_CSPI1);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_CSPI1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPIO_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_GPIO;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT3_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_GPT3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT2_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_GPT2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT1_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_GPT1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT4_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_GPT4;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT5_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_GPT5;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT6_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_GPT6;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case I2C1_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_I2C1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case I2C2_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_I2C2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case IIM_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_IIM;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case KPP_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_KPP;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case OWIRE_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_OWIRE;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case PWM_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_PWM;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case RTC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_RTC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SCC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_SCC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SDHC2_CLK:
-		__enable_perclk2(MXC_CLK_PCLK2_SDHC2);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_SDHC2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SDHC1_CLK:
-		__enable_perclk2(MXC_CLK_PCLK2_SDHC1);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_SDHC1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SDHC3_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg |= CCM_PCCR0_SDHC3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
+	usb_pdf = (CSCR() & CCM_CSCR_USB_MASK) >> CCM_CSCR_USB_OFFSET;
 
-	default:
-		break;
-	}
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	clk->rate = clk->parent->rate / (usb_pdf + 1);
 }
 
-/*!
- * This function is called to disable the individual module clocks
- *
- * @param       clk     as defined in enum mxc_clocks
- */
-void mxc_clks_disable(enum mxc_clocks clk)
+static void _clk_ssi1_recalc(struct clk *clk)
 {
-	unsigned long flags;
-	unsigned long reg;
+	unsigned long ssi1_pdf;
+
+	ssi1_pdf = (PCDR0() & CCM_PCDR0_SSI1BAUDDIV_MASK) >>
+	    CCM_PCDR0_SSI1BAUDDIV_OFFSET;
+
+	clk->rate = clk->parent->rate / (ssi1_pdf + 1);
+}
+
+static void _clk_ssi2_recalc(struct clk *clk)
+{
+	unsigned long ssi2_pdf;
+
+	ssi2_pdf = (PCDR0() & CCM_PCDR0_SSI2BAUDDIV_MASK) >>
+	    CCM_PCDR0_SSI2BAUDDIV_OFFSET;
+
+	clk->rate = clk->parent->rate / (ssi2_pdf + 1);
+}
+
+static void _clk_nfc_recalc(struct clk *clk)
+{
+	unsigned long nfc_pdf;
+
+	nfc_pdf = (PCDR0() & CCM_PCDR0_NFCDIV_MASK) >> CCM_PCDR0_NFCDIV_OFFSET;
+
+	clk->rate = clk->parent->rate / (nfc_pdf + 1);
+}
+
+static void _clk_vpu_recalc(struct clk *clk)
+{
+	unsigned long vpu_pdf;
+
+	vpu_pdf = (PCDR0() & CCM_PCDR0_VPUDIV_MASK) >> CCM_PCDR0_VPUDIV_OFFSET;
+
+	clk->rate = clk->parent->rate / (vpu_pdf + 1);
+}
+
+static void _clk_ipg_recalc(struct clk *clk)
+{
+	unsigned long ipg_pdf;
 
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	switch (clk) {
-	case CSI_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_CSI;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_PERCLK4;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case DMA_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_DMA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_DMA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case RTIC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_RTIC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_RTIC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case BROM_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_BROM;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case EMMA_PRP_CLK:
-		__disable_emma_clk(MXC_CLK_EMMA_PRP);
-		break;
-	case EMMA_PP_CLK:
-		__disable_emma_clk(MXC_CLK_EMMA_PP);
-		break;
-		break;
-	case LCDC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_LCDC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_LCDC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_PERCLK3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case SLCDC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_SLCDC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_SLCDC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case USB_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_USBOTG;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_USBOTG;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case FEC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_FEC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_FEC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case EMI_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_EMI;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case ATA_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_ATA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case VPU_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_VPU_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_VPU;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case SAHARA2_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_SAHARA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_HCLK_SAHARA;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case SSI1_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_SSI1_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_SSI1_IPG;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SSI2_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_SSI2_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_SSI2_IPG;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case NFC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_NFC_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case MSTICK1_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_MSHC_BAUD;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_MSHC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case UART1_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_UART1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART2_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_UART2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART3_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_UART3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART4_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_UART4;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART5_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_UART5;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case UART6_BAUD:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_UART6;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case WDOG_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		reg &= ~CCM_PCCR1_WDT;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
-		break;
-	case CSPI3_CLK:
-		__disable_perclk2(MXC_CLK_PCLK2_CSPI3);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_CSPI3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case CSPI2_CLK:
-		__disable_perclk2(MXC_CLK_PCLK2_CSPI2);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_CSPI2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case CSPI1_CLK:
-		__disable_perclk2(MXC_CLK_PCLK2_CSPI1);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_CSPI1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPIO_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_GPIO;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT3_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_GPT3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT2_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_GPT2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT1_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_GPT1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT4_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_GPT4;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT5_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_GPT5;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case GPT6_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_GPT6;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case I2C1_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_I2C1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case I2C2_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_I2C2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case IIM_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_IIM;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case KPP_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_KPP;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case OWIRE_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_OWIRE;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case PWM_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_PWM;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case RTC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_RTC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SCC_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_SCC;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SDHC2_CLK:
-		__disable_perclk2(MXC_CLK_PCLK2_SDHC2);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_SDHC2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SDHC1_CLK:
-		__disable_perclk2(MXC_CLK_PCLK2_SDHC1);
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_SDHC1;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	case SDHC3_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		reg &= ~CCM_PCCR0_SDHC3;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
-		break;
-	default:
-		break;
+	ipg_pdf = (CSCR() & CCM_CSCR_IPDIV) >> CCM_CSCR_IPDIV_OFFSET;
+
+	clk->rate = clk->parent->rate / (ipg_pdf + 1);
+}
+
+static unsigned long _clk_parent_round_rate(struct clk *clk, unsigned long rate)
+{
+	return clk->parent->round_rate(clk->parent, rate);
+}
+
+static int _clk_parent_set_rate(struct clk *clk, unsigned long rate)
+{
+	int ret;
+	if ((ret = clk->parent->set_rate(clk->parent, rate)) == 0)
+		clk->rate = rate;
+	return ret;
+}
+
+static struct clk ckih_clk = {
+	.name = "ckih",
+	.rate = 0,		/* determined at boot time (26 or 27 MHz) */
+};
+
+static struct clk ckil_clk = {
+	.name = "ckil",
+	.rate = CKIL_CLK_FREQ,
+};
+
+static struct clk mpll_clk = {
+	.name = "mpll",
+	.parent = &ckih_clk,
+	.recalc = _clk_pll_recalc,
+};
+
+static struct clk spll_clk = {
+	.name = "spll",
+	.parent = &ckih_clk,
+	.recalc = _clk_pll_recalc,
+};
+
+static struct clk cpu_clk = {
+	.name = "cpu_clk",
+	.parent = &mpll_clk,
+	.recalc = _clk_cpu_recalc,
+};
+
+static struct clk ahb_clk = {
+	.name = "ahb_clk",
+	.parent = &cpu_clk,
+	.recalc = _clk_ahb_recalc,
+};
+
+static struct clk ipg_clk = {
+	.name = "ipg_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_ipg_recalc,
+};
+
+static struct clk per_clk[] = {
+	{
+	 .name = "per_clk",
+	 .id = 0,
+	 .parent = &mpll_clk,
+	 .recalc = _clk_perclk1_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_PERCLK1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "per_clk",
+	 .id = 1,
+	 .parent = &mpll_clk,
+	 .recalc = _clk_perclk2_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_PERCLK2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "per_clk",
+	 .id = 2,
+	 .parent = &mpll_clk,
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclk3_set_rate,
+	 .recalc = _clk_perclk3_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_PERCLK3_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "per_clk",
+	 .id = 3,
+	 .parent = &mpll_clk,
+	 .round_rate = _clk_perclkx_round_rate,
+	 .set_rate = _clk_perclk4_set_rate,
+	 .recalc = _clk_perclk4_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_PERCLK4_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart1_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 0,
+	 .parent = &per_clk[0],
+	 .secondary = &uart1_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart2_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 1,
+	 .parent = &per_clk[0],
+	 .secondary = &uart2_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart3_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 2,
+	 .parent = &per_clk[0],
+	 .secondary = &uart3_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart4_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 3,
+	 .parent = &per_clk[0],
+	 .secondary = &uart4_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART4_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart5_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 4,
+	 .parent = &per_clk[0],
+	 .secondary = &uart5_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART5_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+struct clk uart6_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 5,
+	 .parent = &per_clk[0],
+	 .secondary = &uart6_clk[1],},
+	{
+	 .name = "uart_ipg_clk",
+	 .id = 5,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_UART6_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt1_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 0,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt1_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt2_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 1,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt2_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt3_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 2,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt3_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt4_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 3,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt4_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 3,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT4_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt5_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 4,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt5_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 4,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT5_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk gpt6_clk[] = {
+	{
+	 .name = "gpt_clk",
+	 .id = 5,
+	 .parent = &per_clk[0],
+	 .secondary = &gpt6_clk[1],},
+	{
+	 .name = "gpt_ipg_clk",
+	 .id = 5,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_GPT6_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk pwm_clk[] = {
+	{
+	 .name = "pwm_clk",
+	 .parent = &per_clk[0],
+	 .secondary = &pwm_clk[1],},
+	{
+	 .name = "pwm_clk",
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_PWM_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk sdhc1_clk[] = {
+	{
+	 .name = "sdhc_clk",
+	 .id = 0,
+	 .parent = &per_clk[1],
+	 .secondary = &sdhc1_clk[1],},
+	{
+	 .name = "sdhc_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SDHC1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk sdhc2_clk[] = {
+	{
+	 .name = "sdhc_clk",
+	 .id = 1,
+	 .parent = &per_clk[1],
+	 .secondary = &sdhc2_clk[1],},
+	{
+	 .name = "sdhc_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SDHC2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk sdhc3_clk[] = {
+	{
+	 .name = "sdhc_clk",
+	 .id = 2,
+	 .parent = &per_clk[1],
+	 .secondary = &sdhc3_clk[1],},
+	{
+	 .name = "sdhc_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SDHC3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk cspi1_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 0,
+	 .parent = &per_clk[1],
+	 .secondary = &cspi1_clk[1],},
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_CSPI1_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk cspi2_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 1,
+	 .parent = &per_clk[1],
+	 .secondary = &cspi2_clk[1],},
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_CSPI2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk cspi3_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 2,
+	 .parent = &per_clk[1],
+	 .secondary = &cspi3_clk[1],},
+	{
+	 .name = "cspi_ipg_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_CSPI3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk lcdc_clk[] = {
+	{
+	 .name = "lcdc_clk",
+	 .parent = &per_clk[2],
+	 .secondary = &lcdc_clk[1],
+	 .round_rate = _clk_parent_round_rate,
+	 .set_rate = _clk_parent_set_rate,},
+	{
+	 .name = "lcdc_ipg_clk",
+	 .parent = &ipg_clk,
+	 .secondary = &lcdc_clk[2],
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_LCDC_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "lcdc_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_HCLK_LCDC_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk csi_clk[] = {
+	{
+	 .name = "csi_clk",
+	 .parent = &per_clk[3],
+	 .secondary = &csi_clk[1],
+	 .round_rate = _clk_parent_round_rate,
+	 .set_rate = _clk_parent_set_rate,},
+	{
+	 .name = "csi_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_HCLK_CSI_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk usb_clk[] = {
+	{
+	 .name = "usb_clk",
+	 .parent = &spll_clk,
+	 .secondary = &usb_clk[1],
+	 .recalc = _clk_usb_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_USBOTG_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "usb_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_HCLK_USBOTG_OFFSET,
+	 .disable = _clk_disable,}
+};
+
+static struct clk ssi1_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 0,
+	 .parent = &mpll_clk,
+	 .secondary = &ssi1_clk[1],
+	 .recalc = _clk_ssi1_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_SSI1_BAUD_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SSI1_IPG_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk ssi2_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .id = 1,
+	 .parent = &mpll_clk,
+	 .secondary = &ssi2_clk[1],
+	 .recalc = _clk_ssi2_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR1,
+	 .enable_shift = CCM_PCCR1_SSI2_BAUD_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "ssi_ipg_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_SSI2_IPG_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk nfc_clk = {
+	.name = "nfc_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_nfc_recalc,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_NFC_BAUD_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk vpu_clk = {
+	.name = "vpu_clk",
+	.parent = &mpll_clk,
+	.recalc = _clk_vpu_recalc,
+	.enable = _clk_vpu_enable,
+	.disable = _clk_vpu_disable,
+};
+
+static struct clk dma_clk = {
+	.name = "dma_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_dma_enable,
+	.disable = _clk_dma_disable,
+};
+
+static struct clk rtic_clk = {
+	.name = "rtic_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_rtic_enable,
+	.disable = _clk_rtic_disable,
+};
+
+static struct clk brom_clk = {
+	.name = "brom_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_HCLK_BROM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk emma_clk = {
+	.name = "emma_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_emma_enable,
+	.disable = _clk_emma_disable,
+};
+
+static struct clk slcdc_clk = {
+	.name = "slcdc_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_slcdc_enable,
+	.disable = _clk_slcdc_disable,
+};
+
+static struct clk fec_clk = {
+	.name = "fec_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_fec_enable,
+	.disable = _clk_fec_disable,
+};
+
+static struct clk emi_clk = {
+	.name = "emi_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_HCLK_EMI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk sahara2_clk = {
+	.name = "sahara_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_sahara2_enable,
+	.disable = _clk_sahara2_disable,
+};
+
+static struct clk ata_clk = {
+	.name = "ata_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_HCLK_ATA_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mstick1_clk = {
+	.name = "mstick1_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_mstick1_enable,
+	.disable = _clk_mstick1_disable,
+};
+
+static struct clk wdog_clk = {
+	.name = "wdog_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR1_WDT_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk gpio_clk = {
+	.name = "gpio_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR1,
+	.enable_shift = CCM_PCCR0_GPIO_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .name = "i2c_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_I2C1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "i2c_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = CCM_PCCR0,
+	 .enable_shift = CCM_PCCR0_I2C2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk iim_clk = {
+	.name = "iim_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_IIM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk kpp_clk = {
+	.name = "kpp_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_KPP_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk owire_clk = {
+	.name = "owire_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_OWIRE_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rtc_clk = {
+	.name = "rtc_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_RTC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk scc_clk = {
+	.name = "scc_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = CCM_PCCR0,
+	.enable_shift = CCM_PCCR0_SCC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static unsigned long _clk_clko_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 8) {
+		div = 8;
 	}
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+
+	return clk->parent->rate / div;
 }
 
-/*!
- * This function is used to modify PLL registers to generate the required
- * frequency.
- *
- * @param  pll_num  the PLL that you wish to modify
- * @param  mfi      multiplication factor integer part
- * @param  pdf      pre-division factor
- * @param  mfd      multiplication factor denominator
- * @param  mfn      multiplication factor numerator
- */
-void mxc_pll_set(enum plls pll_num, unsigned int mfi, unsigned int pdf,
-		 unsigned int mfd, unsigned int mfn)
+static int _clk_clko_set_rate(struct clk *clk, unsigned long rate)
 {
-	unsigned long cscr;
-	unsigned long flags;
-	unsigned long new_pll = 0;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-
-	if (pll_num == MCUPLL) {
-		/* Change the Pll value      */
-		new_pll = (mfi << CCM_MPCTL0_MFI_OFFSET) |
-		    (mfn << CCM_MPCTL0_MFN_OFFSET) |
-		    (mfd << CCM_MPCTL0_MFD_OFFSET) |
-		    (pdf << CCM_MPCTL0_PD_OFFSET);
-
-		__raw_writel(new_pll, IO_ADDRESS(CCM_BASE_ADDR) + CCM_MPCTL0);
-		/* Swap to reference clock and disable PLL */
-		cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		cscr |= CCM_CSCR_MPLLRES;
-		__raw_writel(cscr, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-	} else {
-		if (pll_num == SERIALPLL) {
-			/* Change the Pll value      */
-			new_pll = (mfi << CCM_SPCTL0_MFI_OFFSET) |
-			    (mfn << CCM_SPCTL0_MFN_OFFSET) |
-			    (mfd << CCM_SPCTL0_MFD_OFFSET) |
-			    (pdf << CCM_SPCTL0_PD_OFFSET);
-
-			__raw_writel(new_pll,
-				     IO_ADDRESS(CCM_BASE_ADDR) + CCM_SPCTL0);
-			/* Swap to reference clock and disable PLL */
-			cscr =
-			    __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-			cscr |= CCM_CSCR_SPLLRES;
-			__raw_writel(cscr,
-				     IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
-		}
+	u32 reg;
+	u32 div;
+
+	div = clk->parent->rate / rate;
+
+	if (div > 8 || div < 1 || ((clk->parent->rate / div) != rate)) {
+		return -EINVAL;
 	}
+	div--;
+
+	reg = __raw_readl(CCM_PCDR0) & ~CCM_PCDR0_CLKODIV_MASK;
+	reg |= div << CCM_PCDR0_CLKODIV_OFFSET;
+	__raw_writel(reg, CCM_PCDR0);
+
+	clk->rate = rate;
 
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	return 0;
 }
 
-/*!
- * Configure clock output on CKO pins
- *
- * @param   output  clock output pin
- * @param   clk     clock source to output
- * @param   div     CLKO divider
- *
- */
-void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk, int div)
+static void _clk_clko_recalc(struct clk *clk)
 {
-	unsigned long flags;
-	unsigned long reg;
+	u32 div;
+
+	div = __raw_readl(CCM_PCDR0) & CCM_PCDR0_CLKODIV_MASK >>
+	    CCM_PCDR0_CLKODIV_OFFSET;
+	div++;
+
+	clk->rate = clk->parent->rate / div;
+}
 
-	if (output != CKO) {
-		return;
+static int _clk_clko_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
+
+	reg = __raw_readl(CCM_CCSR) & ~CCM_CCSR_CLKOSEL_MASK;
+
+	if (parent == &ckil_clk) {
+		reg |= 0 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ckih_clk) {
+		reg |= 2 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == mpll_clk.parent) {
+		reg |= 3 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == spll_clk.parent) {
+		reg |= 4 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &mpll_clk) {
+		reg |= 5 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &spll_clk) {
+		reg |= 6 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &cpu_clk) {
+		reg |= 7 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ahb_clk) {
+		reg |= 8 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ipg_clk) {
+		reg |= 9 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &per_clk[0]) {
+		reg |= 0xA << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &per_clk[1]) {
+		reg |= 0xB << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &per_clk[2]) {
+		reg |= 0xC << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &per_clk[3]) {
+		reg |= 0xD << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ssi1_clk[0]) {
+		reg |= 0xE << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &ssi2_clk[0]) {
+		reg |= 0xF << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &nfc_clk) {
+		reg |= 0x10 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &mstick1_clk) {
+		reg |= 0x11 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &vpu_clk) {
+		reg |= 0x12 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else if (parent == &usb_clk[0]) {
+		reg |= 0x15 << CCM_CCSR_CLKOSEL_OFFSET;
+	} else {
+		return -EINVAL;
 	}
 
-	spin_lock_irqsave(&mxc_crm_lock, flags);
+	__raw_writel(reg, CCM_CCSR);
 
-	switch (clk) {
-	case CKIH_CLK:
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
-		reg = (reg & (~0x1f)) | 0x2;
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
-
-		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-		reg = (reg & (~0x03c00000)) | 0x02000000 | ((div - 1) << 22);
-		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
-
-		break;
-	default:
-		break;
-	};
+	return 0;
+}
+
+static int _clk_clko_enable(struct clk *clk)
+{
+	u32 reg;
 
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-	return;
+	reg = __raw_readl(CCM_PCDR0) | CCM_PCDR0_CLKO_EN;
+	__raw_writel(reg, CCM_PCDR0);
+
+	return 0;
 }
 
-/*!
- * This function is called to read the contents of a CCM_MCU register
- *
- * @param reg_offset the CCM_MCU register that will read
- *
- * @return the register contents
- */
-unsigned long mxc_ccm_get_reg(unsigned int reg_offset)
+static void _clk_clko_disable(struct clk *clk)
 {
-	/* TODO */
-	return 0xFFFFFFFF;
+	u32 reg;
+
+	reg = __raw_readl(CCM_PCDR0) & ~CCM_PCDR0_CLKO_EN;
+	__raw_writel(reg, CCM_PCDR0);
 }
 
+static struct clk clko_clk = {
+	.name = "clko_clk",
+	.recalc = _clk_clko_recalc,
+	.set_rate = _clk_clko_set_rate,
+	.round_rate = _clk_clko_round_rate,
+	.set_parent = _clk_clko_set_parent,
+	.enable = _clk_clko_enable,
+	.disable = _clk_clko_disable,
+};
+
+static struct clk *mxc_clks[] = {
+	&ckih_clk,
+	&ckil_clk,
+	&mpll_clk,
+	&spll_clk,
+	&cpu_clk,
+	&ahb_clk,
+	&ipg_clk,
+	&per_clk[0],
+	&per_clk[1],
+	&per_clk[2],
+	&per_clk[3],
+	&clko_clk,
+	&uart1_clk[0],
+	&uart1_clk[1],
+	&uart2_clk[0],
+	&uart2_clk[1],
+	&uart3_clk[0],
+	&uart3_clk[1],
+	&uart4_clk[0],
+	&uart4_clk[1],
+	&uart5_clk[0],
+	&uart5_clk[1],
+	&uart6_clk[0],
+	&uart6_clk[1],
+	&gpt1_clk[0],
+	&gpt1_clk[1],
+	&gpt2_clk[0],
+	&gpt2_clk[1],
+	&gpt3_clk[0],
+	&gpt3_clk[1],
+	&gpt4_clk[0],
+	&gpt4_clk[1],
+	&gpt5_clk[0],
+	&gpt5_clk[1],
+	&gpt6_clk[0],
+	&gpt6_clk[1],
+	&pwm_clk[0],
+	&pwm_clk[1],
+	&sdhc1_clk[0],
+	&sdhc1_clk[1],
+	&sdhc2_clk[0],
+	&sdhc2_clk[1],
+	&sdhc3_clk[0],
+	&sdhc3_clk[1],
+	&cspi1_clk[0],
+	&cspi1_clk[1],
+	&cspi2_clk[0],
+	&cspi2_clk[1],
+	&cspi3_clk[0],
+	&cspi3_clk[1],
+	&lcdc_clk[0],
+	&lcdc_clk[1],
+	&lcdc_clk[2],
+	&csi_clk[0],
+	&csi_clk[1],
+	&usb_clk[0],
+	&usb_clk[1],
+	&ssi1_clk[0],
+	&ssi1_clk[1],
+	&ssi2_clk[0],
+	&ssi2_clk[1],
+	&nfc_clk,
+	&vpu_clk,
+	&dma_clk,
+	&rtic_clk,
+	&brom_clk,
+	&emma_clk,
+	&slcdc_clk,
+	&fec_clk,
+	&emi_clk,
+	&sahara2_clk,
+	&ata_clk,
+	&mstick1_clk,
+	&wdog_clk,
+	&gpio_clk,
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&iim_clk,
+	&kpp_clk,
+	&owire_clk,
+	&rtc_clk,
+	&scc_clk,
+};
+
 /*!
- * This function is called to modify the contents of a CCM_MCU register
+ * Function to get timer clock rate early in boot process before clock tree is
+ * initialized.
  *
- * @param reg_offset the CCM_MCU register that will read
- * @param mask       the mask to be used to clear the bits that are to be modified
- * @param data       the data that should be written to the register
+ * @return	Clock rate for timer
  */
-void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
-			unsigned int data)
+unsigned long __init clk_early_get_timer_rate(void)
 {
-	/* TODO */
+	if (CSCR() & CCM_CSCR_MCU) {
+		mpll_clk.parent = &ckih_clk;
+	} else {
+		mpll_clk.parent = &ckil_clk;
+	}
+
+	/* Determine which high frequency clock source is coming in */
+	if ((__raw_readw(PBC_VERSION_REG) & CKIH_27MHZ_BIT_SET) == 0) {
+		ckih_clk.rate = CKIH_CLK_FREQ_27MHZ;
+	} else {
+		ckih_clk.rate = CKIH_CLK_FREQ;
+	}
+	mpll_clk.recalc(&mpll_clk);
+	per_clk[0].recalc(&per_clk[0]);
+	per_clk[0].enable(&per_clk[0]);
+	gpt1_clk[1].enable(&gpt1_clk[1]);
+	return per_clk[0].rate;
 }
 
-EXPORT_SYMBOL(mxc_pll_set);
-EXPORT_SYMBOL(mxc_pll_clock);
-EXPORT_SYMBOL(mxc_get_clocks);
-EXPORT_SYMBOL(mxc_set_clocks_pll);
-EXPORT_SYMBOL(mxc_set_clocks_div);
-EXPORT_SYMBOL(mxc_clks_disable);
-EXPORT_SYMBOL(mxc_clks_enable);
-EXPORT_SYMBOL(mxc_ccm_get_reg);
-EXPORT_SYMBOL(mxc_ccm_modify_reg);
-EXPORT_SYMBOL(mxc_set_clock_output);
-EXPORT_SYMBOL(mxc_get_clocks_parent);
+extern void propagate_rate(struct clk *tclk);
+
+int __init mxc_clocks_init(void)
+{
+	u32 cscr;
+	struct clk **clkp;
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++) {
+		clk_register(*clkp);
+	}
+
+	/* Turn off all possible clocks */
+	// TODO
+
+	cscr = CSCR();
+	if (cscr & CCM_CSCR_MCU) {
+		mpll_clk.parent = &ckih_clk;
+	} else {
+		mpll_clk.parent = &ckil_clk;
+	}
+	if (cscr & CCM_CSCR_SP) {
+		mpll_clk.parent = &ckih_clk;
+	} else {
+		mpll_clk.parent = &ckil_clk;
+	}
+
+	/* Determine which high frequency clock source is coming in */
+	if ((__raw_readw(PBC_VERSION_REG) & CKIH_27MHZ_BIT_SET) == 0) {
+		ckih_clk.rate = CKIH_CLK_FREQ_27MHZ;
+	} else {
+		ckih_clk.rate = CKIH_CLK_FREQ;
+	}
+	pr_info("Clock input source is %ld\n", ckih_clk.rate);
+
+	/* This will propagate to all children and init all the clock rates */
+	propagate_rate(&ckih_clk);
+
+	clk_enable(&gpio_clk);
+	clk_enable(&gpt1_clk[0]);
+
+	return 0;
+}
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/crm_regs.h linux-2.6.19.2/arch/arm/mach-mx27/crm_regs.h
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/crm_regs.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/crm_regs.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -17,20 +17,20 @@
 #include <asm/arch/hardware.h>
 
 /* Register offsets */
-#define CCM_CSCR                0x0
-#define CCM_MPCTL0              0x4
-#define CCM_MPCTL1              0x8
-#define CCM_SPCTL0              0xC
-#define CCM_SPCTL1              0x10
-#define CCM_OSC26MCTL           0x14
-#define CCM_PCDR0               0x18
-#define CCM_PCDR1               0x1c
-#define CCM_PCCR0               0x20
-#define CCM_PCCR1               0x24
-#define CCM_CCSR                0x28
-#define CCM_PMCTL               0x2c
-#define CCM_PMCOUNT             0x30
-#define CCM_WKGDCTL             0x34
+#define CCM_CSCR                (IO_ADDRESS(CCM_BASE_ADDR) + 0x0)
+#define CCM_MPCTL0              (IO_ADDRESS(CCM_BASE_ADDR) + 0x4)
+#define CCM_MPCTL1              (IO_ADDRESS(CCM_BASE_ADDR) + 0x8)
+#define CCM_SPCTL0              (IO_ADDRESS(CCM_BASE_ADDR) + 0xC)
+#define CCM_SPCTL1              (IO_ADDRESS(CCM_BASE_ADDR) + 0x10)
+#define CCM_OSC26MCTL           (IO_ADDRESS(CCM_BASE_ADDR) + 0x14)
+#define CCM_PCDR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x18)
+#define CCM_PCDR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x1c)
+#define CCM_PCCR0               (IO_ADDRESS(CCM_BASE_ADDR) + 0x20)
+#define CCM_PCCR1               (IO_ADDRESS(CCM_BASE_ADDR) + 0x24)
+#define CCM_CCSR                (IO_ADDRESS(CCM_BASE_ADDR) + 0x28)
+#define CCM_PMCTL               (IO_ADDRESS(CCM_BASE_ADDR) + 0x2c)
+#define CCM_PMCOUNT             (IO_ADDRESS(CCM_BASE_ADDR) + 0x30)
+#define CCM_WKGDCTL             (IO_ADDRESS(CCM_BASE_ADDR) + 0x34)
 
 #define CCM_CSCR_USB_OFFSET     28
 #define CCM_CSCR_USB_MASK       (0x7 << 28)
@@ -115,68 +115,129 @@
 #define CCM_PCDR1_PERDIV1_OFFSET        0
 #define CCM_PCDR1_PERDIV1_MASK          0x3f
 
-#define CCM_PCCR0_CSPI1         (1 << 31)
-#define CCM_PCCR0_CSPI2         (1 << 30)
-#define CCM_PCCR0_CSPI3         (1 << 29)
-#define CCM_PCCR0_DMA           (1 << 28)
-#define CCM_PCCR0_EMMA          (1 << 27)
-#define CCM_PCCR0_FEC           (1 << 26)
-#define CCM_PCCR0_GPIO          (1 << 25)
-#define CCM_PCCR0_GPT1          (1 << 24)
-#define CCM_PCCR0_GPT2          (1 << 23)
-#define CCM_PCCR0_GPT3          (1 << 22)
-#define CCM_PCCR0_GPT4          (1 << 21)
-#define CCM_PCCR0_GPT5          (1 << 20)
-#define CCM_PCCR0_GPT6          (1 << 19)
-#define CCM_PCCR0_I2C1          (1 << 18)
-#define CCM_PCCR0_I2C2          (1 << 17)
-#define CCM_PCCR0_IIM           (1 << 16)
-#define CCM_PCCR0_KPP           (1 << 15)
-#define CCM_PCCR0_LCDC          (1 << 14)
-#define CCM_PCCR0_MSHC          (1 << 13)
-#define CCM_PCCR0_OWIRE         (1 << 12)
-#define CCM_PCCR0_PWM           (1 << 11)
-#define CCM_PCCR0_RTC           (1 << 9)
-#define CCM_PCCR0_RTIC          (1 << 8)
-#define CCM_PCCR0_SAHARA        (1 << 7)
-#define CCM_PCCR0_SCC           (1 << 6)
-#define CCM_PCCR0_SDHC1         (1 << 5)
-#define CCM_PCCR0_SDHC2         (1 << 4)
-#define CCM_PCCR0_SDHC3         (1 << 3)
-#define CCM_PCCR0_SLCDC         (1 << 2)
-#define CCM_PCCR0_SSI1_IPG      (1 << 1)
-#define CCM_PCCR0_SSI2_IPG      (1 << 0)
-
-#define CCM_PCCR1_UART1         (1 << 31)
-#define CCM_PCCR1_UART2         (1 << 30)
-#define CCM_PCCR1_UART3         (1 << 29)
-#define CCM_PCCR1_UART4         (1 << 28)
-#define CCM_PCCR1_UART5         (1 << 27)
-#define CCM_PCCR1_UART6         (1 << 26)
-#define CCM_PCCR1_USBOTG        (1 << 25)
-#define CCM_PCCR1_WDT           (1 << 24)
-#define CCM_PCCR1_HCLK_ATA      (1 << 23)
-#define CCM_PCCR1_HCLK_BROM     (1 << 22)
-#define CCM_PCCR1_HCLK_CSI      (1 << 21)
-#define CCM_PCCR1_HCLK_DMA      (1 << 20)
-#define CCM_PCCR1_HCLK_EMI      (1 << 19)
-#define CCM_PCCR1_HCLK_EMMA     (1 << 18)
-#define CCM_PCCR1_HCLK_FEC      (1 << 17)
-#define CCM_PCCR1_HCLK_VPU     (1 << 16)
-#define CCM_PCCR1_HCLK_LCDC     (1 << 15)
-#define CCM_PCCR1_HCLK_RTIC     (1 << 14)
-#define CCM_PCCR1_HCLK_SAHARA   (1 << 13)
-#define CCM_PCCR1_HCLK_SLCDC    (1 << 12)
-#define CCM_PCCR1_HCLK_USBOTG   (1 << 11)
-#define CCM_PCCR1_PERCLK1       (1 << 10)
-#define CCM_PCCR1_PERCLK2       (1 << 9)
-#define CCM_PCCR1_PERCLK3       (1 << 8)
-#define CCM_PCCR1_PERCLK4       (1 << 7)
-#define CCM_PCCR1_VPU_BAUD     (1 << 6)
-#define CCM_PCCR1_SSI1_BAUD     (1 << 5)
-#define CCM_PCCR1_SSI2_BAUD     (1 << 4)
-#define CCM_PCCR1_NFC_BAUD      (1 << 3)
-#define CCM_PCCR1_MSHC_BAUD     (1 << 2)
+#define CCM_PCCR0_CSPI1_OFFSET          31
+#define CCM_PCCR0_CSPI1_MASK            (1 << 31)
+#define CCM_PCCR0_CSPI2_OFFSET          30
+#define CCM_PCCR0_CSPI2_MASK            (1 << 30)
+#define CCM_PCCR0_CSPI3_OFFSET          29
+#define CCM_PCCR0_CSPI3_MASK            (1 << 29)
+#define CCM_PCCR0_DMA_OFFSET            28
+#define CCM_PCCR0_DMA_MASK              (1 << 28)
+#define CCM_PCCR0_EMMA_OFFSET           27
+#define CCM_PCCR0_EMMA_MASK             (1 << 27)
+#define CCM_PCCR0_FEC_OFFSET            26
+#define CCM_PCCR0_FEC_MASK              (1 << 26)
+#define CCM_PCCR0_GPIO_OFFSET           25
+#define CCM_PCCR0_GPIO_MASK             (1 << 25)
+#define CCM_PCCR0_GPT1_OFFSET           24
+#define CCM_PCCR0_GPT1_MASK             (1 << 24)
+#define CCM_PCCR0_GPT2_OFFSET           23
+#define CCM_PCCR0_GPT2_MASK             (1 << 23)
+#define CCM_PCCR0_GPT3_OFFSET           22
+#define CCM_PCCR0_GPT3_MASK             (1 << 22)
+#define CCM_PCCR0_GPT4_OFFSET           21
+#define CCM_PCCR0_GPT4_MASK             (1 << 21)
+#define CCM_PCCR0_GPT5_OFFSET           20
+#define CCM_PCCR0_GPT5_MASK             (1 << 20)
+#define CCM_PCCR0_GPT6_OFFSET           19
+#define CCM_PCCR0_GPT6_MASK             (1 << 19)
+#define CCM_PCCR0_I2C1_OFFSET           18
+#define CCM_PCCR0_I2C1_MASK             (1 << 18)
+#define CCM_PCCR0_I2C2_OFFSET           17
+#define CCM_PCCR0_I2C2_MASK             (1 << 17)
+#define CCM_PCCR0_IIM_OFFSET            16
+#define CCM_PCCR0_IIM_MASK              (1 << 16)
+#define CCM_PCCR0_KPP_OFFSET            15
+#define CCM_PCCR0_KPP_MASK              (1 << 15)
+#define CCM_PCCR0_LCDC_OFFSET           14
+#define CCM_PCCR0_LCDC_MASK             (1 << 14)
+#define CCM_PCCR0_MSHC_OFFSET           13
+#define CCM_PCCR0_MSHC_MASK             (1 << 13)
+#define CCM_PCCR0_OWIRE_OFFSET          12
+#define CCM_PCCR0_OWIRE_MASK            (1 << 12)
+#define CCM_PCCR0_PWM_OFFSET            11
+#define CCM_PCCR0_PWM_MASK              (1 << 11)
+#define CCM_PCCR0_RTC_OFFSET            9
+#define CCM_PCCR0_RTC_MASK              (1 << 9)
+#define CCM_PCCR0_RTIC_OFFSET           8
+#define CCM_PCCR0_RTIC_MASK             (1 << 8)
+#define CCM_PCCR0_SAHARA_OFFSET         7
+#define CCM_PCCR0_SAHARA_MASK           (1 << 7)
+#define CCM_PCCR0_SCC_OFFSET            6
+#define CCM_PCCR0_SCC_MASK              (1 << 6)
+#define CCM_PCCR0_SDHC1_OFFSET          5
+#define CCM_PCCR0_SDHC1_MASK            (1 << 5)
+#define CCM_PCCR0_SDHC2_OFFSET          4
+#define CCM_PCCR0_SDHC2_MASK            (1 << 4)
+#define CCM_PCCR0_SDHC3_OFFSET          3
+#define CCM_PCCR0_SDHC3_MASK            (1 << 3)
+#define CCM_PCCR0_SLCDC_OFFSET          2
+#define CCM_PCCR0_SLCDC_MASK            (1 << 2)
+#define CCM_PCCR0_SSI1_IPG_OFFSET       1
+#define CCM_PCCR0_SSI1_IPG_MASK         (1 << 1)
+#define CCM_PCCR0_SSI2_IPG_OFFSET       0
+#define CCM_PCCR0_SSI2_IPG_MASK         (1 << 0)
+
+#define CCM_PCCR1_UART1_OFFSET          31
+#define CCM_PCCR1_UART1_MASK            (1 << 31)
+#define CCM_PCCR1_UART2_OFFSET          30
+#define CCM_PCCR1_UART2_MASK            (1 << 30)
+#define CCM_PCCR1_UART3_OFFSET          29
+#define CCM_PCCR1_UART3_MASK            (1 << 29)
+#define CCM_PCCR1_UART4_OFFSET          28
+#define CCM_PCCR1_UART4_MASK            (1 << 28)
+#define CCM_PCCR1_UART5_OFFSET          27
+#define CCM_PCCR1_UART5_MASK            (1 << 27)
+#define CCM_PCCR1_UART6_OFFSET          26
+#define CCM_PCCR1_UART6_MASK            (1 << 26)
+#define CCM_PCCR1_USBOTG_OFFSET         25
+#define CCM_PCCR1_USBOTG_MASK           (1 << 25)
+#define CCM_PCCR1_WDT_OFFSET            24
+#define CCM_PCCR1_WDT_MASK              (1 << 24)
+#define CCM_PCCR1_HCLK_ATA_OFFSET       23
+#define CCM_PCCR1_HCLK_ATA_MASK         (1 << 23)
+#define CCM_PCCR1_HCLK_BROM_OFFSET      22
+#define CCM_PCCR1_HCLK_BROM_MASK        (1 << 22)
+#define CCM_PCCR1_HCLK_CSI_OFFSET       21
+#define CCM_PCCR1_HCLK_CSI_MASK         (1 << 21)
+#define CCM_PCCR1_HCLK_DMA_OFFSET       20
+#define CCM_PCCR1_HCLK_DMA_MASK         (1 << 20)
+#define CCM_PCCR1_HCLK_EMI_OFFSET       19
+#define CCM_PCCR1_HCLK_EMI_MASK         (1 << 19)
+#define CCM_PCCR1_HCLK_EMMA_OFFSET      18
+#define CCM_PCCR1_HCLK_EMMA_MASK        (1 << 18)
+#define CCM_PCCR1_HCLK_FEC_OFFSET       17
+#define CCM_PCCR1_HCLK_FEC_MASK         (1 << 17)
+#define CCM_PCCR1_HCLK_VPU_OFFSET       16
+#define CCM_PCCR1_HCLK_VPU_MASK         (1 << 16)
+#define CCM_PCCR1_HCLK_LCDC_OFFSET      15
+#define CCM_PCCR1_HCLK_LCDC_MASK        (1 << 15)
+#define CCM_PCCR1_HCLK_RTIC_OFFSET      14
+#define CCM_PCCR1_HCLK_RTIC_MASK        (1 << 14)
+#define CCM_PCCR1_HCLK_SAHARA_OFFSET    13
+#define CCM_PCCR1_HCLK_SAHARA_MASK      (1 << 13)
+#define CCM_PCCR1_HCLK_SLCDC_OFFSET     12
+#define CCM_PCCR1_HCLK_SLCDC_MASK       (1 << 12)
+#define CCM_PCCR1_HCLK_USBOTG_OFFSET    11
+#define CCM_PCCR1_HCLK_USBOTG_MASK      (1 << 11)
+#define CCM_PCCR1_PERCLK1_OFFSET        10
+#define CCM_PCCR1_PERCLK1_MASK          (1 << 10)
+#define CCM_PCCR1_PERCLK2_OFFSET        9
+#define CCM_PCCR1_PERCLK2_MASK          (1 << 9)
+#define CCM_PCCR1_PERCLK3_OFFSET        8
+#define CCM_PCCR1_PERCLK3_MASK          (1 << 8)
+#define CCM_PCCR1_PERCLK4_OFFSET        7
+#define CCM_PCCR1_PERCLK4_MASK          (1 << 7)
+#define CCM_PCCR1_VPU_BAUD_OFFSET       6
+#define CCM_PCCR1_VPU_BAUD_MASK         (1 << 6)
+#define CCM_PCCR1_SSI1_BAUD_OFFSET      5
+#define CCM_PCCR1_SSI1_BAUD_MASK        (1 << 5)
+#define CCM_PCCR1_SSI2_BAUD_OFFSET      4
+#define CCM_PCCR1_SSI2_BAUD_MASK        (1 << 4)
+#define CCM_PCCR1_NFC_BAUD_OFFSET       3
+#define CCM_PCCR1_NFC_BAUD_MASK         (1 << 3)
+#define CCM_PCCR1_MSHC_BAUD_OFFSET      2
+#define CCM_PCCR1_MSHC_BAUD_MASK        (1 << 2)
 
 #define CCM_CCSR_32KSR          (1 << 15)
 #define CCM_CCSR_CLKMODE1       (1 << 9)
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/devices.c linux-2.6.19.2/arch/arm/mach-mx27/devices.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/devices.c	2007-04-25 17:37:33.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/devices.c	2007-04-25 17:37:51.000000000 -0600
@@ -9,7 +9,7 @@
  * licensed "as is" without any warranty of any kind, whether express
  * or implied.
  *
- * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
@@ -19,7 +19,6 @@
 #include <linux/spi/spi.h>
 
 #include <asm/hardware.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/mmc.h>
 
  /*!
@@ -90,7 +89,6 @@ static struct platform_device mxc_wdt_de
 
 static void mxc_init_wdt(void)
 {
-	mxc_clks_enable(WDOG_CLK);
 	(void)platform_device_register(&mxc_wdt_device);
 }
 #else
@@ -245,16 +243,9 @@ static inline void mxc_init_mmc(void)
 		mxcsdhc2_device.resource[2].end = cd_irq;
 	}
 
-	mxc_clks_enable(PERCLK2);
-
-	mxc_clks_enable(SDHC1_CLK);
 	(void)platform_device_register(&mxcsdhc1_device);
-
-	mxc_clks_enable(SDHC2_CLK);
 	(void)platform_device_register(&mxcsdhc2_device);
-
 #ifdef CONFIG_MXC_SDHC3
-	mxc_clks_enable(SDHC3_CLK);
 	(void)platform_device_register(&mxcsdhc3_device);
 #endif
 }
@@ -286,16 +277,14 @@ static struct resource mxcspi1_resources
 
 /*! Platform Data for MXC CSPI1 */
 static struct mxc_spi_master mxcspi1_data = {
-	.bus_num = 1,
 	.maxchipselect = 4,
 	.spi_version = 0,
-	.clock = CSPI1_CLK,
 };
 
 /*! Device Definition for MXC CSPI1 */
 static struct platform_device mxcspi1_device = {
 	.name = "mxc_spi",
-	.id = 1,
+	.id = 0,
 	.dev = {
 		.release = mxc_nop_release,
 		.platform_data = &mxcspi1_data,
@@ -325,16 +314,14 @@ static struct resource mxcspi2_resources
 
 /*! Platform Data for MXC CSPI2 */
 static struct mxc_spi_master mxcspi2_data = {
-	.bus_num = 2,
 	.maxchipselect = 4,
 	.spi_version = 0,
-	.clock = CSPI2_CLK,
 };
 
 /*! Device Definition for MXC CSPI2 */
 static struct platform_device mxcspi2_device = {
 	.name = "mxc_spi",
-	.id = 2,
+	.id = 1,
 	.dev = {
 		.release = mxc_nop_release,
 		.platform_data = &mxcspi2_data,
@@ -363,16 +350,14 @@ static struct resource mxcspi3_resources
 
 /*! Platform Data for MXC CSPI3 */
 static struct mxc_spi_master mxcspi3_data = {
-	.bus_num = 3,
 	.maxchipselect = 4,
 	.spi_version = 0,
-	.clock = CSPI3_CLK,
 };
 
 /*! Device Definition for MXC CSPI3 */
 static struct platform_device mxcspi3_device = {
 	.name = "mxc_spi",
-	.id = 3,
+	.id = 2,
 	.dev = {
 		.release = mxc_nop_release,
 		.platform_data = &mxcspi3_data,
@@ -425,7 +410,6 @@ static struct resource mxci2c1_resources
 
 /*! Platform Data for MXC I2C */
 static struct mxc_i2c_platform_data mxci2c1_data = {
-	.clk = I2C_CLK,
 	.i2c_clk = 100000,
 };
 #endif
@@ -449,7 +433,6 @@ static struct resource mxci2c2_resources
 
 /*! Platform Data for MXC I2C */
 static struct mxc_i2c_platform_data mxci2c2_data = {
-	.clk = I2C2_CLK,
 	.i2c_clk = 100000,
 };
 #endif
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/dpm.c linux-2.6.19.2/arch/arm/mach-mx27/dpm.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/dpm.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/dpm.c	2007-04-25 17:37:51.000000000 -0600
@@ -42,6 +42,7 @@
 #include <linux/device.h>
 #include <linux/pm.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 
 #include <asm/hardirq.h>
 #include <asm/page.h>
@@ -120,7 +121,9 @@ static int mxc_dpm_set_opt(struct dpm_op
 				    md_new->cpu / 1000);
 	}
 #ifdef CONFIG_PM
+#if 0
 	mxc_pm_dvfs(md_new->cpu, md_new->ahb, md_new->ip);
+#endif
 	curr_mode = md_new->mode;
 #endif
 
@@ -220,9 +223,9 @@ static int mxc_dpm_get_opt(struct dpm_op
 
 	md_opt = &opt->md_opt;
 
-	md_opt->cpu = mxc_get_clocks(CPU_CLK);
-	md_opt->ahb = mxc_get_clocks(AHB_CLK);
-	md_opt->ip = mxc_get_clocks(IPG_CLK);
+	md_opt->cpu = clk_get(NULL, "cpu_clk")->rate;
+	md_opt->ahb = clk_get(NULL, "ahb_clk")->rate;
+	md_opt->ip = clk_get(NULL, "ipg_clk")->rate;
 	md_opt->mode = curr_mode;
 
 	return 0;
@@ -376,7 +379,7 @@ static void mxc_dpm_startup(void)
 {
 	if (!saved_loops_per_jiffy) {
 		saved_loops_per_jiffy = loops_per_jiffy;
-		saved_cpu_freq = mxc_get_clocks(CPU_CLK) / 1000;
+		saved_cpu_freq = clk_get(NULL, "cpu_clk")->rate / 1000;
 	}
 	orig_idle = pm_idle;
 	pm_idle = dpm_idle;
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/mx27ads.c linux-2.6.19.2/arch/arm/mach-mx27/mx27ads.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/mx27ads.c	2007-04-25 17:37:26.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/mx27ads.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,7 +1,7 @@
 /*
  *  Copyright (C) 2000 Deep Blue Solutions Ltd
  *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
- *  Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -26,6 +26,7 @@
 #include <linux/device.h>
 #include <linux/input.h>
 #include <linux/nodemask.h>
+#include <linux/clk.h>
 #include <linux/spi/spi.h>
 #include <linux/serial_8250.h>
 #if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
@@ -45,7 +46,6 @@
 #include <asm/arch/memory.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/clock.h>
 #include <asm/mach/keypad.h>
 #include "gpio_mux.h"
 
@@ -58,6 +58,7 @@
 
 extern void mxc_map_io(void);
 extern void mxc_init_irq(void);
+extern void mxc_clocks_init(void);
 extern struct sys_timer mxc_timer;
 
 static char command_line[COMMAND_LINE_SIZE];
@@ -609,26 +610,45 @@ static inline int mxc_init_extuart(void)
 #if defined(CONFIG_MXC_PMIC_MC13783) && defined(CONFIG_SND_MXC_PMIC)
 extern void gpio_ssi_active(int ssi_num);
 
-static inline int mxc_init_pmic_audio(void)
+static void __init mxc_init_pmic_audio(void)
 {
-	/* Assign CLK_26M to CLKO */
-	mxc_set_clock_output(CKO, CKIH_CLK, 1);
+	struct clk *ssi_clk;
+	struct clk *ckih_clk;
+	struct clk *cko_clk;
+
+	/* Enable 26 mhz clock on CKO1 for PMIC audio */
+	ckih_clk = clk_get(NULL, "ckih");
+	cko_clk = clk_get(NULL, "clko_clk");
+	if (IS_ERR(ckih_clk) || IS_ERR(cko_clk)) {
+		printk(KERN_ERR "Unable to set CLKO output to CKIH\n");
+	} else {
+		clk_set_parent(cko_clk, ckih_clk);
+		clk_set_rate(cko_clk, clk_get_rate(ckih_clk));
+		clk_enable(cko_clk);
+	}
+	clk_put(ckih_clk);
+	clk_put(cko_clk);
+
+	ssi_clk = clk_get(NULL, "ssi_clk.0");
+	clk_enable(ssi_clk);
+	clk_put(ssi_clk);
+	ssi_clk = clk_get(NULL, "ssi_clk.1");
+	clk_enable(ssi_clk);
+	clk_put(ssi_clk);
+
 	gpio_ssi_active(0);
 	gpio_ssi_active(1);
-	mxc_clks_enable(SSI1_BAUD);
-	mxc_clks_enable(SSI2_BAUD);
-	return 0;
 }
 #else
-static inline int mxc_init_pmic_audio(void)
+static void __inline mxc_init_pmic_audio(void)
 {
-	return 0;
 }
 #endif
 
 static void mxc_board_init(void)
 {
 	pr_info("AIPI VA base: 0x%x\n", IO_ADDRESS(AIPI_BASE_ADDR));
+	mxc_clocks_init();
 	mxc_gpio_init();
 	mxc_expio_init();
 	mxc_init_keypad();
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/mx27ads_gpio.c linux-2.6.19.2/arch/arm/mach-mx27/mx27ads_gpio.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/mx27ads_gpio.c	2007-04-25 17:37:26.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/mx27ads_gpio.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -14,9 +14,9 @@
 #include <linux/errno.h>
 #include <linux/module.h>
 #include <linux/device.h>
+#include <linux/clk.h>
 #include <asm/io.h>
 #include <asm/hardware.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/gpio.h>
 
 #include "gpio_mux.h"
@@ -26,9 +26,9 @@ static int g_uart_activated[MXC_UART_NR]
 
 /*!
  * @file mx27ads_gpio.c
- * 
- * @brief This file contains all the GPIO setup functions for the board. 
- * 
+ *
+ * @brief This file contains all the GPIO setup functions for the board.
+ *
  * @ingroup GPIO
  */
 
@@ -176,7 +176,7 @@ void config_uartdma_event(int port)
  *	PE2,PE1,PE0,PE24,PE25 -- PRIMARY
  	PC7 - PC13  -- PRIMARY
  	PB23,PB24 -- PRIMARY
- 
+
   * PIN Configuration for USBH2:    : High/Full/Low speed host
   *	PA0 - PA4 -- PRIMARY
        PD19, PD20,PD21,PD22,PD23,PD24,PD26 --Alternate (SECONDARY)
@@ -322,7 +322,7 @@ void gpio_usbotg_fs_inactive(void)
 
 /*!
  * end Setup GPIO for USB
- * 
+ *
  */
 
 /************************************************************************/
@@ -645,7 +645,7 @@ void gpio_pmic_active(void)
 }
 
 /*!
- * GPIO settings not required for keypad 
+ * GPIO settings not required for keypad
  *
  */
 void gpio_keypad_active(void)
@@ -653,7 +653,7 @@ void gpio_keypad_active(void)
 }
 
 /*!
- * GPIO settings not required for keypad 
+ * GPIO settings not required for keypad
  *
  */
 void gpio_keypad_inactive(void)
@@ -666,6 +666,8 @@ void gpio_keypad_inactive(void)
  */
 void gpio_ata_active(void)
 {
+	struct clk *ata_clk = clk_get(NULL, "ata_clk");
+
 	gpio_request_mux(MX27_PIN_ATA_DATA0, GPIO_MUX_PRIMARY);
 	gpio_request_mux(MX27_PIN_ATA_DATA1, GPIO_MUX_PRIMARY);
 	gpio_request_mux(MX27_PIN_ATA_DATA2, GPIO_MUX_PRIMARY);
@@ -697,7 +699,7 @@ void gpio_ata_active(void)
 	gpio_request_mux(MX27_PIN_PC_RW_B, GPIO_MUX_ALT);
 	gpio_request_mux(MX27_PIN_PC_POE, GPIO_MUX_ALT);
 
-	mxc_clks_enable(ATA_CLK);
+	clk_enable(ata_clk);
 }
 
 /*!
@@ -706,7 +708,10 @@ void gpio_ata_active(void)
  */
 void gpio_ata_inactive(void)
 {
-	mxc_clks_disable(ATA_CLK);
+	struct clk *ata_clk = clk_get(NULL, "ata_clk");
+
+	clk_disable(ata_clk);
+	clk_put(ata_clk);
 
 	gpio_free_mux(MX27_PIN_ATA_DATA0);
 	gpio_free_mux(MX27_PIN_ATA_DATA1);
@@ -1108,21 +1113,21 @@ void gpio_owire_inactive(void)
 
 void gpio_irda_active(void)
 {
+	struct clk *uart2_baud = clk_get(NULL, "uart_baud.1");
+
 	gpio_uart_active(2, 0);
-	mxc_clks_enable(UART2_BAUD);
+	clk_enable(uart2_baud);
 	/* Band width select */
 	//__raw_writew(PBC_BCTRL2_IRDA_SD, PBC_BCTRL2_SET_REG);
 }
 
 void gpio_irda_inactive(void)
 {
-	mxc_clks_disable(UART2_BAUD);
-	gpio_uart_inactive(2, 0);
-}
+	struct clk *uart2_baud = clk_get(NULL, "uart_baud.1");
 
-unsigned int irda_get_clocks(void)
-{
-	return mxc_get_clocks(UART2_BAUD);
+	clk_disable(uart2_baud);
+	clk_put(uart2_baud);
+	gpio_uart_inactive(2, 0);
 }
 
 EXPORT_SYMBOL(gpio_uart_active);
@@ -1168,5 +1173,4 @@ EXPORT_SYMBOL(gpio_owire_active);
 EXPORT_SYMBOL(gpio_owire_inactive);
 EXPORT_SYMBOL(gpio_irda_active);
 EXPORT_SYMBOL(gpio_irda_inactive);
-EXPORT_SYMBOL(irda_get_clocks);
 
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/mxc_pm.c linux-2.6.19.2/arch/arm/mach-mx27/mxc_pm.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/mxc_pm.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/mxc_pm.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,7 +30,6 @@
 #include <asm/arch/mxc_pm.h>
 #include <asm/arch/mxc.h>
 #include <asm/arch/system.h>
-#include <asm/arch/clock.h>
 #include <asm/irq.h>
 #include "crm_regs.h"
 
@@ -40,39 +39,11 @@
 #define MAX_IPG_FREQ        66500000
 #define FREQ_COMP_TOLERANCE      100	/* tolerance percentage times 100 */
 #define MX27_LLPM_DEBUG	    0
-/*
- * CKO pins configuration
- */
-#define CLKO_CLK32              0
-#define CLKO_PREMCLK            1
-#define CLKO_CLK26M             2
-#define CLKO_MPLLREF            3
-#define CLKO_SPLLREF            4
-#define CLKO_MPLLCLK            5
-#define CLKO_SPLLCLK            6
-#define CLKO_FCLK               7
-#define CLKO_HCLK               8
-#define CLKO_IPGCLK             9
-#define CLKO_PERCLK1            10
-#define CLKO_PERCLK2            11
-#define CLKO_PERCLK3            12
-#define CLKO_PERCLK4            13
-#define CLKO_SSI1BAUD           14
-#define CLKO_SSI2BAUD           15
-#define CLKO_NFCBAUD            16
-#define CLKO_MSHCBAUD           17
-#define CLKO_VPUBAUD           18
-#define CLKO_CLK60M_ALWAYS      19
-#define CLKO_CLK32K_ALWAYS      20
-#define CLKO_CLK60M             21
-#define CLKO_CLKDPTC            22
-
-#define CLKO_MAX                23
 
 /*
  * Global variables
  */
-
+#if 0
 /*!
  * These variables hold the various clock values when the module is loaded.
  * This is needed because these clocks are derived from MPLL and when MPLL
@@ -351,7 +322,7 @@ static s32 mx27_pm_pllscale(u32 arm_freq
 
 	return 0;
 }
-
+#endif
 /*!
  * Implement steps required to transition to low-power modes.
  *
@@ -383,9 +354,9 @@ void mxc_pm_lowpower(s32 mode)
 		interrupt_disabled = 1;
 
 		/* Clear MPEN and SPEN to disable MPLL/SPLL */
-		cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		cscr = __raw_readl(CCM_CSCR);
 		cscr &= 0xFFFFFFFC;
-		__raw_writel(cscr, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		__raw_writel(cscr, CCM_CSCR);
 		break;
 	}
 
@@ -400,24 +371,7 @@ void mxc_pm_lowpower(s32 mode)
 	local_irq_enable();
 }
 
-/*!
- * Configure the desired clock to be output on CLKO pin.
- *
- * @param       opt     desired CLK for CLKO
- */
-void mxc_pm_ckosel(u32 opt)
-{
-	u32 reg;
-
-	if (opt < 0 || opt >= CLKO_MAX)
-		return;
-
-	reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
-	reg = (reg & (~CCM_CCSR_CLKOSEL_MASK)) | opt;
-	__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
-	return;
-}
-
+#if 0
 /*!
  * Called to change the core frequency. This function internally decides
  * whether to do integer scaling or pll scaling.
@@ -467,7 +421,7 @@ int mxc_pm_dvfs(unsigned long arm_freq, 
 	local_irq_restore(flags);
 	return ret;
 }
-
+#endif
 /*
  * This API is not supported on i.MX27
  */
@@ -492,12 +446,6 @@ int mxc_pm_pllscale(long armfreq, long a
 static int __init mxc_pm_init_module(void)
 {
 	printk("MX27: Power management module initialized\n");
-	perclk1 = mxc_get_clocks(PERCLK1);
-	perclk2 = mxc_get_clocks(PERCLK2);
-	perclk3 = mxc_get_clocks(PERCLK3);
-	perclk4 = mxc_get_clocks(PERCLK4);
-	nfcclk = mxc_get_clocks(NFC_CLK);
-	cpuclk = mxc_get_clocks(CPU_CLK);
 	return 0;
 }
 
@@ -513,7 +461,7 @@ module_init(mxc_pm_init_module);
 module_exit(mxc_pm_cleanup_module);
 
 EXPORT_SYMBOL(mxc_pm_lowpower);
-EXPORT_SYMBOL(mxc_pm_dvfs);
+//EXPORT_SYMBOL(mxc_pm_dvfs);
 EXPORT_SYMBOL(mxc_pm_pllscale);
 EXPORT_SYMBOL(mxc_pm_intscale);
 
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/serial.c linux-2.6.19.2/arch/arm/mach-mx27/serial.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/serial.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/serial.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -56,7 +56,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART1_UFCR_RXTL,
 	       .tx_threshold = UART1_UFCR_TXTL,
 	       .shared = UART1_SHARED_PERI,
-	       .clock_id = UART1_BAUD,
 	       .dma_tx_id = MXC_DMA_UART1_TX,
 	       .dma_rx_id = MXC_DMA_UART1_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
@@ -83,7 +82,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART2_UFCR_RXTL,
 	       .tx_threshold = UART2_UFCR_TXTL,
 	       .shared = UART2_SHARED_PERI,
-	       .clock_id = UART2_BAUD,
 	       .dma_tx_id = MXC_DMA_UART2_TX,
 	       .dma_rx_id = MXC_DMA_UART2_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
@@ -110,7 +108,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART3_UFCR_RXTL,
 	       .tx_threshold = UART3_UFCR_TXTL,
 	       .shared = UART3_SHARED_PERI,
-	       .clock_id = UART3_BAUD,
 	       .dma_tx_id = MXC_DMA_UART3_TX,
 	       .dma_rx_id = MXC_DMA_UART3_RX,
 	       .rxd_mux = MXC_UART_IR_RXDMUX,
@@ -137,7 +134,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART4_UFCR_RXTL,
 	       .tx_threshold = UART4_UFCR_TXTL,
 	       .shared = UART4_SHARED_PERI,
-	       .clock_id = UART4_BAUD,
 	       .dma_tx_id = MXC_DMA_UART4_TX,
 	       .dma_rx_id = MXC_DMA_UART4_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
@@ -164,7 +160,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART5_UFCR_RXTL,
 	       .tx_threshold = UART5_UFCR_TXTL,
 	       .shared = UART5_SHARED_PERI,
-	       .clock_id = UART5_BAUD,
 	       .dma_tx_id = MXC_DMA_UART5_TX,
 	       .dma_rx_id = MXC_DMA_UART5_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
@@ -191,7 +186,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART6_UFCR_RXTL,
 	       .tx_threshold = UART6_UFCR_TXTL,
 	       .shared = UART6_SHARED_PERI,
-	       .clock_id = UART6_BAUD,
 	       .dma_tx_id = MXC_DMA_UART6_TX,
 	       .dma_rx_id = MXC_DMA_UART6_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/system.c linux-2.6.19.2/arch/arm/mach-mx27/system.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/system.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/system.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 1999 ARM Limited
  * Copyright (C) 2000 Deep Blue Solutions Ltd
- * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,11 +18,11 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#include <linux/clk.h>
 #include <asm/io.h>
 #include <asm/arch/hardware.h>
 #include <asm/proc-fns.h>
 #include <asm/system.h>
-#include <asm/arch/clock.h>
 
 /*!
  * @defgroup MSL Machine Specific Layer (MSL)
@@ -62,8 +62,11 @@ void arch_idle(void)
  */
 void arch_reset(char mode)
 {
-	volatile u16 v;
-	mxc_clks_enable(WDOG_CLK);
+	u16 v;
+	struct clk *clk;
+
+	clk = clk_get(NULL, "wdog_clk");
+	clk_enable(clk);
 	v = __raw_readw(IO_ADDRESS(WDOG_BASE_ADDR));
 	__raw_writew(v | WDT_WCR_WDE, IO_ADDRESS(WDOG_BASE_ADDR));
 }
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/time.c linux-2.6.19.2/arch/arm/mach-mx27/time.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/time.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/time.c	2007-04-25 17:37:51.000000000 -0600
@@ -35,15 +35,15 @@
 #include <asm/mach/time.h>
 
 #include <asm/arch/hardware.h>
-#include <asm/arch/clock.h>
 
 #ifndef __noinstrument
 #define __noinstrument
 #endif
 
+extern unsigned long clk_early_get_timer_rate(void);
+
 /* OS tick defines */
 #define MXC_GPT_INT_TICK		INT_GPT
-#define MXC_GPT_CLOCK_TICK		GPT1_CLK
 #define MXC_GPT_TCMP_TICK		MXC_GPT_TCMP(MXC_TIMER_GPT1)
 #define MXC_GPT_TSTAT_TICK		MXC_GPT_TSTAT(MXC_TIMER_GPT1)
 #define MXC_GPT_TCTL_TICK		MXC_GPT_TCTL(MXC_TIMER_GPT1)
@@ -51,7 +51,6 @@
 #define MXC_GPT_TCN_TICK		MXC_GPT_TCN(MXC_TIMER_GPT1)
 /* High resolution timer defines */
 #define MXC_GPT_INT_HRT			INT_GPT2
-#define MXC_GPT_CLOCK_HRT		GPT2_CLK
 #define MXC_GPT_TCMP_HRT		MXC_GPT_TCMP(MXC_TIMER_GPT2)
 #define MXC_GPT_TSTAT_HRT		MXC_GPT_TSTAT(MXC_TIMER_GPT2)
 #define MXC_GPT_TCTL_HRT		MXC_GPT_TCTL(MXC_TIMER_GPT2)
@@ -143,7 +142,6 @@ static int __init mx27_hrt_clocksource_i
 	int ret;
 	u32 reg, v;
 
-	mxc_clks_enable(MXC_GPT_CLOCK_HRT);
 	__raw_writel(0, MXC_GPT_TCTL_HRT);
 	__raw_writel(GPT_TCTL_SWR, MXC_GPT_TCTL_HRT);
 
@@ -153,7 +151,7 @@ static int __init mx27_hrt_clocksource_i
 	__raw_writel(GPT_TCTL_FRR | GPT_TCTL_COMPEN | GPT_TCTL_SRC_PER1,
 		     MXC_GPT_TCTL_HRT);
 
-	v = mxc_get_clocks(MXC_GPT_INT_HRT);
+	v = clk_early_get_timer_rate();
 	__raw_writel((v / CLOCK_TICK_RATE) - 1, MXC_GPT_TPRER_HRT);
 
 	if ((v % CLOCK_TICK_RATE) != 0) {
@@ -191,7 +189,6 @@ void __init mxc_init_time(void)
 {
 	u32 reg, v;
 
-	mxc_clks_enable(MXC_GPT_CLOCK_TICK);
 	__raw_writel(0, MXC_GPT_TCTL_TICK);
 	__raw_writel(GPT_TCTL_SWR, MXC_GPT_TCTL_TICK);
 
@@ -202,7 +199,7 @@ void __init mxc_init_time(void)
 
 	__raw_writel(reg, MXC_GPT_TCTL_TICK);
 
-	v = mxc_get_clocks(MXC_GPT_CLOCK_TICK);
+	v = clk_early_get_timer_rate();
 	__raw_writel((v / CLOCK_TICK_RATE) - 1, MXC_GPT_TPRER_TICK);
 
 	if ((v % CLOCK_TICK_RATE) != 0) {
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx27/usb.c linux-2.6.19.2/arch/arm/mach-mx27/usb.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx27/usb.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx27/usb.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  *	otg_{get,set}_transceiver() are from arm/plat-omap/usb.c.
  *	which is Copyright (C) 2004 Texas Instruments, Inc.
@@ -38,6 +38,7 @@
 #include <linux/platform_device.h>
 #include <linux/usb/otg.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -48,7 +49,6 @@
 #include <asm/arch/board.h>
 #include <asm/arch/arc_otg.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/isp1504.h>
 #include <asm/arch/isp1301.h>
 
@@ -82,16 +82,19 @@ extern void gpio_usbotg_fs_inactive(void
 /* The dmamask must be set for EHCI to work */
 static u64 ehci_dmamask = ~(u32) 0;
 
+static struct clk *usb_clk;
 /*
  * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
  */
 static int check_usbclk(void)
 {
-	unsigned long clk;
+	unsigned long freq;
 
-	clk = mxc_get_clocks(USB_CLK);
-	if ((clk < 59999000) || (clk > 60001000)) {
-		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", clk);
+	usb_clk = clk_get(NULL, "usb_clk");
+	freq = clk_get_rate(usb_clk);
+	clk_put(usb_clk);
+	if ((freq < 59999000) || (freq > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", freq);
 		return -1;
 	}
 	return 0;
@@ -252,9 +255,9 @@ static int otg_hs_init(void)
 		dbg("grab OTG-HS pins");
 
 		/* enable OTG/HS */
-		mxc_clks_disable(USB_CLK);
+		clk_disable(usb_clk);
 		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_CLEAR);
-		mxc_clks_enable(USB_CLK);
+		clk_enable(usb_clk);
 
 		gpio_usbotg_hs_active();	/* grab our pins */
 		mdelay(1);
@@ -358,9 +361,9 @@ static int otg_fs_host_init(void)
 	mdelay(1);
 
 	/* enable OTG VBUS */
-	mxc_clks_disable(USB_CLK);
+	clk_disable(usb_clk);
 	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_CLEAR);
-	mxc_clks_enable(USB_CLK);
+	clk_enable(usb_clk);
 
 	otg_fs_set_xcvr();	/* set transceiver type */
 
@@ -424,10 +427,10 @@ static int usbh1_init(void)
 	gpio_usbh1_active();
 	mdelay(1);
 
-	mxc_clks_disable(USB_CLK);
+	clk_disable(usb_clk);
 	__raw_writew(PBC_BCTRL3_FSH_MOD, PBC3_CLEAR);	/* single ended */
 	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_CLEAR);	/* enable FSH VBUS */
-	mxc_clks_enable(USB_CLK);
+	clk_enable(usb_clk);
 
 	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE);	/* disable bypass mode */
 	USBCTRL |= UCTRL_H1SIC_SU6 |	/* single-ended / unidir. */
@@ -497,9 +500,9 @@ static int usbh2_init(void)
 	if (check_usbclk() != 0)
 		return -EINVAL;
 
-	mxc_clks_disable(USB_CLK);
+	clk_disable(usb_clk);
 	__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_CLEAR);	/* enable OTG_VBUS_EN */
-	mxc_clks_enable(USB_CLK);
+	clk_enable(usb_clk);
 	gpio_usbh2_active();	/* grab our pins */
 	mdelay(1);
 
@@ -584,9 +587,9 @@ int otg_fs_dev_init(void)
 	mdelay(1);
 
 	/* disable OTG VBUS */
-	mxc_clks_disable(USB_CLK);
+	clk_disable(usb_clk);
 	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);
-	mxc_clks_enable(USB_CLK);
+	clk_enable(usb_clk);
 
 	otg_fs_set_xcvr();	/* set transceiver type */
 
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/clock.c linux-2.6.19.2/arch/arm/mach-mx3/clock.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/clock.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/clock.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -12,70 +12,131 @@
  */
 
 /*!
- * @file clock.c
- * @brief API for setting up and retrieving clocks.
- *
- * This file contains API for setting up and retrieving clocks.
- *
+ * @file mach-mx3/clock.c
+ * @brief Low level clock structs and functions for MX31 clocks.
  * @ingroup CLOCKS
  */
 
 #include <linux/module.h>
 #include <linux/spinlock.h>
+#include <linux/clk.h>
 #include <asm/io.h>
 #include <asm/arch/clock.h>
 
 #include "crm_regs.h"
 #include "time_priv.h"
 
-/*
- * Clock source bit fields for GPT
- */
-#define CLKSRC_NO_CLK	    	0
-#define CLKSRC_IPG_CLK	    	1
-#define CLKSRC_IPG_CLK_HIGH   	2
-#define CLKSRC_EXT_PAD	    	3
+#define MCU_PLL_MAX_FREQ   600000000	/* Maximum frequency MCU PLL clock */
+#define MCU_PLL_MIN_FREQ   160000000	/* Minimum frequency MCU PLL clock */
+#define NFC_MAX_FREQ        20000000	/* Maximum frequency NFC clock */
+#define PRE_DIV_MIN_FREQ    10000000	/* Minimum Frequency after Predivider */
+
+static struct clk mcu_main_clk;
+static struct clk usb_pll_clk;
+static struct clk serial_pll_clk;
+static struct clk ipg_clk;
+static struct clk ckih_clk;
 
-/*
- * Get Clock errors
- */
-#define ERR_CLK_NO_SUPPORT	    1
+static int _clk_enable(struct clk *clk)
+{
+	u32 reg;
+	reg = __raw_readl(clk->enable_reg);
+	reg |= 3 << clk->enable_shift;
+	__raw_writel(reg, clk->enable_reg);
 
-/*!
- * Spinlock to protect CRM register accesses
- */
-static DEFINE_SPINLOCK(mxc_crm_lock);
+	return 0;
+}
 
-/*
- * This function returns the clock CKIH clock input value.
- */
-static unsigned long mxc_clock_ckih(void)
+static void _clk_disable(struct clk *clk)
 {
-	static unsigned long g_clk_ckih = 0;
+	u32 reg;
 
-	if (g_clk_ckih == 0) {
-		if ((__raw_readw(PBC_BASE_ADDRESS + PBC_BSTAT) &
-		     CKIH_27MHZ_BIT_SET) != 0) {
-			g_clk_ckih = CKIH_CLK_FREQ_27MHZ;
-		} else {
-			g_clk_ckih = CKIH_CLK_FREQ;
-		}
-		pr_info("Clock input source is %ld\n", g_clk_ckih);
+	reg = __raw_readl(clk->enable_reg);
+	reg &= ~(3 << clk->enable_shift);
+	__raw_writel(reg, clk->enable_reg);
+}
+
+static int _clk_pll_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	signed long pd = 1;	/* Pre-divider */
+	signed long mfi;	/* Multiplication Factor (Integer part) */
+	signed long mfn;	/* Multiplication Factor (Integer part) */
+	signed long mfd;	/* Multiplication Factor (Denominator Part) */
+	signed long tmp;
+	u32 ref_freq = clk->parent->rate;
+
+	while (((ref_freq / pd) * 10) > rate) {
+		pd++;
+	}
+
+	if ((ref_freq / pd) < PRE_DIV_MIN_FREQ) {
+		return -EINVAL;
+	}
+
+	/* the ref_freq/2 in the following is to round up */
+	mfi = (((rate / 2) * pd) + (ref_freq / 2)) / ref_freq;
+	if (mfi < 5 || mfi > 15) {
+		return -EINVAL;
+	}
+
+	/* pick a mfd value that will work
+	 * then solve for mfn */
+	mfd = ref_freq / 50000;
+
+	/*
+	 *          pll_freq * pd * mfd
+	 *   mfn = --------------------  -  (mfi * mfd)
+	 *           2 * ref_freq
+	 */
+	/* the tmp/2 is for rounding */
+	tmp = ref_freq / 10000;
+	mfn =
+	    ((((((rate / 2) + (tmp / 2)) / tmp) * pd) * mfd) / 10000) -
+	    (mfi * mfd);
+
+	mfn = mfn & 0x3ff;
+	pd--;
+	mfd--;
+
+	if (clk == &mcu_main_clk) {
+		/* Swap to reference clock and disable PLL */
+		reg = __raw_readl(MXC_CCM_CCMR);
+		reg |= MXC_CCM_CCMR_MDS;
+		reg &= ~MXC_CCM_CCMR_MPE;
+		__raw_writel(reg, MXC_CCM_CCMR);
+	}
+
+	/* Change the Pll value */
+	reg = (mfi << MXC_CCM_PCTL_MFI_OFFSET) |
+	    (mfn << MXC_CCM_PCTL_MFN_OFFSET) |
+	    (mfd << MXC_CCM_PCTL_MFD_OFFSET) | (pd << MXC_CCM_PCTL_PD_OFFSET);
+
+	if (clk == &mcu_main_clk) {
+		__raw_writel(reg, MXC_CCM_MPCTL);
+	} else if (clk == &usb_pll_clk) {
+		__raw_writel(reg, MXC_CCM_UPCTL);
+	} else if (clk == &serial_pll_clk) {
+		__raw_writel(reg, MXC_CCM_SRPCTL);
 	}
 
-	return g_clk_ckih;
+	if (clk == &mcu_main_clk) {
+		/* Swap to the new value */
+		reg = __raw_readl(MXC_CCM_CCMR);
+		reg |= MXC_CCM_CCMR_MPE;
+		reg &= ~MXC_CCM_CCMR_MDS;
+		__raw_writel(reg, MXC_CCM_CCMR);
+	}
+
+	clk->rate = rate;
+	return 0;
 }
 
-/*!
- * This function returns the PLL output value in Hz based on pll.
- * @param       pll     PLL as defined in enum plls
- * @return      PLL value in Hz.
- */
-unsigned long mxc_pll_clock(enum plls pll)
+static void _clk_pll_recalc(struct clk *clk)
 {
-	unsigned long mfi, mfn, mfd, pdf, ref_clk;
-	unsigned long reg = 0, ccmr;
-	unsigned long long temp;
+	long mfi, mfn, mfd, pdf, ref_clk, mfn_abs;
+	volatile unsigned long reg, ccmr;
+	s64 temp;
 	unsigned int prcs;
 
 	ccmr = __raw_readl(MXC_CCM_CCMR);
@@ -83,884 +144,912 @@ unsigned long mxc_pll_clock(enum plls pl
 	if (prcs == 0x1) {
 		ref_clk = CKIL_CLK_FREQ * 1024;
 	} else {
-		ref_clk = mxc_clock_ckih();
+		ref_clk = ckih_clk.rate;
 	}
 
-	if (pll == MCUPLL) {
+	if (clk == &mcu_main_clk) {
 		if ((ccmr & MXC_CCM_CCMR_MPE) == 0) {
-			return ref_clk;
+			clk->rate = ref_clk;
+			return;
 		}
 		if ((ccmr & MXC_CCM_CCMR_MDS) != 0) {
-			return ref_clk;
+			clk->rate = ref_clk;
+			return;
 		}
 		reg = __raw_readl(MXC_CCM_MPCTL);
-	} else if (pll == USBPLL) {
+	} else if (clk == &usb_pll_clk) {
 		reg = __raw_readl(MXC_CCM_UPCTL);
-	} else if (pll == SERIALPLL) {
+	} else if (clk == &serial_pll_clk) {
 		reg = __raw_readl(MXC_CCM_SRPCTL);
 	} else {
-		printk(KERN_ERR "\nUnknown pll: %d\n\n", pll);
-		BUG();		/* oops */
+		BUG();
 	}
 	pdf = (reg & MXC_CCM_PCTL_PD_MASK) >> MXC_CCM_PCTL_PD_OFFSET;
 	mfd = (reg & MXC_CCM_PCTL_MFD_MASK) >> MXC_CCM_PCTL_MFD_OFFSET;
 	mfi = (reg & MXC_CCM_PCTL_MFI_MASK) >> MXC_CCM_PCTL_MFI_OFFSET;
 	mfi = (mfi <= 5) ? 5 : mfi;
-	mfn = reg & MXC_CCM_PCTL_MFN_MASK;
+	mfn = mfn_abs = reg & MXC_CCM_PCTL_MFN_MASK;
 
-	if (mfn < 0x200) {
-		temp = (unsigned long long)2 *ref_clk * mfn;
-		do_div(temp, mfd + 1);
-		temp = (unsigned long long)2 *ref_clk * mfi + temp;
-		do_div(temp, pdf + 1);
-	} else {
-		temp = (unsigned long long)2 *ref_clk * (0x400 - mfn);
-		do_div(temp, mfd + 1);
-		temp = (unsigned long long)2 *ref_clk * mfi - temp;
-		do_div(temp, pdf + 1);
+	if (mfn >= 0x200) {
+		mfn |= 0xFFFFFE00;
+		mfn_abs = -mfn;
 	}
 
-	return (unsigned long)temp;
+	ref_clk *= 2;
+	ref_clk /= pdf + 1;
+
+	temp = (u64) ref_clk *mfn_abs;
+	do_div(temp, mfd + 1);
+	if (mfn < 0)
+		temp = -temp;
+	temp = (ref_clk * mfi) + temp;
+
+	clk->rate = temp;
 }
 
-/*!
- * This function returns the mcu main clock frequency
- *
- * @return      mcu main clock value in Hz.
- */
-static unsigned long mxc_mcu_main_clock(void)
+#define PDR0(mask, off) ((__raw_readl(MXC_CCM_PDR0) & mask) >> off)
+#define PDR1(mask, off) ((__raw_readl(MXC_CCM_PDR1) & mask) >> off)
+#define PDR2(mask, off) ((__raw_readl(MXC_CCM_PDR2) & mask) >> off)
+
+static void _clk_mcu_recalc(struct clk *clk)
 {
-	unsigned long pmcr0 = __raw_readl(MXC_CCM_PMCR0);
-	unsigned long dfsup1 = pmcr0 & MXC_CCM_PMCR0_DFSUP1;
+	unsigned long mcu_pdf;
 
-	if (dfsup1 == 0) {
-		return mxc_pll_clock(SERIALPLL);
-	}
-	return mxc_pll_clock(MCUPLL);
+	mcu_pdf = PDR0(MXC_CCM_PDR0_MCU_PODF_MASK,
+		       MXC_CCM_PDR0_MCU_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (mcu_pdf + 1);
 }
 
-/*!
- * This function returns the main clock values in Hz.
- *
- * @param       clk     as defined in enum mxc_clocks
- *
- * @return      clock value in Hz
- */
-unsigned long mxc_get_clocks(enum mxc_clocks clk)
+static void _clk_hclk_recalc(struct clk *clk)
 {
-	unsigned long pll, ret_val = 0, hclk, gpt_ctrl;
-	unsigned long mcu_pdf, max_pdf, ipg_pdf, nfc_pdf, hsp_pdf, csi_pdf,
-	    usb_pdf;
-	unsigned long ssi1_prepdf, ssi1_pdf, per_pdf;
-	unsigned long ssi2_prepdf, ssi2_pdf, firi_prepdf, firi_pdf, usb_prepdf;
-	unsigned long msti_pdf, epit_offset = 0, pwm_ctrl, epit_ctrl;
-	unsigned long ccmr = __raw_readl(MXC_CCM_CCMR);
-	unsigned long pdr0 = __raw_readl(MXC_CCM_PDR0);
-	unsigned long pdr1 = __raw_readl(MXC_CCM_PDR1);
-	unsigned long pdr2 = __raw_readl(MXC_CCM_PDR2);
-	int clksrc;
-
-	max_pdf =
-	    (pdr0 & MXC_CCM_PDR0_MAX_PODF_MASK) >> MXC_CCM_PDR0_MAX_PODF_OFFSET;
-	ipg_pdf =
-	    (pdr0 & MXC_CCM_PDR0_IPG_PODF_MASK) >> MXC_CCM_PDR0_IPG_PODF_OFFSET;
-	per_pdf =
-	    (pdr0 & MXC_CCM_PDR0_PER_PODF_MASK) >> MXC_CCM_PDR0_PER_PODF_OFFSET;
-
-	switch (clk) {
-	case CKIL_CLK:
-		ret_val = CKIL_CLK_FREQ;
-		break;
-	case CKIH_CLK:
-		ret_val = mxc_clock_ckih();
-		break;
-	case CPU_CLK:
-		pll = mxc_mcu_main_clock();
-		mcu_pdf = pdr0 & MXC_CCM_PDR0_MCU_PODF_MASK;
-		ret_val = pll / (mcu_pdf + 1);
-		break;
-	case AHB_CLK:
-		pll = mxc_mcu_main_clock();
-		ret_val = pll / (max_pdf + 1);
-		break;
-	case CSPI1_CLK:
-	case CSPI2_CLK:
-	case CSPI3_CLK:
-	case IPG_CLK:
-		pll = mxc_mcu_main_clock();
-		hclk = pll / (max_pdf + 1);
-		ret_val = hclk / (ipg_pdf + 1);
-		break;
-	case GPT_CLK:
-		/*
-		 * Three possibilities
-		 * 1. ipg_clk - sourced from mcu_ipg_clk
-		 * 2. ipg_clk_high - same as ipg_clk
-		 * 3. ckil
-		 */
-		gpt_ctrl = __raw_readl(MXC_GPT_GPTCR);
-		clksrc = (gpt_ctrl & GPTCR_CLKSRC_MASK) >> (GPTCR_CLKSRC_SHIFT);
-		switch (clksrc) {
-		case CLKSRC_IPG_CLK_HIGH:
-			if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
-				pll = mxc_pll_clock(USBPLL);
-				ret_val = pll / (per_pdf + 1);
-			} else {
-				pll = mxc_mcu_main_clock();
-				hclk = pll / (max_pdf + 1);
-				ret_val = hclk / (ipg_pdf + 1);
+	unsigned long max_pdf;
 
-			}
-			break;
-		case CLKSRC_IPG_CLK:
-			pll = mxc_mcu_main_clock();
-			hclk = pll / (max_pdf + 1);
-			ret_val = hclk / (ipg_pdf + 1);
-			break;
-		case CLKSRC_NO_CLK:
-		case CLKSRC_EXT_PAD:
-			printk(KERN_ERR
-			       "Warning: GPT clock source not supported !!!\n");
-			return -ERR_CLK_NO_SUPPORT;
-		default:
-			ret_val = CKIL_CLK_FREQ;
-			break;
-		}
-		break;
-	case PWM_CLK:
-		/*
-		 * Three possibilities
-		 * 1. ipg_clk_high - from perclk
-		 * 1. ipg_clk - sourced from mcu_ipg_clk
-		 * 2. ipg_clk_32k - CKIL
-		 */
-		pwm_ctrl = __raw_readl(MXC_PWM_PWMCTRL);
-		clksrc = (pwm_ctrl & (~PWM_CTRL_MASK)) >> (PWM_CTRL_OFFSET);
-		switch (clksrc) {
-		case CLKSRC_IPG_CLK_HIGH:
-			if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
-				pll = mxc_pll_clock(USBPLL);
-				ret_val = pll / (per_pdf + 1);
-			} else {
-				pll = mxc_mcu_main_clock();
-				hclk = pll / (max_pdf + 1);
-				ret_val = hclk / (ipg_pdf + 1);
+	max_pdf = PDR0(MXC_CCM_PDR0_MAX_PODF_MASK,
+		       MXC_CCM_PDR0_MAX_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (max_pdf + 1);
+}
 
-			}
-			break;
-		case CLKSRC_IPG_CLK:
-			pll = mxc_mcu_main_clock();
-			ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
-			break;
-		case CLKSRC_NO_CLK:
-			printk(KERN_ERR
-			       "Warning: PWM clock source not is off !!!\n");
-			return -ERR_CLK_NO_SUPPORT;
-		default:
-			ret_val = CKIL_CLK_FREQ;
-			break;
-		}
-		break;
-	case EPIT2_CLK:
-		epit_offset = 0x4000;
-	case EPIT1_CLK:
-		epit_ctrl = __raw_readl(MXC_EPIT_EPITCR + epit_offset);
-		/*
-		 * Three possibilities
-		 * 1. ipg_clk - sourced from mcu_ipg_clk
-		 * 2. ipg_clk_high - same as ipg_clk
-		 * 3. ipg_clk_32k - CKIL
-		 */
-		clksrc =
-		    (epit_ctrl & EPITCR_CLKSRC_MASK) >> (EPITCR_CLKSRC_SHIFT);
-		switch (clksrc) {
-		case CLKSRC_IPG_CLK_HIGH:
-			if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
-				pll = mxc_pll_clock(USBPLL);
-				ret_val = pll / (per_pdf + 1);
-			} else {
-				pll = mxc_mcu_main_clock();
-				hclk = pll / (max_pdf + 1);
-				ret_val = hclk / (ipg_pdf + 1);
+static void _clk_ipg_recalc(struct clk *clk)
+{
+	unsigned long ipg_pdf;
 
-			}
-			break;
-		case CLKSRC_IPG_CLK:
-			pll = mxc_mcu_main_clock();
-			ret_val = pll / ((max_pdf + 1) * (ipg_pdf + 1));
-			break;
-		case CLKSRC_NO_CLK:
-			printk(KERN_ERR
-			       "Warning: PWM clock source not is off !!!\n");
-			return -ERR_CLK_NO_SUPPORT;
-		default:
-			ret_val = CKIL_CLK_FREQ;
-			break;
-		}
-		break;
-	case NFC_CLK:
-		pll = mxc_mcu_main_clock();
-		hclk = pll / (max_pdf + 1);
-		nfc_pdf = (pdr0 & MXC_CCM_PDR0_NFC_PODF_MASK) >>
-		    MXC_CCM_PDR0_NFC_PODF_OFFSET;
-		ret_val = hclk / (nfc_pdf + 1);
-		break;
-	case IPU_CLK:
-		pll = mxc_mcu_main_clock();
-		hsp_pdf = (pdr0 & MXC_CCM_PDR0_HSP_PODF_MASK) >>
-		    MXC_CCM_PDR0_HSP_PODF_OFFSET;
-		ret_val = pll / (hsp_pdf + 1);
-		break;
-	case USB_CLK:
-		pll = mxc_pll_clock(USBPLL);
-		usb_pdf = (pdr1 & MXC_CCM_PDR1_USB_PODF_MASK) >>
-		    MXC_CCM_PDR1_USB_PODF_OFFSET;
-		usb_prepdf = (pdr1 & MXC_CCM_PDR1_USB_PRDF_MASK) >>
-		    MXC_CCM_PDR1_USB_PRDF_OFFSET;
-		ret_val = pll / ((usb_prepdf + 1) * (usb_pdf + 1));
-		break;
-	case CSI_BAUD:
-		if ((ccmr & MXC_CCM_CCMR_CSCS) == 0) {
-			pll = mxc_pll_clock(USBPLL);
-		} else {
-			pll = mxc_pll_clock(SERIALPLL);
-		}
-		csi_pdf = (pdr0 & MXC_CCM_PDR0_CSI_PODF_MASK) >>
-		    MXC_CCM_PDR0_CSI_PODF_OFFSET;
-		ret_val = pll / (csi_pdf + 1);
-		break;
-	case UART1_BAUD:
-	case UART2_BAUD:
-	case UART3_BAUD:
-	case UART4_BAUD:
-	case UART5_BAUD:
-	case I2C_CLK:
-	case I2C2_CLK:
-	case I2C3_CLK:
-	case OWIRE_CLK:
-	case SDHC1_CLK:
-	case SDHC2_CLK:
-		if ((ccmr & MXC_CCM_CCMR_PERCS) == 0) {
-			pll = mxc_pll_clock(USBPLL);
-			ret_val = pll / (per_pdf + 1);
-		} else {
-			pll = mxc_mcu_main_clock();
-			hclk = pll / (max_pdf + 1);
-			ret_val = hclk / (ipg_pdf + 1);
+	ipg_pdf = PDR0(MXC_CCM_PDR0_IPG_PODF_MASK,
+		       MXC_CCM_PDR0_IPG_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (ipg_pdf + 1);
+}
 
-		}
-		break;
-	case SSI1_BAUD:
-		pll = mxc_pll_clock((ccmr & MXC_CCM_CCMR_SSI1S_MASK) >>
-				    MXC_CCM_CCMR_SSI1S_OFFSET);
-		ssi1_pdf = (pdr1 & MXC_CCM_PDR1_SSI1_PODF_MASK) >>
-		    MXC_CCM_PDR1_SSI1_PODF_OFFSET;
-		ssi1_prepdf = (pdr1 & MXC_CCM_PDR1_SSI1_PRE_PODF_MASK) >>
-		    MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET;
-		ret_val = pll / ((ssi1_prepdf + 1) * (ssi1_pdf + 1));
-		break;
-	case SSI2_BAUD:
-		pll = mxc_pll_clock((ccmr & MXC_CCM_CCMR_SSI2S_MASK) >>
-				    MXC_CCM_CCMR_SSI2S_OFFSET);
-		ssi2_pdf = (pdr1 & MXC_CCM_PDR1_SSI2_PODF_MASK) >>
-		    MXC_CCM_PDR1_SSI2_PODF_OFFSET;
-		ssi2_prepdf = (pdr1 & MXC_CCM_PDR1_SSI2_PRE_PODF_MASK) >>
-		    MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET;
-		ret_val = pll / ((ssi2_prepdf + 1) * (ssi2_pdf + 1));
-		break;
-	case FIRI_BAUD:
-		pll = mxc_get_clocks_parent(FIRI_BAUD);
-		firi_pdf = (pdr1 & MXC_CCM_PDR1_FIRI_PODF_MASK) >>
-		    MXC_CCM_PDR1_FIRI_PODF_OFFSET;
-		firi_prepdf = (pdr1 & MXC_CCM_PDR1_FIRI_PRE_PODF_MASK) >>
-		    MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET;
-		ret_val = pll / ((firi_prepdf + 1) * (firi_pdf + 1));
-		break;
-	case MBX_CLK:
-		pll = mxc_mcu_main_clock();
-		ret_val = pll / (max_pdf + 1);
-		ret_val = ret_val / 2;
-		break;
-	case MSTICK1_BAUD:
-		pll = mxc_pll_clock(USBPLL);
-		msti_pdf = (pdr2 & MXC_CCM_PDR2_MST1_PDF_MASK) >>
-		    MXC_CCM_PDR2_MST1_PDF_OFFSET;
-		ret_val = pll / (msti_pdf + 1);
-		break;
-	case MSTICK2_BAUD:
-		pll = mxc_pll_clock(USBPLL);
-		msti_pdf = (pdr2 & MXC_CCM_PDR2_MST2_PDF_MASK) >>
-		    MXC_CCM_PDR2_MST2_PDF_OFFSET;
-		ret_val = pll / (msti_pdf + 1);
-		break;
-	default:
-		ret_val = 66516666;
-		break;
-	}
-	return ret_val;
+static void _clk_nfc_recalc(struct clk *clk)
+{
+	unsigned long nfc_pdf;
+
+	nfc_pdf = PDR0(MXC_CCM_PDR0_NFC_PODF_MASK,
+		       MXC_CCM_PDR0_NFC_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (nfc_pdf + 1);
 }
 
-/*!
- * This function returns the parent clock values in Hz.
- *
- * @param       clk     as defined in enum mxc_clocks
- *
- * @return      clock value in Hz
- */
-unsigned long mxc_get_clocks_parent(enum mxc_clocks clk)
+static void _clk_hsp_recalc(struct clk *clk)
 {
-	unsigned long ret_val = 0;
-	unsigned long ccmr = __raw_readl(MXC_CCM_CCMR);
+	unsigned long hsp_pdf;
 
-	switch (clk) {
-	case CSI_BAUD:
-		if ((ccmr & MXC_CCM_CCMR_CSCS) == 0) {
-			ret_val = mxc_pll_clock(USBPLL);
-		} else {
-			ret_val = mxc_pll_clock(SERIALPLL);
-		}
-		break;
-	case FIRI_BAUD:
-		switch ((ccmr & MXC_CCM_CCMR_FIRS_MASK) >>
-			MXC_CCM_CCMR_FIRS_OFFSET) {
-		case 0:
-			ret_val = mxc_pll_clock(MCUPLL);
-			break;
-		case 1:
-			ret_val = mxc_pll_clock(USBPLL);
-			break;
-		case 2:
-			ret_val = mxc_pll_clock(SERIALPLL);
-			break;
-		case 3:
-		default:
-			printk(KERN_ERR
-			       "FIRI clock source select is set to RESERVED\n");
+	hsp_pdf = PDR0(MXC_CCM_PDR0_HSP_PODF_MASK,
+		       MXC_CCM_PDR0_HSP_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (hsp_pdf + 1);
+}
+
+static void _clk_usb_recalc(struct clk *clk)
+{
+	unsigned long usb_pdf, usb_prepdf;
+
+	usb_pdf = PDR1(MXC_CCM_PDR1_USB_PODF_MASK,
+		       MXC_CCM_PDR1_USB_PODF_OFFSET);
+	usb_prepdf = PDR1(MXC_CCM_PDR1_USB_PRDF_MASK,
+			  MXC_CCM_PDR1_USB_PRDF_OFFSET);
+	clk->rate = clk->parent->rate / (usb_prepdf + 1) / (usb_pdf + 1);
+}
+
+static void _clk_csi_recalc(struct clk *clk)
+{
+	unsigned long csi_pdf;
+
+	csi_pdf = PDR0(MXC_CCM_PDR0_CSI_PODF_MASK,
+		       MXC_CCM_PDR0_CSI_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (csi_pdf + 1);
+}
+
+static unsigned long _clk_csi_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 512)
+		div = 512;
+
+	return clk->parent->rate / div;
+
+}
+
+static int _clk_csi_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+
+	/* Set CSI clock divider */
+	reg = __raw_readl(MXC_CCM_PDR0) & ~MXC_CCM_PDR0_CSI_PODF_MASK;
+	reg |= (div - 1) << MXC_CCM_PDR0_CSI_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_PDR0);
+
+	clk->rate = rate;
+	return 0;
+}
+
+static void _clk_per_recalc(struct clk *clk)
+{
+	unsigned long per_pdf;
+
+	per_pdf = PDR0(MXC_CCM_PDR0_PER_PODF_MASK,
+		       MXC_CCM_PDR0_PER_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (per_pdf + 1);
+}
+
+static void _clk_ssi1_recalc(struct clk *clk)
+{
+	unsigned long ssi1_pdf, ssi1_prepdf;
+
+	ssi1_pdf = PDR1(MXC_CCM_PDR1_SSI1_PODF_MASK,
+			MXC_CCM_PDR1_SSI1_PODF_OFFSET);
+	ssi1_prepdf = PDR1(MXC_CCM_PDR1_SSI1_PRE_PODF_MASK,
+			   MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (ssi1_prepdf + 1) / (ssi1_pdf + 1);
+}
+
+static void _clk_ssi2_recalc(struct clk *clk)
+{
+	unsigned long ssi2_pdf, ssi2_prepdf;
+
+	ssi2_pdf = PDR1(MXC_CCM_PDR1_SSI2_PODF_MASK,
+			MXC_CCM_PDR1_SSI2_PODF_OFFSET);
+	ssi2_prepdf = PDR1(MXC_CCM_PDR1_SSI2_PRE_PODF_MASK,
+			   MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (ssi2_prepdf + 1) / (ssi2_pdf + 1);
+}
+
+static void _clk_firi_recalc(struct clk *clk)
+{
+	unsigned long firi_pdf, firi_prepdf;
+
+	firi_pdf = PDR1(MXC_CCM_PDR1_FIRI_PODF_MASK,
+			MXC_CCM_PDR1_FIRI_PODF_OFFSET);
+	firi_prepdf = PDR1(MXC_CCM_PDR1_FIRI_PRE_PODF_MASK,
+			   MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET);
+	clk->rate = clk->parent->rate / (firi_prepdf + 1) / (firi_pdf + 1);
+}
+
+static void __calc_pre_post_dividers(u32 div, u32 * pre, u32 * post)
+{
+	u32 min_pre, temp_pre, old_err, err;
+
+	if (div >= 512) {
+		*pre = 8;
+		*post = 64;
+	} else if (div >= 64) {
+		min_pre = (div - 1) / 64 + 1;
+		old_err = 8;
+		for (temp_pre = 8; temp_pre >= min_pre; temp_pre--) {
+			err = div % temp_pre;
+			if (err == 0) {
+				*pre = temp_pre;
+				break;
+			}
+			err = temp_pre - err;
+			if (err < old_err) {
+				old_err = err;
+				*pre = temp_pre;
+			}
 		}
-		break;
-	default:
-		break;
+		*post = (div + *pre - 1) / *pre;
+	} else if (div <= 8) {
+		*pre = div;
+		*post = 1;
+	} else {
+		*pre = 1;
+		*post = div;
 	}
-	return ret_val;
 }
 
-/*!
- * This function calculates the pre and post divider values for a clock
- *
- * @param div  divider value passed in
- * @param div1 returns the pre-divider value
- * @param div2 returns the post-divider value
- * @param lim1 limit of divider 1
- * @param lim2 limit of divider 2
- */
-void mxc_clk_getdivs(unsigned int div, unsigned int *div1,
-		     unsigned int *div2, int lim1, int lim2)
+static unsigned long _clk_firi_round_rate(struct clk *clk, unsigned long rate)
 {
-	int i;
+	u32 pre, post;
+	u32 div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
 
-	if (div <= lim1) {
-		*div1 = div;
-		*div2 = 1;
-		return;
-	}
-	if (div <= lim2) {
-		*div1 = 1;
-		*div2 = div;
-		return;
-	}
-	for (i = 2; i < (lim1 + 1); i++) {
-		if ((div % i) == 0) {
-			*div1 = i;
-			*div2 = div / i;
-			return;
-		}
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	return clk->parent->rate / (pre * post);
+
+}
+
+static int _clk_firi_set_rate(struct clk *clk, unsigned long rate)
+{
+	u32 reg;
+	u32 div, pre, post;
+
+	div = clk->parent->rate / rate;
+
+	if ((clk->parent->rate / div) != rate)
+		return -EINVAL;
+
+	__calc_pre_post_dividers(div, &pre, &post);
+
+	/* Set FIRI clock divider */
+	reg = __raw_readl(MXC_CCM_PDR1) &
+	    ~(MXC_CCM_PDR1_FIRI_PODF_MASK | MXC_CCM_PDR1_FIRI_PRE_PODF_MASK);
+	reg |= (pre - 1) << MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET;
+	reg |= (post - 1) << MXC_CCM_PDR1_FIRI_PODF_OFFSET;
+	__raw_writel(reg, MXC_CCM_PDR1);
+
+	clk->rate = rate;
+	return 0;
+}
+
+static void _clk_mbx_recalc(struct clk *clk)
+{
+	clk->rate = clk->parent->rate / 2;
+}
+
+static void _clk_mstick1_recalc(struct clk *clk)
+{
+	unsigned long msti_pdf;
+
+	msti_pdf = PDR2(MXC_CCM_PDR2_MST1_PDF_MASK,
+			MXC_CCM_PDR2_MST1_PDF_OFFSET);
+	clk->rate = clk->parent->rate / (msti_pdf + 1);
+}
+
+static void _clk_mstick2_recalc(struct clk *clk)
+{
+	unsigned long msti_pdf;
+
+	msti_pdf = PDR2(MXC_CCM_PDR2_MST2_PDF_MASK,
+			MXC_CCM_PDR2_MST2_PDF_OFFSET);
+	clk->rate = clk->parent->rate / (msti_pdf + 1);
+}
+
+static struct clk ckih_clk = {
+	.name = "ckih",
+	.rate = 0,		/* determined later (26 or 27 MHz) */
+};
+
+static struct clk ckil_clk = {
+	.name = "ckil",
+	.rate = CKIL_CLK_FREQ,
+};
+
+static struct clk mcu_main_clk = {
+	.name = "mcu_pll",
+	.parent = &ckih_clk,
+	.set_rate = _clk_pll_set_rate,
+	.recalc = _clk_pll_recalc,
+};
+
+static struct clk serial_pll_clk = {
+	.name = "serial_pll",
+	.parent = &ckih_clk,
+	.set_rate = _clk_pll_set_rate,
+	.recalc = _clk_pll_recalc,
+};
+
+static struct clk usb_pll_clk = {
+	.name = "usb_pll",
+	.parent = &ckih_clk,
+	.set_rate = _clk_pll_set_rate,
+	.recalc = _clk_pll_recalc,
+};
+
+static struct clk cpu_clk = {
+	.name = "cpu_clk",
+	.parent = &mcu_main_clk,
+	.recalc = _clk_mcu_recalc,
+};
+
+static struct clk ahb_clk = {
+	.name = "ahb_clk",
+	.parent = &mcu_main_clk,
+	.recalc = _clk_hclk_recalc,
+};
+
+static struct clk per_clk = {
+	.name = "per_clk",
+	.parent = &usb_pll_clk,
+	.recalc = _clk_per_recalc,
+};
+
+static struct clk perclk_clk = {
+	.name = "perclk_clk",
+	.parent = &ipg_clk,
+};
+
+static struct clk cspi_clk[] = {
+	{
+	 .name = "cspi_clk",
+	 .id = 0,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_CSPI1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "cspi_clk",
+	 .id = 1,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_CSPI2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "cspi_clk",
+	 .id = 2,
+	 .parent = &ipg_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_CSPI3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk ipg_clk = {
+	.name = "ipg_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_ipg_recalc,
+};
+
+static struct clk emi_clk = {
+	.name = "emi_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_EMI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk gpt_clk = {
+	.name = "gpt_clk",
+	.parent = &perclk_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_GPT_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk pwm_clk = {
+	.name = "pwm_clk",
+	.parent = &perclk_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR1_PWM_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk epit_clk[] = {
+	{
+	 .name = "epit_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_EPIT1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "epit_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_EPIT2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk nfc_clk = {
+	.name = "nfc_clk",
+	.parent = &ahb_clk,
+	.recalc = _clk_nfc_recalc,
+};
+
+static struct clk scc_clk = {
+	.name = "scc_clk",
+	.parent = &ipg_clk,
+};
+
+static struct clk ipu_clk = {
+	.name = "ipu_clk",
+	.parent = &mcu_main_clk,
+	.recalc = _clk_hsp_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_IPU_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk kpp_clk = {
+	.name = "kpp_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_KPP_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk wdog_clk = {
+	.name = "wdog_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_WDOG_OFFSET,
+	.disable = _clk_disable,
+};
+static struct clk rtc_clk = {
+	.name = "rtc_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_RTC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk usb_clk = {
+	.name = "usb_clk",
+	.parent = &usb_pll_clk,
+	.recalc = _clk_usb_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_USBOTG_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk csi_clk = {
+	.name = "csi_clk",
+	.parent = &usb_pll_clk,
+	.recalc = _clk_csi_recalc,
+	.round_rate = _clk_csi_round_rate,
+	.set_rate = _clk_csi_set_rate,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_CSI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk uart_clk[] = {
+	{
+	 .name = "uart_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_UART1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_UART2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 2,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_UART3_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 3,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_UART4_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "uart_clk",
+	 .id = 4,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_UART5_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk i2c_clk[] = {
+	{
+	 .name = "i2c_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_I2C1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "i2c_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_I2C2_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "i2c_clk",
+	 .id = 2,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_I2C3_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk owire_clk = {
+	.name = "owire_clk",
+	.parent = &perclk_clk,
+};
+
+static struct clk sdhc_clk[] = {
+	{
+	 .name = "sdhc_clk",
+	 .id = 0,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_SD_MMC1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "sdhc_clk",
+	 .id = 1,
+	 .parent = &perclk_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_SD_MMC2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk ssi_clk[] = {
+	{
+	 .name = "ssi_clk",
+	 .parent = &serial_pll_clk,
+	 .recalc = _clk_ssi1_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_SSI1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "ssi_clk",
+	 .parent = &serial_pll_clk,
+	 .recalc = _clk_ssi2_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR2,
+	 .enable_shift = MXC_CCM_CGR2_SSI2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static struct clk firi_clk = {
+	.name = "firi_clk",
+	.parent = &usb_pll_clk,
+	.round_rate = _clk_firi_round_rate,
+	.set_rate = _clk_firi_set_rate,
+	.recalc = _clk_firi_recalc,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_FIRI_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk ata_clk = {
+	.name = "ata_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_ATA_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mbx_clk = {
+	.name = "mbx_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_GACC_OFFSET,
+	.recalc = _clk_mbx_recalc,
+};
+
+static struct clk rtic_clk = {
+	.name = "rtic_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR2,
+	.enable_shift = MXC_CCM_CGR2_RTIC_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk rng_clk = {
+	.name = "rng_clk",
+	.parent = &ipg_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR0,
+	.enable_shift = MXC_CCM_CGR0_RNG_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk sdma_clk[] = {
+	{
+	 .name = "sdma_ahb_clk",
+	 .parent = &ahb_clk,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR0,
+	 .enable_shift = MXC_CCM_CGR0_SDMA_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "sdma_ipg_clk",
+	 .parent = &ipg_clk,}
+};
+
+static struct clk mpeg4_clk = {
+	.name = "mpeg4_clk",
+	.parent = &ahb_clk,
+	.enable = _clk_enable,
+	.enable_reg = MXC_CCM_CGR1,
+	.enable_shift = MXC_CCM_CGR1_HANTRO_OFFSET,
+	.disable = _clk_disable,
+};
+
+static struct clk mstick_clk[] = {
+	{
+	 .name = "mstick_clk",
+	 .id = 0,
+	 .parent = &usb_pll_clk,
+	 .recalc = _clk_mstick1_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_MEMSTICK1_OFFSET,
+	 .disable = _clk_disable,},
+	{
+	 .name = "mstick_clk",
+	 .id = 1,
+	 .parent = &usb_pll_clk,
+	 .recalc = _clk_mstick2_recalc,
+	 .enable = _clk_enable,
+	 .enable_reg = MXC_CCM_CGR1,
+	 .enable_shift = MXC_CCM_CGR1_MEMSTICK2_OFFSET,
+	 .disable = _clk_disable,},
+};
+
+static unsigned long _clk_cko1_round_rate(struct clk *clk, unsigned long rate)
+{
+	u32 div;
+
+	div = clk->parent->rate / rate;
+	if (clk->parent->rate % rate)
+		div++;
+
+	if (div > 8) {
+		div = 16;
+	} else if (div > 4) {
+		div = 8;
+	} else if (div > 2) {
+		div = 4;
 	}
 
-	*div1 = 1;
-	*div2 = lim2;
-	return;
+	return clk->parent->rate / div;
 }
 
-/*!
- * This function sets the PLL source for a clock.
- *
- * @param clk     as defined in enum mxc_clocks
- * @param pll_num the PLL that you wish to use as source for this clock
- */
-void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num)
+static int _clk_cko1_set_rate(struct clk *clk, unsigned long rate)
 {
-	unsigned long ccmr;
-	unsigned long flags;
+	u32 reg;
+	u32 div;
 
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	ccmr = __raw_readl(MXC_CCM_CCMR);
+	div = clk->parent->rate / rate;
 
-	switch (clk) {
-	case CPU_CLK:
-		if (pll_num == MCUPLL) {
-			ccmr &= ~MXC_CCM_CCMR_MDS;
-		} else {
-			ccmr |= MXC_CCM_CCMR_MDS;
-		}
-		break;
-	case CSI_BAUD:
-		if (pll_num == USBPLL) {
-			ccmr &= ~MXC_CCM_CCMR_CSCS;
-		} else {
-			ccmr |= MXC_CCM_CCMR_CSCS;
-		}
-		break;
-	case SSI1_BAUD:
-		ccmr = (ccmr & (~MXC_CCM_CCMR_SSI1S_MASK)) |
-		    (pll_num << MXC_CCM_CCMR_SSI1S_OFFSET);
-		break;
-	case SSI2_BAUD:
-		ccmr = (ccmr & (~MXC_CCM_CCMR_SSI2S_MASK)) |
-		    (pll_num << MXC_CCM_CCMR_SSI2S_OFFSET);
-		break;
-	case FIRI_BAUD:
-		ccmr = (ccmr & (~MXC_CCM_CCMR_FIRS_MASK)) |
-		    (pll_num << MXC_CCM_CCMR_FIRS_OFFSET);
-		break;
-	default:
-		printk(KERN_ERR
-		       "This clock does not have ability to choose its clock source\n");
-		break;
+	if (div == 16) {
+		div = 4;
+	} else if (div == 8) {
+		div = 3;
+	} else if (div == 4) {
+		div = 2;
+	} else if (div == 2) {
+		div = 1;
+	} else if (div == 1) {
+		div = 0;
+	} else {
+		return -EINVAL;
 	}
-	__raw_writel(ccmr, MXC_CCM_CCMR);
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-	return;
+
+	reg = __raw_readl(MXC_CCM_COSR) & ~MXC_CCM_COSR_CLKOUTDIV_MASK;
+	reg |= div << MXC_CCM_COSR_CLKOUTDIV_OFFSET;
+	__raw_writel(reg, MXC_CCM_COSR);
+
+	return 0;
 }
 
-/*!
- * This function sets the divider value for a clock.
- *
- * @param clk as defined in enum mxc_clocks
- * @param div the division factor to be used for the clock (For SSI & CSI, pass
- *            in 2 times the expected division value to account for FP vals on certain
- *            platforms)
- */
-void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div)
+static void _clk_cko1_recalc(struct clk *clk)
 {
-	unsigned long reg;
-	unsigned long flags;
-	unsigned int d = 0, div1 = 0, div2 = 0;
+	u32 div;
 
-	spin_lock_irqsave(&mxc_crm_lock, flags);
+	div = __raw_readl(MXC_CCM_COSR) & MXC_CCM_COSR_CLKOUTDIV_MASK >>
+	    MXC_CCM_COSR_CLKOUTDIV_OFFSET;
+
+	clk->rate = clk->parent->rate / (1 << div);
+}
+
+static int _clk_cko1_set_parent(struct clk *clk, struct clk *parent)
+{
+	u32 reg;
 
-	switch (clk) {
-	case AHB_CLK:
-		reg = __raw_readl(MXC_CCM_PDR0);
-		reg = (reg & (~MXC_CCM_PDR0_MAX_PODF_MASK)) |
-		    ((div - 1) << MXC_CCM_PDR0_MAX_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR0);
-		break;
-	case CPU_CLK:
-		reg = __raw_readl(MXC_CCM_PDR0);
-		reg = (reg & (~MXC_CCM_PDR0_MCU_PODF_MASK)) |
-		    ((div - 1) << MXC_CCM_PDR0_MCU_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR0);
-		break;
-	case IPG_CLK:
-		reg = __raw_readl(MXC_CCM_PDR0);
-		reg = (reg & (~MXC_CCM_PDR0_IPG_PODF_MASK)) |
-		    ((div - 1) << MXC_CCM_PDR0_IPG_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR0);
-		break;
-	case NFC_CLK:
-		reg = __raw_readl(MXC_CCM_PDR0);
-		reg = (reg & (~MXC_CCM_PDR0_NFC_PODF_MASK)) |
-		    ((div - 1) << MXC_CCM_PDR0_NFC_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR0);
-		break;
-	case CSI_BAUD:
-		reg = __raw_readl(MXC_CCM_PDR0);
-		d = div / 2;
-		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
-		reg = (reg & (~MXC_CCM_PDR0_CSI_PRDF_MASK)) |
-		    ((div1 - 1) << MXC_CCM_PDR0_CSI_PRDF_OFFSET);
-		reg = (reg & (~MXC_CCM_PDR0_CSI_PODF_MASK)) |
-		    ((div2 - 1) << MXC_CCM_PDR0_CSI_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR0);
-		break;
-	case IPU_CLK:
-		reg = __raw_readl(MXC_CCM_PDR0);
-		reg = (reg & (~MXC_CCM_PDR0_HSP_PODF_MASK)) |
-		    ((div - 1) << MXC_CCM_PDR0_HSP_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR0);
-		break;
-	case UART1_BAUD:
-	case UART2_BAUD:
-	case UART3_BAUD:
-	case UART4_BAUD:
-	case UART5_BAUD:
-	case I2C_CLK:
-	case I2C2_CLK:
-	case I2C3_CLK:
-		reg = __raw_readl(MXC_CCM_PDR0);
-		reg = (reg & (~MXC_CCM_PDR0_PER_PODF_MASK)) |
-		    ((div - 1) << MXC_CCM_PDR0_PER_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR0);
-		break;
-	case SSI1_BAUD:
-		reg = __raw_readl(MXC_CCM_PDR1);
-		d = div / 2;
-		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
-		reg = (reg & (~MXC_CCM_PDR1_SSI1_PRE_PODF_MASK)) |
-		    ((div1 - 1) << MXC_CCM_PDR1_SSI1_PRE_PODF_OFFSET);
-		reg = (reg & (~MXC_CCM_PDR1_SSI1_PODF_MASK)) |
-		    ((div2 - 1) << MXC_CCM_PDR1_SSI1_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR1);
-		break;
-	case SSI2_BAUD:
-		reg = __raw_readl(MXC_CCM_PDR1);
-		d = div / 2;
-		mxc_clk_getdivs(d, &div1, &div2, 8, 64);
-		reg = (reg & (~MXC_CCM_PDR1_SSI2_PRE_PODF_MASK)) |
-		    ((div1 - 1) << MXC_CCM_PDR1_SSI2_PRE_PODF_OFFSET);
-		reg = (reg & (~MXC_CCM_PDR1_SSI2_PODF_MASK)) |
-		    ((div2 - 1) << MXC_CCM_PDR1_SSI2_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR1);
-		break;
-	case FIRI_BAUD:
-		reg = __raw_readl(MXC_CCM_PDR1);
-		mxc_clk_getdivs(div, &div1, &div2, 8, 64);
-		reg = (reg & (~MXC_CCM_PDR1_FIRI_PRE_PODF_MASK)) |
-		    ((div1 - 1) << MXC_CCM_PDR1_FIRI_PRE_PODF_OFFSET);
-		reg = (reg & (~MXC_CCM_PDR1_FIRI_PODF_MASK)) |
-		    ((div2 - 1) << MXC_CCM_PDR1_FIRI_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR1);
-		break;
-	case USB_CLK:
-		reg = __raw_readl(MXC_CCM_PDR1);
-		mxc_clk_getdivs(d, &div1, &div2, 4, 8);
-		reg = (reg & (~MXC_CCM_PDR1_USB_PRDF_MASK)) |
-		    ((div1 - 1) << MXC_CCM_PDR1_USB_PRDF_OFFSET);
-		reg = (reg & (~MXC_CCM_PDR1_USB_PODF_MASK)) |
-		    ((div2 - 1) << MXC_CCM_PDR1_USB_PODF_OFFSET);
-		__raw_writel(reg, MXC_CCM_PDR1);
-		break;
-	default:
-		break;
+	reg = __raw_readl(MXC_CCM_COSR) & ~MXC_CCM_COSR_CLKOSEL_MASK;
+
+	if (parent == &mcu_main_clk) {
+		reg |= 0 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &ipg_clk) {
+		reg |= 1 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &usb_pll_clk) {
+		reg |= 2 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == mcu_main_clk.parent) {
+		reg |= 3 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &ahb_clk) {
+		reg |= 5 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &cpu_clk) {
+		reg |= 6 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &serial_pll_clk) {
+		reg |= 7 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &ckih_clk) {
+		reg |= 8 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &emi_clk) {
+		reg |= 9 << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &ipu_clk) {
+		reg |= 0xA << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &nfc_clk) {
+		reg |= 0xB << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else if (parent == &uart_clk[0]) {
+		reg |= 0xC << MXC_CCM_COSR_CLKOSEL_OFFSET;
+	} else {
+		return -EINVAL;
 	}
 
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	__raw_writel(reg, MXC_CCM_COSR);
+
+	return 0;
 }
 
-/*!
- * This function is called to enable the individual module clocks
- *
- * @param       clk     as defined in enum mxc_clocks
- */
-void mxc_clks_enable(enum mxc_clocks clk)
+static int _clk_cko1_enable(struct clk *clk)
 {
-	unsigned long flags;
-	unsigned long reg;
+	u32 reg;
 
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	switch (clk) {
-	case UART1_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_UART1;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case UART2_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_UART2;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case UART3_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_UART3;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case UART4_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_UART4;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case UART5_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_UART5;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case I2C_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_I2C1;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case I2C2_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_I2C2;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case I2C3_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_I2C3;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case SSI1_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_SSI1;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case SSI2_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg |= MXC_CCM_CGR2_SSI2;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case USB_CLK:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_USBOTG;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case FIRI_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg |= MXC_CCM_CGR2_FIRI;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case CSI_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_CSI;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case IPU_CLK:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_IPU;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case KPP_CLK:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_KPP;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case SDHC1_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_SD_MMC1;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case SDHC2_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_SD_MMC2;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case CSPI1_CLK:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg |= MXC_CCM_CGR2_CSPI1;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case CSPI2_CLK:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg |= MXC_CCM_CGR2_CSPI2;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case CSPI3_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_CSPI3;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case ATA_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_ATA;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case MBX_CLK:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg |= MXC_CCM_CGR2_GACC;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case RTIC_CLK:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg |= MXC_CCM_CGR2_RTIC;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case RNG_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_RNG;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case SDMA_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg |= MXC_CCM_CGR0_SDMA;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case MPEG4_CLK:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_HANTRO;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case MSTICK1_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_MEMSTICK1;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case MSTICK2_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg |= MXC_CCM_CGR1_MEMSTICK2;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	default:
-		break;
+	reg = __raw_readl(MXC_CCM_COSR) | MXC_CCM_COSR_CLKOEN;
+	__raw_writel(reg, MXC_CCM_COSR);
+
+	return 0;
+}
+
+static void _clk_cko1_disable(struct clk *clk)
+{
+	u32 reg;
+
+	reg = __raw_readl(MXC_CCM_COSR) & ~MXC_CCM_COSR_CLKOEN;
+	__raw_writel(reg, MXC_CCM_COSR);
+}
+
+static struct clk cko1_clk = {
+	.name = "cko1_clk",
+	.recalc = _clk_cko1_recalc,
+	.set_rate = _clk_cko1_set_rate,
+	.round_rate = _clk_cko1_round_rate,
+	.set_parent = _clk_cko1_set_parent,
+	.enable = _clk_cko1_enable,
+	.disable = _clk_cko1_disable,
+};
+
+static struct clk *mxc_clks[] = {
+	&ckih_clk,
+	&ckil_clk,
+	&usb_pll_clk,
+	&mcu_main_clk,
+	&serial_pll_clk,
+	&cpu_clk,
+	&ahb_clk,
+	&per_clk,
+	&perclk_clk,
+	&cko1_clk,
+	&emi_clk,
+	&cspi_clk[0],
+	&cspi_clk[1],
+	&cspi_clk[2],
+	&ipg_clk,
+	&gpt_clk,
+	&pwm_clk,
+	&wdog_clk,
+	&rtc_clk,
+	&epit_clk[0],
+	&epit_clk[1],
+	&nfc_clk,
+	&ipu_clk,
+	&kpp_clk,
+	&usb_clk,
+	&csi_clk,
+	&uart_clk[0],
+	&uart_clk[1],
+	&uart_clk[2],
+	&uart_clk[3],
+	&uart_clk[4],
+	&i2c_clk[0],
+	&i2c_clk[1],
+	&i2c_clk[2],
+	&owire_clk,
+	&sdhc_clk[0],
+	&sdhc_clk[1],
+	&ssi_clk[0],
+	&ssi_clk[1],
+	&firi_clk,
+	&ata_clk,
+	&mbx_clk,
+	&rtic_clk,
+	&rng_clk,
+	&sdma_clk[0],
+	&sdma_clk[1],
+	&mpeg4_clk,
+	&mstick_clk[0],
+	&mstick_clk[1],
+	&scc_clk,
+};
+
+extern void propagate_rate(struct clk *tclk);
+
+int __init mxc_clocks_init(void)
+{
+	struct clk **clkp;
+
+	for (clkp = mxc_clks; clkp < mxc_clks + ARRAY_SIZE(mxc_clks); clkp++) {
+		clk_register(*clkp);
 	}
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+
+	/* Turn off all possible clocks */
+	// TODO
+
+	/* Determine which high frequency clock source is coming in */
+	if ((__raw_readw(PBC_BASE_ADDRESS + PBC_BSTAT) &
+	     CKIH_27MHZ_BIT_SET) != 0) {
+		ckih_clk.rate = CKIH_CLK_FREQ_27MHZ;
+	} else {
+		ckih_clk.rate = CKIH_CLK_FREQ;
+	}
+	pr_info("Clock input source is %ld\n", ckih_clk.rate);
+
+	/* This will propagate to all children and init all the clock rates */
+	propagate_rate(&ckih_clk);
+
+	return 0;
 }
 
 /*!
- * This function is called to disable the individual module clocks
+ * Function to get timer clock rate early in boot process before clock tree is
+ * initialized.
  *
- * @param       clk     as defined in enum mxc_clocks
+ * @return	Clock rate for timer
  */
-void mxc_clks_disable(enum mxc_clocks clk)
+unsigned long __init clk_early_get_timer_rate(void)
 {
-	unsigned long flags;
-	unsigned long reg;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-	switch (clk) {
-	case UART1_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_UART1;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case UART2_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_UART2;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case UART3_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_UART3;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case UART4_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_UART4;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case UART5_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_UART5;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case I2C_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_I2C1;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case I2C2_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_I2C2;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case I2C3_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_I2C3;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case SSI1_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_SSI1;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case SSI2_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg &= ~MXC_CCM_CGR2_SSI2;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case USB_CLK:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_USBOTG;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case FIRI_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg &= ~MXC_CCM_CGR2_FIRI;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case CSI_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_CSI;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case IPU_CLK:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_IPU;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case KPP_CLK:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_KPP;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case SDHC1_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_SD_MMC1;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case SDHC2_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_SD_MMC2;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case CSPI1_CLK:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg &= ~MXC_CCM_CGR2_CSPI1;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case CSPI2_CLK:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg &= ~MXC_CCM_CGR2_CSPI2;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case CSPI3_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_CSPI3;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case ATA_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_ATA;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case MBX_CLK:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg &= ~MXC_CCM_CGR2_GACC;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case RTIC_CLK:
-		reg = __raw_readl(MXC_CCM_CGR2);
-		reg &= ~MXC_CCM_CGR2_RTIC;
-		__raw_writel(reg, MXC_CCM_CGR2);
-		break;
-	case RNG_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_RNG;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case SDMA_CLK:
-		reg = __raw_readl(MXC_CCM_CGR0);
-		reg &= ~MXC_CCM_CGR0_SDMA;
-		__raw_writel(reg, MXC_CCM_CGR0);
-		break;
-	case MPEG4_CLK:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_HANTRO;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case MSTICK1_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_MEMSTICK1;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	case MSTICK2_BAUD:
-		reg = __raw_readl(MXC_CCM_CGR1);
-		reg &= ~MXC_CCM_CGR1_MEMSTICK2;
-		__raw_writel(reg, MXC_CCM_CGR1);
-		break;
-	default:
-		break;
+	if ((__raw_readw(PBC_BASE_ADDRESS + PBC_BSTAT) &
+	     CKIH_27MHZ_BIT_SET) != 0) {
+		ckih_clk.rate = CKIH_CLK_FREQ_27MHZ;
+	} else {
+		ckih_clk.rate = CKIH_CLK_FREQ;
 	}
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	mcu_main_clk.recalc(&mcu_main_clk);
+	ahb_clk.recalc(&ahb_clk);
+	ipg_clk.recalc(&ipg_clk);
+	return ipg_clk.rate;
 }
 
 /*!
@@ -978,6 +1067,8 @@ unsigned long mxc_ccm_get_reg(unsigned i
 	return reg;
 }
 
+DEFINE_SPINLOCK(mxc_crm_lock);
+
 /*!
  * This function is called to modify the contents of a CCM register
  *
@@ -998,130 +1089,5 @@ void mxc_ccm_modify_reg(unsigned int reg
 	spin_unlock_irqrestore(&mxc_crm_lock, flags);
 }
 
-/*!
- * This function is used to modify PLL registers to generate the required
- * frequency.
- *
- * @param  pll_num  the PLL that you wish to modify
- * @param  mfi      multiplication factor integer part
- * @param  pdf      pre-division factor
- * @param  mfd      multiplication factor denominator
- * @param  mfn      multiplication factor numerator
- */
-void mxc_pll_set(enum plls pll_num, unsigned int mfi, unsigned int pdf,
-		 unsigned int mfd, unsigned int mfn)
-{
-	unsigned long ccmr;
-	unsigned long flags;
-	unsigned long new_pll = 0;
-
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-
-	if (pll_num == MCUPLL) {
-		/* Swap to reference clock and disable PLL */
-		ccmr = __raw_readl(MXC_CCM_CCMR);
-		ccmr |= MXC_CCM_CCMR_MDS;
-		ccmr &= ~MXC_CCM_CCMR_MPE;
-		__raw_writel(ccmr, MXC_CCM_CCMR);
-	}
-
-	/* Change the Pll value */
-	new_pll = (mfi << MXC_CCM_PCTL_MFI_OFFSET) |
-	    (mfn << MXC_CCM_PCTL_MFN_OFFSET) |
-	    (mfd << MXC_CCM_PCTL_MFD_OFFSET) | (pdf << MXC_CCM_PCTL_PD_OFFSET);
-
-	if (pll_num == MCUPLL) {
-		__raw_writel(new_pll, MXC_CCM_MPCTL);
-	} else if (pll_num == USBPLL) {
-		__raw_writel(new_pll, MXC_CCM_UPCTL);
-	} else if (pll_num == SERIALPLL) {
-		__raw_writel(new_pll, MXC_CCM_SRPCTL);
-	}
-
-	if (pll_num == MCUPLL) {
-		/* Swap to the new value */
-		ccmr = __raw_readl(MXC_CCM_CCMR);
-		ccmr |= MXC_CCM_CCMR_MPE;
-		ccmr &= ~MXC_CCM_CCMR_MDS;
-		__raw_writel(ccmr, MXC_CCM_CCMR);
-	}
-
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-}
-
-/*!
- * Configure clock output on CKO pin
- *
- * @param       output     as defined in enum mxc_clk_out
- * @param       clk        as defined in enum mxc_clocks
- * @param       div        clock output divider value. The possible values
- *                               for this are 1, 2, 4, 8 and 16
- *
- */
-void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk, int div)
-{
-	unsigned long flags;
-	int div_value = 0;
-	u32 reg;
-
-	switch (div) {
-	case 1:
-		div_value = 0;
-		break;
-	case 2:
-		div_value = 1;
-		break;
-	case 4:
-		div_value = 2;
-		break;
-	case 8:
-		div_value = 3;
-		break;
-	case 16:
-		div_value = 4;
-		break;
-	default:
-		/* return error */
-		return;
-	}
-	spin_lock_irqsave(&mxc_crm_lock, flags);
-
-	reg = __raw_readl(MXC_CCM_COSR);
-
-	reg = (reg & ~MXC_CCM_COSR_CLKOUTDIV_MASK) |
-	    (div_value << MXC_CCM_COSR_CLKOUTDIV_OFFSET);
-
-	switch (clk) {
-	case CPU_CLK:
-		/* To select AP clock */
-		reg = (reg & ~MXC_CCM_COSR_CLKOSEL_MASK) | 0x00000006;
-		break;
-	case AHB_CLK:
-		/* To select AHB clock */
-		reg = (reg & ~MXC_CCM_COSR_CLKOSEL_MASK) | 0x00000005;
-		break;
-	case IPG_CLK:
-		/* To select IP clock */
-		reg = (reg & ~MXC_CCM_COSR_CLKOSEL_MASK) | 0x00000001;
-		break;
-	default:
-		goto ret;
-	}
-
-	__raw_writel(reg, MXC_CCM_COSR);
-
-      ret:
-	spin_unlock_irqrestore(&mxc_crm_lock, flags);
-}
-
-EXPORT_SYMBOL(mxc_pll_set);
-EXPORT_SYMBOL(mxc_pll_clock);
-EXPORT_SYMBOL(mxc_get_clocks);
-EXPORT_SYMBOL(mxc_get_clocks_parent);
-EXPORT_SYMBOL(mxc_set_clocks_pll);
-EXPORT_SYMBOL(mxc_set_clocks_div);
-EXPORT_SYMBOL(mxc_clks_disable);
-EXPORT_SYMBOL(mxc_clks_enable);
 EXPORT_SYMBOL(mxc_ccm_get_reg);
 EXPORT_SYMBOL(mxc_ccm_modify_reg);
-EXPORT_SYMBOL(mxc_set_clock_output);
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/cpu.c linux-2.6.19.2/arch/arm/mach-mx3/cpu.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/cpu.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/cpu.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,6 +1,6 @@
 /*
  *  Copyright (C) 2001 Deep Blue Solutions Ltd.
- *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -18,15 +18,9 @@
 
 #include <linux/types.h>
 #include <linux/kernel.h>
-#include <linux/cpufreq.h>
 #include <linux/init.h>
-#include <linux/delay.h>
 #include <asm/hardware.h>
-#include <asm/setup.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
-#include <asm/cacheflush.h>
-#include <linux/proc_fs.h>
 
 const u32 system_rev_tbl[SYSTEM_REV_NUM][2] = {
 	/* SREV, own defined ver */
@@ -78,53 +72,3 @@ static int __init post_cpu_init(void)
 }
 
 postcore_initcall(post_cpu_init);
-
-static int mxc_clock_read_proc(char *page, char **start, off_t off,
-			       int count, int *eof, void *data)
-{
-	char *p = page;
-	int len;
-
-	p += sprintf(p, "MCUPLL:\t\t%lu\n", mxc_pll_clock(MCUPLL));
-	p += sprintf(p, "USBPLL:\t\t%lu\n", mxc_pll_clock(USBPLL));
-	p += sprintf(p, "SERIALPLL:\t%lu\n", mxc_pll_clock(SERIALPLL));
-	p += sprintf(p, "CPU_CLK:\t%lu\n", mxc_get_clocks(CPU_CLK));
-	p += sprintf(p, "AHB_CLK:\t%lu\n", mxc_get_clocks(AHB_CLK));
-	p += sprintf(p, "IPG_CLK:\t%lu\n", mxc_get_clocks(IPG_CLK));
-	p += sprintf(p, "NFC_CLK:\t%lu\n", mxc_get_clocks(NFC_CLK));
-	p += sprintf(p, "USB_CLK:\t%lu\n", mxc_get_clocks(USB_CLK));
-	p += sprintf(p, "UART1_BAUD:\t%lu\n", mxc_get_clocks(UART1_BAUD));
-	p += sprintf(p, "UART2_BAUD:\t%lu\n", mxc_get_clocks(UART2_BAUD));
-	p += sprintf(p, "UART3_BAUD:\t%lu\n", mxc_get_clocks(UART3_BAUD));
-	p += sprintf(p, "I2C_CLK:\t%lu\n", mxc_get_clocks(I2C_CLK));
-	p += sprintf(p, "IPU_CLK:\t%lu\n", mxc_get_clocks(IPU_CLK));
-	p += sprintf(p, "SDMA_CLK:\t%lu\n", mxc_get_clocks(SDMA_CLK));
-	p += sprintf(p, "SDHC1_CLK:\t%lu\n", mxc_get_clocks(SDHC1_CLK));
-	p += sprintf(p, "SDHC2_CLK:\t%lu\n", mxc_get_clocks(SDHC2_CLK));
-
-	len = (p - page) - off;
-	if (len < 0)
-		len = 0;
-
-	*eof = (len <= count) ? 1 : 0;
-	*start = page + off;
-
-	return len;
-}
-
-static int __init mxc_setup_proc_entry(void)
-{
-#ifdef CONFIG_PROC_FS
-	struct proc_dir_entry *res;
-
-	res = create_proc_read_entry("cpu/clocks", 0, NULL,
-				     mxc_clock_read_proc, NULL);
-	if (!res) {
-		printk(KERN_ERR "Failed to create proc/cpu/clocks\n");
-		return -ENOMEM;
-	}
-#endif
-	return 0;
-}
-
-late_initcall(mxc_setup_proc_entry);
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/crm_regs.h linux-2.6.19.2/arch/arm/mach-mx3/crm_regs.h
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/crm_regs.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/crm_regs.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -114,49 +114,90 @@
 #define MXC_CCM_PCTL_MFN_OFFSET                 0
 #define MXC_CCM_PCTL_MFN_MASK                   0x3FF
 
-#define MXC_CCM_CGR0_SD_MMC1                    0x3
-#define MXC_CCM_CGR0_SD_MMC2                    (0x3 << 2)
-#define MXC_CCM_CGR0_GPT                        (0x3 << 4)
-#define MXC_CCM_CGR0_EPIT1                      (0x3 << 6)
-#define MXC_CCM_CGR0_EPIT2                      (0x3 << 8)
-#define MXC_CCM_CGR0_IIM                        (0x3 << 10)
-#define MXC_CCM_CGR0_ATA                        (0x3 << 12)
-#define MXC_CCM_CGR0_SDMA                       (0x3 << 14)
-#define MXC_CCM_CGR0_CSPI3                      (0x3 << 16)
-#define MXC_CCM_CGR0_RNG                         (0x3 << 18)
-#define MXC_CCM_CGR0_UART1                      (0x3 << 20)
-#define MXC_CCM_CGR0_UART2                      (0x3 << 22)
-#define MXC_CCM_CGR0_SSI1                       (0x3 << 24)
-#define MXC_CCM_CGR0_I2C1                       (0x3 << 26)
-#define MXC_CCM_CGR0_I2C2                       (0x3 << 28)
-#define MXC_CCM_CGR0_I2C3                       (0x3 << 30)
-
-#define MXC_CCM_CGR1_HANTRO                     0x3
-#define MXC_CCM_CGR1_MEMSTICK1                  (0x3 << 2)
-#define MXC_CCM_CGR1_MEMSTICK2                  (0x3 << 4)
-#define MXC_CCM_CGR1_CSI                        (0x3 << 6)
-#define MXC_CCM_CGR1_RTC                        (0x3 << 8)
-#define MXC_CCM_CGR1_WDOG                       (0x3 << 10)
-#define MXC_CCM_CGR1_PWM                        (0x3 << 12)
-#define MXC_CCM_CGR1_SIM                        (0x3 << 14)
-#define MXC_CCM_CGR1_ECT                        (0x3 << 16)
-#define MXC_CCM_CGR1_USBOTG                     (0x3 << 18)
-#define MXC_CCM_CGR1_KPP                        (0x3 << 20)
-#define MXC_CCM_CGR1_IPU                        (0x3 << 22)
-#define MXC_CCM_CGR1_UART3                      (0x3 << 24)
-#define MXC_CCM_CGR1_UART4                      (0x3 << 26)
-#define MXC_CCM_CGR1_UART5                      (0x3 << 28)
-#define MXC_CCM_CGR1_OWIRE                      (0x3 << 30)
-
-#define MXC_CCM_CGR2_SSI2                       0x3
-#define MXC_CCM_CGR2_CSPI1                      (0x3 << 2)
-#define MXC_CCM_CGR2_CSPI2                      (0x3 << 4)
-#define MXC_CCM_CGR2_GACC                       (0x3 << 6)
-#define MXC_CCM_CGR2_EMI                        (0x3 << 8)
-#define MXC_CCM_CGR2_RTIC                       (0x3 << 10)
-#define MXC_CCM_CGR2_FIRI                       (0x3 << 12)
-#define MXC_CCM_CGR2_IPMUX1                     (0x3 << 14)
-#define MXC_CCM_CGR2_IPMUX2                     (0x3 << 16)
+#define MXC_CCM_CGR0_SD_MMC1_OFFSET             0
+#define MXC_CCM_CGR0_SD_MMC1_MASK               (0x3 << 0)
+#define MXC_CCM_CGR0_SD_MMC2_OFFSET             2
+#define MXC_CCM_CGR0_SD_MMC2_MASK               (0x3 << 2)
+#define MXC_CCM_CGR0_GPT_OFFSET                 4
+#define MXC_CCM_CGR0_GPT_MASK                   (0x3 << 4)
+#define MXC_CCM_CGR0_EPIT1_OFFSET               6
+#define MXC_CCM_CGR0_EPIT1_MASK                 (0x3 << 6)
+#define MXC_CCM_CGR0_EPIT2_OFFSET               8
+#define MXC_CCM_CGR0_EPIT2_MASK                 (0x3 << 8)
+#define MXC_CCM_CGR0_IIM_OFFSET                 10
+#define MXC_CCM_CGR0_IIM_MASK                   (0x3 << 10)
+#define MXC_CCM_CGR0_ATA_OFFSET                 12
+#define MXC_CCM_CGR0_ATA_MASK                   (0x3 << 12)
+#define MXC_CCM_CGR0_SDMA_OFFSET                14
+#define MXC_CCM_CGR0_SDMA_MASK                  (0x3 << 14)
+#define MXC_CCM_CGR0_CSPI3_OFFSET               16
+#define MXC_CCM_CGR0_CSPI3_MASK                 (0x3 << 16)
+#define MXC_CCM_CGR0_RNG_OFFSET                 18
+#define MXC_CCM_CGR0_RNG_MASK                   (0x3 << 18)
+#define MXC_CCM_CGR0_UART1_OFFSET               20
+#define MXC_CCM_CGR0_UART1_MASK                 (0x3 << 20)
+#define MXC_CCM_CGR0_UART2_OFFSET               22
+#define MXC_CCM_CGR0_UART2_MASK                 (0x3 << 22)
+#define MXC_CCM_CGR0_SSI1_OFFSET                24
+#define MXC_CCM_CGR0_SSI1_MASK                  (0x3 << 24)
+#define MXC_CCM_CGR0_I2C1_OFFSET                26
+#define MXC_CCM_CGR0_I2C1_MASK                  (0x3 << 26)
+#define MXC_CCM_CGR0_I2C2_OFFSET                28
+#define MXC_CCM_CGR0_I2C2_MASK                  (0x3 << 28)
+#define MXC_CCM_CGR0_I2C3_OFFSET                30
+#define MXC_CCM_CGR0_I2C3_MASK                  (0x3 << 30)
+
+#define MXC_CCM_CGR1_HANTRO_OFFSET              0
+#define MXC_CCM_CGR1_HANTRO_MASK                (0x3 << 0)
+#define MXC_CCM_CGR1_MEMSTICK1_OFFSET           2
+#define MXC_CCM_CGR1_MEMSTICK1_MASK             (0x3 << 2)
+#define MXC_CCM_CGR1_MEMSTICK2_OFFSET           4
+#define MXC_CCM_CGR1_MEMSTICK2_MASK             (0x3 << 4)
+#define MXC_CCM_CGR1_CSI_OFFSET                 6
+#define MXC_CCM_CGR1_CSI_MASK                   (0x3 << 6)
+#define MXC_CCM_CGR1_RTC_OFFSET                 8
+#define MXC_CCM_CGR1_RTC_MASK                   (0x3 << 8)
+#define MXC_CCM_CGR1_WDOG_OFFSET                10
+#define MXC_CCM_CGR1_WDOG_MASK                  (0x3 << 10)
+#define MXC_CCM_CGR1_PWM_OFFSET                 12
+#define MXC_CCM_CGR1_PWM_MASK                   (0x3 << 12)
+#define MXC_CCM_CGR1_SIM_OFFSET                 14
+#define MXC_CCM_CGR1_SIM_MASK                   (0x3 << 14)
+#define MXC_CCM_CGR1_ECT_OFFSET                 16
+#define MXC_CCM_CGR1_ECT_MASK                   (0x3 << 16)
+#define MXC_CCM_CGR1_USBOTG_OFFSET              18
+#define MXC_CCM_CGR1_USBOTG_MASK                (0x3 << 18)
+#define MXC_CCM_CGR1_KPP_OFFSET                 20
+#define MXC_CCM_CGR1_KPP_MASK                   (0x3 << 20)
+#define MXC_CCM_CGR1_IPU_OFFSET                 22
+#define MXC_CCM_CGR1_IPU_MASK                   (0x3 << 22)
+#define MXC_CCM_CGR1_UART3_OFFSET               24
+#define MXC_CCM_CGR1_UART3_MASK                 (0x3 << 24)
+#define MXC_CCM_CGR1_UART4_OFFSET               26
+#define MXC_CCM_CGR1_UART4_MASK                 (0x3 << 26)
+#define MXC_CCM_CGR1_UART5_OFFSET               28
+#define MXC_CCM_CGR1_UART5_MASK                 (0x3 << 28)
+#define MXC_CCM_CGR1_OWIRE_OFFSET               30
+#define MXC_CCM_CGR1_OWIRE_MASK                 (0x3 << 30)
+
+#define MXC_CCM_CGR2_SSI2_OFFSET                0
+#define MXC_CCM_CGR2_SSI2_MASK                  (0x3 << 0)
+#define MXC_CCM_CGR2_CSPI1_OFFSET               2
+#define MXC_CCM_CGR2_CSPI1_MASK                 (0x3 << 2)
+#define MXC_CCM_CGR2_CSPI2_OFFSET               4
+#define MXC_CCM_CGR2_CSPI2_MASK                 (0x3 << 4)
+#define MXC_CCM_CGR2_GACC_OFFSET                6
+#define MXC_CCM_CGR2_GACC_MASK                  (0x3 << 6)
+#define MXC_CCM_CGR2_EMI_OFFSET                 8
+#define MXC_CCM_CGR2_EMI_MASK                   (0x3 << 8)
+#define MXC_CCM_CGR2_RTIC_OFFSET                10
+#define MXC_CCM_CGR2_RTIC_MASK                  (0x3 << 10)
+#define MXC_CCM_CGR2_FIRI_OFFSET                12
+#define MXC_CCM_CGR2_FIRI_MASK                  (0x3 << 12)
+#define MXC_CCM_CGR2_IPMUX1_OFFSET              14
+#define MXC_CCM_CGR2_IPMUX1_MASK                (0x3 << 14)
+#define MXC_CCM_CGR2_IPMUX2_OFFSET              16
+#define MXC_CCM_CGR2_IPMUX2_MASK                (0x3 << 16)
 
 /*
  * LTR0 register offsets
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/devices.c linux-2.6.19.2/arch/arm/mach-mx3/devices.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/devices.c	2007-04-25 17:37:33.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/devices.c	2007-04-25 17:37:51.000000000 -0600
@@ -9,18 +9,19 @@
  * licensed "as is" without any warranty of any kind, whether express
  * or implied.
  *
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 
 #include <linux/spi/spi.h>
 
 #include <asm/hardware.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/mmc.h>
+#include <asm/arch/clock.h>
 
 #include <asm/arch/spba.h>
 #include "iomux.h"
@@ -292,6 +293,7 @@ static struct platform_device mxcir_devi
 static inline void mxc_init_ir(void)
 {
 	ir_data.uart_ir_mux = 1;
+	ir_data.uart_clk = clk_get(NULL, "uart_clk.1");;
 	(void)platform_device_register(&mxcir_device);
 }
 #else
@@ -441,16 +443,14 @@ static struct resource mxcspi1_resources
 
 /*! Platform Data for MXC CSPI1 */
 static struct mxc_spi_master mxcspi1_data = {
-	.bus_num = 1,
 	.maxchipselect = 4,
 	.spi_version = 4,
-	.clock = CSPI1_CLK,
 };
 
 /*! Device Definition for MXC CSPI1 */
 static struct platform_device mxcspi1_device = {
 	.name = "mxc_spi",
-	.id = 1,
+	.id = 0,
 	.dev = {
 		.release = mxc_nop_release,
 		.platform_data = &mxcspi1_data,
@@ -480,16 +480,14 @@ static struct resource mxcspi2_resources
 
 /*! Platform Data for MXC CSPI2 */
 static struct mxc_spi_master mxcspi2_data = {
-	.bus_num = 2,
 	.maxchipselect = 4,
 	.spi_version = 4,
-	.clock = CSPI2_CLK,
 };
 
 /*! Device Definition for MXC CSPI2 */
 static struct platform_device mxcspi2_device = {
 	.name = "mxc_spi",
-	.id = 2,
+	.id = 1,
 	.dev = {
 		.release = mxc_nop_release,
 		.platform_data = &mxcspi2_data,
@@ -518,16 +516,14 @@ static struct resource mxcspi3_resources
 
 /*! Platform Data for MXC CSPI3 */
 static struct mxc_spi_master mxcspi3_data = {
-	.bus_num = 3,
 	.maxchipselect = 4,
 	.spi_version = 4,
-	.clock = CSPI3_CLK,
 };
 
 /*! Device Definition for MXC CSPI3 */
 static struct platform_device mxcspi3_device = {
 	.name = "mxc_spi",
-	.id = 3,
+	.id = 2,
 	.dev = {
 		.release = mxc_nop_release,
 		.platform_data = &mxcspi3_data,
@@ -582,7 +578,6 @@ static struct resource mxci2c1_resources
 
 /*! Platform Data for MXC I2C */
 static struct mxc_i2c_platform_data mxci2c1_data = {
-	.clk = I2C1_CLK,
 	.i2c_clk = 100000,
 };
 #endif
@@ -606,7 +601,6 @@ static struct resource mxci2c2_resources
 
 /*! Platform Data for MXC I2C */
 static struct mxc_i2c_platform_data mxci2c2_data = {
-	.clk = I2C2_CLK,
 	.i2c_clk = 100000,
 };
 #endif
@@ -630,7 +624,6 @@ static struct resource mxci2c3_resources
 
 /*! Platform Data for MXC I2C */
 static struct mxc_i2c_platform_data mxci2c3_data = {
-	.clk = I2C3_CLK,
 	.i2c_clk = 100000,
 };
 #endif
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/dpm.c linux-2.6.19.2/arch/arm/mach-mx3/dpm.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/dpm.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/dpm.c	2007-04-25 17:37:51.000000000 -0600
@@ -17,7 +17,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
  *
  * Copyright (C) 2002, 2004 MontaVista Software <source@mvista.com>.
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * Based on code by Matthew Locke, Dmitry Chigirev, and Bishop Brock.
  */
@@ -42,6 +42,7 @@
 #include <linux/device.h>
 #include <linux/pm.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 
 #include <asm/hardirq.h>
 #include <asm/page.h>
@@ -50,7 +51,6 @@
 #include <asm/io.h>
 #include <asm/arch/hardware.h>
 #include <asm/arch/mxc_pm.h>
-#include <asm/arch/clock.h>
 
 static unsigned saved_cpu_freq;
 static unsigned long saved_loops_per_jiffy;
@@ -374,9 +374,12 @@ static void mxc_dpm_idle(void)
 
 static void mxc_dpm_startup(void)
 {
+	struct clk *clk;
+
 	if (!saved_loops_per_jiffy) {
 		saved_loops_per_jiffy = loops_per_jiffy;
-		saved_cpu_freq = mxc_get_clocks(CPU_CLK) / 1000;
+		clk = clk_get(NULL, "cpu_clk");
+		saved_cpu_freq = clk_get_rate(clk) / 1000;
 	}
 	orig_idle = pm_idle;
 	pm_idle = dpm_idle;
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/dvfs.c linux-2.6.19.2/arch/arm/mach-mx3/dvfs.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/dvfs.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/dvfs.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -38,13 +38,13 @@
 #include <linux/init.h>
 #include <linux/fs.h>
 #include <linux/interrupt.h>
+#include <linux/clk.h>
 #include <asm/uaccess.h>
 #include <linux/workqueue.h>
 #include <linux/proc_fs.h>
 #include <asm/semaphore.h>
 #include <linux/jiffies.h>
 #include <linux/device.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/sdma.h>
 #include <linux/dma-mapping.h>
@@ -384,16 +384,16 @@ unsigned long dvfs_get_clock(unsigned lo
 	unsigned long pll, ret_val = 0;
 	signed long mcu_pdf;
 	signed long pdf, mfd, mfi, mfn, ref_clk;
+	struct clk *pll_clk;
+	struct clk *parent_clk;
 
-	volatile unsigned long ccmr;
-	unsigned int prcs;
-
-	ccmr = mxc_ccm_get_reg(MXC_CCM_CCMR);
-	prcs = (ccmr & MXC_CCM_CCMR_PRCS_MASK) >> MXC_CCM_CCMR_PRCS_OFFSET;
-	if (prcs == 0x1) {
-		ref_clk = mxc_get_clocks(CKIL_CLK) * 1024;
-	} else {
-		ref_clk = mxc_get_clocks(CKIH_CLK);
+	pll_clk = clk_get(NULL, "mcu_pll");
+	parent_clk = clk_get(NULL, "ckih");
+	if (parent_clk == clk_get_parent(pll_clk)) {
+		ref_clk = clk_get_rate(parent_clk);
+	} else {		/* parent is ckil/fpm */
+		parent_clk = clk_get(NULL, "ckil");
+		ref_clk = clk_get_rate(parent_clk) * 1024;
 	}
 
 	pdf = (signed long)
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/mx31ads.c linux-2.6.19.2/arch/arm/mach-mx3/mx31ads.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/mx31ads.c	2007-04-25 17:37:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/mx31ads.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,7 +1,7 @@
 /*
  *  Copyright (C) 2000 Deep Blue Solutions Ltd
  *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
- *  Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *  Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -28,6 +28,7 @@
 #endif
 #include <linux/input.h>
 #include <linux/nodemask.h>
+#include <linux/clk.h>
 #include <linux/spi/spi.h>
 #if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
 #include <linux/mtd/mtd.h>
@@ -46,7 +47,6 @@
 #include <asm/mach/keypad.h>
 #include <asm/arch/memory.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/clock.h>
 
 #include "crm_regs.h"
 #include "iomux.h"
@@ -64,6 +64,7 @@ extern void mxc_cpu_init(void) __init;
 extern void mx31ads_gpio_init(void) __init;
 extern struct sys_timer mxc_timer;
 extern void mxc_cpu_common_init(void);
+extern int mxc_clocks_init(void);
 
 static void mxc_nop_release(struct device *dev)
 {
@@ -510,15 +511,59 @@ static void __init fixup_mxc_board(struc
 #endif
 }
 
+#if defined(CONFIG_MXC_PMIC_MC13783) && defined(CONFIG_SND_MXC_PMIC)
+extern void gpio_activate_audio_ports(void);
+
+static void __init mxc_init_pmic_audio(void)
+{
+	struct clk *pll_clk;
+	struct clk *ssi_clk;
+	struct clk *ckih_clk;
+	struct clk *cko_clk;
+
+	/* Enable 26 mhz clock on CKO1 for PMIC audio */
+	ckih_clk = clk_get(NULL, "ckih");
+	cko_clk = clk_get(NULL, "cko1_clk");
+	if (IS_ERR(ckih_clk) || IS_ERR(cko_clk)) {
+		printk(KERN_ERR "Unable to set CKO1 output to CKIH\n");
+	} else {
+		clk_set_parent(cko_clk, ckih_clk);
+		clk_set_rate(cko_clk, clk_get_rate(ckih_clk));
+		clk_enable(cko_clk);
+	}
+	clk_put(ckih_clk);
+	clk_put(cko_clk);
+
+	/* Assign USBPLL to be used by SSI1/2 */
+	pll_clk = clk_get(NULL, "usb_pll");
+	ssi_clk = clk_get(NULL, "ssi_clk.0");
+	clk_set_parent(ssi_clk, pll_clk);
+	clk_enable(ssi_clk);
+	clk_put(ssi_clk);
+
+	ssi_clk = clk_get(NULL, "ssi_clk.1");
+	clk_set_parent(ssi_clk, pll_clk);
+	clk_enable(ssi_clk);
+	clk_put(ssi_clk);
+	clk_put(pll_clk);
+
+	gpio_activate_audio_ports();
+}
+#else
+static void __inline mxc_init_pmic_audio(void)
+{
+}
+#endif
+
 /*!
  * Board specific initialization.
  */
 static void __init mxc_board_init(void)
 {
 	mxc_cpu_common_init();
+	mxc_clocks_init();
 
-	/* Enable 26 mhz clock on CKO1 for PMIC audio */
-	mxc_ccm_modify_reg(MXC_CCM_COSR, 0x00000fff, 0x00000208);
+	mxc_init_pmic_audio();
 
 	mxc_gpio_init();
 	mx31ads_gpio_init();
@@ -528,10 +573,6 @@ static void __init mxc_board_init(void)
 	mxc_init_nor_mtd();
 	mxc_init_nand_mtd();
 
-	/* Assign USBPLL to be used by SSI1/2 */
-	mxc_set_clocks_pll(SSI1_BAUD, USBPLL);
-	mxc_set_clocks_pll(SSI2_BAUD, USBPLL);
-
 	spi_register_board_info(mxc_spi_board_info,
 				ARRAY_SIZE(mxc_spi_board_info));
 
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/mx31ads_gpio.c linux-2.6.19.2/arch/arm/mach-mx3/mx31ads_gpio.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/mx31ads_gpio.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/mx31ads_gpio.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -15,9 +15,9 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 #include <asm/io.h>
 #include <asm/hardware.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/gpio.h>
 #include "iomux.h"
 
@@ -990,6 +990,8 @@ EXPORT_SYMBOL(gpio_sensor_inactive);
  */
 void gpio_ata_active(void)
 {
+	struct clk *ata_clk;
+
 	/*
 	 * Configure the GPR for ATA group B signals
 	 */
@@ -1060,9 +1062,9 @@ void gpio_ata_active(void)
 	mxc_iomux_set_pad(MX31_PIN_CAPTURE, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 14
 	mxc_iomux_set_pad(MX31_PIN_COMPARE, PAD_CTL_SRE_FAST | PAD_CTL_PKE_NONE);	// data 12
 
-	/* 
+	/*
 	 * Turn off default pullups on high asserted control signals.
-	 * These are pulled down externally, so it will just waste 
+	 * These are pulled down externally, so it will just waste
 	 * power and create voltage divider action to pull them up
 	 * on chip.
 	 */
@@ -1070,7 +1072,8 @@ void gpio_ata_active(void)
 	mxc_iomux_set_pad(MX31_PIN_USBH2_CLK, PAD_CTL_PKE_NONE);	// ATA_INTRQ
 
 	printk(KERN_DEBUG "gpio_ata_active: Enable clocks\n");
-	mxc_clks_enable(ATA_CLK);
+	ata_clk = clk_get(NULL, "ata_clk.0");
+	clk_enable(ata_clk);
 }
 
 EXPORT_SYMBOL(gpio_ata_active);
@@ -1081,8 +1084,11 @@ EXPORT_SYMBOL(gpio_ata_active);
  */
 void gpio_ata_inactive(void)
 {
+	struct clk *ata_clk = clk_get(NULL, "ata_clk.0");
+
 	printk(KERN_DEBUG "gpio_ata_inactive: Disable clocks\n");
-	mxc_clks_disable(ATA_CLK);
+	clk_disable(ata_clk);
+	clk_put(ata_clk);
 
 	/*
 	 * Turn off ATA group B signals
@@ -1705,15 +1711,7 @@ EXPORT_SYMBOL(gpio_pcmcia_inactive);
  */
 void gpio_firi_init(void)
 {
-	unsigned long clk;
 	gpio_uart_active(1, 0);
-
-	clk = mxc_get_clocks_parent(FIRI_BAUD);
-	/* 
-	 * FIRI module needs a clock which is a multiple of 8 Mhz..
-	 * We are giving it 48 Mhz in this case.
-	 */
-	mxc_set_clocks_div(FIRI_BAUD, (clk / 48000000));
 }
 
 EXPORT_SYMBOL(gpio_firi_init);
@@ -1770,27 +1768,3 @@ void gpio_firi_active(void *fir_cong_reg
 }
 
 EXPORT_SYMBOL(gpio_firi_active);
-
-/*!
- * Find clock for FIRI
- */
-unsigned int firi_get_clocks(void)
-{
-	return (mxc_get_clocks(UART2_BAUD));
-}
-
-EXPORT_SYMBOL(firi_get_clocks);
-
-void firi_disable_uart_clock(void)
-{
-	mxc_clks_disable(UART2_BAUD);
-}
-
-EXPORT_SYMBOL(firi_disable_uart_clock);
-
-void firi_enable_uart_clock(void)
-{
-	mxc_clks_enable(UART2_BAUD);
-}
-
-EXPORT_SYMBOL(firi_enable_uart_clock);
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/mxc_pm.c linux-2.6.19.2/arch/arm/mach-mx3/mxc_pm.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/mxc_pm.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/mxc_pm.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -26,9 +26,9 @@
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
+#include <linux/clk.h>
 #include <asm/hardware.h>
 #include <asm/arch/system.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/mxc_pm.h>
 #include <asm/irq.h>
 #include <asm/arch/dvfs_dptc_struct.h>
@@ -44,27 +44,15 @@
 #define NFC_MAX_FREQ        20000000	/* Maximum frequency NFC clock */
 #define PRE_DIV_MIN_FREQ    10000000	/* Minimum Frequency after Predivider */
 
-static void print_frequencies(void)
-{
-	pr_debug("MCUPLL       %9lu\n", mxc_pll_clock(MCUPLL));
-	pr_debug("SERIALPLL    %9lu\n", mxc_pll_clock(SERIALPLL));
-	pr_debug("USBPLL       %9lu\n", mxc_pll_clock(USBPLL));
-	pr_debug("\n");
-	pr_debug("CPU_CLK      %9lu\n", mxc_get_clocks(CPU_CLK));
-	pr_debug("AHB_CLK      %9lu\n", mxc_get_clocks(AHB_CLK));
-	pr_debug("IPG_CLK      %9lu\n", mxc_get_clocks(IPG_CLK));
-	pr_debug("NFC_CLK      %9lu\n", mxc_get_clocks(NFC_CLK));
-	pr_debug("IPU_CLK      %9lu\n", mxc_get_clocks(IPU_CLK));
-	pr_debug("USB_CLK      %9lu\n", mxc_get_clocks(USB_CLK));
-	pr_debug("CSI_BAUD     %9lu\n", mxc_get_clocks(CSI_BAUD));
-	pr_debug("UART1_BAUD   %9lu\n", mxc_get_clocks(UART1_BAUD));
-	pr_debug("SSI1_BAUD    %9lu\n", mxc_get_clocks(SSI1_BAUD));
-	pr_debug("SSI2_BAUD    %9lu\n", mxc_get_clocks(SSI2_BAUD));
-	pr_debug("FIRI_BAUD    %9lu\n", mxc_get_clocks(FIRI_BAUD));
-	pr_debug("MSTICK1_BAUD %9lu\n", mxc_get_clocks(MSTICK1_BAUD));
-	pr_debug("MSTICK2_BAUD %9lu\n", mxc_get_clocks(MSTICK2_BAUD));
-	pr_debug("\n");
-}
+extern unsigned long mxc_ccm_get_reg(unsigned int reg_offset);
+extern void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
+			       unsigned int data);
+
+static struct clk *mcu_pll_clk;
+static struct clk *cpu_clk;
+static struct clk *ahb_clk;
+static struct clk *ipg_clk;
+static struct clk *csi_baud;
 
 /*!
  * Compare two frequences using allowable tolerance
@@ -182,17 +170,25 @@ int mxc_pm_intscale(long arm_freq, long 
 
 	printk(KERN_INFO "arm_freq=%ld, max_freq=%ld, ip_freq=%ld\n",
 	       arm_freq, max_freq, ip_freq);
-	print_frequencies();	/* debug */
+	//print_frequencies();  /* debug */
 
-	mcu_main_clk = mxc_pll_clock(MCUPLL);
+	mcu_main_clk = clk_get_rate(mcu_pll_clk);
 	ret_value = cal_pdr0_value(mcu_main_clk, arm_freq, max_freq, ip_freq,
 				   &mask, &value);
+	if ((arm_freq != clk_round_rate(cpu_clk, arm_freq)) ||
+	    (max_freq != clk_round_rate(ahb_clk, max_freq)) ||
+	    (ip_freq != clk_round_rate(ipg_clk, ip_freq))) {
+		return -EINVAL;
+	}
 
-	if (ret_value == 0) {
-		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
+	if ((max_freq != clk_get_rate(ahb_clk)) ||
+	    (ip_freq != clk_get_rate(ipg_clk))) {
+		return -EINVAL;
 	}
 
-	print_frequencies();
+	if (arm_freq != clk_get_rate(cpu_clk)) {
+		ret_value = clk_set_rate(cpu_clk, arm_freq);
+	}
 	return ret_value;
 }
 
@@ -219,52 +215,18 @@ int mxc_pm_intscale(long arm_freq, long 
  */
 int mxc_pm_pllscale(long arm_freq, long max_freq, long ip_freq)
 {
-	unsigned long ccmr;	/* clock control register */
-	unsigned long prcs;	/* PLL reference clock select bits. */
-	signed long ref_freq;	/* reference frequency */
-	signed long pll_freq;	/* target pll frequency */
-	signed long pd;		/* Pre-divider */
-	signed long mfi;	/* Multiplication Factor (Integer part) */
-	signed long mfn;	/* Multiplication Factor (Integer part) */
-	signed long mfd;	/* Multiplication Factor (Denominator Part) */
-	signed long old_pll;	/* old pll frequency */
-	signed long tmp;
+	signed long pll_freq = 0;	/* target pll frequency */
+	unsigned long old_pll;
 	unsigned long mask;
 	unsigned long value;
 	int ret_value;
 
 	printk(KERN_INFO "arm_freq=%ld, max_freq=%ld, ip_freq=%ld\n",
 	       arm_freq, max_freq, ip_freq);
-	print_frequencies();
-
-	ccmr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + MXC_CCM_CCMR);
-	prcs = (ccmr & MXC_CCM_CCMR_PRCS_MASK) >> MXC_CCM_CCMR_PRCS_OFFSET;
-	if (prcs == 0x1) {
-		ref_freq = mxc_get_clocks(CKIL_CLK) * 1024;
-	} else {
-		ref_freq = mxc_get_clocks(CKIH_CLK);
-	}
-	/*
-	 * MCU PLL output frequency equation
-	 *
-	 *                           mfn
-	 *                    mfi + -----
-	 *                           mfd
-	 *    ref_freq * 2 * ------------- =  pll_freq
-	 *                        pd
-	 *
-	 *   mfi must be >= 5 and <= 15
-	 *   mfd range 1 to 1024
-	 *   mfn range -512 to 511
-	 *   The absolute value of mfn/mfd must be smaller than 1.
-	 *   pd range 1 to 16
-	 *
-	 */
-
-	pd = 1;
-	pll_freq = arm_freq;
+	//print_frequencies();
 
 	do {
+		pll_freq += arm_freq;
 		if ((pll_freq > MCU_PLL_MAX_FREQ) || (pll_freq / 8 > arm_freq)) {
 			return FREQ_OUT_OF_RANGE;
 		}
@@ -275,54 +237,20 @@ int mxc_pm_pllscale(long arm_freq, long 
 			    cal_pdr0_value(pll_freq, arm_freq, max_freq,
 					   ip_freq, &mask, &value);
 		}
-		if (ret_value != 0) {
-			pll_freq += arm_freq;
-		}
 	} while (ret_value != 0);
 
-	while (((ref_freq / pd) * 10) > pll_freq) {
-		pd++;
-	}
-
-	if ((ref_freq / pd) < PRE_DIV_MIN_FREQ) {
-		return FREQ_OUT_OF_RANGE;
-	}
-
-	/* the ref_freq/2 in the following is to round up */
-	mfi = (((pll_freq / 2) * pd) + (ref_freq / 2)) / ref_freq;
-	if (mfi < 5 || mfi > 15) {
-		return FREQ_OUT_OF_RANGE;
-	}
-
-	/* pick a mfd value that will work
-	 * then solve for mfn */
-	mfd = ref_freq / 50000;
-
-	/*
-	 *          pll_freq * pd * mfd
-	 *   mfn = --------------------  -  (mfi * mfd)
-	 *           2 * ref_freq
-	 */
-	/* the tmp/2 is for rounding */
-	tmp = ref_freq / 10000;
-	mfn =
-	    ((((((pll_freq / 2) + (tmp / 2)) / tmp) * pd) * mfd) / 10000) -
-	    (mfi * mfd);
-
-	mfn = mfn & 0x3ff;
-
-	old_pll = mxc_pll_clock(MCUPLL);
+	old_pll = clk_get_rate(mcu_pll_clk);
 	if (pll_freq > old_pll) {
 		/* if pll freq is increasing then change dividers first */
 		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
-		mxc_pll_set(MCUPLL, mfi, pd - 1, mfd - 1, mfn);
+		ret_value = clk_set_rate(mcu_pll_clk, pll_freq);
 	} else {
 		/* if pll freq is decreasing then change pll first */
-		mxc_pll_set(MCUPLL, mfi, pd - 1, mfd - 1, mfn);
+		ret_value = clk_set_rate(mcu_pll_clk, pll_freq);
 		mxc_ccm_modify_reg(MXC_CCM_PDR0, mask, value);
 	}
-	print_frequencies();
-	return 0;
+	//print_frequencies();
+	return ret_value;
 }
 
 /*!
@@ -351,7 +279,7 @@ void mxc_pm_lowpower(int mode)
 		__raw_writel(INT_GPT, AVIC_INTDISNUM);
 
 		/* work-around for SR mode after camera related test */
-		mxc_clks_enable(CSI_BAUD);
+		clk_enable(csi_baud);
 		__raw_writel(0x51, IPU_CONF);
 		break;
 
@@ -384,7 +312,7 @@ void mxc_pm_lowpower(int mode)
 
 	/* work-around for SR mode after camera related test */
 	__raw_writel(ipu_conf, IPU_CONF);
-	mxc_clks_disable(CSI_BAUD);
+	clk_disable(csi_baud);
 
 	__raw_writel(INT_GPT, AVIC_INTENNUM);
 
@@ -432,6 +360,12 @@ int mxc_pm_dvfs(unsigned long armfreq, l
 static int __init mxc_pm_init_module(void)
 {
 	printk(KERN_INFO "Low-Level PM Driver module loaded\n");
+
+	mcu_pll_clk = clk_get(NULL, "mcu_pll");
+	cpu_clk = clk_get(NULL, "cpu_clk");
+	ahb_clk = clk_get(NULL, "ahb_clk");
+	ipg_clk = clk_get(NULL, "ipg_clk");
+	csi_baud = clk_get(NULL, "csi_baud");
 	return 0;
 }
 
@@ -440,6 +374,10 @@ static int __init mxc_pm_init_module(voi
  */
 static void __exit mxc_pm_cleanup_module(void)
 {
+	clk_put(mcu_pll_clk);
+	clk_put(cpu_clk);
+	clk_put(ahb_clk);
+	clk_put(ipg_clk);
 	printk(KERN_INFO "Low-Level PM Driver module Unloaded\n");
 }
 
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/serial.c linux-2.6.19.2/arch/arm/mach-mx3/serial.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/serial.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/serial.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -57,7 +57,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART1_UFCR_RXTL,
 	       .tx_threshold = UART1_UFCR_TXTL,
 	       .shared = UART1_SHARED_PERI,
-	       .clock_id = UART1_BAUD,
 	       .dma_tx_id = MXC_DMA_UART1_TX,
 	       .dma_rx_id = MXC_DMA_UART1_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
@@ -84,7 +83,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART2_UFCR_RXTL,
 	       .tx_threshold = UART2_UFCR_TXTL,
 	       .shared = UART2_SHARED_PERI,
-	       .clock_id = UART2_BAUD,
 	       .dma_tx_id = MXC_DMA_UART2_TX,
 	       .dma_rx_id = MXC_DMA_UART2_RX,
 	       .rxd_mux = MXC_UART_IR_RXDMUX,
@@ -111,7 +109,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART3_UFCR_RXTL,
 	       .tx_threshold = UART3_UFCR_TXTL,
 	       .shared = UART3_SHARED_PERI,
-	       .clock_id = UART3_BAUD,
 	       .dma_tx_id = MXC_DMA_UART3_TX,
 	       .dma_rx_id = MXC_DMA_UART3_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
@@ -139,7 +136,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART4_UFCR_RXTL,
 	       .tx_threshold = UART4_UFCR_TXTL,
 	       .shared = UART4_SHARED_PERI,
-	       .clock_id = UART4_BAUD,
 	       .dma_tx_id = MXC_DMA_UART4_TX,
 	       .dma_rx_id = MXC_DMA_UART4_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
@@ -167,7 +163,6 @@ static uart_mxc_port mxc_ports[] = {
 	       .rx_threshold = UART5_UFCR_RXTL,
 	       .tx_threshold = UART5_UFCR_TXTL,
 	       .shared = UART5_SHARED_PERI,
-	       .clock_id = UART5_BAUD,
 	       .dma_tx_id = MXC_DMA_UART5_TX,
 	       .dma_rx_id = MXC_DMA_UART5_RX,
 	       .rxd_mux = MXC_UART_RXDMUX,
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/time.c linux-2.6.19.2/arch/arm/mach-mx3/time.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/time.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/time.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,10 +30,11 @@
 #include <linux/interrupt.h>
 #include <asm/mach/time.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
 #include "time_priv.h"
 #include <linux/irq.h>
 
+extern unsigned long clk_early_get_timer_rate(void);
+
 /*!
  * This function converts system timer ticks to microseconds
  *
@@ -206,7 +207,9 @@ void __init mxc_init_time(void)
 
 	__raw_writel(reg, MXC_GPT_GPTCR);
 
-	v = mxc_get_clocks(GPT_CLK);
+	/* Normal clk api are not yet initialized, so use early verion */
+	v = clk_early_get_timer_rate();
+
 	__raw_writel((v / CLOCK_TICK_RATE) - 1, MXC_GPT_GPTPR);
 
 	if ((v % CLOCK_TICK_RATE) != 0) {
diff -uNpr linux-2.6.19.2.orig/arch/arm/mach-mx3/usb.c linux-2.6.19.2/arch/arm/mach-mx3/usb.c
--- linux-2.6.19.2.orig/arch/arm/mach-mx3/usb.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/arch/arm/mach-mx3/usb.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  *	otg_{get,set}_transceiver() are from arm/plat-omap/usb.c.
  *	which is Copyright (C) 2004 Texas Instruments, Inc.
@@ -38,6 +38,7 @@
 #include <linux/platform_device.h>
 #include <linux/usb/otg.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -48,7 +49,6 @@
 #include <asm/arch/board.h>
 #include <asm/arch/arc_otg.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/isp1504.h>
 #include <asm/arch/isp1301.h>
 
@@ -82,16 +82,19 @@ extern void gpio_usbotg_fs_inactive(void
 /* The dmamask must be set for EHCI to work */
 static u64 ehci_dmamask = ~(u32) 0;
 
+static struct clk *usb_clk;
 /*
  * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
  */
 static int check_usbclk(void)
 {
-	unsigned long clk;
+	unsigned long freq;
 
-	clk = mxc_get_clocks(USB_CLK);
-	if ((clk < 59999000) || (clk > 60001000)) {
-		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", clk);
+	usb_clk = clk_get(NULL, "usb_clk");
+	freq = clk_get_rate(usb_clk);
+	clk_put(usb_clk);
+	if ((freq < 59999000) || (freq > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", freq);
 		return -1;
 	}
 	return 0;
@@ -351,9 +354,9 @@ static int otg_fs_host_init(void)
 	mdelay(1);
 
 	/* enable OTG VBUS */
-	mxc_clks_disable(USB_CLK);
+	clk_disable(usb_clk);
 	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_CLEAR);
-	mxc_clks_enable(USB_CLK);
+	clk_enable(usb_clk);
 
 	otg_fs_set_xcvr();	/* set transceiver type */
 
diff -uNpr linux-2.6.19.2.orig/arch/arm/plat-mxc/clock.c linux-2.6.19.2/arch/arm/plat-mxc/clock.c
--- linux-2.6.19.2.orig/arch/arm/plat-mxc/clock.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2/arch/arm/plat-mxc/clock.c	2007-04-25 17:37:51.000000000 -0600
@@ -0,0 +1,516 @@
+/*
+ * Copyright 2007 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*
+ *  Based on arch/arm/plat-omap/clock.c
+ *
+ *  Copyright (C) 2004 - 2005 Nokia corporation
+ *  Written by Tuukka Tikkanen <tuukka.tikkanen@elektrobit.com>
+ *  Modified for omap shared clock framework by Tony Lindgren <tony@atomide.com>
+ */
+/*!
+ * @file plat-mxc/clock.c
+ *
+ * @brief clk API implementation for MXC clocks.
+ *
+ * This file contains API defined in include/linux/clk.h for setting up and
+ * retrieving clocks.
+ *
+ * @ingroup CLOCKS
+ */
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/string.h>
+#include <linux/clk.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+
+#include <asm/io.h>
+#include <asm/semaphore.h>
+
+#include <asm/arch/clock.h>
+
+static LIST_HEAD(clocks);
+static DEFINE_MUTEX(clocks_mutex);
+static DEFINE_SPINLOCK(clockfw_lock);
+
+/*-------------------------------------------------------------------------
+ * Standard clock functions defined in include/linux/clk.h
+ *-------------------------------------------------------------------------*/
+
+/*!
+ * @brief Function to retrieve a clock by name.
+ *
+ * Note that we first try to use device id on the bus
+ * and clock name. If this fails, we try to use "<name>.<id>". If this fails,
+ * we try to use clock name only.
+ *
+ * The reference count to the clock's module owner ref count is incremented.
+ *
+ * @param dev 	Device structure to get bus device id.
+ * @param id	Clock name string
+ *
+ * @return	Returns handle to clock on success or -ENOENT on failure.
+ */
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	struct clk *p, *clk = ERR_PTR(-ENOENT);
+	int idno;
+	char *str;
+
+	if (id == NULL)
+		return clk;
+
+	if (dev == NULL || dev->bus != &platform_bus_type)
+		idno = -1;
+	else
+		idno = to_platform_device(dev)->id;
+
+	mutex_lock(&clocks_mutex);
+
+	list_for_each_entry(p, &clocks, node) {
+		if (p->id == idno &&
+		    strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			goto found;
+		}
+	}
+
+	str = strrchr(id, '.');
+	if (str) {
+		str[0] = '\0';
+		str++;
+		idno = simple_strtol(str, NULL, 10);
+		list_for_each_entry(p, &clocks, node) {
+			if (p->id == idno &&
+			    strcmp(id, p->name) == 0 &&
+			    try_module_get(p->owner)) {
+				clk = p;
+				goto found;
+			}
+		}
+	}
+
+	list_for_each_entry(p, &clocks, node) {
+		if (strcmp(id, p->name) == 0 && try_module_get(p->owner)) {
+			clk = p;
+			goto found;
+		}
+	}
+
+	printk(KERN_WARNING "clk: Unable to get requested clock: %s\n", id);
+
+      found:
+	mutex_unlock(&clocks_mutex);
+
+	return clk;
+}
+
+EXPORT_SYMBOL(clk_get);
+
+static void __clk_disable(struct clk *clk)
+{
+	if (clk->usecount > 0 && !(--clk->usecount)) {
+		if (clk->disable != NULL) {
+			clk->disable(clk);
+		}
+		if (likely((u32) clk->parent))
+			__clk_disable(clk->parent);
+		if (unlikely((u32) clk->secondary))
+			__clk_disable(clk->secondary);
+	}
+}
+
+static int __clk_enable(struct clk *clk)
+{
+	int ret = 0;
+
+	if (clk->usecount++ == 0) {
+		if (likely((u32) clk->parent)) {
+			ret = __clk_enable(clk->parent);
+
+			if (unlikely(ret != 0)) {
+				goto err1;
+			}
+		}
+
+		if (unlikely((u32) clk->secondary)) {
+			ret = __clk_enable(clk->secondary);
+
+			if (unlikely(ret != 0)) {
+				goto err2;
+			}
+		}
+
+		if (clk->enable) {
+			ret = clk->enable(clk);
+		}
+
+		if (unlikely(ret != 0)) {
+			goto err3;
+		}
+	}
+	return 0;
+
+      err3:
+	if (clk->secondary)
+		__clk_disable(clk->secondary);
+      err2:
+	if (clk->parent)
+		__clk_disable(clk->parent);
+      err1:
+	clk->usecount--;
+	return ret;
+}
+
+/*!
+ * @brief Function to enable a clock.
+ *
+ * This function increments the reference count on the clock and enables the
+ * clock if not already enabled. The parent clock tree is recursively enabled.
+ *
+ * @param clk 	Handle to clock to enable.
+ *
+ * @return	Returns 0 on success or error code on failure.
+ */
+int clk_enable(struct clk *clk)
+{
+	unsigned long flags;
+	int ret = 0;
+
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+
+	ret = __clk_enable(clk);
+
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(clk_enable);
+
+/*!
+ * @brief Function to disable a clock.
+ *
+ * This function decrements the reference count on the clock and disables the
+ * clock when reference count is 0. The parent clock tree is recursively
+ * disabled.
+ *
+ * @param clk 	Handle to clock to disable.
+ *
+ */
+void clk_disable(struct clk *clk)
+{
+	unsigned long flags;
+
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+
+	__clk_disable(clk);
+
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+}
+
+EXPORT_SYMBOL(clk_disable);
+
+/*!
+ * @brief Function to get the usage count for the requested clock.
+ *
+ * This function returns the reference count for the clock.
+ *
+ * @param clk 	Handle to clock to disable.
+ *
+ * @return Returns the usage count for the requested clock.
+ */
+int clk_get_usecount(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	return clk->usecount;
+}
+
+EXPORT_SYMBOL(clk_get_usecount);
+
+/*!
+ * @brief Function to retrieve the clock rate for a clock.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ *
+ * @return	Returns the clock's rate in Hz.
+ *
+ */
+unsigned long clk_get_rate(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return 0;
+
+	return clk->rate;
+}
+
+EXPORT_SYMBOL(clk_get_rate);
+
+/*!
+ * @brief Function to decrement the clock's module reference count.
+ *
+ * @param clk 	Handle to clock to put.
+ *
+ */
+void clk_put(struct clk *clk)
+{
+	if (clk && !IS_ERR(clk))
+		module_put(clk->owner);
+}
+
+EXPORT_SYMBOL(clk_put);
+
+/*!
+ * @brief Function to round the requested clock rate to the nearest supported
+ * rate that is less than or equal to the requested rate. This is dependent on
+ * the clock's current parent.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ * @param rate	Desired clock rate in Hz.
+ *
+ * @return	Returns the nearest supported rate in Hz.
+ *
+ */
+long clk_round_rate(struct clk *clk, unsigned long rate)
+{
+	if (clk == NULL || IS_ERR(clk) || !clk->round_rate)
+		return 0;
+
+	return clk->round_rate(clk, rate);
+}
+
+EXPORT_SYMBOL(clk_round_rate);
+
+/* Propagate rate to children */
+void propagate_rate(struct clk *tclk)
+{
+	struct clk *clkp;
+
+	if (tclk == NULL || IS_ERR(tclk))
+		return;
+
+	pr_debug("mxc clock: finding children of %s-%d\n", tclk->name,
+		 tclk->id);
+	list_for_each_entry(clkp, &clocks, node) {
+		if (likely(clkp->parent != tclk))
+			continue;
+		pr_debug("mxc clock: %s-%d: recalculating rate: old = %lu, ",
+			 clkp->name, clkp->id, clkp->rate);
+		if (likely((u32) clkp->recalc))
+			clkp->recalc(clkp);
+		else
+			clkp->rate = tclk->rate;
+		pr_debug("new = %lu\n", clkp->rate);
+		propagate_rate(clkp);
+	}
+}
+
+/*!
+ * @brief Function to set the clock to the requested clock rate. The rate must
+ * match a supported rate exactly based on what clk_round_rate returns.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ * @param rate	Desired clock rate in Hz.
+ *
+ * @return	Returns 0 on success, negative error code on failure.
+ *
+ */
+int clk_set_rate(struct clk *clk, unsigned long rate)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk) || clk->set_rate == NULL || rate == 0)
+		return ret;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+
+	ret = clk->set_rate(clk, rate);
+	if (likely(ret == 0))
+		propagate_rate(clk);
+
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(clk_set_rate);
+
+/*!
+ * @brief Function to set the clock's parent to another clock source.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ * @param parent Desired parent clock input for the clock.
+ *
+ * @return	Returns 0 on success, negative error code on failure.
+ *
+ */
+int clk_set_parent(struct clk *clk, struct clk *parent)
+{
+	unsigned long flags;
+	int ret = -EINVAL;
+
+	if (clk == NULL || IS_ERR(clk) || parent == NULL ||
+	    IS_ERR(parent) || clk->set_parent == NULL)
+		return ret;
+
+	spin_lock_irqsave(&clockfw_lock, flags);
+	ret = clk->set_parent(clk, parent);
+	if (ret == 0) {
+		clk->parent = parent;
+		if (clk->recalc) {
+			clk->recalc(clk);
+		} else {
+			clk->rate = parent->rate;
+		}
+		propagate_rate(clk);
+	}
+	spin_unlock_irqrestore(&clockfw_lock, flags);
+
+	return ret;
+}
+
+EXPORT_SYMBOL(clk_set_parent);
+
+/*!
+ * @brief Function to retrieve the clock's parent clock source.
+ *
+ * @param clk 	Handle to clock to retrieve.
+ *
+ * @return	Returns parent clk on success, NULL on failure.
+ *
+ */
+struct clk *clk_get_parent(struct clk *clk)
+{
+	struct clk *ret = NULL;
+
+	if (clk == NULL || IS_ERR(clk))
+		return ret;
+
+	return clk->parent;
+}
+
+EXPORT_SYMBOL(clk_get_parent);
+
+/*!
+ * @brief Function to add a new clock to the clock tree.
+ *
+ * @param clk 	Handle to clock to add.
+ *
+ * @return	Returns 0 on success, negative error code on failure.
+ *
+ */
+int clk_register(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return -EINVAL;
+
+	mutex_lock(&clocks_mutex);
+	list_add(&clk->node, &clocks);
+	mutex_unlock(&clocks_mutex);
+
+	return 0;
+}
+
+EXPORT_SYMBOL(clk_register);
+
+/*!
+ * @brief Function to remove a clock from the clock tree.
+ *
+ * @param clk 	Handle to clock to add.
+ *
+ */
+void clk_unregister(struct clk *clk)
+{
+	if (clk == NULL || IS_ERR(clk))
+		return;
+
+	mutex_lock(&clocks_mutex);
+	list_del(&clk->node);
+	mutex_unlock(&clocks_mutex);
+}
+
+EXPORT_SYMBOL(clk_unregister);
+
+void mxc_dump_clocks(void)
+{
+	struct clk *clkp;
+	list_for_each_entry(clkp, &clocks, node) {
+		printk("name:\t%s-%d\n", clkp->name, clkp->id);
+		printk("count:\t%d\n", clkp->usecount);
+		printk("rate:\t%lu\n", clkp->rate);
+		if (clkp->parent)
+			printk("parent:\t%s-%d\n\n", clkp->parent->name,
+			       clkp->parent->id);
+		else
+			printk("parent:\tnone\n\n");
+	}
+}
+
+#ifdef CONFIG_PROC_FS
+static int mxc_clock_read_proc(char *page, char **start, off_t off,
+			       int count, int *eof, void *data)
+{
+	struct clk *clkp;
+	char *p = page;
+	int len;
+
+	list_for_each_entry(clkp, &clocks, node) {
+		p += sprintf(p, "%s-%d:\t\t%lu, %d",
+			     clkp->name, clkp->id, clkp->rate, clkp->usecount);
+		if (clkp->parent)
+			p += sprintf(p, ", %s-%d\n", clkp->parent->name,
+				     clkp->parent->id);
+		else
+			p += sprintf(p, "\n");
+	}
+
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int __init mxc_setup_proc_entry(void)
+{
+	struct proc_dir_entry *res;
+
+	res = create_proc_read_entry("cpu/clocks", 0, NULL,
+				     mxc_clock_read_proc, NULL);
+	if (!res) {
+		printk(KERN_ERR "Failed to create proc/cpu/clocks\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+late_initcall(mxc_setup_proc_entry);
+#endif
diff -uNpr linux-2.6.19.2.orig/arch/arm/plat-mxc/dma_mx2.c linux-2.6.19.2/arch/arm/plat-mxc/dma_mx2.c
--- linux-2.6.19.2.orig/arch/arm/plat-mxc/dma_mx2.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/plat-mxc/dma_mx2.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,19 +30,19 @@
 #include <linux/init.h>
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
+#include <linux/clk.h>
 
 #include <linux/proc_fs.h>
 #include <asm/io.h>
 
 #include <asm/hardware.h>
 #include <asm/arch/dma.h>
-#include <asm/arch/clock.h>
 #include <asm/delay.h>
 
 #include <asm/atomic.h>
 
-/* commented temperily for mx27 compilation 
-#define DMA_PM 
+/* commented temperily for mx27 compilation
+#define DMA_PM
 */
 #ifdef DMA_PM
 #include <linux/pm.h>
@@ -55,20 +55,20 @@ struct pm_dev *dma_pm;
 static unsigned int dma_pm_status = DMA_PMST_RESUME;
 #endif
 
-/*! 
- * This variable is used to controll the clock of DMA. 
- * It counts the number of actived channels 
+/*!
+ * This variable is used to controll the clock of DMA.
+ * It counts the number of actived channels
  */
 static atomic_t g_dma_actived = ATOMIC_INIT(0);
 
-/*! 
- * This variable point a proc file which contains the information 
- *	of DMA channels 
+/*!
+ * This variable point a proc file which contains the information
+ *	of DMA channels
  */
 static struct proc_dir_entry *g_proc_dir;
 
-/*! 
- * The dma channels  
+/*!
+ * The dma channels
  */
 static mxc_dma_channel_t g_dma_channels[MAX_DMA_CHANNELS];
 static mx2_dma_priv_t g_dma_privates[MXC_DMA_CHANNELS];
@@ -76,6 +76,8 @@ static mx2_dma_bd_t g_dma_bd_table[MXC_D
 
 static DEFINE_SPINLOCK(dma_list_lock);
 
+static struct clk *dma_clk;
+
 /*!@brief flush buffer descriptor ring*/
 #define flush_dma_bd(private) \
 		{ \
@@ -231,7 +233,7 @@ static unsigned long inline __clear_dma_
 static void inline __enable_dma_clk(void)
 {
 	unsigned long reg;
-	mxc_clks_enable(DMA_CLK);
+	clk_enable(dma_clk);
 	reg = __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);
 	reg |= 0x1;
 	__raw_writel(reg, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);
@@ -244,7 +246,7 @@ static void inline __disable_dma_clk(voi
 	reg = __raw_readl(IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);
 	reg &= ~0x1;
 	__raw_writel(reg, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);
-	mxc_clks_disable(DMA_CLK);
+	clk_disable(dma_clk);
 }
 
 /*!@brief This function enables dma clocks with lock */
@@ -271,8 +273,8 @@ static void inline disable_dma_clk(void)
 	return;
 }
 
-/*!@brief select a buffer to transfer and 
- * 	setup dma channel for current transfer 
+/*!@brief select a buffer to transfer and
+ * 	setup dma channel for current transfer
  */
 static void setup_dmac(mxc_dma_channel_t * dma)
 {
@@ -295,13 +297,13 @@ static void setup_dmac(mxc_dma_channel_t
 	}
 	/* BUSY: transfering
 	 * PEND: Wait for set to DMAC.
-	 * s1: no transfering:  
-	 *      set first(one BUSY). if there are more than one tranfer. set second &repeat is enabled(two BUSY).               
-	 *      
+	 * s1: no transfering:
+	 *      set first(one BUSY). if there are more than one tranfer. set second &repeat is enabled(two BUSY).
+	 *
 	 * s2: transfering & just on transfer
 	 *      one BUSY. set the tranesfer and set repeat bit(two BUSY)
 	 * s3: transfering & repeat has set
-	 *     has two BUSY. 
+	 *     has two BUSY.
 	 */
 	p = priv->bd_ring + priv->bd_rd;
 	q = next_dma_bd(priv);
@@ -352,7 +354,7 @@ static void setup_dmac(mxc_dma_channel_t
 	} else {		/* Just dma channel which supports dma buffer can run to there */
 		BUG_ON(!priv->dma_chaining);
 		if (q) {	/* p is tranfering, then q must be set into dma controller */
-			/*WARNING:: [1] dangerous area begin. 
+			/*WARNING:: [1] dangerous area begin.
 			 *      If the p is completed during MCU run in this erea, the dma channel is crashed.
 			 */
 			__raw_writel(q->src_addr, &(dma_base->SourceAddr));
@@ -626,7 +628,7 @@ static inline int fill_dma_bd(mxc_dma_ch
 		save_dma_interrupt(mask);
 		mask_dma_interrupt(dma->channel);
 		local_irq_restore(flags);
-		/*TODO :: 
+		/*TODO ::
 		 *  If channel is transfering and supports chain_buffer,
 		 *  when the new buffer is 2st buffer , repeat must be enabled
 		 */
@@ -693,7 +695,7 @@ static inline int fill_dma_bd_by_sg(mxc_
 		save_dma_interrupt(mask);
 		mask_dma_interrupt(dma->channel);
 		local_irq_restore(flags);
-		/*TODO :: 
+		/*TODO ::
 		 *  If channel is transfering and supports chain_buffer,
 		 *  when the new buffer is 2st buffer , repeat must be enabled
 		 */
@@ -710,7 +712,7 @@ static inline int fill_dma_bd_by_sg(mxc_
 	return 0;
 }
 
-/*!@brief select next buffer descripter to transfer. 
+/*!@brief select next buffer descripter to transfer.
  *	return 1: need call call-back function. 0: Not need call call-back.
  *	it just is called in ISR
  */
@@ -903,7 +905,7 @@ int mxc_dma_config(int channel_num, mxc_
 		return -EINVAL;
 	}
 
-	/*TODO: fill dma buffer into driver . 
+	/*TODO: fill dma buffer into driver .
 	 * If driver is no enought buffer to save them , it will return -EBUSY
 	 */
 	if (fill_dma_bd(dma, dma_buf, num_buf, mode)) {
@@ -969,7 +971,7 @@ int mxc_dma_sg_config(int channel_num, s
 		return -EINVAL;
 	}
 
-	/*TODO: fill dma buffer into driver . 
+	/*TODO: fill dma buffer into driver .
 	 * If driver is no enought buffer to save them , it will return -EBUSY
 	 */
 	if (fill_dma_bd_by_sg(dma, sg, num_buf, num_of_bytes, mode)) {
@@ -1280,7 +1282,8 @@ int __init mxc_dma_init(void)
 
 	mxc_dma_load_info(g_dma_channels);
 
-	mxc_clks_enable(DMA_CLK);
+	dma_clk = clk_get(NULL, "dma_clk");
+	clk_enable(dma_clk);
 
 	__raw_writel(0x2, IO_ADDRESS(DMA_BASE_ADDR) + DMA_DCR);	/*reset DMA; */
 
diff -uNpr linux-2.6.19.2.orig/arch/arm/plat-mxc/Makefile linux-2.6.19.2/arch/arm/plat-mxc/Makefile
--- linux-2.6.19.2.orig/arch/arm/plat-mxc/Makefile	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/arch/arm/plat-mxc/Makefile	2007-04-25 17:37:51.000000000 -0600
@@ -3,7 +3,7 @@
 #
 
 # Common support
-obj-y := irq.o gpio.o
+obj-y := irq.o gpio.o clock.o
 
 obj-$(CONFIG_ARCH_MX27) += dma_mx2.o
 
diff -uNpr linux-2.6.19.2.orig/arch/arm/plat-mxc/sdma/sdma.c linux-2.6.19.2/arch/arm/plat-mxc/sdma/sdma.c
--- linux-2.6.19.2.orig/arch/arm/plat-mxc/sdma/sdma.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/arch/arm/plat-mxc/sdma/sdma.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -24,10 +24,10 @@
 #include <linux/types.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>
+#include <linux/clk.h>
 #include <asm/irq.h>
 #include <asm/arch/dma.h>
 #include <asm/arch/hardware.h>
-#include <asm/arch/clock.h>
 
 #include <asm/semaphore.h>
 #include <linux/spinlock.h>
@@ -1151,6 +1151,7 @@ static void __init init_sdma_data(void)
  */
 int __init sdma_init(void)
 {
+	struct clk *ahb_clk, *ipg_clk;
 	int res = 0;
 	configs_data confreg_data;
 
@@ -1159,7 +1160,11 @@ int __init sdma_init(void)
 
 	confreg_data.dspdma = MXC_SDMA_DSPDMA;
 	/* Set ACR bit */
-	if (mxc_get_clocks(AHB_CLK) / mxc_get_clocks(IPG_CLK) < 2) {
+	ahb_clk = clk_get(NULL, "sdma_ahb_clk");
+	ipg_clk = clk_get(NULL, "sdma_ipg_clk");
+	clk_enable(ahb_clk);
+	clk_enable(ipg_clk);
+	if (clk_get_rate(ahb_clk) / clk_get_rate(ipg_clk) < 2) {
 		printk(KERN_INFO "Setting SDMA ACR\n");
 		confreg_data.acr = 1;
 	}
diff -uNpr linux-2.6.19.2.orig/drivers/char/mxc_rtc.c linux-2.6.19.2/drivers/char/mxc_rtc.c
--- linux-2.6.19.2.orig/drivers/char/mxc_rtc.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/char/mxc_rtc.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -17,6 +17,7 @@
 #include <linux/interrupt.h>
 #include <linux/rtc.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <asm/rtc.h>
 #include <asm/mach/time.h>
 #include <asm/uaccess.h>
@@ -523,12 +524,15 @@ static struct timespec mxc_rtc_delta;
 
 static int __init mxc_rtc_probe(struct platform_device *pdev)
 {
+	struct clk *clkp;
 	struct timespec tv;
 	struct rtc_time temp_time;
 	u32 sec;
 	int ret;
 
-	mxc_clks_enable(RTC_CLK);
+	clkp = clk_get(&pdev->dev, "rtc_clk");
+	clk_enable(clkp);
+
 	/* Configure and enable the RTC */
 	if ((ret =
 	     request_irq(INT_RTC, mxc_rtc_interrupt, 0, "rtc", NULL)) != 0) {
diff -uNpr linux-2.6.19.2.orig/drivers/char/mxc_rtc.h linux-2.6.19.2/drivers/char/mxc_rtc.h
--- linux-2.6.19.2.orig/drivers/char/mxc_rtc.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/char/mxc_rtc.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -14,7 +14,6 @@
 #define __MXC_RTC_H__
 
 #include <asm/hardware.h>
-#include <asm/arch/clock.h>
 #define RTC_INPUT_CLK_32768HZ
 /*
 #define RTC_INPUT_CLK_32000HZ
diff -uNpr linux-2.6.19.2.orig/drivers/char/watchdog/mxc_wdt.c linux-2.6.19.2/drivers/char/watchdog/mxc_wdt.c
--- linux-2.6.19.2.orig/drivers/char/watchdog/mxc_wdt.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/drivers/char/watchdog/mxc_wdt.c	2007-04-25 17:37:51.000000000 -0600
@@ -3,7 +3,7 @@
  *
  * Watchdog driver for FSL MXC. It is based on omap1610_wdt.c
  *
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  * 2005 (c) MontaVista Software, Inc.  All Rights Reserved.
 
  * This program is free software; you can redistribute it and/or modify
@@ -51,6 +51,7 @@
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
 #include <linux/moduleparam.h>
+#include <linux/clk.h>
 
 #include <asm/io.h>
 #include <asm/uaccess.h>
@@ -66,6 +67,7 @@
 #define WDOG_COUNT_TO_SEC(c)  ((c >> 8) / 2)
 
 static int mxc_wdt_users;
+static struct clk *mxc_wdt_clk;
 
 static unsigned int timer_margin = TIMER_MARGIN_DEFAULT;
 module_param(timer_margin, uint, 0);
@@ -250,6 +252,9 @@ static int __init mxc_wdt_probe(struct p
 
 	mxc_wdt_miscdev.dev = &pdev->dev;
 
+	mxc_wdt_clk = clk_get(NULL, "wdog_clk");
+	clk_enable(mxc_wdt_clk);
+
 	ret = misc_register(&mxc_wdt_miscdev);
 	if (ret)
 		goto fail;
diff -uNpr linux-2.6.19.2.orig/drivers/i2c/busses/mxc_i2c.c linux-2.6.19.2/drivers/i2c/busses/mxc_i2c.c
--- linux-2.6.19.2.orig/drivers/i2c/busses/mxc_i2c.c	2007-04-25 17:37:33.000000000 -0600
+++ linux-2.6.19.2/drivers/i2c/busses/mxc_i2c.c	2007-04-25 17:37:51.000000000 -0600
@@ -30,10 +30,9 @@
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/i2c.h>
-
+#include <linux/clk.h>
 #include <asm/irq.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
 #include "mxc_i2c_reg.h"
 
 /*!
@@ -68,9 +67,9 @@ typedef struct {
 	unsigned int clkdiv;
 
 	/*!
-	 * The default clock source to be used.
+	 * The clock source for the device.
 	 */
-	enum mxc_clocks clk;
+	struct clk *clk;
 
 	/*!
 	 * The current power state of the device
@@ -373,7 +372,7 @@ static int mxc_i2c_writebytes(mxc_i2c_de
  */
 static void mxc_i2c_module_en(mxc_i2c_device * dev, int trans_flag)
 {
-	mxc_clks_enable(dev->clk);
+	clk_enable(dev->clk);
 	/* Set the frequency divider */
 	writew(dev->clkdiv, dev->membase + MXC_IFDR);
 	/* Clear the status register */
@@ -391,7 +390,7 @@ static void mxc_i2c_module_en(mxc_i2c_de
 static void mxc_i2c_module_dis(mxc_i2c_device * dev)
 {
 	writew(0x0, dev->membase + MXC_I2CR);
-	mxc_clks_disable(dev->clk);
+	clk_disable(dev->clk);
 }
 
 /*!
@@ -668,7 +667,8 @@ static int mxci2c_probe(struct platform_
 
 	gpio_i2c_active(id);
 
-	clk_freq = mxc_get_clocks(i2c_plat_data->clk);
+	mxc_i2c->clk = clk_get(&pdev->dev, "i2c_clk");
+	clk_freq = clk_get_rate(mxc_i2c->clk);
 	mxc_i2c->clkdiv = -1;
 	if (i2c_plat_data->i2c_clk) {
 		/* Calculate divider and round up any fractional part */
@@ -729,6 +729,7 @@ static int mxci2c_remove(struct platform
 	free_irq(mxc_i2c->irq, mxc_i2c);
 	i2c_del_adapter(&mxc_i2c->adap);
 	gpio_i2c_inactive(id);
+	clk_put(mxc_i2c->clk);
 	platform_set_drvdata(pdev, NULL);
 	return 0;
 }
diff -uNpr linux-2.6.19.2.orig/drivers/ide/arm/mxc_ide.c linux-2.6.19.2/drivers/ide/arm/mxc_ide.c
--- linux-2.6.19.2.orig/drivers/ide/arm/mxc_ide.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/drivers/ide/arm/mxc_ide.c	2007-04-25 17:37:51.000000000 -0600
@@ -5,7 +5,7 @@
  * Copyright (c) 2003-2004 Simtec Electronics
  *  Ben Dooks <ben@simtec.co.uk>
  *
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -36,6 +36,7 @@
 #include <linux/ide.h>
 #include <linux/init.h>
 #include <linux/ide.h>
+#include <linux/clk.h>
 
 #include <asm/mach-types.h>
 
@@ -43,8 +44,6 @@
 #include <asm/irq.h>
 #include <asm/delay.h>
 #include <asm/hardware.h>
-#include <asm/arch/board.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/dma.h>
 #include "mxc_ide.h"
 
@@ -53,6 +52,8 @@ extern void gpio_ata_inactive(void);
 static int mxc_ide_config_drive(ide_drive_t * drive, u8 xfer_mode);
 static void mxc_ide_dma_callback(void *arg, int error, unsigned int count);
 
+static struct clk *ata_clk;
+
 /* List of registered interfaces */
 static ide_hwif_t *ifs[1];
 
@@ -161,7 +162,7 @@ static struct {
 static int set_ata_bus_timing(int speed, enum ata_mode mode)
 {
 	/* get the bus clock cycle time, in ns */
-	int T = 1 * 1000 * 1000 * 1000 / mxc_get_clocks(ATA_BASE_CLK);
+	int T = 1 * 1000 * 1000 * 1000 / clk_get_rate(ata_clk);
 	mxc_ide_time_cfg_t cfg0, cfg1, cfg2, cfg3, cfg4, cfg5;
 	/* every mode gets the same t_off and t_on */
 
@@ -1016,6 +1017,10 @@ static int __init mxc_ide_init(void)
 	/* Configure the pads */
 	gpio_ata_active();
 
+	/* Enable the ata clock */
+	ata_clk = clk_get(NULL, "ata_clk");
+	clk_enable(ata_clk);
+
 	/* Deassert the reset bit to enable the interface */
 	ATA_RAW_WRITE(MXC_IDE_CTRL_ATA_RST_B, MXC_IDE_ATA_CONTROL);
 
@@ -1107,6 +1112,12 @@ static void __exit mxc_ide_exit(void)
 	PBC_ATA_SIGNAL_INACTIVE();
 
 	/*
+	 * Turn off the clock
+	 */
+	clk_disable(ata_clk);
+	clk_put(ata_clk);
+
+	/*
 	 * Free the pins
 	 */
 	gpio_ata_inactive();
diff -uNpr linux-2.6.19.2.orig/drivers/input/keyboard/mxc_keyb.c linux-2.6.19.2/drivers/input/keyboard/mxc_keyb.c
--- linux-2.6.19.2.orig/drivers/input/keyboard/mxc_keyb.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/input/keyboard/mxc_keyb.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -55,8 +55,8 @@
 #include <linux/miscdevice.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 #include <asm/mach/keypad.h>
-#include <asm/arch/clock.h>
 
 /*
  * Module header file
@@ -74,6 +74,9 @@ static unsigned int key_pad_enabled;
 /*! Input device structure. */
 static struct input_dev *mxckbd_dev = NULL;
 
+/*! KPP clock handle. */
+static struct clk *kpp_clk;
+
 /*! This static variable indicates whether a key event is pressed/released. */
 static unsigned short KPress;
 
@@ -757,7 +760,8 @@ static int mxc_kpp_probe(struct platform
 	}
 
 	/* Enable keypad clock */
-	mxc_clks_enable(KPP_CLK);
+	kpp_clk = clk_get(&pdev->dev, "kpp_clk");
+	clk_enable(kpp_clk);
 
 	/* IOMUX configuration for keypad */
 	gpio_keypad_active();
@@ -912,7 +916,8 @@ static int mxc_kpp_remove(struct platfor
 	__raw_writew(reg_val, KPSR);
 
 	gpio_keypad_inactive();
-	mxc_clks_disable(KPP_CLK);
+	clk_disable(kpp_clk);
+	clk_put(kpp_clk);
 
 	KPress = 0;
 
diff -uNpr linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mc521da.c linux-2.6.19.2/drivers/media/video/mxc/capture/mc521da.c
--- linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mc521da.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/drivers/media/video/mxc/capture/mc521da.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -29,7 +29,6 @@
 #include <linux/i2c.h>
 #include <asm/arch/mxc_i2c.h>
 #include "mxc_v4l2_capture.h"
-#include <asm/arch/clock.h>
 
 #define MC521DA_I2C_ADDRESS	0x22
 #define MC521DA_TERM		0xFF
diff -uNpr linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mt9v111.c linux-2.6.19.2/drivers/media/video/mxc/capture/mt9v111.c
--- linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mt9v111.c	2007-04-25 17:37:33.000000000 -0600
+++ linux-2.6.19.2/drivers/media/video/mxc/capture/mt9v111.c	2007-04-25 17:37:51.000000000 -0600
@@ -27,6 +27,7 @@
 #include <linux/delay.h>
 #include <linux/device.h>
 #include <linux/i2c.h>
+#include <linux/clk.h>
 #include <asm/arch/mxc_i2c.h>
 #include "mxc_v4l2_capture.h"
 #include "mt9v111.h"
@@ -598,7 +599,6 @@ static int mt9v111_detect_client(struct 
 		return -1;
 	}
 
-	mxc_clks_disable(CSI_BAUD);
 	printk(KERN_INFO "MT9V111 Detected\n");
 
 	return 0;
@@ -618,10 +618,19 @@ I2C_CLIENT_INSMOD;
 static int mt9v111_attach(struct i2c_adapter *adap)
 {
 	uint32_t mclk = 27000000;
-	mxc_clks_enable(CSI_BAUD);
+	struct clk *clk;
+	int err;
+
+	clk = clk_get(NULL, "csi_clk");
+	clk_enable(clk);
 	set_mclk_rate(&mclk);
 
-	return i2c_probe(adap, &addr_data, &mt9v111_detect_client);
+	err = i2c_probe(adap, &addr_data, &mt9v111_detect_client);
+
+	clk_disable(clk);
+	clk_put(clk);
+
+	return err;
 }
 
 /*!
diff -uNpr linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mx27_csi.c linux-2.6.19.2/drivers/media/video/mxc/capture/mx27_csi.c
--- linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mx27_csi.c	2007-04-25 17:37:00.000000000 -0600
+++ linux-2.6.19.2/drivers/media/video/mxc/capture/mx27_csi.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -23,11 +23,11 @@
 #include <linux/device.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
-#include <asm/arch/hardware.h>
 #include <linux/spinlock.h>
 #include <linux/delay.h>
-#include <asm/arch/clock.h>
 #include <linux/module.h>
+#include <linux/clk.h>
+#include <asm/arch/hardware.h>
 
 #include "mx27_csi.h"
 
@@ -247,12 +247,17 @@ void csi_set_callback(csi_irq_callback_t
 	g_callback_data = data;
 }
 
+static struct clk *csi_clk;
+
 int32_t __init csi_init_module(void)
 {
 	int ret = 0;
 
-	mxc_clks_enable(CSI_BAUD);
+	csi_clk = clk_get(NULL, "csi_clk");
+	clk_enable(csi_clk);
+
 	csihw_reset();
+	csi_enable_mclk(0, 1, 0);
 
 	/* interrupt enable */
 	ret = request_irq(INT_CSI, csi_irq_handler, 0, "csi", 0);
@@ -267,7 +272,8 @@ void __exit csi_cleanup_module(void)
 	/* free irq */
 	free_irq(INT_CSI, 0);
 
-	mxc_clks_disable(CSI_BAUD);
+	clk_disable(csi_clk);
+	clk_put(csi_clk);
 }
 
 module_init(csi_init_module);
diff -uNpr linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mx27_prphw.c linux-2.6.19.2/drivers/media/video/mxc/capture/mx27_prphw.c
--- linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mx27_prphw.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/media/video/mxc/capture/mx27_prphw.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -21,7 +21,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/string.h>
-#include <asm/arch/clock.h>
+#include <linux/clk.h>
 #include <asm/io.h>
 #include <linux/delay.h>
 
@@ -1078,12 +1078,15 @@ int prphw_isr(void)
 	return status;
 }
 
+static struct clk *emma_clk;
+
 /*!
  * @brief  PrP module clock enable
  */
 void prphw_init(void)
 {
-	mxc_clks_enable(EMMA_PRP_CLK);
+	emma_clk = clk_get(NULL, "emma_clk");
+	clk_enable(emma_clk);
 }
 
 /*!
@@ -1091,5 +1094,6 @@ void prphw_init(void)
  */
 void prphw_exit(void)
 {
-	mxc_clks_disable(EMMA_PRP_CLK);
+	clk_disable(emma_clk);
+	clk_put(emma_clk);
 }
diff -uNpr linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mx27_prpsw.c linux-2.6.19.2/drivers/media/video/mxc/capture/mx27_prpsw.c
--- linux-2.6.19.2.orig/drivers/media/video/mxc/capture/mx27_prpsw.c	2007-04-25 17:37:08.000000000 -0600
+++ linux-2.6.19.2/drivers/media/video/mxc/capture/mx27_prpsw.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -23,7 +23,6 @@
 #include <linux/string.h>
 #include <linux/fb.h>
 #include <linux/pci.h>
-#include <asm/arch/clock.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 
@@ -41,7 +40,7 @@ static emma_prp_cfg g_prp_cfg;
 static int g_vfbuf, g_rotbuf;
 static struct tasklet_struct prp_vf_tasklet;
 
-/* 
+/*
  * The following variables represents the virtual address for the cacheable
  * buffers accessed by SW rotation/mirroring. The rotation/mirroring in
  * cacheable buffers has significant performance improvement than it in
diff -uNpr linux-2.6.19.2.orig/drivers/media/video/mxc/capture/sensor_clock.c linux-2.6.19.2/drivers/media/video/mxc/capture/sensor_clock.c
--- linux-2.6.19.2.orig/drivers/media/video/mxc/capture/sensor_clock.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/media/video/mxc/capture/sensor_clock.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -18,12 +18,11 @@
  *
  * @ingroup Camera
  */
-
 #include <linux/init.h>
 #include <linux/ctype.h>
 #include <linux/types.h>
 #include <linux/device.h>
-#include "asm/arch/clock.h"
+#include <linux/clk.h>
 
 /*
  * set_mclk_rate
@@ -33,25 +32,26 @@
  */
 void set_mclk_rate(uint32_t * p_mclk_freq)
 {
-	uint32_t div;
-	// Calculate the divider using the requested, minimum mclk freq
-	div = mxc_get_clocks_parent(CSI_BAUD) / *p_mclk_freq;
-	/* Calculate and return the actual mclk frequency.
-	   The integer division error/truncation will ensure the actual freq is
-	   greater than the requested freq.
+	struct clk *clk;
+	int i;
+	uint32_t freq = 0;
+	uint32_t step = *p_mclk_freq / 8;
+
+	clk = clk_get(NULL, "csi_clk");
+
+	/* clk_round_rate rounds down, but we need it rounded up
+	 * So we try 9 steps up to 2x the requested freq.
 	 */
-	if (*p_mclk_freq < mxc_get_clocks_parent(CSI_BAUD) / div) {
-		div++;
+	for (i = 0; i <= 8; i++) {
+		freq = clk_round_rate(clk, *p_mclk_freq + (i * step));
+		if (freq >= *p_mclk_freq)
+			break;
 	}
+	clk_set_rate(clk, freq);
 
-	*p_mclk_freq = mxc_get_clocks_parent(CSI_BAUD) / div;
-
-#ifdef CONFIG_MXC_EMMA
-	mxc_set_clocks_div(CSI_BAUD, div / 2);
-#else
-	mxc_set_clocks_div(CSI_BAUD, div * 2);
-#endif
+	*p_mclk_freq = freq;
 
+	clk_put(clk);
 	pr_debug("mclk frequency = %d\n", *p_mclk_freq);
 }
 
diff -uNpr linux-2.6.19.2.orig/drivers/media/video/mxc/output/mx27_pp.c linux-2.6.19.2/drivers/media/video/mxc/output/mx27_pp.c
--- linux-2.6.19.2.orig/drivers/media/video/mxc/output/mx27_pp.c	2007-04-25 17:37:18.000000000 -0600
+++ linux-2.6.19.2/drivers/media/video/mxc/output/mx27_pp.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -24,9 +24,9 @@
 #include <linux/string.h>
 #include <linux/module.h>
 #include <linux/fb.h>
-#include <asm/irq.h>
+#include <linux/clk.h>
+#include <linux/interrupt.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
 
 #include "mx27_pp.h"
 #include "mxc_v4l2_output.h"
@@ -883,12 +883,15 @@ static int pphw_isr(void)
 	return status;
 }
 
+static struct clk *emma_clk;
+
 /*!
  * @brief PP module clock enable
  */
 static void pphw_init(void)
 {
-	mxc_clks_enable(EMMA_PP_CLK);
+	emma_clk = clk_get(NULL, "emma_clk");
+	clk_enable(emma_clk);
 }
 
 /*!
@@ -896,5 +899,6 @@ static void pphw_init(void)
  */
 static void pphw_exit(void)
 {
-	mxc_clks_disable(EMMA_PP_CLK);
+	clk_disable(emma_clk);
+	clk_put(emma_clk);
 }
diff -uNpr linux-2.6.19.2.orig/drivers/mmc/mxc_mmc.c linux-2.6.19.2/drivers/mmc/mxc_mmc.c
--- linux-2.6.19.2.orig/drivers/mmc/mxc_mmc.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mmc/mxc_mmc.c	2007-04-25 17:37:51.000000000 -0600
@@ -12,7 +12,7 @@
  */
 
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -52,6 +52,7 @@
 #include <linux/mmc/protocol.h>
 #include <linux/delay.h>
 #include <linux/timer.h>
+#include <linux/clk.h>
 
 #include <asm/dma.h>
 #include <asm/io.h>
@@ -62,7 +63,6 @@
 #include <asm/arch/mmc.h>
 
 #include "mxc_mmc.h"
-#include <asm/arch/clock.h>
 
 #if defined(CONFIG_MXC_MC13783_POWER)
 #include <asm/arch/pmic_power.h>
@@ -232,7 +232,7 @@ struct mxcmci_host {
 	/*!
 	 * Clock id to hold ipg_perclk.
 	 */
-	enum mxc_clocks clock_id;
+	struct clk *clk;
 	/*!
 	 * MMC mode.
 	 */
@@ -812,7 +812,7 @@ static irqreturn_t mxcmci_irq(int irq, v
 	u32 intctrl;
 
 	if (host->mxc_mmc_suspend_flag == 1) {
-		mxc_clks_enable(host->clock_id);
+		clk_enable(host->clk);
 	}
 
 	status = __raw_readl(host->base + MMC_STATUS);
@@ -895,7 +895,7 @@ static void mxcmci_set_ios(struct mmc_ho
 	struct mxcmci_host *host = mmc_priv(mmc);
 	/*This variable holds the value of clock prescaler */
 	int prescaler;
-	int clk_rate = mxc_get_clocks(host->clock_id);
+	int clk_rate = clk_get_rate(host->clk);
 #ifdef MXC_MMC_DMA_ENABLE
 	mxc_dma_device_t dev_id = 0;
 #endif
@@ -1241,16 +1241,12 @@ static int mxcmci_probe(struct platform_
 		goto out;
 	}
 
-	if (pdev->id == 0) {
-		host->clock_id = SDHC1_CLK;
-	} else {
-		host->clock_id = SDHC2_CLK;
-	}
+	host->clk = clk_get(&pdev->dev, "sdhc_clk");
+	clk_enable(host->clk);
 
 	mmc->f_min = mmc_plat->min_clk;
 	mmc->f_max = mmc_plat->max_clk;
-	pr_debug("SDHC:%d clock:%lu\n", pdev->id,
-		 mxc_get_clocks(host->clock_id));
+	pr_debug("SDHC:%d clock:%lu\n", pdev->id, clk_get_rate(host->clk));
 
 	spin_lock_init(&host->lock);
 	host->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
@@ -1343,6 +1339,7 @@ static int mxcmci_probe(struct platform_
 	release_mem_region(pdev->resource[0].start,
 			   pdev->resource[0].end - pdev->resource[0].start + 1);
       out:
+	clk_disable(host->clk);
 	mmc_free_host(mmc);
 	platform_set_drvdata(pdev, NULL);
 	return ret;
@@ -1413,7 +1410,7 @@ static int mxcmci_suspend(struct platfor
 		reg &= ~INT_CNTR_SDIO_INT_WKP_EN;
 		__raw_writel(reg, host->base + MMC_INT_CNTR);
 	}
-	mxc_clks_disable(host->clock_id);
+	clk_disable(host->clk);
 
 	return ret;
 }
@@ -1448,7 +1445,7 @@ static int mxcmci_resume(struct platform
 		ret = mmc_resume_host(mmc);
 		host->mxc_mmc_suspend_flag = 0;
 	}
-	mxc_clks_enable(host->clock_id);
+	clk_enable(host->clk);
 	if (host->sdio_set_wake_enable == 1) {
 		reg = __raw_readl(host->base + MMC_INT_CNTR);
 		reg &= ~INT_CNTR_SDIO_INT_WKP_EN;
diff -uNpr linux-2.6.19.2.orig/drivers/mtd/nand/mxc_nd.c linux-2.6.19.2/drivers/mtd/nand/mxc_nd.c
--- linux-2.6.19.2.orig/drivers/mtd/nand/mxc_nd.c	2007-04-25 17:36:56.000000000 -0600
+++ linux-2.6.19.2/drivers/mtd/nand/mxc_nd.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -20,10 +20,10 @@
 #include <linux/interrupt.h>
 #include <linux/device.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <linux/err.h>
 #include <linux/mtd/partitions.h>
 #include <asm/mach/flash.h>
-#include <asm/arch/clock.h>
 #include <asm/io.h>
 #include "mxc_nd.h"
 
@@ -77,6 +77,8 @@ static int Ecc_disabled;
 
 static int is2k_Pagesize = 0;
 
+static struct clk *nfc_clk;
+
 /*
  * OOB placement block for use with hardware ecc generation
  */
@@ -190,7 +192,7 @@ static void send_addr(u16 addr, bool isl
  * This function requests the NANDFC to initate the transfer
  * of data currently in the NANDFC RAM buffer to the NAND device.
  *
- * @param	buf_id	      Specify Internal RAM Buffer number (0-3)	
+ * @param	buf_id	      Specify Internal RAM Buffer number (0-3)
  * @param       bSpareOnly    set true if only the spare area is transferred
  */
 static void send_prog_page(u8 buf_id, bool bSpareOnly)
@@ -218,7 +220,7 @@ static void send_prog_page(u8 buf_id, bo
 /*!
  * This function will correct the single bit ECC error
  *
- * @param  buf_id	Specify Internal RAM Buffer number (0-3)	
+ * @param  buf_id	Specify Internal RAM Buffer number (0-3)
  * @param  eccpos 	Ecc byte and bit position
  * @param  bSpareOnly  	set to true if only spare area needs correction
  */
@@ -252,7 +254,7 @@ static void mxc_nd_correct_error(u8 buf_
  * This function will maintains state of single bit Error
  * in Main & spare  area
  *
- * @param buf_id	Specify Internal RAM Buffer number (0-3)	
+ * @param buf_id	Specify Internal RAM Buffer number (0-3)
  * @param spare  	set to true if only spare area needs correction
  */
 static void mxc_nd_correct_ecc(u8 buf_id, bool spare)
@@ -344,7 +346,7 @@ static void mxc_nd_correct_ecc(u8 buf_id
  * This function requests the NANDFC to initated the transfer
  * of data from the NAND device into in the NANDFC ram buffer.
  *
- * @param  	buf_id		Specify Internal RAM Buffer number (0-3)	
+ * @param  	buf_id		Specify Internal RAM Buffer number (0-3)
  * @param       bSpareOnly    	set true if only the spare area is transferred
  */
 static void send_read_page(u8 buf_id, bool bSpareOnly)
@@ -455,7 +457,7 @@ static u16 get_dev_status(void)
  */
 static int mxc_nand_dev_ready(struct mtd_info *mtd)
 {
-	/* 
+	/*
 	 * NFC handles R/B internally.Therefore,this function
 	 * always returns status as ready.
 	 */
@@ -818,11 +820,11 @@ static void mxc_nand_select_chip(struct 
 	switch (chip) {
 	case -1:
 		/* Disable the NFC clock */
-		mxc_clks_disable(NFC_CLK);
+		clk_disable(nfc_clk);
 		break;
 	case 0:
 		/* Enable the NFC clock */
-		mxc_clks_enable(NFC_CLK);
+		clk_enable(nfc_clk);
 		break;
 
 	default:
@@ -883,11 +885,11 @@ static void mxc_nand_command(struct mtd_
 	case NAND_CMD_SEQIN:
 		if (column >= mtd->writesize) {
 			if (is2k_Pagesize) {
-				/** 			 
+				/**
 				  * FIXME: before send SEQIN command for write OOB,
-				  * We must read one page out. 			 
-				  * For K9F1GXX has no READ1 command to set current HW 			 
-				  * pointer to spare area, we must write the whole page including OOB together.			 
+				  * We must read one page out.
+				  * For K9F1GXX has no READ1 command to set current HW
+				  * pointer to spare area, we must write the whole page including OOB together.
 				  */
 				/* call itself to read a page */
 				mxc_nand_command(mtd, NAND_CMD_READ0, 0,
@@ -1090,6 +1092,8 @@ static int __init mxcnd_probe(struct pla
 	this->read_buf = mxc_nand_read_buf;
 	this->verify_buf = mxc_nand_verify_buf;
 
+	nfc_clk = clk_get(&pdev->dev, "nfc_clk");
+
 	NFC_CONFIG1 |= NFC_INT_MSK;
 	init_waitqueue_head(&irq_waitq);
 	err = request_irq(INT_NANDFC, mxc_nfc_irq, 0, "mxc_nd", NULL);
@@ -1183,6 +1187,7 @@ static int __exit mxcnd_remove(struct pl
 {
 	struct mtd_info *mtd = platform_get_drvdata(pdev);
 
+	clk_put(nfc_clk);
 	platform_set_drvdata(pdev, NULL);
 
 	if (mxc_nand_data) {
@@ -1217,7 +1222,7 @@ static int mxcnd_suspend(struct platform
 		ret = info->suspend(info);
 
 	/* Disable the NFC clock */
-	mxc_clks_disable(NFC_CLK);
+	clk_disable(nfc_clk);
 
 	return ret;
 }
@@ -1238,7 +1243,7 @@ static int mxcnd_resume(struct platform_
 
 	DEBUG(MTD_DEBUG_LEVEL0, "MXC_ND : NAND resume\n");
 	/* Enable the NFC clock */
-	mxc_clks_enable(NFC_CLK);
+	clk_enable(nfc_clk);
 
 	if (info) {
 		info->resume(info);
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_adc.c linux-2.6.19.2/drivers/mxc/ipu/ipu_adc.c
--- linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_adc.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/ipu/ipu_adc.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -25,7 +25,6 @@
 #include <linux/spinlock.h>
 #include <linux/delay.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/ipu.h>
 
 #include "ipu_prv.h"
@@ -219,6 +218,9 @@ int32_t ipu_adc_set_update_mode(ipu_chan
 	int32_t err = 0;
 	uint32_t ref_per, reg, src = 0;
 	uint32_t lock_flags;
+	uint32_t ipu_freq;
+
+	ipu_freq = clk_get_rate(g_ipu_clk);
 
 	spin_lock_irqsave(&ipu_lock, lock_flags);
 
@@ -233,7 +235,7 @@ int32_t ipu_adc_set_update_mode(ipu_chan
 			err = -EINVAL;
 			goto err0;
 		}
-		ref_per = (refresh_rate * g_ipu_clk) / 217;
+		ref_per = (refresh_rate * ipu_freq) / 217;
 		ref_per--;
 		reg |= ref_per << FS_AUTO_REF_PER_OFFSET;
 
@@ -244,7 +246,7 @@ int32_t ipu_adc_set_update_mode(ipu_chan
 			err = -EINVAL;
 			goto err0;
 		}
-		ref_per = (refresh_rate * g_ipu_clk) / 217;
+		ref_per = (refresh_rate * ipu_freq) / 217;
 		ref_per--;
 		reg |= ref_per << FS_AUTO_REF_PER_OFFSET;
 
@@ -496,10 +498,13 @@ int32_t ipu_adc_init_ifc_timing(display_
 	uint32_t down_per;
 	uint32_t read_per;
 	uint32_t pixclk_per = 0;
+	uint32_t ipu_freq;
+
+	ipu_freq = clk_get_rate(g_ipu_clk);
 
-	clk_per = (cycle_time * (g_ipu_clk / 1000L) * 16L) / 1000000L;
-	up_per = (up_time * (g_ipu_clk / 1000L) * 4L) / 1000000L;
-	down_per = (down_time * (g_ipu_clk / 1000L) * 4L) / 1000000L;
+	clk_per = (cycle_time * (ipu_freq / 1000L) * 16L) / 1000000L;
+	up_per = (up_time * (ipu_freq / 1000L) * 4L) / 1000000L;
+	down_per = (down_time * (ipu_freq / 1000L) * 4L) / 1000000L;
 
 	reg = (clk_per << DISPx_IF_CLK_PER_OFFSET) |
 	    (up_per << DISPx_IF_CLK_UP_OFFSET) |
@@ -507,9 +512,9 @@ int32_t ipu_adc_init_ifc_timing(display_
 
 	if (read) {
 		read_per =
-		    (read_latch_time * (g_ipu_clk / 1000L) * 4L) / 1000000L;
+		    (read_latch_time * (ipu_freq / 1000L) * 4L) / 1000000L;
 		if (pixel_clk)
-			pixclk_per = (g_ipu_clk * 16L) / pixel_clk;
+			pixclk_per = (ipu_freq * 16L) / pixel_clk;
 		time_conf3 = (read_per << DISPx_IF_CLK_READ_EN_OFFSET) |
 		    (pixclk_per << DISPx_PIX_CLK_PER_OFFSET);
 	}
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_common.c linux-2.6.19.2/drivers/mxc/ipu/ipu_common.c
--- linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_common.c	2007-04-25 17:37:16.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/ipu/ipu_common.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -25,8 +25,8 @@
 #include <linux/errno.h>
 #include <linux/spinlock.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 #include <asm/io.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/ipu.h>
 
 #include "ipu_prv.h"
@@ -46,8 +46,8 @@ struct ipu_irq_node {
 };
 
 /* Globals */
-uint32_t g_ipu_clk;
-uint32_t g_ipu_csi_clk;
+struct clk *g_ipu_clk;
+struct clk *g_ipu_csi_clk;
 int g_ipu_irq[2];
 int g_ipu_hw_rev;
 bool g_sec_chan_en[21];
@@ -115,9 +115,11 @@ int ipu_probe(struct platform_device *pd
 
 	/* Enable IPU and CSI clocks */
 	/* Get IPU clock freq */
-	mxc_clks_enable(IPU_CLK);
-	g_ipu_clk = mxc_get_clocks(IPU_CLK);
-	dev_dbg(g_ipu_dev, "g_ipu_clk = %d\n", g_ipu_clk);
+	g_ipu_clk = clk_get(&pdev->dev, "ipu_clk");
+	clk_enable(g_ipu_clk);
+	dev_dbg(g_ipu_dev, "ipu_clk = %d\n", clk_get_rate(g_ipu_clk));
+
+	g_ipu_csi_clk = clk_get(&pdev->dev, "csi_clk");
 
 	__raw_writel(0x00100010L, DI_HSP_CLK_PER);
 
@@ -412,10 +414,10 @@ void ipu_uninit_channel(ipu_channel_t ch
  *                              Setting this to a value other than NULL enables
  *                              double buffering mode.
  *
- * @param       u		       	private u offset for additional cropping, 
+ * @param       u		       	private u offset for additional cropping,
  *								zero if not used.
  *
- * @param       v		       	private v offset for additional cropping, 
+ * @param       v		       	private v offset for additional cropping,
  *								zero if not used.
  *
  * @return      This function returns 0 on success or negative error code on fail
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_csi.c linux-2.6.19.2/drivers/mxc/ipu/ipu_csi.c
--- linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_csi.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/ipu/ipu_csi.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -23,7 +23,6 @@
 #include <linux/errno.h>
 #include <linux/spinlock.h>
 #include <linux/delay.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/ipu.h>
 
 #include "ipu_prv.h"
@@ -141,13 +140,13 @@ int32_t ipu_csi_enable_mclk(int src, boo
 		return 0;
 
 	if (flag == true) {
-		mxc_clks_enable(CSI_BAUD);
+		clk_enable(g_ipu_csi_clk);
 		if (wait == true)
 			msleep(10);
 		/*printk("enable csi clock from source %d\n", src);     */
 		gipu_csi_get_mclk_flag = true;
 	} else if (csi_mclk_flag == 0) {
-		mxc_clks_disable(CSI_BAUD);
+		clk_disable(g_ipu_csi_clk);
 		/*printk("disable csi clock from source %d\n", src); */
 		gipu_csi_get_mclk_flag = flag;
 	}
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_lpmc.c linux-2.6.19.2/drivers/mxc/ipu/ipu_lpmc.c
--- linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_lpmc.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/ipu/ipu_lpmc.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -20,13 +20,13 @@
  */
 
 #include <linux/module.h>
+#include <linux/clk.h>
 #include <asm/arch/ipu.h>
 
 #ifdef CONFIG_MXC_IPU_LPMC
 
 #include "ipu_prv.h"
 #include <asm/io.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/mxc_pm.h>
 
 #define LPMC_CNTL	IO_ADDRESS(LPMC_BASE_ADDR + 0)
@@ -38,6 +38,9 @@
 #define LPMC_CNTL_RMP_END_PTR_OFFSET    16
 #define LPMC_CNTL_LPMP_END_PTR_OFFSET   24
 
+static struct clk *dfm_clk;
+static struct clk *lpmc_clk;
+
 /*!
  * This function initializes low-power self-refresh mode.
  *
@@ -64,12 +67,16 @@ int ipu_lpmc_init(u32 dfm_freq,
 	u32 reg, lpmc_cntl;
 	u32 lpmc_state, previous_lpmc_state;
 
-	mxc_set_dfm_clock(dfm_freq);
-	mxc_clks_enable(LPMC_CLK);
+	lpmc_clk = clk_get(NULL, "lpmc_clk");
+	clk_enable(lpmc_clk);
+
+	dfm_clk = clk_get(NULL, "dfm_clk");
+	dfm_freq = clk_round_rate(dfm_clk, dfm_freq);
+	clk_set_rate(dfm_clk, dfm_freq);
+	clk_enable(dfm_clk);
 
-#ifdef CONFIG_DPM
 	mxc_pm_lp_ack_enable(MXC_PM_LOWPWR_ACK_IPU);
-#endif
+
 	lpmc_cntl = (save_count) << LPMC_CNTL_RMP_END_PTR_OFFSET;
 	lpmc_cntl |= (lpm_count + save_count) << LPMC_CNTL_LPMP_END_PTR_OFFSET;
 	__raw_writel(lpmc_cntl, LPMC_CNTL);
@@ -106,7 +113,7 @@ int ipu_lpmc_init(u32 dfm_freq,
 	dev_dbg(g_ipu_dev, "LPMC off - LPMC_STAT = 0x%X\n", lpmc_state);
 
 	lpmc_cntl |= LPMC_CNTL_LOW_PWR_CLK | LPMC_CNTL_LPMC_EN;
-	__raw_writel(lpmc_cntl, LPMC_CNTL);	/* EXIT LPMC Mode */
+	__raw_writel(lpmc_cntl, LPMC_CNTL);
 	dev_dbg(g_ipu_dev, "LPMC_CNTL = 0x%08X\n", lpmc_cntl);
 
 	while (lpmc_state != 0xC) {
@@ -133,9 +140,8 @@ void ipu_lpmc_uninit(void)
 
 	spin_lock_irqsave(&ipu_lock, lock_flags);
 
-#ifdef CONFIG_DPM
 	mxc_pm_lp_ack_disable(MXC_PM_LOWPWR_ACK_IPU);
-#endif
+
 	reg = __raw_readl(LPMC_CNTL);
 	reg &= ~LPMC_CNTL_LOW_PWR_CLK;
 	__raw_writel(reg, LPMC_CNTL);	/* EXIT LPMC Mode */
@@ -152,8 +158,10 @@ void ipu_lpmc_uninit(void)
 	}
 
 	__raw_writel(0, LPMC_CNTL);	/* Disable LPMC */
-	mxc_clks_disable(LPMC_CLK);
-	mxc_set_dfm_clock(0);
+	clk_disable(dfm_clk);
+	clk_disable(lpmc_clk);
+	clk_put(dfm_clk);
+	clk_put(lpmc_clk);
 }
 
 #else
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_prv.h linux-2.6.19.2/drivers/mxc/ipu/ipu_prv.h
--- linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_prv.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/ipu/ipu_prv.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -15,13 +15,15 @@
 
 #include <linux/types.h>
 #include <linux/device.h>
+#include <linux/clk.h>
 #include <linux/interrupt.h>
 #include <asm/arch/hardware.h>
 
 /* Globals */
 extern struct device *g_ipu_dev;
 extern spinlock_t ipu_lock;
-extern uint32_t g_ipu_clk;
+extern struct clk *g_ipu_clk;
+extern struct clk *g_ipu_csi_clk;
 
 ipu_color_space_t format_to_colorspace(uint32_t fmt);
 
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_sdc.c linux-2.6.19.2/drivers/mxc/ipu/ipu_sdc.c
--- linux-2.6.19.2.orig/drivers/mxc/ipu/ipu_sdc.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/ipu/ipu_sdc.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -125,7 +125,7 @@ int32_t ipu_sdc_init_panel(ipu_panel_t p
 	/* Calculate divider */
 	/* fractional part is 4 bits so simply multiple by 2^4 to get fractional part */
 	dev_dbg(g_ipu_dev, "pixel clk = %d\n", pixel_clk);
-	div = (g_ipu_clk * 16) / pixel_clk;
+	div = (clk_get_rate(g_ipu_clk) * 16) / pixel_clk;
 	if (div < 0x40) {	/* Divider less than 4 */
 		dev_dbg(g_ipu_dev,
 			"InitPanel() - Pixel clock divider less than 1\n");
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/pm/dptc.c linux-2.6.19.2/drivers/mxc/pm/dptc.c
--- linux-2.6.19.2.orig/drivers/mxc/pm/dptc.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/pm/dptc.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -45,7 +45,6 @@
 #include <linux/jiffies.h>
 #include <linux/platform_device.h>
 #include <asm/arch/sdma.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/pmic_power.h>
 
 /*
@@ -65,6 +64,10 @@
 #include "../../../arch/arm/mach-mx3/crm_regs.h"
 #endif
 
+extern unsigned long mxc_ccm_get_reg(unsigned int reg_offset);
+extern void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
+			       unsigned int data);
+
 /*!
  * The dvfs_dptc_params structure holds all the internal DPTC driver parameters
  * (current working point, current frequency, translation table and DPTC
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/pm/dptc_mx27.c linux-2.6.19.2/drivers/mxc/pm/dptc_mx27.c
--- linux-2.6.19.2.orig/drivers/mxc/pm/dptc_mx27.c	2007-04-25 17:37:03.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/pm/dptc_mx27.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -15,17 +15,17 @@
  * @file dptc_mx27.c
  *
  * @brief Driver for the Freescale Semiconductor MX27 DPTC module.
- * 
- * The DPTC driver is designed as a character driver which interacts with the 
- * MX27 DPTC hardware. Upon initialization, the DPTC driver initializes the 
- * DPTC hardware sets up driver nodes attaches to the DPTC interrupt and 
- * initializes internal data structures. When the DPTC interrupt occurs the 
+ *
+ * The DPTC driver is designed as a character driver which interacts with the
+ * MX27 DPTC hardware. Upon initialization, the DPTC driver initializes the
+ * DPTC hardware sets up driver nodes attaches to the DPTC interrupt and
+ * initializes internal data structures. When the DPTC interrupt occurs the
  * driver checks the cause of the interrupt (lower voltage, increase voltage or
- * emergency) and changes the CPU voltage according to translation table that 
- * is loaded into the driver(the voltage changes are done by calling some 
- * routines in the mc13783 driver). The driver read method is used to read the 
- * currently loaded DPTC translation table and the write method is used 
- * in-order to update the translation table. Driver ioctls are used to change 
+ * emergency) and changes the CPU voltage according to translation table that
+ * is loaded into the driver(the voltage changes are done by calling some
+ * routines in the mc13783 driver). The driver read method is used to read the
+ * currently loaded DPTC translation table and the write method is used
+ * in-order to update the translation table. Driver ioctls are used to change
  * driver parameters and enable/disable the DPTC operation.
  *
  * @ingroup PM
@@ -35,12 +35,12 @@
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <asm/uaccess.h>
 #include <linux/workqueue.h>
 #include <linux/proc_fs.h>
 #include <asm/semaphore.h>
 #include <linux/vmalloc.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/pmic_power.h>
 #include <asm/arch/dvfs_dptc_struct.h>
 #include "dvfs_dptc.h"
@@ -267,10 +267,10 @@ static int disable_ref_circuits(unsigned
 }
 
 /*!
- * This function updates the CPU voltage, produced by MC13783, by calling 
- * MC13783 driver functions. 
+ * This function updates the CPU voltage, produced by MC13783, by calling
+ * MC13783 driver functions.
  *
- * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table. 
+ * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table.
  * @param    wp			current wp value.
  *
  */
@@ -286,7 +286,7 @@ static void set_pmic_voltage(dvfs_dptc_t
 /*!
  * This function updates the DPTC threshold registers.
  *
- * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table. 
+ * @param    dvfs_dptc_tables_ptr    pointer to the DPTC translation table.
  * @param    wp			current wp value.
  *
  */
@@ -306,12 +306,12 @@ static void update_dptc_thresholds(dvfs_
 }
 
 /*!
- * This function increments a log buffer index (head or tail) 
+ * This function increments a log buffer index (head or tail)
  * by the value of val.
  *
- * @param    index	pointer to the DPTC log buffer index that 
+ * @param    index	pointer to the DPTC log buffer index that
  *			we wish to change.
- * @param    val	the value in which the index should be incremented. 
+ * @param    val	the value in which the index should be incremented.
  *
  */
 static void inc_log_index(int *index, int val)
@@ -323,16 +323,16 @@ static void inc_log_index(int *index, in
  * This function adds a new entry to the DPTC log buffer.
  *
  * @param    dptc_log		pointer to the DPTC log buffer structure.
- * @param    wp			value of the working point index written 
+ * @param    wp			value of the working point index written
  *				to the log buffer.
  *
- * @return   number of log buffer entries. 
+ * @return   number of log buffer entries.
  *
  */
 static void add_dptc_log_entry(dptc_log_s * dptc_log, int wp)
 {
 	/*
-	 * Down the log buffer mutex to exclude others from reading and 
+	 * Down the log buffer mutex to exclude others from reading and
 	 * writing to the log buffer.
 	 */
 	if (down_interruptible(&dptc_log->mutex)) {
@@ -358,8 +358,8 @@ static void add_dptc_log_entry(dptc_log_
 }
 
 /*!
- * This function updates the drivers current working point index. This index is 
- * used for access the current DTPC table entry and it corresponds to the 
+ * This function updates the drivers current working point index. This index is
+ * used for access the current DTPC table entry and it corresponds to the
  * current CPU working point measured by the DPTC hardware.
  *
  * @param    new_wp	New working point index value to be set.
@@ -368,7 +368,7 @@ static void add_dptc_log_entry(dptc_log_
 static void set_dptc_wp(int new_wp)
 {
 	/*
-	 * Check if new index is smaller than the maximal working point 
+	 * Check if new index is smaller than the maximal working point
 	 * index in the DPTC translation table and larger that 0.
 	 */
 	if ((new_wp < dptc_params.dvfs_dptc_tables_ptr->wp_num)
@@ -378,13 +378,13 @@ static void set_dptc_wp(int new_wp)
 	}
 
 	/*
-	 * Check if new index is larger than the maximal working point index in 
+	 * Check if new index is larger than the maximal working point index in
 	 * the DPTC translation table.
 	 */
 	if (new_wp >= dptc_params.dvfs_dptc_tables_ptr->wp_num) {
-		/* 
-		 * Set current working point index to maximal working point 
-		 * index in the DPTC translation table. 
+		/*
+		 * Set current working point index to maximal working point
+		 * index in the DPTC translation table.
 		 */
 		dptc_params.dvfs_dptc_tables_ptr->curr_wp =
 		    dptc_params.dvfs_dptc_tables_ptr->wp_num - 1;
@@ -413,22 +413,22 @@ static void set_dptc_wp(int new_wp)
 static void dptc_workqueue_handler(void *arg)
 {
 	if (dptc_intr_status & 0x4) {
-		/* Chip working point has increased dramatically, 
+		/* Chip working point has increased dramatically,
 		 * raise working point to maximum */
 		set_dptc_wp(dptc_params.dvfs_dptc_tables_ptr->curr_wp - 2);
 	} else if (dptc_intr_status & 0x2) {
-		/* Chip working point has increased, raise working point 
+		/* Chip working point has increased, raise working point
 		 * by one */
 		set_dptc_wp(dptc_params.dvfs_dptc_tables_ptr->curr_wp + 1);
 	} else {
-		/* Chip working point has decreased, lower working point 
+		/* Chip working point has decreased, lower working point
 		 * by one */
 		set_dptc_wp(dptc_params.dvfs_dptc_tables_ptr->curr_wp - 1);
 	}
 
 	/*
-	 * If the DPTC module is still active, re-enable 
-	 * the DPTC hardware 
+	 * If the DPTC module is still active, re-enable
+	 * the DPTC hardware
 	 */
 	if (dptc_params.dptc_is_active) {
 		dptc_enable_dptc();
@@ -438,7 +438,7 @@ static void dptc_workqueue_handler(void 
 
 /*!
  * This function enables the DPTC module. this function updates the DPTC
- * thresholds, updates the MC13783, unmasks the DPTC interrupt and enables 
+ * thresholds, updates the MC13783, unmasks the DPTC interrupt and enables
  * the DPTC module
  *
  * @return      0 if DPTC module was enabled else returns -EINVAL.
@@ -452,7 +452,7 @@ static int start_dptc(void)
 		disable_ref_circuits(~dptc_params.rc_state);
 
 		/*
-		 * Set the DPTC thresholds and MC13783 voltage to 
+		 * Set the DPTC thresholds and MC13783 voltage to
 		 * correspond to the current working point and frequency.
 		 */
 		set_pmic_voltage(dptc_params.dvfs_dptc_tables_ptr,
@@ -477,9 +477,9 @@ static int start_dptc(void)
 }
 
 /*!
- * This function disables the DPTC module. 
+ * This function disables the DPTC module.
  *
- * @return      0 if DPTC module was disabled else returns -EINVAL. 
+ * @return      0 if DPTC module was disabled else returns -EINVAL.
  */
 static int stop_dptc(void)
 {
@@ -519,7 +519,7 @@ static void init_dptc_wp(void)
 	}
 
 	/*
-	 * Check if new index is smaller than the maximal working point 
+	 * Check if new index is smaller than the maximal working point
 	 * index in the DPTC translation table and larger that 0.
 	 */
 	if ((i < dptc_params.dvfs_dptc_tables_ptr->wp_num) && (i >= 0)) {
@@ -528,13 +528,13 @@ static void init_dptc_wp(void)
 	}
 
 	/*
-	 * Check if new index is larger than the maximal working point index in 
+	 * Check if new index is larger than the maximal working point index in
 	 * the DPTC translation table.
 	 */
 	if (i >= dptc_params.dvfs_dptc_tables_ptr->wp_num) {
-		/* 
-		 * Set current working point index to maximal working point 
-		 * index in the DPTC translation table. 
+		/*
+		 * Set current working point index to maximal working point
+		 * index in the DPTC translation table.
 		 */
 		dptc_params.dvfs_dptc_tables_ptr->curr_wp =
 		    dptc_params.dvfs_dptc_tables_ptr->wp_num - 1;
@@ -552,7 +552,7 @@ static void init_dptc_wp(void)
  *
  * @param    dptc_log	pointer to the DPTC log buffer structure.
  *
- * @return   number of log buffer entries. 
+ * @return   number of log buffer entries.
  *
  */
 static int get_entry_count(dptc_log_s * dptc_log)
@@ -566,17 +566,17 @@ static int get_entry_count(dptc_log_s * 
  * and returns the data written in the log buffer.
  *
  * @param    buf	pointer to the buffer the data should be written to.
- * @param    start	pointer to the pointer where the new data is 
+ * @param    start	pointer to the pointer where the new data is
  *                      written to.
- *			procedure should update the start pointer to point to 
+ *			procedure should update the start pointer to point to
  *			where in the buffer the data was written.
  * @param    offset	current offset in the DPTC proc file.
  * @param    count	number of bytes to read.
- * @param    eof	pointer to eof flag. should be set to 1 when 
+ * @param    eof	pointer to eof flag. should be set to 1 when
  *                      reaching eof.
  * @param    data	driver specific data pointer.
  *
- * @return   number byte read from the log buffer. 
+ * @return   number byte read from the log buffer.
  *
  */
 static int read_log(char *buf, char **start, off_t offset, int count,
@@ -597,8 +597,8 @@ static int read_log(char *buf, char **st
 	num_of_entries = get_entry_count(&params->dptc_log_buffer);
 
 	/*
-	 * If number of entries to read is larger that the number of entries 
-	 * in the log buffer set number of entries to read to number of 
+	 * If number of entries to read is larger that the number of entries
+	 * in the log buffer set number of entries to read to number of
 	 * entries in the log buffer and set eof flag to 1
 	 */
 	if (num_of_entries < entries_to_read) {
@@ -607,7 +607,7 @@ static int read_log(char *buf, char **st
 	}
 
 	/*
-	 * Down the log buffer mutex to exclude others from reading and 
+	 * Down the log buffer mutex to exclude others from reading and
 	 * writing to the log buffer.
 	 */
 	if (down_interruptible(&params->dptc_log_buffer.mutex)) {
@@ -630,7 +630,7 @@ static int read_log(char *buf, char **st
 		memcpy(buf, entry_ptr,
 		       (entries_to_read * sizeof(dptc_log_entry_s)));
 	} else {
-		/* 
+		/*
 		 * Tail wrap around.
 		 * First copy data from current position until end of buffer,
 		 * after that copy the rest from start of the log buffer.
@@ -685,9 +685,9 @@ static int init_dptc_controller(void)
 
 	if (create_proc_read_entry(PROC_NODE_NAME, 0,
 				   NULL, read_log, &dptc_params) == NULL) {
-		/* 
-		 * Error creating proc file system entry. 
-		 * Exit and return error code 
+		/*
+		 * Error creating proc file system entry.
+		 * Exit and return error code
 		 */
 		printk(KERN_ERR "DPTC: Unable create proc entry");
 		return -EFAULT;
@@ -1140,6 +1140,7 @@ read more than %d\n", MAX_TABLE_SIZE);
 static int dptc_mx27_ioctl(struct inode *inode, struct file *filp,
 			   unsigned int cmd, unsigned long arg)
 {
+	struct clk *clk;
 	unsigned int tmp;
 	int ret_val = -ENOIOCTLCMD;
 	char *tmp_str;
@@ -1219,7 +1220,8 @@ static int dptc_mx27_ioctl(struct inode 
 		break;
 
 	case PM_IOCGFREQ:
-		ret_val = mxc_get_clocks(CPU_CLK);
+		clk = clk_get(NULL, "cpu_clk");
+		ret_val = clk_get_rate(clk);
 		break;
 
 		/* Unknown ioctl command -> return error */
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/pm/dvfs_dptc.c linux-2.6.19.2/drivers/mxc/pm/dvfs_dptc.c
--- linux-2.6.19.2.orig/drivers/mxc/pm/dvfs_dptc.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/pm/dvfs_dptc.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -36,6 +36,7 @@
 #include <linux/fs.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <asm/uaccess.h>
 #include <linux/workqueue.h>
 #include <linux/proc_fs.h>
@@ -43,7 +44,6 @@
 #include <linux/jiffies.h>
 #include <linux/vmalloc.h>
 #include <asm/arch/hardware.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/pmic_external.h>
 
 /*
@@ -417,6 +417,7 @@ static int __init dvfs_dptc_init_default
 {
 	int res = 0;
 	char *table_str;
+	struct clk *clk;
 
 	dvfs_dptc_tables_s *default_table;
 
@@ -425,16 +426,19 @@ static int __init dvfs_dptc_init_default
 	if (!default_table) {
 		return -ENOMEM;
 	}
+
+	table_str = default_table_str;
+	if (cpu_is_mx31()) {
+		clk = clk_get(NULL, "ckih");
+		if (clk_get_rate(clk) == 27000000) {
+			printk(KERN_INFO
+			       "DVFS & DPTC: using 27MHz CKIH table\n");
 #ifdef CONFIG_ARCH_MX3
-	if (mxc_get_clocks(CKIH_CLK) == 27000000) {
-		printk("DVFS & DPTC: using 27MHz CKIH table\n");
-		table_str = default_table_str_27ckih;
-	} else {
+			table_str = default_table_str_27ckih;
 #endif
-		table_str = default_table_str;
-#ifdef CONFIG_ARCH_MX3
+		}
+		clk_put(clk);
 	}
-#endif
 
 	memset(default_table, 0, sizeof(dvfs_dptc_tables_s));
 	res = dvfs_dptc_parse_table(default_table, table_str);
@@ -995,6 +999,7 @@ static ssize_t dvfs_dptc_read(struct fil
 static int dvfs_dptc_ioctl(struct inode *inode, struct file *filp,
 			   unsigned int cmd, unsigned long arg)
 {
+	struct clk *clk;
 	unsigned int tmp;
 	int ret_val = -ENOIOCTLCMD;
 	char *tmp_str;
@@ -1135,7 +1140,8 @@ static int dvfs_dptc_ioctl(struct inode 
 		break;
 #endif				/* CONFIG_MXC_DVFS */
 	case PM_IOCGFREQ:
-		ret_val = mxc_get_clocks(CPU_CLK);
+		clk = clk_get(NULL, "cpu_clk");
+		ret_val = clk_get_rate(clk);
 		break;
 
 		/* Unknown ioctl command -> return error */
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/security/mxc_rtic.c linux-2.6.19.2/drivers/mxc/security/mxc_rtic.c
--- linux-2.6.19.2.orig/drivers/mxc/security/mxc_rtic.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/security/mxc_rtic.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -26,9 +26,9 @@
  */
 
 #include "mxc_rtic.h"
-#include <asm/arch/clock.h>
 
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #ifdef CONFIG_MXC_RTIC_TEST_DEBUG
 #include <linux/module.h>
 #endif				/* CONFIG_MXC_RTIC_TEST_DEBUG */
@@ -44,9 +44,10 @@
 
 void rtic_init(void)
 {
-#ifdef CONFIG_ARCH_MX27
-	mxc_clks_enable(RTIC_CLK);
-#endif				/* CONFIG_ARCH_MX27 */
+	struct clk *clk;
+
+	clk = clk_get(NULL, "rtic_clk");
+	clk_enable(clk);
 }
 
 /*!
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/security/mxc_scc.c linux-2.6.19.2/drivers/mxc/security/mxc_scc.c
--- linux-2.6.19.2.orig/drivers/mxc/security/mxc_scc.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/security/mxc_scc.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -49,9 +49,9 @@
  */
 
 #include "mxc_scc_internals.h"
-#include <asm/arch/clock.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 /******************************************************************************
  *
  *  Global / Static Variables
@@ -75,8 +75,9 @@
  * #SCC_WRITE_REGISTER macros and their ilk.  All dereferences must be
  * 32 bits wide.
  */
-#define static
-static volatile void *scc_base;
+//#define static
+static void *scc_base;
+static struct clk *scc_clk;
 
 /*! Array to hold function pointers registered by
     #scc_monitor_security_failure() and processed by
@@ -169,7 +170,7 @@ static int mxc_scc_suspend(struct platfo
 #endif
 
 	/* Turn off clock */
-	mxc_clks_disable(SCC_CLK);
+	clk_disable(scc_clk);
 
 	return 0;
 }
@@ -189,7 +190,7 @@ static int mxc_scc_resume(struct platfor
 #endif
 
 	/* Turn on clock */
-	mxc_clks_enable(SCC_CLK);
+	clk_enable(scc_clk);
 
 	return 0;
 }
@@ -240,13 +241,12 @@ static int scc_init(void)
 	int return_value = -EIO;	/* assume error */
 
 	/* Enable the SCC clocks  */
-#if defined(CONFIG_ARCH_MX27)
 #ifdef SCC_DEBUG
 	printk(KERN_ALERT "SCC: Enabling the SCC CLK ... \n");
 
 #endif				/* SCC_DEBUG */
-	mxc_clks_enable(SCC_CLK);
-#endif				/* CONFIG_ARCH_MX27 */
+	scc_clk = clk_get(NULL, "scc_clk");
+	clk_enable(scc_clk);
 
 	ret = platform_driver_register(&mxc_scc_driver);
 
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/security/mxc_scc_internals.h linux-2.6.19.2/drivers/mxc/security/mxc_scc_internals.h
--- linux-2.6.19.2.orig/drivers/mxc/security/mxc_scc_internals.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/security/mxc_scc_internals.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -263,9 +263,6 @@ struct scc_key_slot {
 	uint32_t status;	/**< 0 = unassigned, 1 = assigned. */
 };
 
-/*! Calculated once for quick reference to max address in SCM */
-extern uint32_t scm_highest_memory_address;
-
 /* Forward-declare a number routines which are not part of user api */
 static int scc_init(void);
 static void scc_cleanup(void);
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/security/sahara2/include/linux_port.h linux-2.6.19.2/drivers/mxc/security/sahara2/include/linux_port.h
--- linux-2.6.19.2.orig/drivers/mxc/security/sahara2/include/linux_port.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/security/sahara2/include/linux_port.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -70,7 +70,7 @@
 
 #include <linux/platform_device.h>	/* used in dynamic power management */
 
-#include <asm/arch/clock.h>	/* clock en/disable for DPM */
+#include <linux/clk.h>	/* clock en/disable for DPM */
 
 #include <linux/dmapool.h>
 #include <linux/dma-mapping.h>
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/security/sahara2/sah_driver_interface.c linux-2.6.19.2/drivers/mxc/security/sahara2/sah_driver_interface.c
--- linux-2.6.19.2.orig/drivers/mxc/security/sahara2/sah_driver_interface.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/security/sahara2/sah_driver_interface.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -156,6 +156,7 @@ static char Diag_msg[DIAG_MSG_SIZE];
 */
 OS_DEV_INIT(sah_init)
 {
+	struct clk *clk;
 	/* Status variable */
 	int os_error_code = 0;
 #ifdef DIAG_DRV_IF
@@ -168,7 +169,8 @@ OS_DEV_INIT(sah_init)
 #ifdef DIAG_DRV_IF
 	LOG_KDIAG("SAHARA : Enabling the IPG and AHB clocks\n")
 #endif				/*DIAG_DRV_IF */
-	    mxc_clks_enable(SAHARA2_CLK);
+	clk = clk_get(NULL, "sahara_clk");
+	clk_enable(clk);
 
 	if (os_error_code == 0) {
 		sah_hw_version = sah_HW_Read_Version();
@@ -322,6 +324,7 @@ OS_DEV_SHUTDOWN(sah_cleanup)
 #if defined(CONFIG_DEVFS_FS) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
 	devfs_unregister(Sahara_devfs_handle);
 #else
+	struct clk *clk;
 	int ret_val = 0;
 
 	if (Sahara_procfs_handle != NULL) {
@@ -355,7 +358,8 @@ OS_DEV_SHUTDOWN(sah_cleanup)
 #ifdef DIAG_DRV_IF
 	LOG_KDIAG("SAHARA : Disabling the clocks\n")
 #endif				/*DIAG_DRV_IF */
-	    mxc_clks_disable(SAHARA2_CLK);
+	clk = clk_get(NULL, "sahara_clk");
+	clk_disable(clk);
 
 	os_dev_shutdown_return(OS_ERROR_OK_S);
 }
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/ssi/ssi.c linux-2.6.19.2/drivers/mxc/ssi/ssi.c
--- linux-2.6.19.2.orig/drivers/mxc/ssi/ssi.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/ssi/ssi.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -24,7 +24,6 @@
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <asm/uaccess.h>
-#include <asm/arch/clock.h>
 
 #include "registers.h"
 #include "ssi.h"
diff -uNpr linux-2.6.19.2.orig/drivers/mxc/vpu/mxc_vpu.c linux-2.6.19.2/drivers/mxc/vpu/mxc_vpu.c
--- linux-2.6.19.2.orig/drivers/mxc/vpu/mxc_vpu.c	2007-04-25 17:36:54.000000000 -0600
+++ linux-2.6.19.2/drivers/mxc/vpu/mxc_vpu.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -34,6 +34,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/wait.h>
 #include <linux/list.h>
+#include <linux/clk.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -41,7 +42,6 @@
 #include <asm/dma-mapping.h>
 #include <asm/hardware.h>
 
-#include <asm/arch/clock.h>
 #include <asm/arch/mxc_vpu.h>
 
 #define	BIT_INT_CLEAR		0x00C
@@ -65,6 +65,7 @@ static int vpu_major = 0;
 static struct class *vpu_class;
 static struct vpu vpu_data;
 static u8 open_count = 0;
+static struct clk *vpu_clk;
 
 /* implement the blocking ioctl */
 static int codec_done = 0;
@@ -119,7 +120,7 @@ static irqreturn_t vpu_irq_handler(int i
  */
 static int vpu_hardware_enable(void)
 {
-	mxc_clks_enable(VPU_BAUD);
+	clk_enable(vpu_clk);
 	/* enable user space access for vpu register */
 	__raw_writel(0x1, IO_ADDRESS(AIPI_BASE_ADDR + 0x20008));
 	return 0;
@@ -132,7 +133,7 @@ static int vpu_hardware_enable(void)
  */
 static int vpu_hardware_disable(void)
 {
-	mxc_clks_disable(VPU_BAUD);
+	clk_disable(vpu_clk);
 	__raw_writel(0xffffffff, IO_ADDRESS(AIPI_BASE_ADDR + 0x20008));
 	return 0;
 
@@ -384,6 +385,8 @@ static int vpu_dev_probe(struct platform
 		goto err_out_class;
 	}
 
+	vpu_clk = clk_get(&pdev->dev, "vpu_clk");
+
 	request_irq(INT_VPU, vpu_irq_handler, 0, "VPU_CODEC_IRQ",
 		    (void *)(&vpu_data));
 
@@ -432,6 +435,8 @@ static void __exit vpu_exit(void)
 		vpu_major = 0;
 	}
 
+	clk_put(vpu_clk);
+
 	platform_driver_unregister(&mxcvpu_driver);
 	return;
 }
diff -uNpr linux-2.6.19.2.orig/drivers/net/fec.c linux-2.6.19.2/drivers/net/fec.c
--- linux-2.6.19.2.orig/drivers/net/fec.c	2007-04-25 17:37:32.000000000 -0600
+++ linux-2.6.19.2/drivers/net/fec.c	2007-04-25 17:37:51.000000000 -0600
@@ -25,7 +25,7 @@
  * Copyright (c) 2004-2006 Macq Electronique SA.
  */
 /*
- * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2006-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 #include <linux/module.h>
@@ -45,6 +45,7 @@
 #include <linux/spinlock.h>
 #include <linux/workqueue.h>
 #include <linux/bitops.h>
+#include <linux/clk.h>
 
 #include <asm/irq.h>
 #include <asm/uaccess.h>
@@ -60,7 +61,6 @@
 #define FEC_ALIGNMENT  (0x03)          /*FEC needs 4bytes alignment*/
 #elif defined(CONFIG_ARCH_MXC)
 #include <asm/arch/hardware.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/iim.h>
 #include "fec.h"
 #define FEC_ALIGNMENT  (0x0F)          /*FEC needs 128bits(32bytes) alignment*/	
@@ -247,6 +247,8 @@ struct fec_enet_private {
 	int	link;
 	int	old_link;
 	int	full_duplex;
+
+	struct clk *clk;
 };
 
 static int fec_enet_open(struct net_device *dev);
@@ -2017,8 +2019,11 @@ extern void gpio_fec_inactive(void);
  */
 static void __inline__ fec_arch_init(void)
 {
+	struct clk *clk;
 	gpio_fec_active();
-	mxc_clks_enable(FEC_CLK);
+	clk = clk_get(NULL, "fec_clk");
+	clk_enable(clk);
+	clk_put(clk);
 	return;
 }
 /*
@@ -2026,7 +2031,10 @@ static void __inline__ fec_arch_init(voi
  */
 static void __inline__ fec_arch_exit(void)
 {
-	mxc_clks_disable(FEC_CLK);
+	struct clk *clk;
+	clk = clk_get(NULL, "fec_clk");
+	clk_disable(clk);
+	clk_put(clk);
 	gpio_fec_inactive();
 	return;
 }
@@ -2057,6 +2065,8 @@ static void __inline__ fec_release_intrs
 
 static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
 {
+	u32 rate;
+	struct clk *clk;
 	volatile fec_t *fecp;
 	fecp = fep->hwp;
 	fecp->fec_r_cntrl = OPT_FRAME_SIZE | 0x04;
@@ -2065,8 +2075,12 @@ static void __inline__ fec_set_mii(struc
  	/*
 	 * Set MII speed to 2.5 MHz
 	 */
+	clk = clk_get(NULL, "fec_clk");
+	rate = clk_get_rate(clk);
+	clk_put(clk);
+
 	fep->phy_speed =
-		((((mxc_get_clocks(AHB_CLK) / 2 + 4999999) / 2500000) / 2) & 0x3F) << 1;
+		((((rate / 2 + 4999999) / 2500000) / 2) & 0x3F) << 1;
 	fecp->fec_mii_speed = fep->phy_speed;
 	fec_restart(dev, 0);
 }
diff -uNpr linux-2.6.19.2.orig/drivers/net/irda/mxc_ir.c linux-2.6.19.2/drivers/net/irda/mxc_ir.c
--- linux-2.6.19.2.orig/drivers/net/irda/mxc_ir.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/net/irda/mxc_ir.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -36,6 +36,7 @@
 #include <linux/delay.h>
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
+#include <linux/clk.h>
 
 #include <net/irda/irda.h>
 #include <net/irda/wrapper.h>
@@ -45,7 +46,6 @@
 #include <asm/dma.h>
 #include <asm/hardware.h>
 #include <asm/arch/mxc_uart.h>
-#include <asm/arch/clock.h>
 #include "mxc_ir.h"
 
 #define IS_SIR(mi)		( (mi)->speed <= 115200 )
@@ -174,7 +174,17 @@ struct mxc_irda {
 	/*!
 	 * UART clock needed for baud rate calculations
 	 */
-	unsigned int uartclk;
+	struct clk *uart_clk;
+
+	/*!
+	 * UART clock needed for baud rate calculations
+	 */
+	unsigned long uart_clk_rate;
+
+	/*!
+	 * FIRI clock needed for baud rate calculations
+	 */
+	struct clk *firi_clk;
 
 	/*!
 	 * FIRI IRQ number.
@@ -216,9 +226,6 @@ struct mxc_irda {
 extern void gpio_firi_active(void *, unsigned int);
 extern void gpio_firi_inactive(void);
 extern void gpio_firi_init(void);
-extern unsigned int firi_get_clocks(void);
-extern void firi_disable_uart_clock(void);
-extern void firi_enable_uart_clock(void);
 
 void mxc_irda_firi_init(struct mxc_irda *si);
 #ifdef FIRI_SDMA_RX
@@ -338,8 +345,8 @@ static int mxc_irda_set_speed(struct mxc
 		gpio_firi_inactive();
 
 		num = baud / 100 - 1;
-		denom = si->uartclk / 1600 - 1;
-		if ((denom < 65536) && (si->uartclk > 1600)) {
+		denom = si->uart_clk_rate / 1600 - 1;
+		if ((denom < 65536) && (si->uart_clk_rate > 1600)) {
 			writel(num, si->uart_base + MXC_UARTUBIR);
 			writel(denom, si->uart_base + MXC_UARTUBMR);
 		}
@@ -383,7 +390,7 @@ static int mxc_irda_set_speed(struct mxc
 		writel(cr, si->firi_base + FIRITCR);
 
 		gpio_firi_active(si->firi_base + FIRITCR, FIRITCR_TPP);
-		
+
 		si->speed = speed;
 
 		cr = readl(si->firi_base + FIRIRCR);
@@ -1053,8 +1060,14 @@ void mxc_irda_firi_init(struct mxc_irda 
 	unsigned int firi_baud, osf = 6;
 	unsigned int tcr, rcr, cr;
 
-	firi_baud = mxc_get_clocks(FIRI_BAUD);
-	mxc_clks_enable(FIRI_BAUD);
+	si->firi_clk = clk_get(si->dev, "firi_clk");
+	firi_baud = clk_round_rate(si->firi_clk, 48004500);
+	if ((firi_baud < 47995500) ||
+		(clk_set_rate(si->firi_clk, firi_baud) < 0)) {
+		dev_err(si->dev, "Unable to set FIR clock to 48MHz.\n");
+		return;
+	}
+	clk_enable(si->firi_clk);
 
 	writel(0xFFFF, si->firi_base + FIRITSR);
 	writel(0xFFFF, si->firi_base + FIRIRSR);
@@ -1115,7 +1128,7 @@ static int mxc_irda_uart_init(struct mxc
 	/* Configure the IOMUX for the UART */
 	gpio_firi_init();
 
-	per_clk = firi_get_clocks();
+	per_clk = clk_get_rate(si->uart_clk);
 	baud = per_clk / 16;
 	if (baud > MAX_UART_BAUDRATE) {
 		baud = MAX_UART_BAUDRATE;
@@ -1124,8 +1137,10 @@ static int mxc_irda_uart_init(struct mxc
 			d = 6;
 		}
 	}
-	si->uartclk = per_clk / d;
-	writel(si->uartclk / 1000, si->uart_base + MXC_UARTONEMS);
+	clk_enable(si->uart_clk);
+
+	si->uart_clk_rate = per_clk / d;
+	writel(si->uart_clk_rate / 1000, si->uart_base + MXC_UARTONEMS);
 
 	writel(MXC_IRDA_RX_INV | MXC_UARTUCR4_IRSC,
 	       si->uart_base + MXC_UARTUCR4);
@@ -1155,9 +1170,9 @@ static int mxc_irda_uart_init(struct mxc
 
 	baud = 9600;
 	num = baud / 100 - 1;
-	denom = si->uartclk / 1600 - 1;
+	denom = si->uart_clk_rate / 1600 - 1;
 
-	if ((denom < 65536) && (si->uartclk > 1600)) {
+	if ((denom < 65536) && (si->uart_clk_rate > 1600)) {
 		writel(num, si->uart_base + MXC_UARTUBIR);
 		writel(denom, si->uart_base + MXC_UARTUBMR);
 	}
@@ -1469,7 +1484,7 @@ static int mxc_irda_suspend(struct platf
 		cr = readl(si->uart_base + MXC_UARTUCR1);
 		cr &= ~MXC_UARTUCR1_UARTEN;
 		writel(cr, si->uart_base + MXC_UARTUCR1);
-		firi_disable_uart_clock();
+		clk_disable(si->uart_clk);
 
 		/*Disable Tx and Rx for FIRI and then disable the FIRI clock.. */
 		cr = readl(si->firi_base + FIRITCR);
@@ -1478,7 +1493,7 @@ static int mxc_irda_suspend(struct platf
 		cr = readl(si->firi_base + FIRIRCR);
 		cr &= ~FIRIRCR_RE;
 		writel(cr, si->firi_base + FIRIRCR);
-		mxc_clks_disable(FIRI_BAUD);
+		clk_disable(si->firi_clk);
 
 		gpio_firi_inactive();
 
@@ -1511,7 +1526,7 @@ static int mxc_irda_resume(struct platfo
 	if (si->suspend == 1 && !si->open) {
 
 		/*Initialise the UART first */
-		firi_enable_uart_clock();
+		clk_enable(si->uart_clk);
 
 		/*Now init FIRI */
                 gpio_firi_active(si->firi_base + FIRITCR, FIRITCR_TPP);
@@ -1612,6 +1627,7 @@ static int mxc_irda_probe(struct platfor
 	si->dev = &pdev->dev;
 
 	si->mxc_ir_plat = pdev->dev.platform_data;
+	si->uart_clk = si->mxc_ir_plat->uart_clk;
 
 	si->uart_res = uart_res;
 	si->firi_res = firi_res;
diff -uNpr linux-2.6.19.2.orig/drivers/pcmcia/mx31ads-pcmcia.c linux-2.6.19.2/drivers/pcmcia/mx31ads-pcmcia.c
--- linux-2.6.19.2.orig/drivers/pcmcia/mx31ads-pcmcia.c	2007-04-25 17:28:15.000000000 -0600
+++ linux-2.6.19.2/drivers/pcmcia/mx31ads-pcmcia.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,7 +1,7 @@
 /*======================================================================
     drivers/pcmcia/mx31ads-pcmica.c
 
-    Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+    Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
 
     Device driver for the PCMCIA control functionality of i.Mx31
     microprocessors.
@@ -36,13 +36,13 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 
 #include <pcmcia/version.h>
 #include <pcmcia/cs_types.h>
 #include <pcmcia/cs.h>
 #include <pcmcia/ss.h>
 #include <asm/mach-types.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/pcmcia.h>
 #include <linux/interrupt.h>
 #include <linux/delay.h>
@@ -842,15 +842,13 @@ mx31ads_common_pcmcia_get_timing(struct 
 	    calc_speed(skt->spd_attr, MAX_WIN, PCMCIA_ATTR_MEM_ACCESS);
 }
 
-extern unsigned long mxc_get_clocks(enum mxc_clocks clk);
-
 static int mx31ads_pcmcia_set_timing(struct mx31ads_pcmcia_socket *skt)
 {
 	u_int clk_ns;
 	struct mx31ads_pcmcia_timing timing;
 
 	/* How many nanoseconds */
-	clk_ns = (1000 * 1000 * 1000) / mxc_get_clocks(AHB_CLK);
+	clk_ns = (1000 * 1000 * 1000) / clk_get_rate(skt->clk);
 	pr_debug(KERN_INFO "clk_ns = %d\n", clk_ns);
 
 	mx31ads_common_pcmcia_get_timing(skt, &timing);
@@ -1072,6 +1070,8 @@ static int mx31ads_common_drv_pcmcia_pro
 	skt->dev = &pdev->dev;
 	skt->ops = ops;
 
+	skt->clk = clk_get(NULL, "pcmcia_clk");
+
 	skt->res_skt.start = _PCMCIA(0);
 	skt->res_skt.end = _PCMCIA(0) + PCMCIASp - 1;
 	skt->res_skt.name = MX31ADS_PCMCIA;
diff -uNpr linux-2.6.19.2.orig/drivers/pcmcia/mx31ads-pcmcia.h linux-2.6.19.2/drivers/pcmcia/mx31ads-pcmcia.h
--- linux-2.6.19.2.orig/drivers/pcmcia/mx31ads-pcmcia.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/pcmcia/mx31ads-pcmcia.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,7 +1,7 @@
 /*
  * linux/drivers/pcmcia/mx31ads-pcmcia.h
  *
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  *
  * This file contains definitions for the PCMCIA support code common to
  * integrated SOCs like the i.Mx31 microprocessors.
@@ -38,6 +38,8 @@ struct mx31ads_pcmcia_socket {
 	unsigned int nr;
 	unsigned int irq;
 
+	struct clk *clk;
+
 	/*
 	 * Core PCMCIA state
 	 */
diff -uNpr linux-2.6.19.2.orig/drivers/serial/mxc_uart.c linux-2.6.19.2/drivers/serial/mxc_uart.c
--- linux-2.6.19.2.orig/drivers/serial/mxc_uart.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/serial/mxc_uart.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -34,6 +34,7 @@
 #include <linux/platform_device.h>
 #include <linux/sysrq.h>
 #include <linux/dma-mapping.h>
+#include <linux/clk.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/dma.h>
@@ -1275,7 +1276,7 @@ static void mxcuart_set_termios(struct u
 	cr2_mask = ~(MXC_UARTUCR2_IRTS | MXC_UARTUCR2_CTSC | MXC_UARTUCR2_PREN |
 		     MXC_UARTUCR2_PROE | MXC_UARTUCR2_STPB | MXC_UARTUCR2_WS);
 
-	per_clk = mxc_get_clocks(umxc->clock_id);
+	per_clk = clk_get_rate(umxc->clk);
 
 	mxcuart_get_maxbaud(per_clk, &max_baud);
 	/*
@@ -1510,9 +1511,9 @@ mxcuart_pm(struct uart_port *port, unsig
 	uart_mxc_port *umxc = (uart_mxc_port *) port;
 
 	if (state)
-		mxc_clks_disable(umxc->clock_id);
+		clk_disable(umxc->clk);
 	else
-		mxc_clks_enable(umxc->clock_id);
+		clk_enable(umxc->clk);
 }
 
 /*!
@@ -1792,7 +1793,7 @@ static int mxcuart_resume(struct platfor
  *                information that is used by the suspend, resume and remove
  *                functions
  *
- * @return  The function always returns 0.
+ * @return  The function returns 0 if successful; -1 otherwise.
  */
 static int mxcuart_probe(struct platform_device *pdev)
 {
@@ -1809,6 +1810,11 @@ static int mxcuart_probe(struct platform
 		if (mxc_ports[id]->dma_enabled == 1) {
 			mxc_ports[id]->port.flags |= UPF_LOW_LATENCY;
 		}
+
+		mxc_ports[id]->clk = clk_get(&pdev->dev, "uart_clk");
+		if (mxc_ports[id]->clk == NULL)
+			return -1;
+
 		uart_add_one_port(&mxc_reg, &mxc_ports[id]->port);
 		platform_set_drvdata(pdev, mxc_ports[id]);
 		pdev->dev.power.can_wakeup = 1;
diff -uNpr linux-2.6.19.2.orig/drivers/spi/mxc_spi.c linux-2.6.19.2/drivers/spi/mxc_spi.c
--- linux-2.6.19.2.orig/drivers/spi/mxc_spi.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/spi/mxc_spi.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -28,6 +28,7 @@
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/types.h>
+#include <linux/clk.h>
 
 #include <linux/spi/spi.h>
 #include <linux/spi/spi_bitbang.h>
@@ -36,7 +37,6 @@
 #include <asm/irq.h>
 #include <asm/io.h>
 #include <asm/arch/gpio.h>
-#include <asm/arch/clock.h>
 
 #ifdef CONFIG_ARCH_MX27
 #include "mxc_spi_mx27.h"
@@ -194,7 +194,7 @@ struct mxc_spi {
 	/*!
 	 * CSPI Clock id.
 	 */
-	enum mxc_clocks clock_id;
+	struct clk *clk;
 	/*!
 	 * CSPI input clock SCLK.
 	 */
@@ -576,13 +576,12 @@ static int mxc_spi_probe(struct platform
 
 	/* Set this master's data from platform_info */
 
-	master->bus_num = mxc_platform_info->bus_num;
+	master->bus_num = pdev->id + 1;
 	master->num_chipselect = mxc_platform_info->maxchipselect;
 
 	/* Set the master controller driver data for this master */
 
 	master_drv_data = spi_master_get_devdata(master);
-	master_drv_data->clock_id = mxc_platform_info->clock;
 	master_drv_data->mxc_bitbang.master = spi_master_get(master);
 
 	/* Set the master bitbang data */
@@ -663,10 +662,9 @@ static int mxc_spi_probe(struct platform
 
 	/* Enable the CSPI Clock, CSPI Module, set as a master */
 
-	mxc_clks_enable(master_drv_data->clock_id);
-
-	master_drv_data->spi_ipg_clk =
-	    mxc_get_clocks(master_drv_data->clock_id);
+	master_drv_data->clk = clk_get(&pdev->dev, "cspi_clk");
+	clk_enable(master_drv_data->clk);
+	master_drv_data->spi_ipg_clk = clk_get_rate(master_drv_data->clk);
 
 	__raw_writel(MXC_CSPICTRL_ENABLE | MXC_CSPICTRL_MASTER,
 		     master_drv_data->base + MXC_CSPICTRL);
@@ -702,7 +700,8 @@ static int mxc_spi_probe(struct platform
 
       err2:
 	gpio_spi_inactive(master->bus_num - 1);
-	mxc_clks_disable(master_drv_data->clock_id);
+	clk_disable(master_drv_data->clk);
+	clk_put(master_drv_data->clk);
 	free_irq(master_drv_data->irq, master_drv_data);
       err1:
 	release_mem_region(pdev->resource[0].start,
@@ -732,7 +731,7 @@ static int mxc_spi_remove(struct platfor
 		    spi_master_get_devdata(master);
 
 		gpio_spi_inactive(master->bus_num - 1);
-		mxc_clks_disable(master_drv_data->clock_id);
+		clk_disable(master_drv_data->clk);
 
 		/* Disable the CSPI module */
 
@@ -832,7 +831,7 @@ static int mxc_spi_suspend(struct platfo
 	__raw_writel(MXC_CSPICTRL_DISABLE,
 		     master_drv_data->base + MXC_CSPICTRL);
 
-	mxc_clks_disable(master_drv_data->clock_id);
+	clk_disable(master_drv_data->clk);
 	gpio_spi_inactive(master->bus_num - 1);
 
 	return ret;
@@ -852,7 +851,7 @@ static int mxc_spi_resume(struct platfor
 	struct mxc_spi *master_drv_data = spi_master_get_devdata(master);
 
 	gpio_spi_active(master->bus_num - 1);
-	mxc_clks_enable(master_drv_data->clock_id);
+	clk_enable(master_drv_data->clk);
 
 	spi_bitbang_resume(&master_drv_data->mxc_bitbang);
 	__raw_writel(MXC_CSPICTRL_ENABLE | MXC_CSPICTRL_MASTER,
diff -uNpr linux-2.6.19.2.orig/drivers/video/mxc/mx2fb.c linux-2.6.19.2/drivers/video/mxc/mx2fb.c
--- linux-2.6.19.2.orig/drivers/video/mxc/mx2fb.c	2007-04-25 17:37:42.000000000 -0600
+++ linux-2.6.19.2/drivers/video/mxc/mx2fb.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -33,8 +33,8 @@
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
+#include <linux/clk.h>
 #include <asm/uaccess.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/mxcfb.h>
 
 #include "mx2fb.h"
@@ -51,7 +51,7 @@ static int fb_enabled = 0;
 static unsigned long default_bpp = 16;
 static unsigned char brightness = 255;
 static ATOMIC_NOTIFIER_HEAD(mx2fb_notifier_list);
-
+static struct clk *lcdc_clk;
 /*!
  * @brief Structure containing the MX2 specific framebuffer information.
  */
@@ -845,7 +845,7 @@ static void _enable_lcdc(struct fb_info 
 	if (mx2fbi->type == MX2FB_TYPE_GW)
 		_enable_graphic_window(info);
 	else if (!fb_enabled) {
-		mxc_clks_enable(LCDC_CLK);
+		clk_enable(lcdc_clk);
 		gpio_lcdc_active();
 		board_power_lcd(1);
 		_set_brightness(brightness);
@@ -882,7 +882,7 @@ static void _disable_lcdc(struct fb_info
 			gpio_lcdc_inactive();
 			board_power_lcd(0);
 			_set_brightness(0);
-			mxc_clks_disable(LCDC_CLK);
+			clk_disable(lcdc_clk);
 			fb_enabled = 0;
 		}
 #ifdef CONFIG_FB_MXC_TVOUT
@@ -1050,11 +1050,15 @@ static void _update_lcdc(struct fb_info 
 	__raw_writel(info->var.xres_virtual >> 1, LCDC_REG(LCDC_LVPWR));
 
 	/* To setup LCDC pixel clock */
-	mxc_set_clocks_div(LCDC_CLK, 1);
+	perclk3 = clk_round_rate(lcdc_clk, 133000000);
+	if (clk_set_rate(lcdc_clk, perclk3)) {
+		printk(KERN_INFO "mx2fb: Unable to set clock to %lu\n",
+		       perclk3);
+		perclk3 = clk_get_rate(lcdc_clk);
+	}
 
 	/* Calculate pixel clock divider, and round to the nearest integer */
-	perclk3 = mxc_get_clocks(PERCLK3);
-	pcd = (perclk3 * 10 / (PICOS2KHZ(var->pixclock) * 1000UL) + 5) / 10;
+	pcd = (perclk3 * 8 / (PICOS2KHZ(var->pixclock) * 1000UL) + 4) / 8;
 	if (--pcd > 0x3F)
 		pcd = 0x3F;
 
@@ -1265,6 +1269,8 @@ static int mx2fb_probe(struct platform_d
 {
 	int ret, i;
 
+	lcdc_clk = clk_get(&pdev->dev, "lcdc_clk");
+
 	for (i = 0; i < sizeof(mx2fb_info) / sizeof(struct fb_info); i++) {
 		if ((ret = _install_fb(&mx2fb_info[i], pdev))) {
 			dev_err(&pdev->dev,
diff -uNpr linux-2.6.19.2.orig/drivers/w1/masters/mxc_w1.c linux-2.6.19.2/drivers/w1/masters/mxc_w1.c
--- linux-2.6.19.2.orig/drivers/w1/masters/mxc_w1.c	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/drivers/w1/masters/mxc_w1.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -43,9 +43,9 @@
 #include <linux/timer.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
+#include <linux/clk.h>
 #include <asm/hardware.h>
 #include <asm/setup.h>
-#include <asm/arch/clock.h>
 
 #include "../w1.h"
 #include "../w1_int.h"
@@ -90,6 +90,7 @@ struct mxc_w1_device {
 	char *base_address;
 	unsigned long found;
 	unsigned int clkdiv;
+	struct clk *clk;
 	struct w1_bus_master *bus_master;
 };
 
@@ -164,7 +165,7 @@ static u8 mxc_w1_ds2_touch_bit(void *dat
  */
 static void mxc_w1_hw_init(struct mxc_w1_device *dev)
 {
-	mxc_clks_enable(OWIRE_CLK);
+	clk_enable(dev->clk);
 
 	/* set the timer divider clock to divide by 65 */
 	/* as the clock to the One Wire is at 66.5MHz */
@@ -173,11 +174,6 @@ static void mxc_w1_hw_init(struct mxc_w1
 	return;
 }
 
-static int mxc_w1_getdiv(void)
-{
-	return ((mxc_get_clocks(OWIRE_CLK) / 1000000) - 1);
-}
-
 /*!
  * this is the probe routine for the One Wire driver.
  * It is called during the driver initilaization.
@@ -191,17 +187,17 @@ static int __devinit mxc_w1_probe(struct
 	struct mxc_w1_device *dev;
 	int err = 0;
 
-	dev = kmalloc(sizeof(struct mxc_w1_device) +
+	dev = kzalloc(sizeof(struct mxc_w1_device) +
 		      sizeof(struct w1_bus_master), GFP_KERNEL);
 	if (!dev) {
 		return -ENOMEM;
 	}
 
-	memset(dev, 0,
-	       sizeof(struct mxc_w1_device) + sizeof(struct w1_bus_master));
+	dev->clk = clk_get(&pdev->dev, "owire_clk");
+
 	dev->bus_master = (struct w1_bus_master *)(dev + 1);
 	dev->found = 1;
-	dev->clkdiv = mxc_w1_getdiv();
+	dev->clkdiv = (clk_get_rate(dev->clk) / 1000000) - 1;
 	dev->base_address = (void *)IO_ADDRESS(OWIRE_BASE_ADDR);
 
 	mxc_w1_hw_init(dev);
@@ -232,6 +228,7 @@ static int mxc_w1_remove(struct platform
 {
 	struct mxc_w1_device *dev = platform_get_drvdata(pdev);
 
+	clk_put(dev->clk);
 	if (dev->found) {
 		w1_remove_master_device(dev->bus_master);
 	}
diff -uNpr linux-2.6.19.2.orig/include/asm-arm/arch-mxc/board.h linux-2.6.19.2/include/asm-arm/arch-mxc/board.h
--- linux-2.6.19.2.orig/include/asm-arm/arch-mxc/board.h	2007-04-25 17:37:33.000000000 -0600
+++ linux-2.6.19.2/include/asm-arm/arch-mxc/board.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -18,8 +18,6 @@
 #error "Do not include directly."
 #endif
 
-#include <asm/arch/clock.h>
-
 #ifndef __ASSEMBLY__
 
 struct mxc_ipu_config {
@@ -28,10 +26,10 @@ struct mxc_ipu_config {
 
 struct mxc_ir_platform_data {
 	int uart_ir_mux;
+	struct clk *uart_clk;
 };
 
 struct mxc_i2c_platform_data {
-	enum mxc_clocks clk;
 	u32 i2c_clk;
 };
 
diff -uNpr linux-2.6.19.2.orig/include/asm-arm/arch-mxc/board-mx27ads.h linux-2.6.19.2/include/asm-arm/arch-mxc/board-mx27ads.h
--- linux-2.6.19.2.orig/include/asm-arm/arch-mxc/board-mx27ads.h	2007-04-25 17:37:33.000000000 -0600
+++ linux-2.6.19.2/include/asm-arm/arch-mxc/board-mx27ads.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -34,11 +34,6 @@
  */
 #include <asm/arch/board.h>
 
-#define CKIH_CLK_FREQ           26000000	/* 26M reference clk */
-#define CKIH_CLK_FREQ_27MHZ     27000000
-#define CKIL_CLK_FREQ           (32768 * 1024)	/* 32.768k oscillator in */
-#define CKIH_27MHZ_BIT_SET      (1 << 3)
-
 /* Start of physical RAM */
 #define PHYS_OFFSET             UL(0xA0000000)
 
diff -uNpr linux-2.6.19.2.orig/include/asm-arm/arch-mxc/clock.h linux-2.6.19.2/include/asm-arm/arch-mxc/clock.h
--- linux-2.6.19.2.orig/include/asm-arm/arch-mxc/clock.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/include/asm-arm/arch-mxc/clock.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2005-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2005-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -28,281 +28,56 @@
  *
  * @ingroup CLOCKS
  */
-
 #ifndef __ASSEMBLY__
-/*!
- * Enumerations of plls and available clock sources
- */
-enum plls {
-	MCUPLL = 0,		/*!< MCU PLL */
-	USBPLL = 2,		/*!< USB PLL */
-	DSPPLL = 1,		/*!< DSP PLL */
-	CDPLL = 3,		/*!< Corrected Clock PLL */
-	CKIH = 4,		/*!< Main Network clock */
-	CKIH_X2 = 5,		/*!< Doubled version of CKIH */
-	DIGRF = 6,		/*!< DIGRF ref clock */
-	DIGRF_X2 = 7,		/*!< Doubled version of DIGRF */
-	USBCLK = 8,		/*!< USB Clock */
-	MRCG_2_CLK = 9,		/*!< MRCG CLock */
-	TURBOPLL,		/*!< Turbo PLL */
-	SERIALPLL,		/*!<  PLL */
-};
-
-enum mxc_clk_out {
-	CKOH,
-	CKO,
-	CKO2,
-	CKO1,
-};
-
-/*!
- * Enumerations for MXC clocks
- */
-enum mxc_clocks {
-	CLK_NONE,
-	CKIL_CLK,
-	CKIH_CLK,
-	CPU_CLK,
-	AHB_CLK,
-	IPG_CLK,
-	NFC_CLK,
-	USB_CLK,
-	UART1_BAUD,
-	UART2_BAUD,
-	UART3_BAUD,
-	UART4_BAUD,
-	UART5_BAUD,
-	UART6_BAUD,
-	SSI1_BAUD,
-	SSI2_BAUD,
-	CSI_BAUD,
-	FIRI_BAUD,
-	I2C_CLK,
-	I2C1_CLK = I2C_CLK,
-	I2C2_CLK,
-	I2C3_CLK,
-	CSPI1_CLK,
-	CSPI2_CLK,
-	CSPI3_CLK,
-	GPT_CLK,
-	GPT1_CLK = GPT_CLK,
-	GPT2_CLK,
-	GPT3_CLK,
-	GPT4_CLK,
-	GPT5_CLK,
-	GPT6_CLK,
-	RTC_CLK,
-	EPIT1_CLK,
-	EPIT2_CLK,
-	EDIO_CLK,
-	WDOG_CLK,
-	WDOG2_CLK,
-	PWM_CLK,
-	IPU_CLK,
-	SIM1_CLK,
-	SIM2_CLK,
-	HAC_CLK,
-	GEM_CLK,
-	SDHC1_CLK,
-	SDHC2_CLK,
-	SDMA_CLK,
-	RNG_CLK,
-	KPP_CLK,
-	MU_CLK,
-	RTIC_CLK,
-	SCC_CLK,
-	SPBA_CLK,
-	DSM_CLK,
-	SAHARA2_CLK,
-	MQSPI_IPG_CLK,
-	MQSPI_CKIH_CLK,
-	EL1T_IPG_CLK,
-	EL1T_NET_CLK,
-	LPMC_CLK,
-	MPEG4_CLK,
-	OWIRE_CLK,
-	MBX_CLK,
-	MSTICK1_BAUD,
-	MSTICK2_BAUD,
-	ATA_CLK,
-	PERCLK1,
-	PERCLK2,
-	PERCLK3,
-	PERCLK4,
-	DMA_CLK,
-	EMMA_PRP_CLK,
-	EMMA_PP_CLK,
-	FEC_CLK,
-	GPIO_CLK,
-	IIM_CLK,
-	LCDC_CLK,
-	SDHC3_CLK,
-	SLCDC_CLK,
-	BROM_CLK,
-	EMI_CLK,
-	VPU_BAUD,
-	BMI_AHB_CLK,
-};
-
-/*!
- * This function is used to modify PLL registers to generate the required
- * frequency.
- *
- * @param  pll      the PLL that you wish to modify
- * @param  mfi      multiplication factor integer part
- * @param  pdf      pre-division factor
- * @param  mfd      multiplication factor denominator
- * @param  mfn      multiplication factor numerator
- */
-void mxc_pll_set(enum plls pll, unsigned int mfi, unsigned int pdf,
-		 unsigned int mfd, unsigned int mfn);
-
-/*!
- * This function is used to get PLL registers values used generate the clock
- * frequency.
- *
- * @param  pll      the PLL that you wish to access
- * @param  mfi      pointer that holds multiplication factor integer part
- * @param  pdf      pointer that holds pre-division factor
- * @param  mfd      pointer that holds multiplication factor denominator
- * @param  mfn      pointer that holds multiplication factor numerator
- */
-void mxc_pll_get(enum plls pll, unsigned int *mfi, unsigned int *pdf,
-		 unsigned int *mfd, unsigned int *mfn);
-
-/*!
- * This function returns the PLL output value in Hz based on pll.
- *
- * @param       pll     PLL as defined in enum plls
- *
- * @return      PLL value in Hz.
- */
-unsigned long mxc_pll_clock(enum plls pll);
+#include <linux/list.h>
 
-/*!
- * This function returns the clock value in Hz for various MXC modules.
- *
- * @param       clk     as defined in enum mxc_clocks
- *
- * @return      clock value in Hz
- */
-unsigned long mxc_get_clocks(enum mxc_clocks clk);
-
-/*!
- * This function returns the parent clock value in Hz for various MXC modules.
- *
- * @param       clk     as defined in enum mxc_clocks
- *
- * @return      clock value in Hz
- */
-unsigned long mxc_get_clocks_parent(enum mxc_clocks clk);
+struct module;
 
 /*!
- * This function sets the PLL source for a clock.
+ * MXC specific struct for defining and controlling a single clock.
  *
- * @param clk     as defined in enum mxc_clocks
- * @param pll_num the PLL that you wish to use as source for this clock
- */
-void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num);
-
-/*!
- * This function sets the division factor for a clock.
- *
- * @param clk as defined in enum mxc_clocks
- * @param div the division factor to be used for the clock (For SSI, pass in
- *            2 times the expected division value to account for FP vals)
- */
-void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div);
-
-/*!
- * This function returns the peripheral clock dividers.
- * Note that for SSI divider, in order to maintain the accuracy, the returned
- * divider is doubled.
- *
- * @param       clk     peripheral clock as defined in enum mxc_clocks
- *
- * @return      divider value
- */
-unsigned long mxc_peri_clock_divider(enum mxc_clocks clk);
-
-/*!
- * This function returns the main clock dividers.
- *
- * @param       clk     peripheral clock as defined in enum mxc_clocks
- *
- * @return      divider value
- */
-unsigned long mxc_main_clock_divider(enum mxc_clocks clk);
-
-/*!
- * This function sets the digital frequency multiplier clock.
- *
- * @param       freq    Desired DFM output frequency in Hz
- *
- * @return      Actual DFM frequency in Hz
- */
-unsigned long mxc_set_dfm_clock(unsigned int freq);
-
-/*!
- * This function returns the DFS block divider - LFDF value
- *
- * @return      Low Voltage frequency Divider Factor value
- */
-unsigned int mxc_get_lfdf_value(void);
-
-/*!
- * This function is called to gate off the individual module clocks
- *
- * @param clks     as defined in enum mxc_clocks
- */
-void mxc_clks_disable(enum mxc_clocks clks);
-
-/*!
- * This function is called to enable the individual module clocks
- *
- * @param clks     as defined in enum mxc_clocks
- */
-void mxc_clks_enable(enum mxc_clocks clks);
-
-/*!
- * This function is called to read the contents of a CCM register
- *
- * @param reg_offset the CCM register that will read
- *
- * @return the register contents
- */
-unsigned long mxc_ccm_get_reg(unsigned int reg_offset);
-
-/*!
- * This function is called to modify the contents of a CCM register
- *
- * @param reg_offset the CCM register that will read
- * @param mask       the mask to be used to clear the bits that are to be modified
- * @param data       the data that should be written to the register
- */
-void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
-			unsigned int data);
-
-/*!
- * Configure clock output on CKO1/CKO2 pins
- *
- * @param   output  The desired clock needed to measure. Possible
- *                  values are, CKOH_AP_SEL, CKOH_AHB_SEL or CKOH_IP_SEL
- * @param   clk     as defined in enum mxc_clocks
- * @param   div     divider value
- *
- */
-void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk,
-			  int div);
+ * This structure should not be accessed directly. Use clk_xxx API all
+ * clock accesses.
+ */
+struct clk {
+	struct list_head node;
+	struct module *owner;
+	const char *name;
+	int id;
+	/*! Source clock this clk depends on */
+	struct clk *parent;
+	/*! Secondary clock to enable/disable with this clock */
+	struct clk *secondary;
+	/*! Current clock rate */
+	unsigned long rate;
+	/*! Reference count of clock enable/disable */
+	__s8 usecount;
+	/*! Register bit position for clock's enable/disable control. */
+	u8 enable_shift;
+	/*! Register address for clock's enable/disable control. */
+	u32 enable_reg;
+	/*! Function ptr to recalculate the clock's rate based on parent
+	   clock's rate */
+	void (*recalc) (struct clk *);
+	/*! Function ptr to set the clock to a new rate. The rate must match a
+	   supported rate returned from round_rate. Leave blank if clock is not
+	   programmable */
+	int (*set_rate) (struct clk *, unsigned long);
+	/*! Function ptr to round the requested clock rate to the nearest
+	   supported rate that is less than or equal to the requested rate. */
+	unsigned long (*round_rate) (struct clk *, unsigned long);
+	/*! Function ptr to enable the clock. Leave blank if clock can not
+	   be gated. */
+	int (*enable) (struct clk *);
+	/*! Function ptr to disable the clock. Leave blank if clock can not
+	   be gated. */
+	void (*disable) (struct clk *);
+	/*! Function ptr to set the parent clock of the clock. */
+	int (*set_parent) (struct clk *, struct clk *);
+};
 
-/*!
- * This function returns the divider value for a clock.
- *
- * @param       clk as defined in enum mxc_clocks
- *
- * @return      divider value
- */
-unsigned long mxc_get_clocks_div(enum mxc_clocks clk);
+int clk_register(struct clk *clk);
+void clk_unregister(struct clk *clk);
 
 #endif				/* __ASSEMBLY__ */
 #endif				/* __ASM_ARCH_MXC_CLOCK_H__ */
diff -uNpr linux-2.6.19.2.orig/include/asm-arm/arch-mxc/mx27.h linux-2.6.19.2/include/asm-arm/arch-mxc/mx27.h
--- linux-2.6.19.2.orig/include/asm-arm/arch-mxc/mx27.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/include/asm-arm/arch-mxc/mx27.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -41,8 +41,6 @@
  */
 #define CLOCK_TICK_RATE         13300000
 
-#define ATA_BASE_CLK            (AHB_CLK)
-
 /*!
  * Register an interrupt handler for the SMN as well as the SCC.  In some
  * implementations, the SMN is not connected at all, and in others, it is
diff -uNpr linux-2.6.19.2.orig/include/asm-arm/arch-mxc/mx31.h linux-2.6.19.2/include/asm-arm/arch-mxc/mx31.h
--- linux-2.6.19.2.orig/include/asm-arm/arch-mxc/mx31.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/include/asm-arm/arch-mxc/mx31.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -24,7 +24,6 @@
  */
 #define CLOCK_TICK_RATE         16625000
 
-#define ATA_BASE_CLK            (IPG_CLK)
 /*!
  * Register an interrupt handler for the SMN as well as the SCC.  In some
  * implementations, the SMN is not connected at all, and in others, it is
diff -uNpr linux-2.6.19.2.orig/include/asm-arm/arch-mxc/mxc.h linux-2.6.19.2/include/asm-arm/arch-mxc/mxc.h
--- linux-2.6.19.2.orig/include/asm-arm/arch-mxc/mxc.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/include/asm-arm/arch-mxc/mxc.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -47,10 +47,6 @@ struct mxc_spi_master {
 	 * CSPI Hardware Version.
 	 */
 	unsigned int spi_version;
-	/*!
-	 * CSPI Clock.
-	 */
-	unsigned int clock;
 };
 #endif
 
diff -uNpr linux-2.6.19.2.orig/include/asm-arm/arch-mxc/mxc_uart.h linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_uart.h
--- linux-2.6.19.2.orig/include/asm-arm/arch-mxc/mxc_uart.h	2007-04-25 17:28:14.000000000 -0600
+++ linux-2.6.19.2/include/asm-arm/arch-mxc/mxc_uart.h	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -30,7 +30,6 @@
 #ifdef __KERNEL__
 
 #include <linux/serial_core.h>
-#include <asm/arch/clock.h>
 #include <asm/arch/dma.h>
 
 /*!
@@ -128,9 +127,9 @@ typedef struct {
 	 */
 	unsigned int shared;
 	/*!
-	 * Clock id from clock.h
+	 * Clock id for UART clock
 	 */
-	enum mxc_clocks clock_id;
+	struct clk *clk;
 	/*!
 	 * Information whether RXDMUXSEL must be set or not for IR port
 	 */
diff -uNpr linux-2.6.19.2.orig/sound/arm/mxc-alsa-pmic.c linux-2.6.19.2/sound/arm/mxc-alsa-pmic.c
--- linux-2.6.19.2.orig/sound/arm/mxc-alsa-pmic.c	2007-04-25 17:37:40.000000000 -0600
+++ linux-2.6.19.2/sound/arm/mxc-alsa-pmic.c	2007-04-25 17:37:51.000000000 -0600
@@ -1,5 +1,5 @@
 /*
- * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Copyright 2004-2007 Freescale Semiconductor, Inc. All Rights Reserved.
  */
 
 /*
@@ -51,8 +51,6 @@
 #endif				/* CONFIG_PM */
 
 #include <asm/arch/dma.h>
-#include <asm/arch/spba.h>
-#include <asm/arch/clock.h>
 #include <asm/mach-types.h>
 
 #include <ssi/ssi.h>
