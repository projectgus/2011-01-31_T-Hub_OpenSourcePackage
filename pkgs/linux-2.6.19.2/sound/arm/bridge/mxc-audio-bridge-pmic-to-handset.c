/*
 *  DECT audio bridge driver.
 *
 *  Copyright (C) 2006 - 2009 Sagemcom All rights reserved
 *
 *  File name: mxc-audio-bridge-pmic-to-handset.c
 *  Creation date: 17/04/2009
 *  Author: Farid Hammane, Sagemcom
 *
 *  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General
 *  Public License as published by the Free Software Foundation; either version 2 of the License, or (at your
 *  option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY
 *  WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *  See the GNU General Public License for more details.
 *  Write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA to
 *  receive a copy of the GNU General Public License.
 *  This Copyright notice should not be removed
 */


 /*!
  * @defgroup SOUND_DRV MXC Sound Driver for ALSA
  */

 /*!
  * @file       mxc-audio-bridge-pmic-to-handset.c
  * @brief      this fle  mxc-audio-bridge-pmic-to-handset.c     
  * @brief      this file implements the audio bridge which implements the
  *             interface between mxc-alsa-pmic and dectusb_audio.c 
  *             However, behaviour can be generalized as follow : 
  *             The audio bridge is a driver enabling 2 audio devices to exchanges 
  *             audio packets. The samples capture by one drivers are pushed to the 
  *             playback interface of the other one and vice versa.
  *             Since it is not always possible for each driver to consume there 
  *             data as they are offered by the opposite device, the use of buffer 
  *             is compulsory. However, he aim of the audio_bridge is to minimize 
  *             the delay as well as its variation (some signal processing function 
  *             are sensitive to delay variations such as Audio Echo Cancellation). 
  *
  */

#include "mxc-audio-bridge-pmic-to-handset.h"
#include "mxc-audio-bridge-pmic-to-handset_priv.h"
#include <linux/version.h>
#include <sound/sound_bridge.h>
#include <linux/relay.h>
#include <linux/debugfs.h>


#define assert(a) \
	do{ \
		if(unlikely(!(a))) { \
			printk(KERN_ERR "ASSERT FAILED (%s) at: %s:%d:%s()\n", #a, __FILE__, __LINE__, __func__); \
			BUG();\
			panic("BUG!");\
		}\
	}while(0)



#ifdef CONFIG_AUDIO_BRIDGE_CONSOLE_TRACES
#define TRACES(fmt, args...) printk("TRACE  %d %s()  "fmt"\n",  __LINE__, __func__, ## args);
#define INFOS(fmt, args...)  printk("INFOS  %d %s()  "fmt"\n", __LINE__, __func__, ## args);
#else
#define TRACES(fmt, args...)
#define INFOS(fmt, args...) 
#endif


#define WARNING(fmt, args...) printk(KERN_ERR "WARNING  %d %s()  "fmt"\n", __LINE__, __func__, ## args);
#define ERROR(fmt, args...) printk(KERN_ERR "ERROR  %d %s()  "fmt"\n", __LINE__, __func__, ## args);

#define BRIDGE_BUG do { \
	        ERROR("BUG: failure\n"); \
	        panic("BUG!"); \
		BUG(); \
} while (0)


#define NB_OF_MAX_PERIODS 1

/* Ugly hack to avoid crackling whenever 
   sound starts up. Crackling seems to be 
   generated by the dect (base or handset).
   Turning off sagem amplifier when preparing 
   bridge to start and turning on after a few 
   delay (after crackling stops).
   */
#include "../sagem-audio-pwr-amp.h"
static char mute_counter = 0;
static unsigned long mute_timeout = 0;
#define mute_pwr_amp()	{\
	pm_message_t state = {0};\
	TRACES("Suspend amplifier");\
	assert(mute_counter++ == 0);\
	sagem_audio_pwr_amp_suspend(NULL, state);\
}
#define unmute_pwr_amp() {\
	TRACES("Resume amplifier");\
	assert(mute_counter-- == 1);\
	sagem_audio_pwr_amp_resume(NULL);\
}

static struct semaphore bridge_audio_mutex;
#define MUTEX_INIT		sema_init(&bridge_audio_mutex, 1);
#define MUTEX_LOCK		down(&bridge_audio_mutex);
#define MUTEX_UNLOCK		up(&bridge_audio_mutex);



/*!  
 *  bridge_stream structure is dedicated to audio stream management
 *  This structure is intanciated on driver registration of a stream 
 *  to the audio_bridge. Therefore a stream is characterized 2 ports: 
 *  a playback and a capture port for which the management methods have
 *  been exported by the driver at registration time. 
 * 
 *  Besides, a stream needs to be associated with another stream
 *  to achieve its goal. This association is performed by the core
 *  of the audio bridge.
 *
 */
struct bridge_stream {
	struct audio_bridge_operations	*ops;                   /*Operations registered for stream by device  */
	struct bridge_buffer_info 	binfo;                  /*The capture buffer dedicated to this stream */
	                                                        /*playback uses playback_bstream->binfo       */
	struct bridge_stream		*playback_bstream;      /*The associated stream*/
	
	/*Bridge status*/
	int				capture_stream_active;  /*set when audio_bridge_capture_start returned successfully*/
	int				playback_stream_active; /*set when audio_bridge_playback_start returned successfully*/

	int				playback_status;        /*set when audio_bridge_playback_open */
	int				capture_status;         /*set when audio_bridge_capture_open  */

	int				stream_id;		/* Stream id, essentially used for debuging */
};




#define MAX_STREAMS_IN_BRIDGE	2  /*DON'T CHANGE: CODE ITSELF IS TILED TO 2, or improve this code */


/*!
 *  The brigde_ctx structure centralizes all registered streams.
 */
struct bridge_ctx {
	/*
	 * Number of registered devices using bridge
	 */
	int			devices;
	struct bridge_stream 	bstream[MAX_STREAMS_IN_BRIDGE];
	struct semaphore	sem_buffer;
};

/*! Pointer to driver context
  */
static struct bridge_ctx *g_ctx;


/*Local declarations*/
static int audio_bridge_capture_stop(struct bridge_stream *pstream);


/*
 * Debugging utilities
 *
 */    

       
#ifdef CONFIG_DUMP_SIN_BRIDGE /* 80 samples */
static short dump_sin_bridge[] = {
	/*0*/	   -12 , 12529  ,  23162 ,  30266 ,  32767 ,  30277 ,  23181 ,  12550 ,     12 , -12528,
	/*10*/  -23160 , -30268 , -32768 , -30278 , -23176 , -12551 ,    -10 ,  12526 ,  23161 ,  30267, 
	/*20*/   32766 , 30275  ,  23179 ,  12550 ,     12 , -12528 , -23159 , -30266 , -32766 , -30279, 
	/*30*/  -23178 , -12552 ,    -14 ,  12528 ,  23163 ,  30268 ,  32767 ,  30277 ,  23179 ,  12550, 
	/*40*/      11 , -12528 , -23160 , -30267 , -32766 , -30280 , -23178 , -12553 ,    -11 ,  12528,
	/*50*/   23158 ,  30266 ,  32766 ,  30278 ,  23179 ,  12550 ,     12 , -12529 , -23163 , -30268,
	/*60*/  -32767 , -30278 , -23176 , -12552 ,    -15 ,  12530 ,  23161 ,  30268,   32767 ,  30276, 
	/*70*/   23179 ,  12552,      12 , -12528 , -23164 , -30268 , -32764 , -30278,  -23177, -12550,};
#define DUMP_SIN_START_POS	40
int dump_sin_bridge_pos = DUMP_SIN_START_POS;
#endif



/*********************** Chaning periods  ************************** */

/* TODO : will become a field of bridge_buffer_info */
/* TODO rename this function to focus on chaning streaming */
int start_chaning_playback_dma(struct bridge_stream *pstream, void **src, int *period_size){/* Period size is in samples */
	int delay;
	*src = 0;
	*period_size = 0;
	if(pstream->binfo.playback_chained){/* dam already chained */
#ifdef CONFIG_ULOG_AUDIO_BRIDGE
		ulog(ULOG_AUDIO_BRIDGE_PLAYBACK_ERROR_DMA_ALREADY_CHAINED,0);
#endif
		WARNING("dma already chained");
		return -EPERM;
	}
	/* start_chaning_playback_dma will be call to 
	 * enable dma chaining or because of missing data for
	 * playback. In both cases, a playback period is already 
	 * playing and has not yet elapsed. delay is equal to 
	 * capture_offet - playback_offset - not yet elapsed 
	 * playback period_size.
	 */
	delay = pstream->binfo.capture_offset - pstream->binfo.playback_offset - pstream->binfo.playback_period_size;
	if(delay - pstream->binfo.playback_period_size > pstream->binfo.playback_period_size){
		*src = pstream->binfo.buffer + ((pstream->binfo.playback_offset + pstream->binfo.playback_period_size) % pstream->binfo.buffer_size);
		*period_size = pstream->binfo.playback_period_size;
		pstream->binfo.playback_chained = 1;
		return 0;
	}
	/*WARNING("Could not chain dma. Not enougth data");*/
	return -ENOBUFS;
}
EXPORT_SYMBOL(start_chaning_playback_dma);



int start_chaining_capture_dma(struct bridge_stream *pstream, void **src, int *period_size){
	int delay;
	*src = 0;
	*period_size = 0;
	if(pstream->binfo.capture_chained){
#ifdef CONFIG_ULOG_AUDIO_BRIDGE
		ulog(ULOG_AUDIO_BRIDGE_CAPTURE_ERROR_DMA_ALREADY_CHAINED,0);
#endif
		WARNING("dma already chained");
		return -EPERM;
	}
	delay = pstream->binfo.capture_offset - pstream->binfo.playback_offset - pstream->binfo.capture_period_size;
	if(delay +  pstream->binfo.capture_period_size <  pstream->binfo.capture_period_size){
		*src = pstream->binfo.buffer + ((pstream->binfo.capture_offset + pstream->binfo.capture_period_size) % pstream->binfo.buffer_size);
		*period_size = pstream->binfo.capture_period_size;
		pstream->binfo.capture_chained = 1;
		return 0;
	}
	/*WARNING("Could not chain dma. Not enougth data");*/
	return -ENOBUFS;
}
EXPORT_SYMBOL(start_chaining_capture_dma);

/******************** MEM ALLACATION ***********************/

/* Jitter max */
#define BRIDGE_DELAY_TOLERANCE (5*16)

/*
 * Check buffer parameters, allocate the buffer, and sets its pointers
 *
 *
 * Precondition : *_period_size have been initialized in pstream->binfo
 *
 */

static int bridge_audio_alloc_buffer(struct bridge_stream *pstream){
	int i, tmp_tolerance;

	TRACES("Allocating Buffer: for %s", pstream->ops->name);

	if(pstream->binfo.buffer_size){
		ERROR("Buffer has already been allocated.");
		return -EPERM;
	}

	if(pstream->binfo.capture_period_size < 1){
		ERROR("Capture : invalid capture period size : %d", pstream->binfo.capture_period_size);
		return -EINVAL;
	}

	if(pstream->binfo.playback_period_size < 1){
		ERROR("Playback : invalid playback period size : %d", pstream->binfo.playback_period_size);
		return -EINVAL;
	}

	if(pstream->binfo.capture_period_size != pstream->playback_bstream->binfo.playback_period_size){
		WARNING("Playback and capture period are different");
	}

	/*Extract max_period_size and min_period_size*/
	pstream->binfo.max_period_size = max(pstream->binfo.capture_period_size, pstream->binfo.playback_period_size);
	pstream->binfo.min_period_size = min(pstream->binfo.capture_period_size, pstream->binfo.playback_period_size);

	/* set delays */
	pstream->binfo.target_delay = 2*pstream->binfo.max_period_size;

	/* set tolerance */
	tmp_tolerance = 2*pstream->binfo.min_period_size;
	if(tmp_tolerance > BRIDGE_DELAY_TOLERANCE){
		tmp_tolerance = BRIDGE_DELAY_TOLERANCE;
	}

	if(pstream->binfo.capture_period_size > pstream->binfo.playback_period_size){
		pstream->binfo.delay_tolerance_hight = pstream->binfo.target_delay + tmp_tolerance;
		pstream->binfo.delay_tolerance_low = pstream->binfo.target_delay - pstream->binfo.capture_period_size - tmp_tolerance;
	}else if(pstream->binfo.capture_period_size < pstream->binfo.playback_period_size){
		pstream->binfo.delay_tolerance_hight = pstream->binfo.target_delay + pstream->binfo.playback_period_size + tmp_tolerance;
		pstream->binfo.delay_tolerance_low = pstream->binfo.target_delay  - tmp_tolerance;
	}else{
		/* FIXME */
		pstream->binfo.delay_tolerance_hight = pstream->binfo.delay_tolerance_low = BRIDGE_DELAY_TOLERANCE;
	}

	/* TODO : check min/max buffer size and limit them. */
	/* Buffer capture and playback period size are
	 * both multiple of buffer size. 
	 */

	pstream->binfo.buffer_size = 0;
	/* TODO Needs update, find a better way to compute it */
	i = 10;
	while(i <= pstream->binfo.capture_period_size * pstream->binfo.playback_period_size){
		if((i*pstream->binfo.max_period_size) % pstream->binfo.min_period_size == 0){
			pstream->binfo.buffer_size = i*pstream->binfo.max_period_size;
			break;
		}
	}
	assert(pstream->binfo.buffer_size > (pstream->binfo.delay_tolerance_hight + 2*pstream->binfo.max_period_size));
	pstream->binfo.buffer = kzalloc(pstream->binfo.buffer_size*sizeof(short), GFP_KERNEL); 
	if(!pstream->binfo.buffer){
		ERROR("%s : Could not alloc space for buffer. (size %d)", pstream->ops->name,pstream->binfo.buffer_size);
		/* Clear context. */
		pstream->binfo.buffer = NULL;
		pstream->binfo.buffer_size =
			pstream->binfo.target_delay = 
			pstream->binfo.delay_tolerance_low = 
			pstream->binfo.max_period_size =
			pstream->binfo.min_period_size =
			pstream->binfo.dma_addr = 0;
		return -ENOMEM;
	}

	/*Initialize offset*/
	pstream->binfo.playback_offset = 0;
	pstream->binfo.playback_chained = 0;
	pstream->binfo.capture_chained = 0;
	pstream->binfo.capture_offset = 0;
	pstream->binfo.overrun=0;
	pstream->binfo.underrun=0;
	
	TRACES("  --------------------");
	TRACES("  stream 		: 0x%p"	, pstream);
	TRACES("  capture_period_size   : %d"	, pstream->binfo.capture_period_size);
	TRACES("  playback_period_size  : %d"	, pstream->binfo.playback_period_size);
	TRACES("  min_period_size       : %d"	, pstream->binfo.min_period_size);
	TRACES("  max_period_size       : %d"	, pstream->binfo.max_period_size);	
	TRACES("  buffer_size           : %d"	, pstream->binfo.buffer_size);
	TRACES("  addr                  : 0x%x"	, (unsigned int) pstream->binfo.buffer);
	TRACES("  dma adress            : 0x%x"	, pstream->binfo.dma_addr);
	TRACES("  target delay          : %d"	, pstream->binfo.target_delay);
	TRACES("  delay_tolerance_hight : %d"	, pstream->binfo.delay_tolerance_hight);
	TRACES("  delay_tolerance_low   : %d"	, pstream->binfo.delay_tolerance_low);
	TRACES("  overrun               : %d"	, pstream->binfo.overrun);
	TRACES("  underrun              : %d"	, pstream->binfo.underrun);
	TRACES("  --------------------");
	return 0;
}


static void bridge_audio_free_buffer(struct bridge_stream *pstream){
	if(pstream->binfo.buffer)
		kfree(pstream->binfo.buffer);
	pstream->binfo.buffer_size = 0;
	return;
}



/******************** DEVICES OPEN CLOSE *************************/


/*!
 * audio_bridge_playback_open opens playback port on driver side
 *
 */
static int audio_bridge_playback_open(struct bridge_stream *pstream){
	int ret;
	
	ulog_trace(ULOG_AUDIO_BRIDGE_PLAYBACK_OPEN);

	if(!pstream || !pstream->ops)
		return -EFAULT;

	INFOS("%s", pstream->ops->name);

	if(pstream->playback_status){
		return -EBUSY;
	}

	ret = pstream->ops->playback_open(pstream->ops->private_data);
	if(ret)
		return ret;

	pstream->playback_status = 1;
	return 0;
}


/*!
 * audio_bridge_playback_close closes the playback port on driver side after 
 * stopping playback (if needed)
 * 
 */
static void audio_bridge_playback_close(struct bridge_stream *pstream){

	int ret;

	ulog_trace(ULOG_AUDIO_BRIDGE_PLAYBACK_CLOSE);

	if(!pstream || !pstream->ops){
		ERROR("Null pointer (%p)", pstream);
		return;
	}

	INFOS("%s", pstream->ops->name);	
	
	if(pstream->playback_stream_active){
		ret=pstream->ops->playback_stop(pstream->ops->private_data);
		if(ret){
			ERROR("stopping playback failed, close will continue");
		}
		pstream->playback_stream_active = 0;
	}

	if(pstream->playback_status){
		pstream->ops->playback_close(pstream->ops->private_data);
		pstream->playback_status = 0;
	}
	else{
		INFOS("Device was already closed apparently");
		return;
	}

	if(unlikely(mute_counter)){
		if(pstream->stream_id == 0){
			TRACES("unmute amplifier (closing device)");
			unmute_pwr_amp();
		}
	}

	return;
}



/*!
 * audio_bridge_capture_open opens capture port on driver side
 *
 * Precondition: the capture buffer for this stream should have 
 *               been allocated and initialized. Be aware that this
 *               method is not called through audio_bridge_capture_prepare
 *               this may not be the case. Besides, this methods does not 
 *               open the pstream->playback_stream->playback_open which
 *               the audio_bridge_capture_prepare function does. 
 */
static int audio_bridge_capture_open(struct bridge_stream *pstream){
	int ret;

	ulog_trace(ULOG_AUDIO_BRIDGE_CAPTURE_OPEN);

	if(!pstream || !pstream->ops)
		return -EFAULT;

	INFOS("%s", pstream->ops->name);	

	if(!pstream->binfo.buffer){
		ERROR("Buffer is null.");
		return -EINVAL;
	}

	if(pstream->capture_status){
		return -EBUSY;
	}

	ret = pstream->ops->capture_open(pstream->ops->private_data);
	if(ret)
		return ret;

	pstream->capture_status = 1;
	return 0;
}


/*!
 * audio_bridge_playback_close closes the playback port on driver side after 
 * stopping playback (if needed)
 * 
 * Success : iff (pstream->playback_active==0) && (playback->playback_status=0)
 *           in which case the capture buffer is re-initialized. 
 *
 */
static void audio_bridge_capture_close(struct bridge_stream *pstream){

	int ret;

	ulog_trace(ULOG_AUDIO_BRIDGE_CAPTURE_CLOSE);

	if(!pstream || !pstream->ops){
		ERROR("Null poiter (%p)", pstream);
		return;
	}

	INFOS("%s", pstream->ops->name);	
	
	if(pstream->capture_stream_active){
		ret = audio_bridge_capture_stop(pstream);
		if(ret)
			ERROR("Stopping capture failed, close will continue");
		pstream->capture_stream_active = 0;
	}

	if(pstream->capture_status){
		pstream->ops->capture_close(pstream->ops->private_data);
		pstream->capture_status = 0;
	}
	else{
		INFOS("Device was already apparently closed");
	}


#ifdef CONFIG_DUMP_SIN_BRIDGE
	dump_sin_bridge_pos = DUMP_SIN_START_POS;
#endif

	return;
}


/*! 
 * audio_bridge_capture_prepare opens the capture port on the stream 
 * passed as parameter. As data will be delivered on the capture buffer,
 * it opens also the playback interface tilled to this buffer, so as to 
 * consume data.
 * 
 * If not already done, this function will allocate the capture buffer
 * 
 * Precondition: 
 *    - none of the capture port and associated playback port on
 *      the other stream should already be opened. 
 */
static int audio_bridge_capture_prepare(struct bridge_stream *pstream){
	int ret;


	if(!pstream)
		return -EINVAL;

	if(!pstream->binfo.buffer){
		INFOS("Buffer area not yet allocated");
		ret = bridge_audio_alloc_buffer(pstream);
		if(ret)
			return ret;
	}

	ret = audio_bridge_playback_open(pstream->playback_bstream);
	if(ret){
		/*fail if playback is already opened*/
		return ret;
	}
	ret = audio_bridge_capture_open(pstream);
	if(ret){
		audio_bridge_capture_close(pstream);
		audio_bridge_playback_close(pstream->playback_bstream);
		return ret;
	}

	if(pstream->stream_id == 0){
		mute_pwr_amp();
	}
	
	return 0;
}

/*********************** STREAMING **********************/

/*!
 * audio_bridge_playback_elapsed is a callback function used by the playback_start 
 * method of the driver, if it needs more data to playback. Basically, one the 
 * playback buffer passed is exhausted, it will ask for more.
 * 
 * As a result, this function is the place where delay accounting, and playback_offset
 * is updated.
 *
 */
void audio_bridge_playback_elapsed(void *data, int err, unsigned int count);



/*!
 * audio_bridge_playback_call_start is used to actually pass the buffer to the
 * driver's playback method. It receives as parameter capture_buffer that has
 * been prepared for reading.
 * 
 * This function has 2 entry points:  
 *   - audio_bridge_playback_start   (the initialization method)
 *   - audio_bridge_playback_elapsed (the callback method)
 */
static int audio_bridge_playback_call_start(struct bridge_stream *capture_stream){

	int err = 0;
	struct bridge_stream *playback_stream;
	short * src;
	int offset;

	offset = (capture_stream->binfo.playback_offset + 
			(capture_stream->binfo.playback_chained?capture_stream->binfo.playback_period_size:0)) % capture_stream->binfo.buffer_size;

	src = (short *)(capture_stream->binfo.buffer) + offset;

	playback_stream = capture_stream->playback_bstream;

	ulog_playback_jitter(capture_stream->stream_id, (unsigned int)offset);

	err = playback_stream->ops->playback_start(playback_stream->ops->private_data,
			src, 
			capture_stream->binfo.playback_period_size, 
			capture_stream, 
			audio_bridge_playback_elapsed);
	if(err){
		ERROR("Could not start playback : %s to %s", capture_stream->ops->name, playback_stream->ops->name);
		playback_stream->playback_stream_active = 0;
	}

	return err;
}


/*See above*/
void audio_bridge_playback_elapsed(void *data, int err, unsigned int sample_count){

	struct bridge_stream *pstream_playback;
	struct bridge_stream *pstream;
	int ret;
	unsigned long flags;
	unsigned int actual_delay;

#if defined (CONFIG_DUMP_SIN_BRIDGE) || defined (CONFIG_RELAY_TO_DEBUGFS)
	short *ptr;
#endif


	ulog_trace(ULOG_AUDIO_BRIDGE_PLAYBACK_ELAPSED);

	/*Recover capture stream associated to playback*/
	pstream = (struct bridge_stream *) data;
	if(!pstream){
		ERROR("Playback associated capture stream is NULL");
		return;
	}

	/*Recover playback stream out of the identified capture stream*/
	pstream_playback = pstream->playback_bstream;
	if(!pstream_playback){
		ERROR("Playback stream is NULL");
		return;
	}


	if(err){
		ulog_trace_error( PLAYBACK_ELASPSE_COUNT_ERR , (pstream == &(g_ctx->bstream[0]) )? 0 : 1); 
		ERROR("Driver has return an error : stream (%d), error (%d)",
				(pstream == &(g_ctx->bstream[0]) )? 0 : 1, err);
	}


	if(sample_count != pstream->binfo.playback_period_size && sample_count != 0){
		ulog_trace_error( PLAYBACK_ELASPSE_COUNT_ERR , sample_count ); 
		/*Do as if nothing happend*/
	}


	if(!pstream_playback->playback_stream_active){
		INFOS("Ending playback transfer");
		return;
	}


#if defined (CONFIG_RELAY_TO_DEBUGFS)
	ptr=(short *)pstream->binfo.buffer + pstream->binfo.playback_offset;
	ulog_trace_value(ULOG_AUDIO_BRIDGE_TRACE_VALUE_1, (unsigned int) pstream->binfo.buffer );
	if(pstream->binfo.playback_rchan){
		relay_write(pstream->binfo.playback_rchan,
			    ptr,
			    (pstream->binfo.playback_period_size)*sizeof(short));
	}
#endif

	spin_lock_irqsave(&(pstream->binfo.lock), flags);

	ulog_playback_jitter_done(pstream->stream_id, 0);
	
	/* FIXME
	 * avoid an unsigned int overflow
	 */

	actual_delay = pstream->binfo.capture_offset - pstream->binfo.playback_offset;

	if(pstream->binfo.playback_period_size == pstream->binfo.max_period_size){
		pstream->binfo.playback_offset += pstream->binfo.playback_period_size;
	}else {
		ulog_delay_update((pstream == &(g_ctx->bstream[0]) )? 0 : 1, actual_delay);
		if(actual_delay < pstream->binfo.delay_tolerance_low){
			/* playback overrun */
			ulog_trace_value( ULOG_AUDIO_BRIDGE_PLAYBACK_OVERRUN, actual_delay);
			pstream->binfo.overrun ++;
		}else if(actual_delay > pstream->binfo.delay_tolerance_hight){
			/* playback underrun */
			pstream->binfo.playback_offset += (pstream->binfo.playback_period_size*3);
			ulog_trace_value( ULOG_AUDIO_BRIDGE_PLAYBACK_UNDERRUN, actual_delay);
			pstream->binfo.underrun ++;
		}else{
			pstream->binfo.playback_offset += pstream->binfo.playback_period_size;
		}
	}

	ulog_playback_offset_update( (pstream==&(g_ctx->bstream[0])) ? 0 : 1, pstream->binfo.playback_offset%pstream->binfo.buffer_size);
	spin_unlock_irqrestore(&(pstream->binfo.lock),flags);

	if(unlikely(mute_counter)){
		if(pstream->stream_id == 0 && 
				time_after(jiffies, mute_timeout)){
			TRACES("Timeout : unmuting audio amplifier");
			unmute_pwr_amp();
		}
	}

	ret = audio_bridge_playback_call_start(pstream);
	if(ret){
		ERROR("Could not start playback");
		return;
	}

	ulog_trace(ULOG_AUDIO_BRIDGE_PLAYBACK_ELAPSED_DONE);

	return;
}


/*!
 * audio_bridge_playback_start is the main entry point to starting playback
 * of the stream captured
 *
 * param is the capture stream.
 */
static int audio_bridge_playback_start(struct bridge_stream *pstream){

	ulog_trace(ULOG_AUDIO_BRIDGE_PLAYBACK_START);

	if(!pstream || !pstream->playback_bstream)
		return -EFAULT;

	TRACES("Playback START")

	pstream->playback_bstream->playback_stream_active = 1;
	return audio_bridge_playback_call_start(pstream);
}





/*!
 * audio_bridge_capture_elapsed is a callback function used by the capture_start 
 * method of the driver. After capturing a buffer, this callback should be called
 * to update capture_offset in buffer for future capture of audio packets. The 
 * next capture is then automatically launch by this function through the  
 * audio_bridge_capture_call_start function in order to provide continuous capture. 
 * 
 */
void audio_bridge_capture_elapsed(void *stream, int error, unsigned int sample_count);



/*!
 * audio_bridge_capture_call_start is used to actually pass the buffer to the
 * driver's capture method. It receives as parameter the capture_buffer that has
 * been prepared for writing.
 * 
 * This function has 2 entry points:  
 *   - audio_bridge_capture_start   (the initialization method)
 *   - audio_bridge_capture_elapsed (the callback method)
 */
static int audio_bridge_capture_call_start(struct bridge_stream *pstream){
	int offset;
	int err=0;
	short * src;

	offset = (pstream->binfo.capture_offset + (pstream->binfo.capture_chained?pstream->binfo.capture_period_size:0)) % pstream->binfo.buffer_size;

	src = (short *) (pstream->binfo.buffer) + offset;

	ulog_capture_jitter(pstream->stream_id, (unsigned int)offset);

	err = pstream->ops->capture_start(pstream->ops->private_data, 
			src, 
			pstream->binfo.capture_period_size, 
			pstream, 
			audio_bridge_capture_elapsed);
	if(err){
		ERROR("Could not start capture");
		pstream->capture_stream_active = 0;
		/* Stopping playback if capture_start fails */
		pstream->playback_bstream->playback_stream_active = 0;
		return err;
	}

	return err;
}



/*! The audio_bridge_capture_elapse_debug function a provide debugging
 *  support specfic to the audio_bridge_capture_elapsed method.
 *
 */
#if defined (CONFIG_DUMP_SIN_BRIDGE) || defined (CONFIG_RELAY_TO_DEBUGFS)
void audio_bridge_capture_elapse_debug(struct bridge_stream *pstream){

	short *ptr;
	int i;

	ptr=(short *)pstream->binfo.buffer + pstream->binfo.capture_offset;
	ulog_trace_value(ULOG_AUDIO_BRIDGE_TRACE_VALUE_3, (unsigned int) pstream->binfo.buffer );


#ifdef CONFIG_DUMP_SIN_BRIDGE
	if(strcmp(pstream->ops->name, "mxc_pmic")) /* Only debug streaming going to handset */
	{
#if CONFIG_DUMP_SIN_FROM_PMIC
		for(i = 0; i < pstream->binfo.capture_period_size; i++){
			ptr[i] = dump_sin_bridge[(dump_sin_bridge_pos++)%80];
		}
		dump_sin_bridge_pos %= 80;
#endif
	}
	else{
#if CONFIG_DUMP_SIN_FROM_DECT
		for(i = 0; i < pstream->binfo.capture_period_size; i++){
			ptr[i] = dump_sin_bridge[(dump_sin_bridge_pos++)%80];
		}
		dump_sin_bridge_pos %= 80;
#endif 
	}
#endif /*CONFIG_DUMP_SIN_BRIDGE*/




#ifdef CONFIG_RELAY_TO_DEBUGFS
	if(pstream->binfo.capture_rchan){
		relay_write(pstream->binfo.capture_rchan,
			    ptr,
			    (pstream->binfo.capture_period_size)*sizeof(short));
	}
#endif


}
#else
void audio_bridge_capture_elapse_debug(struct bridge_stream *pstream){return;};
#endif



/** 
 * 
 * @param stream
 * @param error 
 * @param count_period_size : in sample (no a buffer size).
 */
void audio_bridge_capture_elapsed(void *stream, int error, unsigned int sample_count){//ok,thibault


	int err = 0;
	struct bridge_stream *pstream = stream;
	unsigned long flags;
	unsigned int delay;


	ulog_trace(ULOG_AUDIO_BRIDGE_CAPTURE_ELAPSED);


	if(!pstream || !pstream->ops || !pstream->playback_bstream){
		ERROR("Null pointer : !pstream (%p) or !pstream->ops (%p) or !pstream->playback_bstream (%p)", 
				pstream, pstream->ops, pstream->playback_bstream);
		return;
	}

	if(error){
		ERROR("Driver has return an error : %d", error);
	}

	if(!pstream->capture_stream_active){
		INFOS("Ending transfer");
		return;
	}

	if(sample_count != pstream->binfo.capture_period_size){
		WARNING("captured %d samples instead of %d (error returned (%d))", 
			sample_count, 
			pstream->binfo.capture_period_size,
			error);
		/* TODO:
		 * Making silence of missing data.
		 * Check if an error occurs.
		 */
	}

	/*Debugging information*/
	audio_bridge_capture_elapse_debug(pstream);


	/*
	 * Buffer capture_offset management
	 *
	 */

	/*
	 * Protects against playback modifying binfo
	 */
	spin_lock_irqsave(&(pstream->binfo.lock), flags);
	
	ulog_capture_jitter_done(pstream->stream_id, 0);

	delay = pstream->binfo.capture_offset - pstream->binfo.playback_offset;

	/* FIXME
	 * Check if capture_offset will reach unsigned int max value
	 */
	if(pstream->binfo.capture_period_size == pstream->binfo.max_period_size){
		pstream->binfo.capture_offset += pstream->binfo.capture_period_size;
	}else{
		ulog_delay_update((pstream == &(g_ctx->bstream[0]) )? 0 : 1, delay);
		if(delay < pstream->binfo.delay_tolerance_low){
			/* Capture is to slow. Adding silent */
			/* TODO add a real silence, not just jumping */
			ulog_trace_value(ULOG_AUDIO_BRIDGE_CAPTURE_UNDERRUN, delay);
			pstream->binfo.capture_offset += pstream->binfo.capture_period_size*3;
			pstream->binfo.underrun ++;
		} else if(delay > pstream->binfo.delay_tolerance_hight){
			/* Capture goes to fast, waiting for playback */
			ulog_trace_value(ULOG_AUDIO_BRIDGE_CAPTURE_OVERRUN, delay);
			pstream->binfo.overrun ++;
		}else{
			pstream->binfo.capture_offset += pstream->binfo.capture_period_size;
		}
	}

	ulog_capture_offset_update((pstream == &(g_ctx->bstream[0]) )? 0 : 1 , pstream->binfo.capture_offset%pstream->binfo.buffer_size);
	spin_unlock_irqrestore(&(pstream->binfo.lock),flags);

	err = audio_bridge_capture_call_start(pstream);
	if(err){
		ERROR("Could not start capture");
		return;
	}

	if(!pstream->playback_bstream->playback_stream_active &&
			pstream->binfo.capture_offset >= pstream->binfo.target_delay &&
			pstream->playback_bstream->playback_status){
		TRACES("playback stream not yet started");

		err = audio_bridge_playback_start(pstream);
		if(err)
			ERROR("Could not start playback");

		if(pstream->stream_id == 0){
			TRACES("Starting timout before unmuting audio amplifier (waiting 1/4 sec)");
			mute_timeout = jiffies + (HZ/4);
		}
	}
	
	
	ulog_trace(ULOG_AUDIO_BRIDGE_CAPTURE_ELAPSED_DONE);	


	return;
}


static int audio_bridge_capture_start_check(struct bridge_stream *pstream){

	if(!pstream || !pstream->ops || !pstream->playback_bstream){
		ERROR("Null pointer : pstream (%p) ops (%p) playback_bstream (%p)", 
				pstream, 
				pstream?pstream->ops:NULL, 
				pstream?pstream->playback_bstream:NULL);
		return -EFAULT;
	}
	
	if(!pstream->capture_status){
		ERROR("%s : stream is not open", pstream->ops->name);
		return -EPERM;
	}

	if(pstream->capture_stream_active){
		ERROR("%s : stream is busy (already active)", pstream->ops->name);
		return -EBUSY;
	}

	if(!pstream->binfo.buffer){
		ERROR("%s : buffer is NULL", pstream->ops->name);
		return -EFAULT;
	}

	if(pstream->binfo.buffer_size < (pstream->binfo.delay_tolerance_hight + 2*pstream->binfo.max_period_size)){
		ERROR("%s : Invalid buffer size (%d bytes)", pstream->ops->name, pstream->binfo.buffer_size);
		return -EINVAL;
	}
	
	return 0;
}

static int audio_bridge_capture_start(struct bridge_stream *pstream){

	int ret;

	ulog_trace(ULOG_AUDIO_BRIDGE_CAPTURE_START);

	ret = audio_bridge_capture_start_check(pstream);
	if(ret)
		return ret;

	memset(pstream->binfo.buffer, 0x0, (pstream->binfo.buffer_size)*sizeof(short));

	pstream->capture_stream_active = 1;

	return audio_bridge_capture_call_start(pstream);
}


static int audio_bridge_capture_stop(struct bridge_stream *pstream){
	int ret;

	ulog_trace(ULOG_AUDIO_BRIDGE_CAPTURE_STOP);

	if(!pstream || !pstream->ops){
		ERROR("Null pointer : pstream (%p)", pstream);
		return -EFAULT;
	}
	
	if(!pstream->capture_status){
		ERROR("%s : stream is close (%p)", pstream->ops->name, pstream);
		return -EPERM;
	}
	
	if(!pstream->capture_stream_active){
		WARNING("%s : stream (%p) was not active", pstream->ops->name, pstream);
		return 0;
	}

	pstream->playback_bstream->playback_stream_active = 0;
	ret = pstream->playback_bstream->ops->playback_stop(pstream->playback_bstream->ops->private_data);
	if(ret)
		ERROR("%s : Could not stop playback stream", pstream->playback_bstream->ops->name);
	

	pstream->capture_stream_active = 0;
	ret = pstream->ops->capture_stop(pstream->ops->private_data);
	if(ret)
		ERROR("%s : Could not stop stream. close will continue", pstream->ops->name);

	pstream->binfo.playback_offset = 0;
	pstream->binfo.capture_offset = 0;
	pstream->binfo.playback_chained = 0;
	pstream->binfo.capture_chained = 0;
	pstream->binfo.overrun=0;
	pstream->binfo.underrun=0;

	if(unlikely(mute_counter)){
		if(pstream->stream_id == 0){
			TRACES("unmute audio amplifier (capture_stop)");
			unmute_pwr_amp();
		}
	}

	return 0;
}

static int audio_bridge_prepare_all(struct bridge_stream *pstream1, struct bridge_stream *pstream2){
	int ret = audio_bridge_capture_prepare(pstream1);
	if(ret){
		return ret;
	}

	ret = audio_bridge_capture_prepare(pstream2);
	if(ret){
		audio_bridge_playback_close(pstream1->playback_bstream);
		audio_bridge_capture_close(pstream1);
		return ret;
	}
	return 0;
}

static void audio_bridge_close_all(struct bridge_stream *pstream1, struct bridge_stream *pstream2){
	audio_bridge_playback_close(pstream1->playback_bstream);
	audio_bridge_capture_close(pstream1);
	audio_bridge_playback_close(pstream2->playback_bstream);
	audio_bridge_capture_close(pstream2);
	return;
}

static int audio_bridge_start_all(struct bridge_stream *pstream1, struct bridge_stream *pstream2){
	int ret = audio_bridge_capture_start(pstream1);
	if(ret){
		return ret;
	}
	ret = audio_bridge_capture_start(pstream2);
	if(ret){
		audio_bridge_capture_stop(pstream1);
		return ret;
	}
	return 0;
}

static void audio_bridge_stop_all(struct bridge_stream *pstream1, struct bridge_stream *pstream2){
	audio_bridge_capture_stop(pstream1);
	audio_bridge_capture_stop(pstream2);
	return;
}


/***************************** IOCTL ***********************************/

static int audio_bridge_ioctl(struct inode *pinode, struct file *pfile, unsigned int cmd, unsigned long arg){
	int ret;
	struct bridge_stream *pstream1;
	struct bridge_stream *pstream2;
	struct bridge_ctx *pctx = pfile->private_data;

	ulog_trace_value(ULOG_AUDIO_BRIDGE_IOCTL_CALL,cmd);

	if(!pctx)
		return -EFAULT;

	pstream1 = &(pctx->bstream[0]);
	pstream2 = &(pctx->bstream[1]);

	switch(cmd){
		case IOCTL_AUDIO_BRIDGE_OPEN_DECT_CAPTURE:
			return audio_bridge_capture_prepare(pstream1);
			

		case IOCTL_AUDIO_BRIDGE_CLOSE_DECT_CAPTURE:
			audio_bridge_playback_close(pstream1->playback_bstream);
			audio_bridge_capture_close(pstream1);
			break;

		case IOCTL_AUDIO_BRIDGE_START_DECT_CAPTURE:
			return audio_bridge_capture_start(pstream1);

		case IOCTL_AUDIO_BRIDGE_STOP_DECT_CAPTURE:
			return audio_bridge_capture_stop(pstream1);


		case IOCTL_AUDIO_BRIDGE_OPEN_PMIC_CAPTURE:
			return audio_bridge_capture_prepare(pstream2);

		case IOCTL_AUDIO_BRIDGE_CLOSE_PMIC_CAPTURE:
			audio_bridge_playback_close(pstream2->playback_bstream);
			audio_bridge_capture_close(pstream2);
			break;

		case IOCTL_AUDIO_BRIDGE_START_PMIC_CAPTURE:
			return audio_bridge_capture_start(pstream2);


		case IOCTL_AUDIO_BRIDGE_STOP_PMIC_CAPTURE:
			return audio_bridge_capture_stop(pstream2);

				
		case IOCTL_AUDIO_BRIDGE_START:
			ret = audio_bridge_prepare_all(pstream1, pstream2);
			if(ret){
				return ret;
			}
			ret = audio_bridge_start_all(pstream1, pstream2);
			if(ret){
				audio_bridge_close_all(pstream1, pstream2);
				return ret;
			}
			break;

		case IOCTL_AUDIO_BRIDGE_STOP:
			audio_bridge_stop_all(pstream1, pstream2);
			audio_bridge_close_all(pstream1, pstream2);
			break;
		
#ifdef CONFIG_RELAY_TO_DEBUGFS
		case IOCTL_AUDIO_BRIDGE_GET_RELAY_BUFFER_SIZE:
			arg = SUBBUF_SIZE; 
			break;
#endif

		default:
			ERROR("%s : Default case", __func__);
			return -EINVAL;
	}
	return 0;
}

/*********************** OPEN /CLOSE ****************************/

int audio_bridge_open(struct inode *pinode, struct file *pfile){
	TRACES("-");
	pfile->private_data = (void *)g_ctx;
	return 0;
}


int audio_bridge_close(struct inode *pinode, struct file *pfile){
	struct bridge_ctx *pctx = pfile->private_data;
	TRACES("-");

	if(!pctx){
		WARNING("Private data is NULL.");
		return -ENODEV;
	}

	audio_bridge_stop_all(&(pctx->bstream[0]), &(pctx->bstream[1]));
	audio_bridge_close_all(&(pctx->bstream[0]), &(pctx->bstream[1]));

	pfile->private_data = NULL;
	return 0;
}




/* *******************************   RELAY_TO_DEBUGFS   ***********************************/

#ifdef CONFIG_RELAY_TO_DEBUGFS

static struct dentry *exr_create_buf_file_handler(const char *filename, struct dentry *parent, int mode, struct rchan_buf *buf, int *is_global){
        return debugfs_create_file(filename, mode, parent, buf, &relay_file_operations);
}

static int exr_remove_buf_file_handler(struct dentry *dentry){
        debugfs_remove(dentry);
        return 0;
}

static struct rchan_callbacks exr_callbacks =
{
        .create_buf_file = exr_create_buf_file_handler,
        .remove_buf_file = exr_remove_buf_file_handler,
};



#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20))
#define _relay_open(a)      relay_open(a, NULL, SUBBUF_SIZE, N_SUBBUFS, &exr_callbacks)
#else
#define _relay_open(a)      relay_open(a, NULL, SUBBUF_SIZE, N_SUBBUFS, &exr_callbacks, NULL);
#endif


void register_relay_to_debugfs(struct bridge_stream *pstream){


	if(!strcmp(pstream->ops->name, "mxc_pmic")){

		/*Registration of DECT CAPTURE STREAM*/

#ifdef CONFIG_RELAY_DECT_CAPTURE
		pstream->binfo.capture_rchan = _relay_open("dect_capture_record.raw");
		if(!pstream->binfo.capture_rchan){
			WARNING("Error. Not fatal : Will not be able to capture data using relay");
		}
#else
		pstream->binfo.capture_rchan = NULL;
#endif

		/*Thus associated PLAYBACK stream is PMIC playback stream*/
#ifdef CONFIG_RELAY_PMIC_PLAYBACK
		pstream->binfo.playback_rchan = _relay_open("pmic_playback_record.raw");
		if(!pstream->binfo.playback_rchan){
			WARNING("Error. Not fatal : Will not be able to capture data using relay");
		}
#else
		pstream->binfo.playback_rchan = NULL;	
#endif


	}
	else{

		/*Registration of PMIC CAPTURE STREAM*/	

#ifdef CONFIG_RELAY_PMIC_CAPTURE
		pstream->binfo.capture_rchan = _relay_open("pmic_capture_record.raw");
		if(!pstream->binfo.capture_rchan){
			WARNING("Error. Not fatal : Will not be able to capture data using relay");
		}
#else
		pstream->binfo.capture_rchan = NULL;
#endif

		/*Thus associated PLAYBACK stream is DECT playback stream*/
#ifdef CONFIG_RELAY_DECT_PLAYBACK
		pstream->binfo.playback_rchan = _relay_open("dect_playback_record.raw");
		if(!pstream->binfo.playback_rchan){
			WARNING("Error. Not fatal : Will not be able to capture data using relay");
		}
#else
		pstream->binfo.playback_rchan = NULL;	
#endif


	}



}

#endif  /*CONFIG_RELAY_TO_DEBUGFS*/





/******************** REGISTRATION ***********************/

int check_ops_struct(struct audio_bridge_operations *pops){
	if(!pops || 
	   !pops->playback_open ||
	   !pops->playback_close ||
	   !pops->playback_start ||
	   !pops->playback_stop ||
	   !pops->capture_open ||
	   !pops->capture_close ||
	   !pops->capture_start ||
	   !pops->capture_stop ||
	   !pops->private_data ||
	   !pops->name ||
	   (pops->period_size < 0) ||
	   strlen(pops->name) > SIZE_MAX_BRIDGE_FOPS_NAME-1){
		return -ENODEV;
	}
	return 0;
}

struct bridge_stream *register_audio_bridge(struct audio_bridge_operations *pops){
	int err;
	int i;
	struct bridge_stream *bstream;
	TRACES("Enter");
	
	if(!pops || !g_ctx){
		ERROR("Invalid value : pops (%p) g_ctx (%p)", pops, g_ctx);
		return NULL;
	}

	MUTEX_LOCK;
	if(g_ctx->devices >= MAX_STREAMS_IN_BRIDGE){
		ERROR("audio bridge cannot register more than %d streams", MAX_STREAMS_IN_BRIDGE);
		MUTEX_UNLOCK;
		return NULL;
	}

	err = check_ops_struct(pops);
	if(err){
		ERROR("Error while checking struct ops");
		return NULL;
	}


	for(i = 0; i < MAX_STREAMS_IN_BRIDGE; i++){

		if(!g_ctx->bstream[i].ops){
			bstream = &(g_ctx->bstream[i]);
			bstream->capture_stream_active = 0;
			bstream->playback_stream_active = 0;
			bstream->capture_status = 0;
			bstream->playback_status = 0;
			bstream->ops = pops;
			bstream->ops->buffer_infos = &(bstream->binfo);
			bstream->stream_id = i;


			//binfo initialization
			spin_lock_init(&(bstream->binfo.lock));	
			bstream->binfo.target_delay = 0;
			bstream->binfo.delay_tolerance_low = 0;
			bstream->binfo.delay_tolerance_hight = 0;
			bstream->binfo.capture_period_size=pops->period_size;
			bstream->playback_bstream->binfo.playback_period_size=pops->period_size;
			g_ctx->devices ++;

#ifdef CONFIG_RELAY_TO_DEBUGFS
			register_relay_to_debugfs(bstream);
#endif

			MUTEX_UNLOCK;


			INFOS("REGISTERED stream %d : %s", i, bstream->ops->name);
			TRACES("   stream_id              : %d",bstream->stream_id);
			TRACES("   capture_stream_status  : %d",bstream->capture_status);
			TRACES("   capture_stream_active  : %d",bstream->capture_stream_active);
			TRACES("   playback_status        : %d",bstream->playback_status);
			TRACES("   playback_stream_active : %d",bstream->playback_stream_active);
			TRACES("   buffer address         : 0x%x", (unsigned int) bstream->ops->buffer_infos->buffer);
			TRACES("   capture_period_size    : %d",bstream->binfo.capture_period_size);
			TRACES("   playback_period_size   : %d",bstream->playback_bstream->binfo.playback_period_size);

			return bstream;
		}
	}
	BUG();
	panic("What are you doing here ?");
	MUTEX_UNLOCK;
	return NULL;
}
EXPORT_SYMBOL(register_audio_bridge);

void unregister_audio_bridge(struct bridge_stream *pstream){//thibault, ok
	INFOS("Enter");

	if(!pstream || !g_ctx)
		return;

	if(!pstream->ops){
		ERROR("Device not registered");
		return;
	}

	audio_bridge_stop_all(pstream, pstream->playback_bstream);

	MUTEX_LOCK;
	
#ifdef CONFIG_RELAY_TO_DEBUGFS
	if(pstream->binfo.capture_rchan)
		relay_close(pstream->binfo.capture_rchan);
	if(pstream->binfo.playback_rchan)
		relay_close(pstream->binfo.playback_rchan);
#endif

	/*freeing buffers*/
	if(pstream->binfo.buffer){
		bridge_audio_free_buffer(pstream);
		pstream->binfo.buffer = NULL;

	}
	else
		WARNING("%s : Capture buffer was NULL", pstream->ops->name);


#ifdef CONFIG_DUMP_SIN_BRIDGE
	dump_sin_bridge_pos = DUMP_SIN_START_POS;
#endif

	
	INFOS("UNREGISTERED stream : %s", pstream->ops->name);
	TRACES("   stream_id              : %d",pstream->stream_id);
	TRACES("   capture_stream_status  : %d",pstream->capture_status);
	TRACES("   capture_stream_active  : %d",pstream->capture_stream_active);
	TRACES("   playback_status        : %d",pstream->playback_status);
	TRACES("   playback_stream_active : %d",pstream->playback_stream_active);
	TRACES("   buffer address         : 0x%x", (unsigned int) pstream->ops->buffer_infos->buffer);
	TRACES("   capture_period_size    : %d",pstream->binfo.capture_period_size);
	TRACES("   playback_period_size   : %d",pstream->playback_bstream->binfo.playback_period_size);
	


	pstream->ops = NULL;
	pstream = NULL;    

	g_ctx->devices--;
	MUTEX_UNLOCK;
	return;
}
EXPORT_SYMBOL(unregister_audio_bridge);



/***************** /SYS ***********************/


#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,27))
static ssize_t audio_bridge_sys_read(struct sys_device *dev, char *buf)
#else
static ssize_t audio_bridge_sys_read(struct sys_device *dev, struct sysdev_attribute *attr, char *buf)
#endif
{
	int size = 0;
	int i;

	if(!g_ctx)
		return -EFAULT;
	
	MUTEX_LOCK;

	for(i = 0; i < MAX_STREAMS_IN_BRIDGE; i++){

		size += sprintf((buf + size), "Bridge stream              %d :\n", g_ctx->bstream[i].stream_id);
		size += sprintf((buf + size), "  @                        %p\n", &(g_ctx->bstream[i]));
		if(g_ctx->bstream[i].ops){
			size += sprintf((buf + size), "  Used by          %s\n", g_ctx->bstream[i].ops->name);
		}
		size += sprintf((buf + size), "  ops                      %p\n", g_ctx->bstream[i].ops);
		size += sprintf((buf + size), "  playback stream          %p\n", g_ctx->bstream[i].playback_bstream);
		size += sprintf((buf + size), "  Is open :\n");
		size += sprintf((buf + size), "    playback               %d\n", g_ctx->bstream[i].playback_status);
		size += sprintf((buf + size), "    capture                %d\n", g_ctx->bstream[i].capture_status);

		size += sprintf((buf + size), "  Stream status :\n");
		size += sprintf((buf + size), "    playback               %d\n", g_ctx->bstream[i].playback_stream_active);
		size += sprintf((buf + size), "    capture                %d\n", g_ctx->bstream[i].capture_stream_active);
	
		size += sprintf((buf + size), "  binfo : \n");
		size += sprintf((buf + size), "    @                      %p\n", g_ctx->bstream[i].binfo.buffer);
		size += sprintf((buf + size), "    capture period size    %d\n", g_ctx->bstream[i].binfo.capture_period_size);
		size += sprintf((buf + size), "    Target delay           %d\n", g_ctx->bstream[i].binfo.target_delay);
		size += sprintf((buf + size), "    Tolerance hight        %d\n", g_ctx->bstream[i].binfo.delay_tolerance_hight);
		size += sprintf((buf + size), "    Tolerance low          %d\n", g_ctx->bstream[i].binfo.delay_tolerance_low);
	
		size += sprintf((buf + size), "    playback_offset        %d\n", g_ctx->bstream[i].binfo.playback_offset);
		size += sprintf((buf + size), "    capture_offset         %d\n", g_ctx->bstream[i].binfo.capture_offset);

		size += sprintf((buf + size), "    underrun               %d\n", g_ctx->bstream[i].binfo.underrun);
		size += sprintf((buf + size), "    overrun                %d\n", g_ctx->bstream[i].binfo.overrun);

		/*size += sprintf((buf + size), "\n");*/
	}

	MUTEX_UNLOCK;
	return size;
}


static SYSDEV_ATTR(audio_bridge, 0444, audio_bridge_sys_read, NULL);

static struct sysdev_class sysclass = {
#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25))
	 set_kset_name("audio_bridge"),
#else
	 .name = "audio_bridge",
#endif
};


static struct sys_device sysdevice = {
	.id = 0,
	.cls = &sysclass,
};

#ifdef CONFIG_ULOG_AUDIO_BRIDGE
static void sysdev_remove_files_4_ulog(void){
	sysdev_remove_file(&sysdevice, &attr_ulog_trace);
	sysdev_remove_file(&sysdevice, &attr_ulog_trace_value);
	sysdev_remove_file(&sysdevice, &attr_ulog_trace_stream);
	sysdev_remove_file(&sysdevice, &attr_ulog_trace_error);
	sysdev_remove_file(&sysdevice, &attr_ulog_delay_update);
	sysdev_remove_file(&sysdevice, &attr_ulog_capture_offset_update);
	sysdev_remove_file(&sysdevice, &attr_ulog_playback_offset_update);
	sysdev_remove_file(&sysdevice, &attr_ulog_delay_compensation);
	sysdev_remove_file(&sysdevice, &attr_ulog_capture_jitter);
	sysdev_remove_file(&sysdevice, &attr_ulog_playback_jitter);
	sysdev_remove_file(&sysdevice, &attr_ulog_check_all);

}

int sysdev_create_files_4_ulog(void){
	if(
			sysdev_create_file(&sysdevice, &attr_ulog_playback_jitter) ||
			sysdev_create_file(&sysdevice, &attr_ulog_capture_jitter) ||
			sysdev_create_file(&sysdevice, &attr_ulog_trace) ||
			sysdev_create_file(&sysdevice, &attr_ulog_trace_value) ||
			sysdev_create_file(&sysdevice, &attr_ulog_trace_stream) ||
			sysdev_create_file(&sysdevice, &attr_ulog_trace_error) ||
			sysdev_create_file(&sysdevice, &attr_ulog_delay_update) ||
			sysdev_create_file(&sysdevice, &attr_ulog_capture_offset_update) ||
			sysdev_create_file(&sysdevice, &attr_ulog_playback_offset_update) ||
			sysdev_create_file(&sysdevice, &attr_ulog_delay_compensation) ||
			sysdev_create_file(&sysdevice, &attr_ulog_check_all)){
		printk(KERN_ERR "Error while creating sysdev files for ulog traces\n");
		return -EINVAL;
	}
	return 0;
}
#endif




static void audio_bridge_sysdev_exit(void){
#ifdef CONFIG_ULOG_AUDIO_BRIDGE
	sysdev_remove_files_4_ulog();
#endif
	sysdev_remove_file(&sysdevice, &attr_audio_bridge);
	sysdev_unregister(&sysdevice);
	sysdev_class_unregister(&sysclass);
}

static int audio_bridge_sysdev_init(void){
	int err;
	err = sysdev_class_register(&sysclass);
	if(err){
		ERROR("Could not register class : error %d", err);
		return err;
	}

	err = sysdev_register(&sysdevice);
	if(err){
		ERROR("Could not register device : error %d", err);
		audio_bridge_sysdev_exit();
		return err;
	}

	err = sysdev_create_file(&sysdevice, &attr_audio_bridge);
	if(err){
		ERROR("Could not create a sysdev file to export pins state : error %d", err);
		audio_bridge_sysdev_exit();
		return err;
	}

#ifdef CONFIG_ULOG_AUDIO_BRIDGE
	err = sysdev_create_files_4_ulog();
	if(err){
		audio_bridge_sysdev_exit();
		return err;
	}
#endif
	return 0;
}





static struct file_operations fops = {
	.open = audio_bridge_open,
	.ioctl = audio_bridge_ioctl,
	.release = audio_bridge_close,
};


static int __init audio_bridge_init(void){
	int err;
	printk(KERN_INFO "Init audio bridge\n");

	err = audio_bridge_sysdev_init();
	if(err){
		ERROR("Could not init sysdev");
		return err;
	}
	
	MUTEX_INIT;

	g_ctx = kzalloc(sizeof(struct bridge_ctx), GFP_KERNEL);
	if(!g_ctx){
		ERROR("Could not allocate memory for driver context context\n");
		return -ENOMEM;
	}
	g_ctx->bstream[0].playback_bstream = &(g_ctx->bstream[1]);
	g_ctx->bstream[1].playback_bstream = &(g_ctx->bstream[0]);


	err = register_chrdev(AUDIO_BRIDGE_NODE_NUMBER, AUDIO_BRIDGE_MODULE_NAME, &fops);
	if(err){
		if(g_ctx){
			kfree(g_ctx);
			g_ctx = NULL;
		}
		unregister_chrdev(AUDIO_BRIDGE_NODE_NUMBER, AUDIO_BRIDGE_MODULE_NAME);
		return err;
	}
	
	return 0;
	
}



static void __exit audio_bridge_exit(void){

	printk(KERN_INFO "Exit audio bridge\n");
	
	if(mute_counter){
		unmute_pwr_amp();
	}
	
	if(g_ctx){

		audio_bridge_stop_all(&(g_ctx->bstream[0]),&(g_ctx->bstream[1]));
		
		unregister_audio_bridge(&(g_ctx->bstream[0]));	
		unregister_audio_bridge(&(g_ctx->bstream[1]));
		
		kfree(g_ctx);
		g_ctx = NULL;
	}

	audio_bridge_sysdev_exit();

	unregister_chrdev(AUDIO_BRIDGE_NODE_NUMBER, AUDIO_BRIDGE_MODULE_NAME);

}

fs_initcall(audio_bridge_init);
/*module_init(audio_bridge_init);*/
module_exit(audio_bridge_exit);
MODULE_LICENSE("GPL");

