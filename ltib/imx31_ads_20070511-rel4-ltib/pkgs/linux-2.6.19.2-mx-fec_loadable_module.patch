Bug #429. Make FEC driver load/unload as a kernel module.
--- linux-2.6.19/drivers/net/fec.c	15 Jan 2007 05:44:51 -0000	1.2
+++ linux-2.6.19-mx/drivers/net/fec.c	1 Feb 2007 11:59:12 -0000	1.3
@@ -274,6 +274,11 @@
  */
 static int fec_copy_threshold = 192;
 
+/*
+ * fec_device records the devices created for cleanup
+ */
+struct net_device *fec_device[FEC_MAX_PORTS];
+
 /* MII processing.  We keep this as simple as possible.  Requests are
  * placed on the list (if there is room).  When the request is finished
  * by the MII, an optional function may be called.
@@ -2041,6 +2046,15 @@
 	disable_irq(EXPIO_INT_FEC);
 }
 
+static void __inline__ fec_release_intrs(struct net_device *dev)
+{
+	disable_irq(EXPIO_INT_FEC);
+	disable_irq(INT_FEC);
+
+	free_irq(EXPIO_INT_FEC, dev);
+	free_irq(INT_FEC, dev);
+}
+
 static void __inline__ fec_set_mii(struct net_device *dev, struct fec_enet_private *fep)
 {
 	volatile fec_t *fecp;
@@ -3053,6 +3067,8 @@
 			return -EIO;
 		}
 
+		fec_device[i] = dev;
+
 		printk("%s: ethernet ", dev->name);
 		for (j = 0; (j < 5); j++)
 			printk("%02x:", dev->dev_addr[j]);
@@ -3063,4 +3079,23 @@
 
 module_init(fec_enet_module_init);
 
+#ifdef CONFIG_ARCH_MXC
+static void __exit fec_enet_module_cleanup(void)
+{
+	struct net_device *dev;
+	int i;
+
+	for (i = 0; (i < FEC_MAX_PORTS); i++) {
+		dev = fec_device[i];
+		fec_release_intrs(dev);
+		unregister_netdev(dev);
+		free_netdev(dev);
+		fec_device[i] = NULL;
+	}
+
+	fec_arch_exit();
+}
+module_exit(fec_enet_module_cleanup);
+#endif
+
 MODULE_LICENSE("GPL");
