--- linux-2.6.19.2/arch/arm/configs/imx27ads_defconfig	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/configs/imx27ads_defconfig	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,1536 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.18.1
+# Tue Dec 19 15:53:33 2006
+#
+CONFIG_ARM=y
+CONFIG_MMU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+
+#
+# General setup
+#
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+# CONFIG_RELAY is not set
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_EMBEDDED=y
+CONFIG_UID16=y
+CONFIG_SYSCTL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SHMEM=y
+CONFIG_SLAB=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_RT_MUTEXES=y
+# CONFIG_TINY_SHMEM is not set
+CONFIG_BASE_SMALL=0
+# CONFIG_SLOB is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_KMOD=y
+
+#
+# Block layer
+#
+# CONFIG_BLK_DEV_IO_TRACE is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+
+#
+# System Type
+#
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_CLPS7500 is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CO285 is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IMX is not set
+# CONFIG_ARCH_IOP3XX is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_L7200 is not set
+CONFIG_ARCH_MXC=y
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_OMAP is not set
+
+#
+# Freescale MXC Implementations
+#
+# CONFIG_ARCH_MX3 is not set
+CONFIG_ARCH_MX27=y
+
+#
+# MX27 Options
+#
+CONFIG_MACH_MX27ADS=y
+CONFIG_ISP1504_MXC=y
+CONFIG_ISP1301_MXC=y
+CONFIG_MXC_EMMA=y
+
+#
+# Processor Type
+#
+CONFIG_CPU_32=y
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+
+#
+# Bus support
+#
+CONFIG_ISA=y
+
+#
+# PCCARD (PCMCIA/CardBus) support
+#
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_PREEMPT=y
+# CONFIG_NO_IDLE_HZ is not set
+CONFIG_HZ=100
+# CONFIG_AEABI is not set
+# CONFIG_ARCH_DISCONTIGMEM_ENABLE is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+# CONFIG_SPARSEMEM_STATIC is not set
+CONFIG_SPLIT_PTLOCK_CPUS=4096
+# CONFIG_RESOURCES_64BIT is not set
+CONFIG_ALIGNMENT_TRAP=y
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="noinitrd console=ttymxc0 root=/dev/mtdblock2 rw ip=off"
+# CONFIG_XIP_KERNEL is not set
+
+#
+# CPU Frequency scaling
+#
+# CONFIG_CPU_FREQ is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+# CONFIG_ARTHUR is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_LEGACY is not set
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM is not set
+
+#
+# Networking
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_NETDEBUG is not set
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_BIC=y
+# CONFIG_IPV6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+
+#
+# DCCP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_DCCP is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+
+#
+# TIPC Configuration (EXPERIMENTAL)
+#
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+CONFIG_IRDA=m
+
+#
+# IrDA protocols
+#
+CONFIG_IRLAN=m
+CONFIG_IRNET=m
+CONFIG_IRCOMM=m
+# CONFIG_IRDA_ULTRA is not set
+
+#
+# IrDA options
+#
+CONFIG_IRDA_CACHE_LAST_LSAP=y
+CONFIG_IRDA_FAST_RR=y
+# CONFIG_IRDA_DEBUG is not set
+
+#
+# Infrared-port device drivers
+#
+
+#
+# SIR device drivers
+#
+CONFIG_IRTTY_SIR=m
+
+#
+# Dongle support
+#
+# CONFIG_DONGLE is not set
+
+#
+# Old SIR device drivers
+#
+# CONFIG_IRPORT_SIR is not set
+
+#
+# Old Serial dongle support
+#
+
+#
+# FIR device drivers
+#
+# CONFIG_USB_IRDA is not set
+# CONFIG_SIGMATEL_FIR is not set
+# CONFIG_MCS_FIR is not set
+# CONFIG_MXC_FIR is not set
+# CONFIG_BT is not set
+CONFIG_IEEE80211=y
+# CONFIG_IEEE80211_DEBUG is not set
+# CONFIG_IEEE80211_CRYPT_WEP is not set
+# CONFIG_IEEE80211_CRYPT_CCMP is not set
+# CONFIG_IEEE80211_CRYPT_TKIP is not set
+# CONFIG_IEEE80211_SOFTMAC is not set
+CONFIG_WIRELESS_EXT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+# CONFIG_SYS_HYPERVISOR is not set
+
+#
+# Connector - unified userspace <-> kernelspace linker
+#
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+CONFIG_MTD_REDBOOT_PARTS=y
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+# CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED is not set
+# CONFIG_MTD_REDBOOT_PARTS_READONLY is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+CONFIG_MTD_CFI_ADV_OPTIONS=y
+CONFIG_MTD_CFI_NOSWAP=y
+# CONFIG_MTD_CFI_BE_BYTE_SWAP is not set
+# CONFIG_MTD_CFI_LE_BYTE_SWAP is not set
+CONFIG_MTD_CFI_GEOMETRY=y
+# CONFIG_MTD_MAP_BANK_WIDTH_1 is not set
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+# CONFIG_MTD_MAP_BANK_WIDTH_4 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+# CONFIG_MTD_CFI_I2 is not set
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_OTP is not set
+# CONFIG_MTD_CFI_INTELEXT is not set
+CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+CONFIG_MTD_RAM=y
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PHYSMAP is not set
+# CONFIG_MTD_ARM_INTEGRATOR is not set
+# CONFIG_MTD_PLATRAM is not set
+CONFIG_MTD_MXC=y
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_MXC=y
+# CONFIG_MTD_NAND_MXC_SWECC is not set
+# CONFIG_MTD_NAND_MXC_FORCE_CE is not set
+# CONFIG_MTD_NAND_MXC_ECC_CORRECTION_OPTION2 is not set
+# CONFIG_CONFIG_MXC_NAND_LOW_LEVEL_ERASE is not set
+
+#
+# OneNAND Flash Device Drivers
+#
+# CONFIG_MTD_ONENAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+# CONFIG_PNP is not set
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+# CONFIG_BLK_DEV_INITRD is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+# CONFIG_BLK_DEV_IDE_SATA is not set
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+# CONFIG_BLK_DEV_IDECD is not set
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
+CONFIG_BLK_DEV_IDE_MXC=y
+# CONFIG_IDE_CHIPSETS is not set
+CONFIG_BLK_DEV_IDEDMA=y
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_SCSI_AHA152X is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_IN2000 is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_DTC3280 is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_GENERIC_NCR5380 is not set
+# CONFIG_SCSI_GENERIC_NCR5380_MMIO is not set
+# CONFIG_SCSI_NCR53C406A is not set
+# CONFIG_SCSI_PAS16 is not set
+# CONFIG_SCSI_PSI240I is not set
+# CONFIG_SCSI_QLOGIC_FAS is not set
+# CONFIG_SCSI_SYM53C416 is not set
+# CONFIG_SCSI_T128 is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# I2O device support
+#
+
+#
+# Network device support
+#
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# PHY device support
+#
+# CONFIG_PHYLIB is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_SMC is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_NET_VENDOR_RACAL is not set
+# CONFIG_AT1700 is not set
+# CONFIG_DEPCA is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_ISA is not set
+CONFIG_NET_PCI=y
+# CONFIG_AC3200 is not set
+# CONFIG_APRICOT is not set
+CONFIG_CS89x0=y
+# CONFIG_FEC is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+
+#
+# Ethernet (10000 Mbit)
+#
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+CONFIG_NET_RADIO=y
+# CONFIG_NET_WIRELESS_RTNETLINK is not set
+
+#
+# Obsolete Wireless cards support (pre-802.11)
+#
+# CONFIG_STRIP is not set
+# CONFIG_ARLAN is not set
+# CONFIG_WAVELAN is not set
+
+#
+# Wireless 802.11b ISA/PCI cards support
+#
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_HOSTAP is not set
+CONFIG_NET_WIRELESS=y
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+CONFIG_PPP=m
+# CONFIG_PPP_MULTILINK is not set
+# CONFIG_PPP_FILTER is not set
+CONFIG_PPP_ASYNC=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_PPP_DEFLATE=m
+# CONFIG_PPP_BSDCOMP is not set
+# CONFIG_PPP_MPPE is not set
+# CONFIG_PPPOE is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ATKBD is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+CONFIG_KEYBOARD_MXC=y
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+CONFIG_TOUCHSCREEN_MXC=y
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=1
+CONFIG_SERIAL_8250_RUNTIME_UARTS=1
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_MXC=y
+CONFIG_SERIAL_MXC_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_NOWAYOUT=y
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_MXC_WATCHDOG=y
+
+#
+# ISA-based Watchdog Cards
+#
+# CONFIG_PCWATCHDOG is not set
+# CONFIG_MIXCOMWD is not set
+# CONFIG_WDT is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_NVRAM is not set
+CONFIG_MXC_RTC=y
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_RAW_DRIVER is not set
+
+#
+# TPM devices
+#
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+
+#
+# I2C support
+#
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+
+#
+# I2C Algorithms
+#
+# CONFIG_I2C_ALGOBIT is not set
+# CONFIG_I2C_ALGOPCF is not set
+# CONFIG_I2C_ALGOPCA is not set
+
+#
+# I2C Hardware Bus support
+#
+# CONFIG_I2C_ELEKTOR is not set
+CONFIG_I2C_MXC=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_PCA_ISA is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_SENSORS_DS1337 is not set
+# CONFIG_SENSORS_DS1374 is not set
+# CONFIG_SENSORS_EEPROM is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+
+#
+# SPI support
+#
+CONFIG_SPI=y
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+CONFIG_SPI_BITBANG=y
+CONFIG_SPI_MXC=y
+# CONFIG_SPI_MXC_TEST_LOOPBACK is not set
+CONFIG_SPI_MXC_SELECT1=y
+CONFIG_SPI_MXC_SELECT2=y
+# CONFIG_SPI_MXC_SELECT3 is not set
+
+#
+# SPI Protocol Masters
+#
+
+#
+# Dallas's 1-wire bus
+#
+CONFIG_W1=m
+CONFIG_W1_CON=y
+
+#
+# 1-wire Bus Masters
+#
+# CONFIG_W1_MASTER_DS2490 is not set
+# CONFIG_W1_MASTER_DS2482 is not set
+CONFIG_W1_MASTER_MXC=m
+
+#
+# 1-wire Slaves
+#
+# CONFIG_W1_SLAVE_THERM is not set
+# CONFIG_W1_SLAVE_SMEM is not set
+CONFIG_W1_SLAVE_DS2433=m
+# CONFIG_W1_SLAVE_DS2433_CRC is not set
+
+#
+# Hardware Monitoring support
+#
+# CONFIG_HWMON is not set
+# CONFIG_HWMON_VID is not set
+
+#
+# Misc devices
+#
+
+#
+# LED devices
+#
+# CONFIG_NEW_LEDS is not set
+
+#
+# LED drivers
+#
+
+#
+# LED Triggers
+#
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+CONFIG_VIDEO_V4L1=y
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_VIDEO_V4L2=y
+
+#
+# Video Capture Adapters
+#
+
+#
+# Video Capture Adapters
+#
+# CONFIG_VIDEO_ADV_DEBUG is not set
+# CONFIG_VIDEO_VIVI is not set
+# CONFIG_VIDEO_PMS is not set
+CONFIG_VIDEO_MXC_CAMERA=y
+
+#
+# MXC Camera/V4L2 PRP Features support
+#
+CONFIG_VIDEO_MXC_EMMA_CAMERA=y
+CONFIG_MXC_CAMERA_MICRON111=y
+CONFIG_VIDEO_MXC_OUTPUT=y
+CONFIG_VIDEO_MXC_EMMA_OUTPUT=y
+CONFIG_VIDEO_MXC_OPL=y
+# CONFIG_VIDEO_CPIA is not set
+# CONFIG_VIDEO_CPIA2 is not set
+# CONFIG_VIDEO_SAA5246A is not set
+# CONFIG_VIDEO_SAA5249 is not set
+# CONFIG_TUNER_3036 is not set
+
+#
+# Encoders and Decoders
+#
+# CONFIG_VIDEO_MSP3400 is not set
+# CONFIG_VIDEO_CS53L32A is not set
+# CONFIG_VIDEO_TLV320AIC23B is not set
+# CONFIG_VIDEO_WM8775 is not set
+# CONFIG_VIDEO_WM8739 is not set
+# CONFIG_VIDEO_CX2341X is not set
+# CONFIG_VIDEO_CX25840 is not set
+# CONFIG_VIDEO_SAA711X is not set
+# CONFIG_VIDEO_SAA7127 is not set
+# CONFIG_VIDEO_UPD64031A is not set
+# CONFIG_VIDEO_UPD64083 is not set
+
+#
+# V4L USB devices
+#
+# CONFIG_VIDEO_PVRUSB2 is not set
+# CONFIG_VIDEO_EM28XX is not set
+# CONFIG_USB_VICAM is not set
+# CONFIG_USB_IBMCAM is not set
+# CONFIG_USB_KONICAWC is not set
+# CONFIG_USB_QUICKCAM_MESSENGER is not set
+# CONFIG_USB_ET61X251 is not set
+# CONFIG_VIDEO_OVCAMCHIP is not set
+# CONFIG_USB_W9968CF is not set
+# CONFIG_USB_OV511 is not set
+# CONFIG_USB_SE401 is not set
+# CONFIG_USB_SN9C102 is not set
+# CONFIG_USB_STV680 is not set
+# CONFIG_USB_ZC0301 is not set
+# CONFIG_USB_PWC is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_CADET is not set
+# CONFIG_RADIO_RTRACK is not set
+# CONFIG_RADIO_RTRACK2 is not set
+# CONFIG_RADIO_AZTECH is not set
+# CONFIG_RADIO_GEMTEK is not set
+# CONFIG_RADIO_MAESTRO is not set
+# CONFIG_RADIO_SF16FMI is not set
+# CONFIG_RADIO_SF16FMR2 is not set
+# CONFIG_RADIO_TERRATEC is not set
+# CONFIG_RADIO_TRUST is not set
+# CONFIG_RADIO_TYPHOON is not set
+# CONFIG_RADIO_ZOLTRIX is not set
+# CONFIG_USB_DSBR is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+CONFIG_FB_MXC=y
+CONFIG_FB_MXC_SYNC_PANEL=y
+CONFIG_FB_MXC_TVOUT=y
+# CONFIG_FB_MXC_OVERLAY is not set
+# CONFIG_FB_MXC_ASYNC_PANEL is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Sound
+#
+CONFIG_SOUND=y
+
+#
+# Advanced Linux Sound Architecture
+#
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+
+#
+# Generic devices
+#
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# ALSA ARM devices
+#
+CONFIG_SND_MXC_PMIC=y
+
+#
+# USB devices
+#
+# CONFIG_SND_USB_AUDIO is not set
+
+#
+# Open Sound System
+#
+# CONFIG_SOUND_PRIME is not set
+
+#
+# USB support
+#
+CONFIG_USB_ARCH_HAS_HCD=y
+# CONFIG_USB_ARCH_HAS_OHCI is not set
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_BANDWIDTH is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+CONFIG_USB_SUSPEND=y
+# CONFIG_USB_OTG is not set
+
+#
+# USB Host Controller Drivers
+#
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ARC=y
+CONFIG_USB_EHCI_ARC_H1=y
+# CONFIG_USB_EHCI_ARC_H2 is not set
+CONFIG_USB_EHCI_ARC_OTG=y
+# CONFIG_USB_EHCI_ARC_OTGHS is not set
+CONFIG_USB_EHCI_ARC_OTGFS=y
+# CONFIG_USB_EHCI_SPLIT_ISO is not set
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+
+#
+# NOTE: USB_STORAGE enables SCSI, and 'SCSI disk support'
+#
+
+#
+# may also be needed; see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_DPCM is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=m
+CONFIG_USB_HIDINPUT=y
+# CONFIG_USB_HIDINPUT_POWERBOOK is not set
+# CONFIG_HID_FF is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+# CONFIG_USB_AIPTEK is not set
+# CONFIG_USB_WACOM is not set
+# CONFIG_USB_ACECAD is not set
+# CONFIG_USB_KBTAB is not set
+# CONFIG_USB_POWERMATE is not set
+# CONFIG_USB_TOUCHSCREEN is not set
+# CONFIG_USB_YEALINK is not set
+# CONFIG_USB_XPAD is not set
+# CONFIG_USB_ATI_REMOTE is not set
+# CONFIG_USB_ATI_REMOTE2 is not set
+# CONFIG_USB_KEYSPAN_REMOTE is not set
+# CONFIG_USB_APPLETOUCH is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_USB_MON=y
+
+#
+# USB port drivers
+#
+
+#
+# USB Serial Converter support
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_AUERSWALD is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGETKIT is not set
+# CONFIG_USB_PHIDGETSERVO is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TEST is not set
+
+#
+# USB DSL modem support
+#
+
+#
+# USB Gadget Support
+#
+CONFIG_USB_GADGET=m
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_PXA2XX is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+CONFIG_USB_GADGET_ARC=y
+CONFIG_USB_ARC=m
+# CONFIG_USB_GADGET_AT91 is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_USB_GADGET_ARC_OTG=y
+CONFIG_USB_GADGET_ARC_OTGFS=y
+# CONFIG_USB_GADGET_ARC_OTGHS is not set
+# CONFIG_USB_ZERO is not set
+CONFIG_USB_ETH=m
+CONFIG_USB_ETH_RNDIS=y
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_FILE_STORAGE=m
+# CONFIG_USB_FILE_STORAGE_TEST is not set
+# CONFIG_USB_G_SERIAL is not set
+
+#
+# MMC/SD Card support
+#
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_MXC=y
+
+#
+# Real Time Clock
+#
+CONFIG_RTC_LIB=y
+# CONFIG_RTC_CLASS is not set
+
+#
+# MXC support drivers
+#
+
+#
+# MXC IPU
+#
+
+#
+# MXC SSI support
+#
+CONFIG_MXC_SSI=y
+
+#
+# MXC Digital Audio Multiplexer support
+#
+CONFIG_MXC_DAM=y
+
+#
+# MXC PMIC support
+#
+CONFIG_MXC_SPI_PMIC_CORE=y
+CONFIG_MXC_PMIC=y
+CONFIG_MXC_PMIC_CHARDEV=y
+
+#
+# MXC PMIC Client Drivers
+#
+CONFIG_MXC_PMIC_MC13783=y
+CONFIG_MXC_MC13783_ADC=y
+CONFIG_MXC_MC13783_AUDIO=y
+CONFIG_MXC_MC13783_RTC=y
+CONFIG_MXC_MC13783_LIGHT=y
+CONFIG_MXC_MC13783_BATTERY=y
+CONFIG_MXC_MC13783_CONNECTIVITY=y
+CONFIG_MXC_MC13783_POWER=y
+
+#
+# Advanced Power Management devices
+#
+CONFIG_MX27_DPTC=y
+
+#
+# MXC Security Drivers
+#
+CONFIG_MXC_SECURITY_SCC=y
+CONFIG_MXC_SECURITY_RTIC=y
+# CONFIG_MXC_RTIC_TEST_DEBUG is not set
+CONFIG_MXC_SECURITY_CORE=y
+
+#
+# SAHARA2 Security Hardware Support
+#
+CONFIG_MXC_SAHARA=y
+CONFIG_MXC_SAHARA_USER_MODE=y
+# CONFIG_MXC_SAHARA_POLL_MODE is not set
+
+#
+# MXC MPEG4 Encoder Kernel module support
+#
+
+#
+# H.264 VPU Codec support
+#
+CONFIG_MXC_VPU=y
+# CONFIG_MXC_VPU_DEBUG is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+CONFIG_DNOTIFY=y
+# CONFIG_AUTOFS_FS is not set
+CONFIG_AUTOFS4_FS=m
+# CONFIG_FUSE_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+# CONFIG_CONFIGFS_FS is not set
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_JFFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_CRAMFS=y
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+# CONFIG_9P_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_DEBUG_BUGVERBOSE is not set
+# CONFIG_DEBUG_FS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_UNWIND_INFO is not set
+# CONFIG_DEBUG_USER is not set
+
+#
+# CodeTEST setup
+#
+# CONFIG_CODETEST is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Hardware crypto devices
+#
+
+#
+# Library routines
+#
+CONFIG_CRC_CCITT=m
+# CONFIG_CRC16 is not set
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_PLIST=y
--- linux-2.6.19.2/arch/arm/mach-mx27/clock.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/clock.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,1323 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file clock.c
+ * @brief API for setting up and retrieving clocks.
+ *
+ * This file contains API for setting up and retrieving clocks.
+ *
+ * @ingroup CLOCKS
+ */
+
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include "crm_regs.h"
+/*!
+ * Spinlock to protect CRM register accesses
+ */
+static DEFINE_SPINLOCK(mxc_crm_lock);
+
+/*!
+ * define a variable & macro to control the perclk2.
+ */
+#define MXC_CLK_PCLK2_CSPI1	0
+#define MXC_CLK_PCLK2_CSPI2	1
+#define MXC_CLK_PCLK2_CSPI3	2
+#define MXC_CLK_PCLK2_SDHC1	3
+#define MXC_CLK_PCLK2_SDHC2	4
+static int g_perclk2_map = 0;
+
+/*!
+ * g_emma_clock_map is defined to control the emma_clock .
+ * emma_clock will be disabled until emma_prp_clk and emma_pp_clk are closed.
+ */
+#define MXC_CLK_EMMA_PRP	0
+#define MXC_CLK_EMMA_PP		1
+static int g_emma_clock_map = 0;
+
+/*
+ * Bit fields
+ */
+#define CLKSRC_NO_CLK	    	0
+#define CLKSRC_PERCLK	    	1
+#define CLKSRC_PERCLK_4   	2
+#define CLKSRC_EXT_PAD	    	3
+
+/*
+ * Get Clock errors
+ */
+#define ERR_CLK_NO_SUPPORT	1
+
+/*!
+ * This function enables the perclk2.
+ * @param	source each bit of source indicate the clock status of mdoule
+ *		which is using emma clk
+ * @return      none.
+ */
+static void inline __enable_perclk2(unsigned long source)
+{
+	unsigned long reg;
+
+	BUG_ON(source > 31);
+	if (g_perclk2_map == 0) {
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_PERCLK2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+	}
+	g_perclk2_map |= (1 << source);
+}
+
+/*!
+ * This function disables the perclk2.
+ * @param	source each bit of source indicate the clock status of mdoule
+ *		which is using emma clk
+ * @return      none.
+ */
+static void inline __disable_perclk2(unsigned long source)
+{
+	unsigned long reg;
+
+	BUG_ON(source > 31);
+	g_perclk2_map &= ~(1 << source);
+	if (g_perclk2_map == 0) {
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_PERCLK2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+	}
+}
+
+/*!
+ * This function enables the emma clock.
+ * @param	source each bit of source indicate the clock status of mdoule
+ *		which is using emma clk
+ * @return 	none
+ */
+static void inline __enable_emma_clk(unsigned long source)
+{
+	unsigned long reg;
+
+	if (g_emma_clock_map == 0) {
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_EMMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_EMMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+	}
+	g_emma_clock_map |= (1 << source);
+}
+
+/*!
+ * This function disables the emma clock.
+ * @param	source each bit of source indicate the clock status of mdoule
+ *		which is using emma clk
+ * @return 	none
+ */
+static void inline __disable_emma_clk(unsigned long source)
+{
+	unsigned long reg;
+
+	g_emma_clock_map &= ~(1 << source);
+	if (g_emma_clock_map == 0) {
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_EMMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_EMMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+	}
+}
+
+/*
+ * This function returns the clock CKIH clock input value.
+ */
+static unsigned long mxc_clock_ckih(void)
+{
+	static unsigned long g_clk_ckih = 0;
+
+	if (g_clk_ckih == 0) {
+		if ((__raw_readw(PBC_VERSION_REG) & CKIH_27MHZ_BIT_SET) == 0) {
+			g_clk_ckih = CKIH_CLK_FREQ_27MHZ;
+		} else {
+			g_clk_ckih = CKIH_CLK_FREQ;
+		}
+		pr_info("Clock input source is %ld\n", g_clk_ckih);
+	}
+
+	return g_clk_ckih;
+}
+
+/*!
+ * This function returns the PLL output value in Hz based on pll.
+ * @param       pll     PLL as defined in enum plls
+ * @return      PLL value in Hz.
+ */
+unsigned long mxc_pll_clock(enum plls pll)
+{
+	unsigned long mfi = 0, mfn = 0, mfd = 0, pdf = 0;
+	unsigned long ref_clk = 0, prcs = 0;
+	unsigned long reg, cscr;
+	unsigned long long temp;
+
+	cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	if (pll == MCUPLL) {
+		prcs = (cscr & CCM_CSCR_MCU);
+		if (prcs == CCM_CSCR_MCU) {
+			ref_clk = mxc_clock_ckih();
+		} else {
+			ref_clk = CKIL_CLK_FREQ;
+		}
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_MPCTL0);
+		pdf = (reg & CCM_MPCTL0_PD_MASK) >> CCM_MPCTL0_PD_OFFSET;
+		mfd = (reg & CCM_MPCTL0_MFD_MASK) >> CCM_MPCTL0_MFD_OFFSET;
+		mfi = (reg & CCM_MPCTL0_MFI_MASK) >> CCM_MPCTL0_MFI_OFFSET;
+		mfn = (reg & CCM_MPCTL0_MFN_MASK) >> CCM_MPCTL0_MFN_OFFSET;
+	} else if (pll == SERIALPLL) {
+		prcs = (cscr & CCM_CSCR_SP);
+		if (prcs == CCM_CSCR_SP) {
+			ref_clk = mxc_clock_ckih();
+		} else {
+			ref_clk = CKIL_CLK_FREQ;
+		}
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_SPCTL0);
+		pdf = (reg & CCM_SPCTL0_PD_MASK) >> CCM_SPCTL0_PD_OFFSET;
+		mfd = (reg & CCM_SPCTL0_MFD_MASK) >> CCM_SPCTL0_MFD_OFFSET;
+		mfi = (reg & CCM_SPCTL0_MFI_MASK) >> CCM_SPCTL0_MFI_OFFSET;
+		mfn = (reg & CCM_SPCTL0_MFN_MASK) >> CCM_SPCTL0_MFN_OFFSET;
+	} else {
+		printk(KERN_ERR "\nUnknown pll: %d\n\n", pll);
+		BUG();		/* oops */
+	}
+
+	mfi = (mfi <= 5) ? 5 : mfi;
+	temp = (unsigned long long)2 *ref_clk * mfn;
+	do_div(temp, mfd + 1);
+	temp = (unsigned long long)2 *ref_clk * mfi + temp;
+	do_div(temp, pdf + 1);
+
+	return (unsigned long)temp;
+}
+
+/*!
+ * This function returns the mcu main clock frequency
+ *
+ * @return      mcu main clock value in Hz.
+ */
+static unsigned long mxc_mcu_main_clock(void)
+{
+	return mxc_pll_clock(MCUPLL);
+}
+
+/*!
+ * This function returns the GPT module clock frequency
+ *
+ * @param       gpt_ctrl     GPT control register value
+ * @param       perclk       PERCLK1 frequency in Hz
+ *
+ * @return      GPT clock frequency value in Hz.
+ */
+static unsigned long mxc_get_gpt_clk(unsigned long gpt_ctrl,
+				     unsigned long perclk)
+{
+	unsigned long ret_val = 0;
+	int clksrc;
+
+	/*
+	 * Three possibilities
+	 */
+	clksrc = (gpt_ctrl & (~GPT_CTRL_MASK)) >> (GPT_CTRL_OFFSET);
+	switch (clksrc) {
+	case CLKSRC_PERCLK:
+		ret_val = perclk;
+		break;
+	case CLKSRC_PERCLK_4:
+		ret_val = (perclk / 4);
+		break;
+	case CLKSRC_NO_CLK:
+	case CLKSRC_EXT_PAD:
+		printk(KERN_ERR
+		       "Warning: GPT clock source not supported !!!\n");
+		return -ERR_CLK_NO_SUPPORT;
+	default:
+		ret_val = CKIL_CLK_FREQ;
+		break;
+	}
+
+	return ret_val;
+}
+
+/*!
+ * This function returns the main clock values in Hz.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks(enum mxc_clocks clk)
+{
+	unsigned long pll, spll, ret_val = 0, hclk, gpt_ctrl;
+	unsigned long presc_pdf, ipg_pdf, nfc_pdf, usb_pdf;
+	unsigned long cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	unsigned long pcdr0 =
+	    __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+	unsigned long pcdr1 =
+	    __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+
+	unsigned long fclk, ipgclk, perclk1, perclk2, perclk3, perclk4;
+	unsigned long bclk_pdf;
+	unsigned long perclk1_pdf, perclk2_pdf, perclk3_pdf, perclk4_pdf;
+	unsigned long clk_src;
+	unsigned long ssi1_pdf = 0;
+	unsigned long ssi2_pdf = 0;
+	unsigned long vpu_pdf = 0;
+	presc_pdf = (cscr & CCM_CSCR_PRESC_MASK) >> CCM_CSCR_PRESC_OFFSET;
+	bclk_pdf = (cscr & CCM_CSCR_BCLK_MASK) >> CCM_CSCR_BCLK_OFFSET;
+	ipg_pdf = (cscr & CCM_CSCR_IPDIV) >> CCM_CSCR_IPDIV_OFFSET;
+	perclk1_pdf =
+	    (pcdr1 & CCM_PCDR1_PERDIV1_MASK) >> CCM_PCDR1_PERDIV1_OFFSET;
+	perclk2_pdf =
+	    (pcdr1 & CCM_PCDR1_PERDIV2_MASK) >> CCM_PCDR1_PERDIV2_OFFSET;
+	perclk3_pdf =
+	    (pcdr1 & CCM_PCDR1_PERDIV3_MASK) >> CCM_PCDR1_PERDIV3_OFFSET;
+	perclk4_pdf =
+	    (pcdr1 & CCM_PCDR1_PERDIV4_MASK) >> CCM_PCDR1_PERDIV4_OFFSET;
+
+	pll = mxc_mcu_main_clock();
+	spll = mxc_pll_clock(SERIALPLL);
+	fclk = pll / (presc_pdf + 1);
+	hclk = fclk / (bclk_pdf + 1);
+	ipgclk = hclk / (ipg_pdf + 1);
+	perclk1 = pll / (perclk1_pdf + 1);
+	perclk2 = pll / (perclk2_pdf + 1);
+	perclk3 = pll / (perclk3_pdf + 1);
+	perclk4 = pll / (perclk4_pdf + 1);
+	switch (clk) {
+	case CKIL_CLK:
+		ret_val = CKIL_CLK_FREQ;
+		break;
+	case CKIH_CLK:
+		ret_val = mxc_clock_ckih();
+		break;
+	case CPU_CLK:
+		ret_val = fclk;
+		break;
+	case AHB_CLK:
+		ret_val = hclk;
+		break;
+	case PERCLK1:
+	case UART6_BAUD:
+	case UART5_BAUD:
+	case UART4_BAUD:
+	case UART3_BAUD:
+	case UART2_BAUD:
+	case UART1_BAUD:
+		ret_val = perclk1;
+		break;
+	case GPT6_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(6));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT5_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(5));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT4_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(4));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT3_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(3));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT2_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(2));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case GPT1_CLK:
+		gpt_ctrl = __raw_readl(MXC_GPT_TCTL(1));
+		ret_val = mxc_get_gpt_clk(gpt_ctrl, perclk1);
+		break;
+	case PWM_CLK:
+		ret_val = perclk1;
+		break;
+	case PERCLK2:
+	case SDHC2_CLK:
+	case SDHC1_CLK:
+	case CSPI3_CLK:
+	case CSPI2_CLK:
+	case CSPI1_CLK:
+		ret_val = perclk2;
+		break;
+	case PERCLK3:
+	case LCDC_CLK:
+		ret_val = perclk3;
+		break;
+	case PERCLK4:
+	case CSI_BAUD:
+		ret_val = perclk4;
+		break;
+	case USB_CLK:
+		usb_pdf = (cscr & CCM_CSCR_USB_MASK) >> CCM_CSCR_USB_OFFSET;
+		ret_val = spll / (usb_pdf + 1);
+		break;
+	case SSI1_BAUD:
+		ssi1_pdf = (pcdr0 & CCM_PCDR0_SSI1BAUDDIV_MASK) >>
+		    CCM_PCDR0_SSI1BAUDDIV_OFFSET;
+		clk_src = (cscr & CCM_CSCR_SSI1) >> CCM_CSCR_SSI1_OFFSET;
+		if (clk_src)
+			ret_val = pll / (ssi1_pdf + 1);
+		else
+			ret_val = spll / (ssi1_pdf + 1);
+		break;
+	case SSI2_BAUD:
+		ssi1_pdf = (pcdr0 & CCM_PCDR0_SSI2BAUDDIV_MASK) >>
+		    CCM_PCDR0_SSI2BAUDDIV_OFFSET;
+		clk_src = (cscr & CCM_CSCR_SSI2) >> CCM_CSCR_SSI2_OFFSET;
+		if (clk_src)
+			ret_val = pll / (ssi2_pdf + 1);
+		else
+			ret_val = spll / (ssi2_pdf + 1);
+		break;
+	case NFC_CLK:
+		nfc_pdf = (pcdr0 & CCM_PCDR0_NFCDIV_MASK) >>
+		    CCM_PCDR0_NFCDIV_OFFSET;
+		ret_val = hclk / (nfc_pdf + 1);
+		break;
+	case VPU_BAUD:
+		vpu_pdf = (pcdr0 & CCM_PCDR0_VPUDIV_MASK) >>
+		    CCM_PCDR0_VPUDIV_OFFSET;
+		clk_src = (cscr & CCM_CSCR_VPU) >> CCM_CSCR_VPU_OFFSET;
+		if (clk_src)
+			ret_val = pll / (vpu_pdf + 1);
+		else
+			ret_val = spll / (vpu_pdf + 1);
+		break;
+	case OWIRE_CLK:
+	default:
+		ret_val = ipgclk;
+		break;
+	}
+	return ret_val;
+}
+
+/*!
+ * This function returns the parent clock values in Hz.
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ *
+ * @return      clock value in Hz
+ */
+unsigned long mxc_get_clocks_parent(enum mxc_clocks clk)
+{
+	unsigned long ret_val = 0;
+
+	switch (clk) {
+	case CSI_BAUD:
+		ret_val = mxc_mcu_main_clock();
+		break;
+	default:
+		break;
+	}
+	return ret_val;
+}
+
+/*!
+ * This function sets the PLL source for a clock.
+ *
+ * @param clk     as defined in enum mxc_clocks
+ * @param pll_num the PLL that you wish to use as source for this clock
+ */
+void mxc_set_clocks_pll(enum mxc_clocks clk, enum plls pll_num)
+{
+	unsigned long cscr;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+
+	switch (clk) {
+	case SSI1_BAUD:
+		cscr = (cscr & (~CCM_CSCR_SSI1)) |
+		    (pll_num << CCM_CSCR_SSI1_OFFSET);
+		break;
+	case SSI2_BAUD:
+		cscr = (cscr & (~CCM_CSCR_SSI2)) |
+		    (pll_num << CCM_CSCR_SSI2_OFFSET);
+		break;
+	case VPU_BAUD:
+		cscr = (cscr & (~CCM_CSCR_VPU)) |
+		    (pll_num << CCM_CSCR_VPU_OFFSET);
+		break;
+	default:
+		printk(KERN_ERR
+		       "This clock does not have ability to choose its clock source\n");
+		break;
+	}
+	__raw_writel(cscr, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	return;
+}
+
+/*!
+ * This function sets the divider value for a clock.
+ *
+ * @param clk as defined in enum mxc_clocks
+ * @param div the division factor to be used for the clock (For SSI & CSI, pass
+ *            in 2 times the expected division value to account for FP vals on certain
+ *            platforms)
+ */
+void mxc_set_clocks_div(enum mxc_clocks clk, unsigned int div)
+{
+	unsigned long reg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	switch (clk) {
+	case SSI2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~CCM_PCDR0_SSI2BAUDDIV_MASK)) |
+		    ((div - 1) << CCM_PCDR0_SSI2BAUDDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~CCM_PCDR0_SSI1BAUDDIV_MASK)) |
+		    ((div - 1) << CCM_PCDR0_SSI1BAUDDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		break;
+	case NFC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~CCM_PCDR0_NFCDIV_MASK)) |
+		    ((div - 1) << CCM_PCDR0_NFCDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		break;
+	case VPU_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~CCM_PCDR0_VPUDIV_MASK)) |
+		    ((div - 1) << CCM_PCDR0_VPUDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		break;
+	case PERCLK1:
+	case UART6_BAUD:
+	case UART5_BAUD:
+	case UART4_BAUD:
+	case UART3_BAUD:
+	case UART2_BAUD:
+	case UART1_BAUD:
+	case GPT6_CLK:
+	case GPT5_CLK:
+	case GPT4_CLK:
+	case GPT3_CLK:
+	case GPT2_CLK:
+	case GPT1_CLK:
+	case PWM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		reg = (reg & (~CCM_PCDR1_PERDIV1_MASK)) |
+		    ((div - 1) << CCM_PCDR1_PERDIV1_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		break;
+	case PERCLK2:
+	case SDHC2_CLK:
+	case SDHC1_CLK:
+	case CSPI3_CLK:
+	case CSPI2_CLK:
+	case CSPI1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		reg = (reg & (~CCM_PCDR1_PERDIV2_MASK)) |
+		    ((div - 1) << CCM_PCDR1_PERDIV2_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		break;
+	case PERCLK3:
+	case LCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		reg = (reg & (~CCM_PCDR1_PERDIV3_MASK)) |
+		    ((div - 1) << CCM_PCDR1_PERDIV3_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		break;
+	case PERCLK4:
+	case CSI_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		reg = (reg & (~CCM_PCDR1_PERDIV4_MASK)) |
+		    ((div - 1) << CCM_PCDR1_PERDIV4_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR1);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		reg = (reg & (~CCM_CSCR_USB_MASK)) |
+		    ((div - 1) << CCM_CSCR_USB_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		break;
+	case IPG_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		reg = (reg & (~CCM_CSCR_IPDIV)) |
+		    ((div - 1) << CCM_CSCR_IPDIV_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		break;
+	case CPU_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		reg = (reg & (~CCM_CSCR_PRESC_MASK)) |
+		    ((div - 1) << CCM_CSCR_PRESC_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		break;
+	case AHB_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		reg = (reg & (~CCM_CSCR_BCLK_MASK)) |
+		    ((div - 1) << CCM_CSCR_BCLK_OFFSET);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		break;
+	default:
+		break;
+	}
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to enable the individual module clocks
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ */
+void mxc_clks_enable(enum mxc_clocks clk)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	switch (clk) {
+	case CSI_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_PERCLK4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_CSI;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case DMA_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_DMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_DMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case RTIC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_RTIC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_RTIC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case BROM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_BROM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case EMMA_PRP_CLK:
+		__enable_emma_clk(MXC_CLK_EMMA_PRP);
+		break;
+	case EMMA_PP_CLK:
+		__enable_emma_clk(MXC_CLK_EMMA_PP);
+		break;
+	case LCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_PERCLK3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_LCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_LCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SLCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SLCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_SLCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_USBOTG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_USBOTG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case FEC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_FEC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_FEC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case EMI_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_EMI;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case ATA_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_ATA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case VPU_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_VPU_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_VPU;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SAHARA2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SAHARA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_HCLK_SAHARA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_SSI1_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SSI1_IPG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_SSI2_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SSI2_IPG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case NFC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_NFC_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case MSTICK1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_MSHC_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_MSHC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case UART1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART3_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART4_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART5_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART5;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART6_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_UART6;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case WDOG_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg |= CCM_PCCR1_WDT;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+
+	case CSPI3_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_CSPI3);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_CSPI3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case CSPI2_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_CSPI2);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_CSPI2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case CSPI1_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_CSPI1);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_CSPI1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPIO_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPIO;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT3_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT4_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT5_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT5;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT6_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_GPT6;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case I2C1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_I2C1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case I2C2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_I2C2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case IIM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_IIM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case KPP_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_KPP;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case OWIRE_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_OWIRE;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case PWM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_PWM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case RTC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_RTC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SCC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SCC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC2_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_SDHC2);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SDHC2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC1_CLK:
+		__enable_perclk2(MXC_CLK_PCLK2_SDHC1);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SDHC1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC3_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg |= CCM_PCCR0_SDHC3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is called to disable the individual module clocks
+ *
+ * @param       clk     as defined in enum mxc_clocks
+ */
+void mxc_clks_disable(enum mxc_clocks clk)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+	switch (clk) {
+	case CSI_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_CSI;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_PERCLK4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case DMA_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_DMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_DMA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case RTIC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_RTIC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_RTIC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case BROM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_BROM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case EMMA_PRP_CLK:
+		__disable_emma_clk(MXC_CLK_EMMA_PRP);
+		break;
+	case EMMA_PP_CLK:
+		__disable_emma_clk(MXC_CLK_EMMA_PP);
+		break;
+		break;
+	case LCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_LCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_LCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_PERCLK3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SLCDC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SLCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_SLCDC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case USB_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_USBOTG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_USBOTG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case FEC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_FEC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_FEC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case EMI_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_EMI;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case ATA_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_ATA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case VPU_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_VPU_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_VPU;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SAHARA2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SAHARA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_HCLK_SAHARA;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case SSI1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_SSI1_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SSI1_IPG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SSI2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_SSI2_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SSI2_IPG;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case NFC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_NFC_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case MSTICK1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_MSHC_BAUD;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_MSHC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case UART1_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART2_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART3_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART4_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART5_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART5;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case UART6_BAUD:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_UART6;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case WDOG_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		reg &= ~CCM_PCCR1_WDT;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR1);
+		break;
+	case CSPI3_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_CSPI3);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_CSPI3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case CSPI2_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_CSPI2);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_CSPI2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case CSPI1_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_CSPI1);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_CSPI1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPIO_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPIO;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT3_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT4_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT4;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT5_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT5;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case GPT6_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_GPT6;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case I2C1_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_I2C1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case I2C2_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_I2C2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case IIM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_IIM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case KPP_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_KPP;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case OWIRE_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_OWIRE;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case PWM_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_PWM;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case RTC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_RTC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SCC_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SCC;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC2_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_SDHC2);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SDHC2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC1_CLK:
+		__disable_perclk2(MXC_CLK_PCLK2_SDHC1);
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SDHC1;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	case SDHC3_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		reg &= ~CCM_PCCR0_SDHC3;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCCR0);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * This function is used to modify PLL registers to generate the required
+ * frequency.
+ *
+ * @param  pll_num  the PLL that you wish to modify
+ * @param  mfi      multiplication factor integer part
+ * @param  pdf      pre-division factor
+ * @param  mfd      multiplication factor denominator
+ * @param  mfn      multiplication factor numerator
+ */
+void mxc_pll_set(enum plls pll_num, unsigned int mfi, unsigned int pdf,
+		 unsigned int mfd, unsigned int mfn)
+{
+	unsigned long cscr;
+	unsigned long flags;
+	unsigned long new_pll = 0;
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	if (pll_num == MCUPLL) {
+		/* Change the Pll value      */
+		new_pll = (mfi << CCM_MPCTL0_MFI_OFFSET) |
+		    (mfn << CCM_MPCTL0_MFN_OFFSET) |
+		    (mfd << CCM_MPCTL0_MFD_OFFSET) |
+		    (pdf << CCM_MPCTL0_PD_OFFSET);
+
+		__raw_writel(new_pll, IO_ADDRESS(CCM_BASE_ADDR) + CCM_MPCTL0);
+		/* Swap to reference clock and disable PLL */
+		cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		cscr |= CCM_CSCR_MPLLRES;
+		__raw_writel(cscr, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	} else {
+		if (pll_num == SERIALPLL) {
+			/* Change the Pll value      */
+			new_pll = (mfi << CCM_SPCTL0_MFI_OFFSET) |
+			    (mfn << CCM_SPCTL0_MFN_OFFSET) |
+			    (mfd << CCM_SPCTL0_MFD_OFFSET) |
+			    (pdf << CCM_SPCTL0_PD_OFFSET);
+
+			__raw_writel(new_pll,
+				     IO_ADDRESS(CCM_BASE_ADDR) + CCM_SPCTL0);
+			/* Swap to reference clock and disable PLL */
+			cscr =
+			    __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+			cscr |= CCM_CSCR_SPLLRES;
+			__raw_writel(cscr,
+				     IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		}
+	}
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+}
+
+/*!
+ * Configure clock output on CKO pins
+ *
+ * @param   output  clock output pin
+ * @param   clk     clock source to output
+ * @param   div     CLKO divider
+ *
+ */
+void mxc_set_clock_output(enum mxc_clk_out output, enum mxc_clocks clk, int div)
+{
+	unsigned long flags;
+	unsigned long reg;
+
+	if (output != CKO) {
+		return;
+	}
+
+	spin_lock_irqsave(&mxc_crm_lock, flags);
+
+	switch (clk) {
+	case CKIH_CLK:
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
+		reg = (reg & (~0x1f)) | 0x2;
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
+
+		reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+		reg = (reg & (~0x03c00000)) | 0x02000000 | ((div - 1) << 22);
+		__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_PCDR0);
+
+		break;
+	default:
+		break;
+	};
+
+	spin_unlock_irqrestore(&mxc_crm_lock, flags);
+	return;
+}
+
+/*!
+ * This function is called to read the contents of a CCM_MCU register
+ *
+ * @param reg_offset the CCM_MCU register that will read
+ *
+ * @return the register contents
+ */
+unsigned long mxc_ccm_get_reg(unsigned int reg_offset)
+{
+	/* TODO */
+	return 0xFFFFFFFF;
+}
+
+/*!
+ * This function is called to modify the contents of a CCM_MCU register
+ *
+ * @param reg_offset the CCM_MCU register that will read
+ * @param mask       the mask to be used to clear the bits that are to be modified
+ * @param data       the data that should be written to the register
+ */
+void mxc_ccm_modify_reg(unsigned int reg_offset, unsigned int mask,
+			unsigned int data)
+{
+	/* TODO */
+}
+
+EXPORT_SYMBOL(mxc_pll_set);
+EXPORT_SYMBOL(mxc_pll_clock);
+EXPORT_SYMBOL(mxc_get_clocks);
+EXPORT_SYMBOL(mxc_set_clocks_pll);
+EXPORT_SYMBOL(mxc_set_clocks_div);
+EXPORT_SYMBOL(mxc_clks_disable);
+EXPORT_SYMBOL(mxc_clks_enable);
+EXPORT_SYMBOL(mxc_ccm_get_reg);
+EXPORT_SYMBOL(mxc_ccm_modify_reg);
+EXPORT_SYMBOL(mxc_set_clock_output);
+EXPORT_SYMBOL(mxc_get_clocks_parent);
--- linux-2.6.19.2/arch/arm/mach-mx27/crm_regs.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/crm_regs.h	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,189 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX27_CRM_REGS_H__
+#define __ARCH_ARM_MACH_MX27_CRM_REGS_H__
+
+#include <asm/arch/hardware.h>
+
+/* Register offsets */
+#define CCM_CSCR                0x0
+#define CCM_MPCTL0              0x4
+#define CCM_MPCTL1              0x8
+#define CCM_SPCTL0              0xC
+#define CCM_SPCTL1              0x10
+#define CCM_OSC26MCTL           0x14
+#define CCM_PCDR0               0x18
+#define CCM_PCDR1               0x1c
+#define CCM_PCCR0               0x20
+#define CCM_PCCR1               0x24
+#define CCM_CCSR                0x28
+#define CCM_PMCTL               0x2c
+#define CCM_PMCOUNT             0x30
+#define CCM_WKGDCTL             0x34
+
+#define CCM_CSCR_USB_OFFSET     28
+#define CCM_CSCR_USB_MASK       (0x7 << 28)
+#define CCM_CSCR_SD_OFFSET      24
+#define CCM_CSCR_SD_MASK        (0x3 << 24)
+#define CCM_CSCR_SSI2           (1 << 23)
+#define CCM_CSCR_SSI2_OFFSET    23
+#define CCM_CSCR_SSI1           (1 << 22)
+#define CCM_CSCR_SSI1_OFFSET    22
+#define CCM_CSCR_VPU           (1 << 21)
+#define CCM_CSCR_VPU_OFFSET    21
+#define CCM_CSCR_MSHC           (1 << 20)
+#define CCM_CSCR_SPLLRES        (1 << 19)
+#define CCM_CSCR_MPLLRES        (1 << 18)
+#define CCM_CSCR_SP             (1 << 17)
+#define CCM_CSCR_MCU            (1 << 16)
+#define CCM_CSCR_PRESC_OFFSET   13
+#define CCM_CSCR_PRESC_MASK     (0x7 << 13)
+#define CCM_CSCR_BCLK_OFFSET    9
+#define CCM_CSCR_BCLK_MASK      (0xf << 9)
+#define CCM_CSCR_IPDIV_OFFSET   8
+#define CCM_CSCR_IPDIV          (1 << 8)
+#define CCM_CSCR_OSC26MDIV      (1 << 4)
+#define CCM_CSCR_OSC26M         (1 << 3)
+#define CCM_CSCR_FPM            (1 << 2)
+#define CCM_CSCR_SPEN           (1 << 1)
+#define CCM_CSCR_MPEN           1
+
+#define CCM_MPCTL0_CPLM         (1 << 31)
+#define CCM_MPCTL0_PD_OFFSET    26
+#define CCM_MPCTL0_PD_MASK      (0xf << 26)
+#define CCM_MPCTL0_MFD_OFFSET   16
+#define CCM_MPCTL0_MFD_MASK     (0x3ff << 16)
+#define CCM_MPCTL0_MFI_OFFSET   10
+#define CCM_MPCTL0_MFI_MASK     (0xf << 10)
+#define CCM_MPCTL0_MFN_OFFSET   0
+#define CCM_MPCTL0_MFN_MASK     0x3ff
+
+#define CCM_MPCTL1_LF           (1 << 15)
+#define CCM_MPCTL1_BRMO         (1 << 6)
+
+#define CCM_SPCTL0_CPLM         (1 << 31)
+#define CCM_SPCTL0_PD_OFFSET    26
+#define CCM_SPCTL0_PD_MASK      (0xf << 26)
+#define CCM_SPCTL0_MFD_OFFSET   16
+#define CCM_SPCTL0_MFD_MASK     (0x3ff << 16)
+#define CCM_SPCTL0_MFI_OFFSET   10
+#define CCM_SPCTL0_MFI_MASK     (0xf << 10)
+#define CCM_SPCTL0_MFN_OFFSET   0
+#define CCM_SPCTL0_MFN_MASK     0x3ff
+
+#define CCM_SPCTL1_LF           (1 << 15)
+#define CCM_SPCTL1_BRMO         (1 << 6)
+
+#define CCM_OSC26MCTL_PEAK_OFFSET       16
+#define CCM_OSC26MCTL_PEAK_MASK         (0x3 << 16)
+#define CCM_OSC26MCTL_AGC_OFFSET        8
+#define CCM_OSC26MCTL_AGC_MASK          (0x3f << 8)
+#define CCM_OSC26MCTL_ANATEST_OFFSET    0
+#define CCM_OSC26MCTL_ANATEST_MASK      0x3f
+
+#define CCM_PCDR0_SSI2BAUDDIV_OFFSET    26
+#define CCM_PCDR0_SSI2BAUDDIV_MASK      (0x3f << 26)
+#define CCM_PCDR0_CLKO_EN               25
+#define CCM_PCDR0_CLKODIV_OFFSET        22
+#define CCM_PCDR0_CLKODIV_MASK          (0x7 << 22)
+#define CCM_PCDR0_SSI1BAUDDIV_OFFSET    16
+#define CCM_PCDR0_SSI1BAUDDIV_MASK      (0x3f << 16)
+#define CCM_PCDR0_NFCDIV_OFFSET         12
+#define CCM_PCDR0_NFCDIV_MASK           (0xf << 12)
+#define CCM_PCDR0_VPUDIV_OFFSET        8
+#define CCM_PCDR0_VPUDIV_MASK          (0xf << 8)
+#define CCM_PCDR0_MSHCDIV_OFFSET        0
+#define CCM_PCDR0_MSHCDIV_MASK          0x1f
+
+#define CCM_PCDR1_PERDIV4_OFFSET        24
+#define CCM_PCDR1_PERDIV4_MASK          (0x3f << 24)
+#define CCM_PCDR1_PERDIV3_OFFSET        16
+#define CCM_PCDR1_PERDIV3_MASK          (0x3f << 16)
+#define CCM_PCDR1_PERDIV2_OFFSET        8
+#define CCM_PCDR1_PERDIV2_MASK          (0x3f << 8)
+#define CCM_PCDR1_PERDIV1_OFFSET        0
+#define CCM_PCDR1_PERDIV1_MASK          0x3f
+
+#define CCM_PCCR0_CSPI1         (1 << 31)
+#define CCM_PCCR0_CSPI2         (1 << 30)
+#define CCM_PCCR0_CSPI3         (1 << 29)
+#define CCM_PCCR0_DMA           (1 << 28)
+#define CCM_PCCR0_EMMA          (1 << 27)
+#define CCM_PCCR0_FEC           (1 << 26)
+#define CCM_PCCR0_GPIO          (1 << 25)
+#define CCM_PCCR0_GPT1          (1 << 24)
+#define CCM_PCCR0_GPT2          (1 << 23)
+#define CCM_PCCR0_GPT3          (1 << 22)
+#define CCM_PCCR0_GPT4          (1 << 21)
+#define CCM_PCCR0_GPT5          (1 << 20)
+#define CCM_PCCR0_GPT6          (1 << 19)
+#define CCM_PCCR0_I2C1          (1 << 18)
+#define CCM_PCCR0_I2C2          (1 << 17)
+#define CCM_PCCR0_IIM           (1 << 16)
+#define CCM_PCCR0_KPP           (1 << 15)
+#define CCM_PCCR0_LCDC          (1 << 14)
+#define CCM_PCCR0_MSHC          (1 << 13)
+#define CCM_PCCR0_OWIRE         (1 << 12)
+#define CCM_PCCR0_PWM           (1 << 11)
+#define CCM_PCCR0_RTC           (1 << 9)
+#define CCM_PCCR0_RTIC          (1 << 8)
+#define CCM_PCCR0_SAHARA        (1 << 7)
+#define CCM_PCCR0_SCC           (1 << 6)
+#define CCM_PCCR0_SDHC1         (1 << 5)
+#define CCM_PCCR0_SDHC2         (1 << 4)
+#define CCM_PCCR0_SDHC3         (1 << 3)
+#define CCM_PCCR0_SLCDC         (1 << 2)
+#define CCM_PCCR0_SSI1_IPG      (1 << 1)
+#define CCM_PCCR0_SSI2_IPG      (1 << 0)
+
+#define CCM_PCCR1_UART1         (1 << 31)
+#define CCM_PCCR1_UART2         (1 << 30)
+#define CCM_PCCR1_UART3         (1 << 29)
+#define CCM_PCCR1_UART4         (1 << 28)
+#define CCM_PCCR1_UART5         (1 << 27)
+#define CCM_PCCR1_UART6         (1 << 26)
+#define CCM_PCCR1_USBOTG        (1 << 25)
+#define CCM_PCCR1_WDT           (1 << 24)
+#define CCM_PCCR1_HCLK_ATA      (1 << 23)
+#define CCM_PCCR1_HCLK_BROM     (1 << 22)
+#define CCM_PCCR1_HCLK_CSI      (1 << 21)
+#define CCM_PCCR1_HCLK_DMA      (1 << 20)
+#define CCM_PCCR1_HCLK_EMI      (1 << 19)
+#define CCM_PCCR1_HCLK_EMMA     (1 << 18)
+#define CCM_PCCR1_HCLK_FEC      (1 << 17)
+#define CCM_PCCR1_HCLK_VPU     (1 << 16)
+#define CCM_PCCR1_HCLK_LCDC     (1 << 15)
+#define CCM_PCCR1_HCLK_RTIC     (1 << 14)
+#define CCM_PCCR1_HCLK_SAHARA   (1 << 13)
+#define CCM_PCCR1_HCLK_SLCDC    (1 << 12)
+#define CCM_PCCR1_HCLK_USBOTG   (1 << 11)
+#define CCM_PCCR1_PERCLK1       (1 << 10)
+#define CCM_PCCR1_PERCLK2       (1 << 9)
+#define CCM_PCCR1_PERCLK3       (1 << 8)
+#define CCM_PCCR1_PERCLK4       (1 << 7)
+#define CCM_PCCR1_VPU_BAUD     (1 << 6)
+#define CCM_PCCR1_SSI1_BAUD     (1 << 5)
+#define CCM_PCCR1_SSI2_BAUD     (1 << 4)
+#define CCM_PCCR1_NFC_BAUD      (1 << 3)
+#define CCM_PCCR1_MSHC_BAUD     (1 << 2)
+
+#define CCM_CCSR_32KSR          (1 << 15)
+#define CCM_CCSR_CLKMODE1       (1 << 9)
+#define CCM_CCSR_CLKMODE0       (1 << 8)
+#define CCM_CCSR_CLKOSEL_OFFSET 0
+#define CCM_CCSR_CLKOSEL_MASK   0x1f
+
+#define SYS_FMCR                0x14	/*  Functional Muxing Control Reg */
+
+#endif				/* __ARCH_ARM_MACH_MX27_CRM_REGS_H__ */
--- linux-2.6.19.2/arch/arm/mach-mx27/devices.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/devices.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,518 @@
+/*
+ * Author: MontaVista Software, Inc.
+ *       <source@mvista.com>
+ *
+ * Based on the OMAP devices.c
+ *
+ * 2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+
+#include <linux/spi/spi.h>
+
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/mmc.h>
+
+ /*!
+  * @file devices.c
+  * @brief device configurations including nor/nand/watchdog for mx27.
+  *
+  * @ingroup MSL
+  */
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_W1_MASTER_MXC) || defined(CONFIG_W1_MASTER_MXC_MODULE)
+static struct platform_device mxc_w1_devices = {
+	.name = "mxc_w1",
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.id = 0
+};
+
+static void mxc_init_owire(void)
+{
+	(void)platform_device_register(&mxc_w1_devices);
+}
+#else
+static inline void mxc_init_owire(void)
+{
+}
+#endif
+
+#if defined(CONFIG_MXC_RTC) || defined(CONFIG_MXC_RTC_MODULE)
+
+static struct platform_device mxc_rtc_device = {
+	.name = "mxc_rtc",
+	.id = 0,
+};
+static void mxc_init_rtc(void)
+{
+	(void)platform_device_register(&mxc_rtc_device);
+}
+#else
+static inline void mxc_init_rtc(void)
+{
+}
+#endif
+#if defined(CONFIG_MXC_WATCHDOG) || defined(CONFIG_MXC_WATCHDOG_MODULE)
+
+static struct resource wdt_resources[] = {
+	{
+	 .start = WDOG_BASE_ADDR,
+	 .end = WDOG_BASE_ADDR + 0x30,
+	 .flags = IORESOURCE_MEM,
+	 },
+};
+
+static struct platform_device mxc_wdt_device = {
+	.name = "mxc_wdt",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.num_resources = ARRAY_SIZE(wdt_resources),
+	.resource = wdt_resources,
+};
+
+static void mxc_init_wdt(void)
+{
+	mxc_clks_enable(WDOG_CLK);
+	(void)platform_device_register(&mxc_wdt_device);
+}
+#else
+static inline void mxc_init_wdt(void)
+{
+}
+#endif
+
+/* MMC device data */
+
+#if defined(CONFIG_MMC_MXC) || defined(CONFIG_MMC_MXC_MODULE)
+
+extern unsigned int sdhc_get_card_det_status(struct device *dev);
+extern int sdhc_init_card_det(int id);
+
+static struct mxc_mmc_platform_data mmc_data = {
+	.ocr_mask = MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30,
+	.min_clk = 150000,
+	.max_clk = 25000000,
+	.card_inserted_state = 0,
+	.status = sdhc_get_card_det_status,
+};
+
+/*!
+ * Resource definition for the SDHC1
+ */
+static struct resource mxcsdhc1_resources[] = {
+	[0] = {
+	       .start = SDHC1_BASE_ADDR,
+	       .end = SDHC1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_SDHC1,
+	       .end = INT_SDHC1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO1_CARD_IRQ,
+	       .end = MXC_SDIO1_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*!
+ * Resource definition for the SDHC2
+ */
+static struct resource mxcsdhc2_resources[] = {
+	[0] = {
+	       .start = SDHC2_BASE_ADDR,
+	       .end = SDHC2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_SDHC2,
+	       .end = INT_SDHC2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO2_CARD_IRQ,
+	       .end = MXC_SDIO2_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC1 */
+static struct platform_device mxcsdhc1_device = {
+	.name = "mxcmci",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc1_resources),
+	.resource = mxcsdhc1_resources,
+};
+
+/*! Device Definition for MXC SDHC2 */
+static struct platform_device mxcsdhc2_device = {
+	.name = "mxcmci",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc2_resources),
+	.resource = mxcsdhc2_resources,
+};
+
+#ifdef CONFIG_MXC_SDHC3
+/*!
+ * Resource definition for the SDHC3
+ */
+static struct resource mxcsdhc3_resources[] = {
+	[0] = {
+	       .start = SDHC3_BASE_ADDR,
+	       .end = SDHC3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_SDHC3,
+	       .end = INT_SDHC3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[2] = {
+	       .start = 0,
+	       .end = 0,
+	       .flags = IORESOURCE_IRQ,
+	       },
+	[3] = {
+	       .start = MXC_SDIO3_CARD_IRQ,
+	       .end = MXC_SDIO3_CARD_IRQ,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Device Definition for MXC SDHC3 */
+static struct platform_device mxcsdhc3_device = {
+	.name = "mxcmci",
+	.id = 2,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mmc_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcsdhc3_resources),
+	.resource = mxcsdhc3_resources,
+};
+#endif
+
+static inline void mxc_init_mmc(void)
+{
+	int cd_irq;
+
+	cd_irq = sdhc_init_card_det(0);
+	if (cd_irq) {
+		mxcsdhc1_device.resource[2].start = cd_irq;
+		mxcsdhc1_device.resource[2].end = cd_irq;
+	}
+	cd_irq = sdhc_init_card_det(1);
+	if (cd_irq) {
+		mxcsdhc2_device.resource[2].start = cd_irq;
+		mxcsdhc2_device.resource[2].end = cd_irq;
+	}
+
+	mxc_clks_enable(PERCLK2);
+
+	mxc_clks_enable(SDHC1_CLK);
+	(void)platform_device_register(&mxcsdhc1_device);
+
+	mxc_clks_enable(SDHC2_CLK);
+	(void)platform_device_register(&mxcsdhc2_device);
+
+#ifdef CONFIG_MXC_SDHC3
+	mxc_clks_enable(SDHC3_CLK);
+	(void)platform_device_register(&mxcsdhc3_device);
+#endif
+}
+#else
+static inline void mxc_init_mmc(void)
+{
+}
+#endif
+
+/* SPI controller and device data */
+#if defined(CONFIG_SPI_MXC) || defined(CONFIG_SPI_MXC_MODULE)
+
+#ifdef CONFIG_SPI_MXC_SELECT1
+/*!
+ * Resource definition for the CSPI1
+ */
+static struct resource mxcspi1_resources[] = {
+	[0] = {
+	       .start = CSPI1_BASE_ADDR,
+	       .end = CSPI1_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI1,
+	       .end = INT_CSPI1,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI1 */
+static struct mxc_spi_master mxcspi1_data = {
+	.bus_num = 1,
+	.maxchipselect = 4,
+	.spi_version = 0,
+	.clock = CSPI1_CLK,
+};
+
+/*! Device Definition for MXC CSPI1 */
+static struct platform_device mxcspi1_device = {
+	.name = "mxc_spi",
+	.id = 1,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi1_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi1_resources),
+	.resource = mxcspi1_resources,
+};
+
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+
+#ifdef CONFIG_SPI_MXC_SELECT2
+/*!
+ * Resource definition for the CSPI2
+ */
+static struct resource mxcspi2_resources[] = {
+	[0] = {
+	       .start = CSPI2_BASE_ADDR,
+	       .end = CSPI2_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI2,
+	       .end = INT_CSPI2,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI2 */
+static struct mxc_spi_master mxcspi2_data = {
+	.bus_num = 2,
+	.maxchipselect = 4,
+	.spi_version = 0,
+	.clock = CSPI2_CLK,
+};
+
+/*! Device Definition for MXC CSPI2 */
+static struct platform_device mxcspi2_device = {
+	.name = "mxc_spi",
+	.id = 2,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi2_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi2_resources),
+	.resource = mxcspi2_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+
+#ifdef CONFIG_SPI_MXC_SELECT3
+/*!
+ * Resource definition for the CSPI3
+ */
+static struct resource mxcspi3_resources[] = {
+	[0] = {
+	       .start = CSPI3_BASE_ADDR,
+	       .end = CSPI3_BASE_ADDR + SZ_4K - 1,
+	       .flags = IORESOURCE_MEM,
+	       },
+	[1] = {
+	       .start = INT_CSPI3,
+	       .end = INT_CSPI3,
+	       .flags = IORESOURCE_IRQ,
+	       },
+};
+
+/*! Platform Data for MXC CSPI3 */
+static struct mxc_spi_master mxcspi3_data = {
+	.bus_num = 3,
+	.maxchipselect = 4,
+	.spi_version = 0,
+	.clock = CSPI3_CLK,
+};
+
+/*! Device Definition for MXC CSPI3 */
+static struct platform_device mxcspi3_device = {
+	.name = "mxc_spi",
+	.id = 3,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxcspi3_data,
+		},
+	.num_resources = ARRAY_SIZE(mxcspi3_resources),
+	.resource = mxcspi3_resources,
+};
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+
+static inline void mxc_init_spi(void)
+{
+#ifdef CONFIG_SPI_MXC_SELECT1
+	if (platform_device_register(&mxcspi1_device) < 0)
+		printk("Error: Registering the SPI Controller_1\n");
+#endif				/* CONFIG_SPI_MXC_SELECT1 */
+#ifdef CONFIG_SPI_MXC_SELECT2
+	if (platform_device_register(&mxcspi2_device) < 0)
+		printk("Error: Registering the SPI Controller_2\n");
+#endif				/* CONFIG_SPI_MXC_SELECT2 */
+#ifdef CONFIG_SPI_MXC_SELECT3
+	if (platform_device_register(&mxcspi3_device) < 0)
+		printk("Error: Registering the SPI Controller_3\n");
+#endif				/* CONFIG_SPI_MXC_SELECT3 */
+}
+#else
+static inline void mxc_init_spi(void)
+{
+}
+#endif
+
+#ifdef	CONFIG_MXC_VPU
+/*! Platform Data for MXC VPU */
+static struct platform_device mxcvpu_device = {
+	.name = "mxc_vpu",
+	.dev = {
+		.release = mxc_nop_release,
+		},
+	.id = 0,
+};
+
+static inline void mxc_init_vpu(void)
+{
+	if (platform_device_register(&mxcvpu_device) < 0)
+		printk(KERN_ERR "Error: Registering the VPU.\n");
+}
+#else
+static inline void mxc_init_vpu(void)
+{
+}
+#endif
+
+#ifdef  CONFIG_MXC_IRDA
+/*
+ * Resource definition for the MXC IrDA
+ */
+static struct resource mxcirda_resources[] = {
+	[0] = {
+		.start   = UART3_BASE_ADDR,
+		.end     = UART3_BASE_ADDR + SZ_4K - 1,
+		.flags   = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start   = INT_UART3,
+		.end     = INT_UART3,
+		.flags   = IORESOURCE_IRQ,
+	},
+};
+
+/* Platform Data for MXC IrDA */
+static struct platform_device mxcirda_device = {
+	.name = "mxc_irda",
+	.dev = {
+		.release = mxc_nop_release,
+	},
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxcirda_resources),
+	.resource = mxcirda_resources,
+};
+
+static inline void mxc_init_irda(void)
+{
+	if (platform_device_register(&mxcirda_device) < 0)
+		printk(KERN_ERR "Error: Registering the MXC IrDA.\n");
+	printk("IrDA: MXC IrDA registered\n");
+}
+#else
+static inline void mxc_init_irda(void)
+{
+}
+#endif
+
+struct mxc_gpio_port mxc_gpio_ports[GPIO_PORT_NUM] = {
+	{
+	 .num = 0,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR),
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_BASE,
+	 },
+	{
+	 .num = 1,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x100,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN,
+	 },
+	{
+	 .num = 2,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x200,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 2,
+	 },
+	{
+	 .num = 3,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x300,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 3,
+	 },
+	{
+	 .num = 4,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x400,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 4,
+	 },
+	{
+	 .num = 5,
+	 .base = IO_ADDRESS(GPIO_BASE_ADDR) + 0x500,
+	 .irq = INT_GPIO,
+	 .virtual_irq_start = MXC_GPIO_BASE + GPIO_NUM_PIN * 5,
+	 },
+};
+
+static int __init mxc_init_devices(void)
+{
+	mxc_init_wdt();
+	mxc_init_mmc();
+	mxc_init_spi();
+	mxc_init_rtc();
+	mxc_init_owire();
+	mxc_init_vpu();
+	mxc_init_irda();
+	return 0;
+}
+
+arch_initcall(mxc_init_devices);
--- linux-2.6.19.2/arch/arm/mach-mx27/dma.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/dma.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,536 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@file dma.c
+ *@brief This file contains the dma parameter which is depend on the platform  .
+ * @ingroup DMA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <asm/dma.h>
+
+/*!
+ * @brief  the structure stored device_id and dma_info pointer
+ */
+typedef struct dma_info_entry_s {
+	mxc_dma_device_t device;
+	/* if there are two dma_info , first is for reading, another is for writing */
+	mx2_dma_info_t *info;
+} dma_info_entry_t;
+
+/*!
+ * @brief dma_info from memory to memory for dma testing
+ */
+static mx2_dma_info_t ram2ram_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 0
+};
+
+/*!
+ * @brief dma_info from 2D memory to 2D memory for dma testing
+ */
+static mx2_dma_info_t ram2d2ram2d_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.rto_en = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_2D,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_2D,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 1,.msel = 0,.W = 0x80,.X = 0x40,.Y = 0x10
+};
+
+/*!
+ * @brief dma_info from memory to 2D memory for dma testing
+ */
+static mx2_dma_info_t ram2ram2d_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_2D,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 1,.msel = 0,.W = 0x100,.X = 0x80,.Y = 0x10
+};
+
+/*!
+ * @brief dma_info from 2D memory to memory for dma testing 
+ */
+static mx2_dma_info_t ram2d2ram_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_2D,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 1,.msel = 0,.W = 0x100,.X = 0x100,.Y = 0x10
+};
+
+/*!
+ * @brief dma_info with dma chaining feature for dma testing
+ */
+static mx2_dma_info_t hw_chaining_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 1,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info without dma chaining feature for dma testing
+ */
+static mx2_dma_info_t sw_chaining_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 0,
+	.burstLength = 4,.request = 0,.busuntils = 0,
+	.sourceType = DMA_TYPE_LINEAR,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for ATA recieveing
+ */
+static mx2_dma_info_t ata_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 32,.request = 29,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.per_address = (ATA_BASE_ADDR + 0x18),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for ATA transmitting
+ */
+static mx2_dma_info_t ata_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 32,.request = 28,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_32BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_32BIT,
+	.per_address = (ATA_BASE_ADDR + 0x18),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART1 recieveing
+ */
+static mx2_dma_info_t uart1_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 1,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 26,.busuntils = 8,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART1_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART1 transmitting
+ */
+static mx2_dma_info_t uart1_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 27,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART1_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART2 recieveing
+ */
+static mx2_dma_info_t uart2_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 24,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART2_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART2 transmitting
+ */
+static mx2_dma_info_t uart2_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 25,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART2_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART3 recieveing
+ */
+static mx2_dma_info_t uart3_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 22,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART3_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART3 transmitting
+ */
+static mx2_dma_info_t uart3_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 23,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART3_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART4 recieveing
+ */
+static mx2_dma_info_t uart4_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 20,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART4_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART4transmitting
+ */
+static mx2_dma_info_t uart4_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 21,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART4_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART5 recieveing
+ */
+static mx2_dma_info_t uart5_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 32,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART5_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART5 transmitting
+ */
+static mx2_dma_info_t uart5_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 33,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART5_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma_info for UART6 recieveing
+ */
+static mx2_dma_info_t uart6_rx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 34,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART6_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief: dma_info for UART6 transmitting
+ */
+static mx2_dma_info_t uart6_tx_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 1,.request = 35,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = TRANSFER_8BIT,
+	.destType = DMA_TYPE_LINEAR,.destPort = TRANSFER_8BIT,
+	.per_address = (UART6_BASE_ADDR + 0x40),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi1_16bit_rx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_CAPTURE_CHAIN_DMA,.ren = 1,
+	.burstLength = 8,.request = DMA_REQ_SSI1_RX0,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI1_BASE_ADDR + 0x08),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi1_16bit_tx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_PLAYBACK_CHAIN_DMA,.ren = 1,
+	.burstLength = 8,.request = DMA_REQ_SSI1_TX0,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI1_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi2_16bit_rx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_CAPTURE_CHAIN_DMA,.ren = 1,
+	.burstLength = 8,.request = DMA_REQ_SSI2_RX0,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI2_BASE_ADDR + 0x08),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t ssi2_16bit_tx0_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 1,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = MXC_SOUND_PLAYBACK_CHAIN_DMA,.ren = 1,
+	.burstLength = 8,.request = DMA_REQ_SSI2_TX0,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_16,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SSI2_BASE_ADDR),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc1_width1_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 16,.request = DMA_REQ_SDHC1,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC1_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc1_width4_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 0,.request = DMA_REQ_SDHC1,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC1_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc2_width1_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 16,.request = DMA_REQ_SDHC2,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC2_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+static mx2_dma_info_t mmc2_width4_dma_info = {
+	.dma_chan = MXC_DMA_DYNAMIC_CHANNEL,
+	.mode = 0,
+	.rto_en = 0,
+	.dir = 0,
+	.dma_chaining = 0,.ren = 1,
+	.burstLength = 0,.request = DMA_REQ_SDHC2,.busuntils = 0,
+	.sourceType = DMA_TYPE_FIFO,.sourcePort = DMA_MEM_SIZE_32,
+	.destType = DMA_TYPE_LINEAR,.destPort = DMA_MEM_SIZE_32,
+	.per_address = (SDHC2_BASE_ADDR + 0x38),
+	.M2D_Valid = 0,
+};
+
+/*!
+ * @brief dma info array which is actived
+ *    DEVICE_ID  RX/(RX&TX)	TX
+ */
+static dma_info_entry_t active_dma_info[] = {
+	{MXC_DMA_TEST_RAM2RAM, &ram2ram_dma_info},
+	{MXC_DMA_TEST_RAM2D2RAM2D, &ram2d2ram2d_dma_info},
+	{MXC_DMA_TEST_RAM2RAM2D, &ram2ram2d_dma_info},
+	{MXC_DMA_TEST_RAM2D2RAM, &ram2d2ram_dma_info},
+	{MXC_DMA_TEST_HW_CHAINING, &hw_chaining_dma_info},
+	{MXC_DMA_TEST_SW_CHAINING, &sw_chaining_dma_info},
+	{MXC_DMA_ATA_RX, &ata_rx_dma_info},
+	{MXC_DMA_ATA_TX, &ata_tx_dma_info},
+	{MXC_DMA_UART1_RX, &uart1_rx_dma_info},
+	{MXC_DMA_UART1_TX, &uart1_tx_dma_info},
+	{MXC_DMA_UART2_RX, &uart2_rx_dma_info},
+	{MXC_DMA_UART2_TX, &uart2_tx_dma_info},
+	{MXC_DMA_UART3_RX, &uart3_rx_dma_info},
+	{MXC_DMA_UART3_TX, &uart3_tx_dma_info},
+	{MXC_DMA_UART4_RX, &uart4_rx_dma_info},
+	{MXC_DMA_UART4_TX, &uart4_tx_dma_info},
+	{MXC_DMA_UART5_RX, &uart5_rx_dma_info},
+	{MXC_DMA_UART5_TX, &uart5_tx_dma_info},
+	{MXC_DMA_UART6_RX, &uart6_rx_dma_info},
+	{MXC_DMA_UART6_TX, &uart6_tx_dma_info},
+	{MXC_DMA_SSI1_16BIT_RX0, &ssi1_16bit_rx0_dma_info},
+	{MXC_DMA_SSI1_16BIT_TX0, &ssi1_16bit_tx0_dma_info},
+	{MXC_DMA_SSI2_16BIT_RX0, &ssi2_16bit_rx0_dma_info},
+	{MXC_DMA_SSI2_16BIT_TX0, &ssi2_16bit_tx0_dma_info},
+	{MXC_DMA_MMC1_WIDTH_1, &mmc1_width1_dma_info},
+	{MXC_DMA_MMC1_WIDTH_4, &mmc1_width4_dma_info},
+	{MXC_DMA_MMC2_WIDTH_1, &mmc2_width1_dma_info},
+	{MXC_DMA_MMC2_WIDTH_4, &mmc2_width4_dma_info},
+};
+
+/*!
+ * @brief the number of actived dma info
+ */
+static int dma_info_entrys =
+    sizeof(active_dma_info) / sizeof(active_dma_info[0]);
+
+/*!
+ * @brief get the dma info by channel_id
+ */
+mx2_dma_info_t *mxc_dma_get_info(mxc_dma_device_t channel_id)
+{
+	dma_info_entry_t *p = active_dma_info;
+	int i;
+	for (i = 0; i < dma_info_entrys; i++, p++) {
+		if (p->device == channel_id)
+			return p->info;
+	}
+	return NULL;
+}
+
+/*!
+ * @brief: scan dma parameter list . And collect information about which channels are dynamic .
+ */
+void mxc_dma_load_info(mxc_dma_channel_t * dma)
+{
+	int i, idx;
+	dma_info_entry_t *p = active_dma_info;
+
+	BUG_ON(dma == NULL);
+	BUG_ON(p == NULL);
+
+	for (i = 0; i < MXC_DMA_CHANNELS; i++) {
+		dma[i].dynamic = 1;
+	}
+
+	for (i = 0; i < dma_info_entrys; i++, p++) {
+		BUG_ON((p->info == NULL));
+
+		idx = p->info->dma_chan;
+
+		BUG_ON(((idx >= MAX_DMA_CHANNELS)
+			&& (idx != MXC_DMA_DYNAMIC_CHANNEL)));
+		if ((idx < 0) || (idx == MXC_DMA_DYNAMIC_CHANNEL))
+			continue;
+		dma[idx].dynamic = 0;
+	}
+}
+
+EXPORT_SYMBOL(mxc_dma_get_info);
+EXPORT_SYMBOL(mxc_dma_load_info);
--- linux-2.6.19.2/arch/arm/mach-mx27/dpm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/dpm.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,405 @@
+/* REVISIT Doxygen fixups */
+/*
+ * DPM support for Freescale i.MX27
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * Copyright (C) 2002, 2004 MontaVista Software <source@mvista.com>.
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * Based on code by Matthew Locke, Dmitry Chigirev, and Bishop Brock.
+ */
+
+/*!
+ * @file dpm.c
+ *
+ * @brief This file provides DPM support hooks for the Freescale i.MX27
+ *
+ * @ingroup DPM
+ */
+
+#include <linux/dpm.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kmod.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/string.h>
+#include <linux/device.h>
+#include <linux/pm.h>
+#include <linux/delay.h>
+
+#include <asm/hardirq.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/mxc_pm.h>
+#include <asm/arch/clock.h>
+
+static unsigned saved_cpu_freq;
+static unsigned long saved_loops_per_jiffy;
+static unsigned int curr_mode = DPM_MODE_RUN;
+
+extern void (*pm_idle) (void);
+
+static int mxc_dpm_set_opt(struct dpm_opt *cur, struct dpm_opt *new)
+{
+	struct dpm_md_opt *md_cur, *md_new;
+	unsigned long flags;
+
+	md_cur = &cur->md_opt;
+	md_new = &new->md_opt;
+
+	if (md_new->cpu == -1)
+		md_new->cpu = md_cur->cpu;
+	if (md_new->ahb == -1)
+		md_new->ahb = md_cur->ahb;
+	if (md_new->ip == -1)
+		md_new->ip = md_cur->ip;
+	if (md_new->mode == -1)
+		md_new->mode = md_cur->mode;
+
+	if (md_new->cpu == 0 || md_new->mode == DPM_MODE_SLEEP) {
+
+#ifdef CONFIG_PM
+		pm_suspend(PM_SUSPEND_MEM);
+
+		/* Here when we wake up.  Recursive call to switch back to
+		 * to task state.
+		 */
+		dpm_set_os(DPM_TASK_STATE);
+#endif
+		return 0;
+	}
+
+	if (md_new->mode == DPM_MODE_WAIT) {
+#ifdef CONFIG_PM
+		pm_suspend(PM_SUSPEND_STANDBY);
+
+		/* Here when we wake up.  Recursive call to switch back to
+		 * to task state.
+		 */
+		dpm_set_os(DPM_TASK_STATE);
+#endif
+		return 0;
+	}
+
+	if (md_new->mode == DPM_MODE_STOP) {
+#ifdef CONFIG_PM
+		pm_suspend(PM_SUSPEND_STOP);
+
+		/* Here when we wake up.  Recursive call to switch back to
+		 * to task state.
+		 */
+		dpm_set_os(DPM_TASK_STATE);
+#endif
+		return 0;
+	}
+
+	local_irq_save(flags);
+
+	if (md_new->cpu) {
+		loops_per_jiffy =
+		    dpm_compute_lpj(saved_loops_per_jiffy, saved_cpu_freq,
+				    md_new->cpu / 1000);
+	}
+#ifdef CONFIG_PM
+	mxc_pm_dvfs(md_new->cpu, md_new->ahb, md_new->ip);
+	curr_mode = md_new->mode;
+#endif
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+static int mxc_dpm_init_opt(struct dpm_opt *opt)
+{
+	int core = opt->pp[DPM_CORE_FREQ];
+	int ahb = opt->pp[DPM_AHB_FREQ];
+	int ip = opt->pp[DPM_IP_FREQ];
+	int mode = opt->pp[DPM_MODE];
+	struct dpm_md_opt *md_opt = &opt->md_opt;
+
+	if (mode != DPM_MODE_SLEEP &&
+	    mode != DPM_MODE_RUN &&
+	    mode != DPM_MODE_WAIT && mode != DPM_MODE_STOP && mode != -1) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "MCU mode is out of range. "
+		       "Possible settings: 0 - sleep,  1 - run, 2 - wait, 3 - stop\n");
+		return -EINVAL;
+	}
+
+	if (mode == DPM_MODE_SLEEP || core == 0) {
+		md_opt->cpu = 0;
+		md_opt->ahb = 0;
+		md_opt->ip = 0;
+		md_opt->mode = mode;
+		return 0;
+	}
+
+	if (ahb != -1 && (ahb > AHB_MAX || ahb < AHB_MIN)) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "AHB frequency setting %u is out of range for opt "
+		       "named %s. Possible settings: %d .. %d.\n",
+		       ahb, opt->name, AHB_MIN, AHB_MAX);
+		return -EINVAL;
+	}
+
+	if (ahb != -1 && ahb % AHB_MIN != 0) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "AHB frequency setting %u is out of range for opt "
+		       "named %s. AHB frequency should be multiple of %d.\n",
+		       ahb, opt->name, AHB_MIN);
+		return -EINVAL;
+	}
+
+	if (ip != -1 && (ip > IPG_MAX || ip < IPG_MIN)) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "IPG frequency setting %u is out of range for opt "
+		       "named %s. Possible settings: %d .. %d.\n",
+		       ip, opt->name, IPG_MIN, IPG_MAX);
+		return -EINVAL;
+	}
+
+	if (ip != -1 && ip % IPG_MIN != 0) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "IP frequency setting %u is out of range for opt "
+		       "named %s. IP frequency should be multiple of %d.\n",
+		       ip, opt->name, IPG_MIN);
+		return -EINVAL;
+	}
+
+	if (core != -1 && (core > ARM_MAX || core < ARM_MIN) && core != 0) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "ARM frequency setting %u is out of range for opt "
+		       "named %s. Possible settings: %d .. %d.\n",
+		       core, opt->name, ARM_MIN, ARM_MAX);
+		return -EINVAL;
+	}
+#if 0
+	if (core != -1 && core % ARM_MIN != 0) {
+		printk(KERN_ERR "MXC DPM Error: "
+		       "ARM frequency setting %u is out of range for opt "
+		       "named %s. ARM frequency should be multiple of %d.\n",
+		       core, opt->name, ARM_MIN);
+		return -EINVAL;
+	}
+#endif
+	md_opt->cpu = core;
+	md_opt->ahb = ahb;
+	md_opt->ip = ip;
+	md_opt->mode = mode;
+	return 0;
+}
+
+/*!
+ * Fully determine the current machine-dependent operating point, and fill in a
+ * structure presented by the caller. This should only be called when the
+ * dpm_sem is held. This call can return an error if the system is currently at
+ * an operating point that could not be constructed by dpm_md_init_opt().
+ */
+static int mxc_dpm_get_opt(struct dpm_opt *opt)
+{
+	struct dpm_md_opt *md_opt;
+
+	md_opt = &opt->md_opt;
+
+	md_opt->cpu = mxc_get_clocks(CPU_CLK);
+	md_opt->ahb = mxc_get_clocks(AHB_CLK);
+	md_opt->ip = mxc_get_clocks(IPG_CLK);
+	md_opt->mode = curr_mode;
+
+	return 0;
+}
+
+/****************************************************************************
+ * Machine-dependent /proc/driver/dpm/md entries
+ ****************************************************************************/
+
+static inline int p5d(char *buf, unsigned mhz)
+{
+	return sprintf(buf, "%5d", mhz);	/* Round */
+}
+
+int dpm_proc_print_opt(char *buf, struct dpm_opt *opt)
+{
+	int len = 0;
+	struct dpm_md_opt *md_opt;
+
+	md_opt = &opt->md_opt;
+
+	len += sprintf(buf + len, "%12s %9lu", opt->name, opt->stats.count);
+	len += sprintf(buf + len, "\t%d\t%d\t%d\n",
+		       md_opt->cpu, md_opt->ahb, md_opt->ip);
+	/* Add MODE string later */
+	return len;
+}
+
+int
+read_proc_dpm_md_opts(char *page, char **start, off_t offset,
+		      int count, int *eof, void *data)
+{
+	int len = 0;
+	int limit = offset + count;
+	struct dpm_opt *opt;
+	struct list_head *opt_list;
+
+	/* FIXME: For now we assume that the complete table,
+	 * formatted, fits within one page */
+	if (offset >= PAGE_SIZE)
+		return 0;
+
+	if (dpm_lock_interruptible())
+		return -ERESTARTSYS;
+
+	if (!dpm_initialized)
+		len += sprintf(page + len, "DPM is not initialized\n");
+	else if (!dpm_enabled)
+		len += sprintf(page + len, "DPM is disabled\n");
+	else {
+		len += sprintf(page + len,
+			       "The active DPM policy is \"%s\"\n",
+			       dpm_active_policy->name);
+		len += sprintf(page + len,
+			       "The current operating point is \"%s\"\n",
+			       dpm_active_opt->name);
+	}
+
+	if (dpm_initialized) {
+		len += sprintf(page + len,
+			       "Table of all defined operating points, "
+			       "frequencies in MHz:\n");
+
+		len += sprintf(page + len,
+			       " Name           Count  DPLL  CPU  TC  PER  DSP  DSPMMU   LCD\n");
+
+		list_for_each(opt_list, &dpm_opts) {
+			opt = list_entry(opt_list, struct dpm_opt, list);
+			if (len >= PAGE_SIZE)
+				BUG();
+			if (len >= limit)
+				break;
+			len += dpm_proc_print_opt(page + len, opt);
+		}
+	}
+	dpm_unlock();
+	*eof = 1;
+	if (offset >= len)
+		return 0;
+	*start = page + offset;
+	return min(count, len - (int)offset);
+}
+
+/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ *
+ * /proc/driver/dpm/md/cmd (Write-only)
+ *
+ *  This is a catch-all, simple command processor for the MX27 DPM
+ *  implementation. These commands are for experimentation and development
+ *  _only_, and may leave the system in an unstable state.
+ *
+ *  No commands defined now.
+ *
+ ****************************************************************************/
+
+int
+write_proc_dpm_md_cmd(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	char *buf, *tok, *s;
+	static const char *whitespace = " \t\r\n";
+	int ret = 0;
+
+	if (current->uid != 0)
+		return -EACCES;
+	if (count == 0)
+		return 0;
+	if (!(buf = kmalloc(count + 1, GFP_KERNEL)))
+		return -ENOMEM;
+	if (copy_from_user(buf, buffer, count)) {
+		kfree(buf);
+		return -EFAULT;
+	}
+	buf[count] = '\0';
+	s = buf + strspn(buf, whitespace);
+	tok = strsep(&s, whitespace);
+
+	if (strcmp(tok, "define-me") == 0) {
+		;
+	} else {
+		ret = -EINVAL;
+	}
+	kfree(buf);
+	if (ret == 0)
+		return count;
+	else
+		return ret;
+}
+
+/****************************************************************************
+ *  DPM Idle Handler
+ ****************************************************************************/
+
+static void (*orig_idle) (void);
+
+static void mxc_dpm_idle(void)
+{
+	extern void default_idle(void);
+
+	if (orig_idle)
+		orig_idle();
+	else
+		default_idle();
+}
+
+/****************************************************************************
+ * Initialization/Exit
+ ****************************************************************************/
+
+static void mxc_dpm_startup(void)
+{
+	if (!saved_loops_per_jiffy) {
+		saved_loops_per_jiffy = loops_per_jiffy;
+		saved_cpu_freq = mxc_get_clocks(CPU_CLK) / 1000;
+	}
+	orig_idle = pm_idle;
+	pm_idle = dpm_idle;
+}
+
+static void mxc_dpm_cleanup(void)
+{
+	pm_idle = orig_idle;
+}
+
+static int __init mxc_dpm_init(void)
+{
+	printk("Freescale i.MX27 Dynamic Power Management.\n");
+
+	dpm_md.init_opt = mxc_dpm_init_opt;
+	dpm_md.set_opt = mxc_dpm_set_opt;
+	dpm_md.get_opt = mxc_dpm_get_opt;
+	dpm_md.check_constraint = dpm_default_check_constraint;
+	dpm_md.idle = mxc_dpm_idle;
+	dpm_md.startup = mxc_dpm_startup;
+	dpm_md.cleanup = mxc_dpm_cleanup;
+
+	return 0;
+}
+
+__initcall(mxc_dpm_init);
--- linux-2.6.19.2/arch/arm/mach-mx27/gpio_mux.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/gpio_mux.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,302 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@file gpio_mux.c
+ *@brief This file contains the IOMUX implementation details. 
+ * @ingroup GPIO
+ */
+
+#include <linux/kernel.h>
+#include <linux/cache.h>
+#include <linux/spinlock.h>
+
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/gpio.h>
+#include "gpio_mux.h"
+
+/*!
+ * This structure defines the offset of registers in gpio module.
+ */
+enum gpio_reg {
+	GPIO_GIUS = 0x20,
+	GPIO_GPR = 0x38,
+	GPIO_PUEN = 0x40,
+	GPIO_DDIR = 0x00,
+	GPIO_OCR1 = 0x04,
+	GPIO_OCR2 = 0x08,
+	GPIO_ICONFA1 = 0x0C,
+	GPIO_ICONFA2 = 0x10,
+	GPIO_ICONFB1 = 0x14,
+	GPIO_ICONFB2 = 0x18,
+};
+
+/*!
+ * This enumeration data type defines the configuration for input mode.
+ */
+typedef enum {
+	GPIO_INPUT_GPIO = 0x00,
+	GPIO_INPUT_INTR = 0x01,
+	GPIO_INPUT_LOW = 0x02,
+	GPIO_INPUT_HIGH = 0x03
+} gpio_input_cfg_t;
+
+/*!
+ * This enumeration data type defines the configuration for output mode.
+ */
+typedef enum {
+	GPIO_OUTPUT_A = 0x00,
+	GPIO_OUTPUT_B = 0x01,
+	GPIO_OUTPUT_C = 0x02,
+	GPIO_OUTPUT_DR = 0x03
+} gpio_output_cfg_t;
+
+extern struct mxc_gpio_port mxc_gpio_ports[];
+
+/*!
+ * defines a spinlock to protected the accessing to gpio pin.
+ */
+DEFINE_SPINLOCK(gpio_mux_lock);
+
+/*!
+ * This function enable or disable the pullup feature to the pin. 
+ * @param port  	a pointer of gpio port
+ * @param index 	the index of the  pin in the port
+ * @param en		0 if disable pullup, otherwise enable it.
+ * @return		none
+ */
+static inline void _gpio_set_puen(struct mxc_gpio_port *port, u32 index,
+				  bool en)
+{
+	u32 reg;
+
+	reg = __raw_readl(port->base + GPIO_PUEN);
+	if (en) {
+		reg |= 1 << index;
+	} else {
+		reg &= ~(1 << index);
+	}
+	__raw_writel(reg, port->base + GPIO_PUEN);
+}
+
+/*!
+ * This function set the input configuration A. 
+ * @param port  	a pointer of gpio port
+ * @param index 	the index of the  pin in the port
+ * @param config	a mode as define in \b #gpio_input_cfg_t
+ * @return		none
+ */
+static inline void _gpio_set_iconfa(struct mxc_gpio_port *port, u32 index,
+				    gpio_input_cfg_t config)
+{
+	u32 reg, val;
+	u32 mask;
+
+	mask = 0x3 << ((index % 16) << 1);
+
+	if (index >= 16) {
+		reg = port->base + GPIO_ICONFA2;
+		val = config << ((index - 16) * 2);
+	} else {
+		reg = port->base + GPIO_ICONFA1;
+		val = config << (index * 2);
+	}
+	val |= __raw_readl(reg) & ~(mask);
+	__raw_writel(val, reg);
+}
+
+/*!
+ * This function set the input configuration B. 
+ * @param port  	a pointer of gpio port
+ * @param index 	the index of the  pin in the port
+ * @param config	a mode as define in \b #gpio_input_cfg_t
+ * @return		none
+ */
+static inline void _gpio_set_iconfb(struct mxc_gpio_port *port, u32 index,
+				    gpio_input_cfg_t config)
+{
+	u32 reg, val;
+	u32 mask;
+
+	mask = 0x3 << ((index % 16) << 1);
+
+	if (index >= 16) {
+		reg = port->base + GPIO_ICONFB2;
+		val = config << ((index - 16) * 2);
+	} else {
+		reg = port->base + GPIO_ICONFB1;
+		val = config << (index * 2);
+	}
+	val |= __raw_readl(reg) & (~mask);
+	__raw_writel(val, reg);
+}
+
+/*!
+ * This function set the output configuration. 
+ * @param port  	a pointer of gpio port
+ * @param index 	the index of the  pin in the port
+ * @param config	a mode as define in \b #gpio_output_cfg_t
+ * @return		none
+ */
+static inline void _gpio_set_ocr(struct mxc_gpio_port *port, u32 index,
+				 gpio_output_cfg_t config)
+{
+	u32 reg, val;
+	u32 mask;
+
+	mask = 0x3 << ((index % 16) << 1);
+	if (index >= 16) {
+		reg = port->base + GPIO_OCR2;
+		val = config << ((index - 16) * 2);
+	} else {
+		reg = port->base + GPIO_OCR1;
+		val = config << (index * 2);
+	}
+	val |= __raw_readl(reg) & (~mask);
+	__raw_writel(val, reg);
+}
+
+/*!
+ *@brief gpio_config_mux - just configure the mode of the gpio pin.
+ *@param pin   a pin number as defined in \b #iomux_pin_name_t
+ *@param mode  a module as define in \b #gpio_mux_mode_t;
+ *	GPIO_MUX_PRIMARY set pin to work as primary function.
+ *	GPIO_MUX_ALT set pin to work as alternate function.
+ *	GPIO_MUX_GPIO set pin to work as output function based the data register
+ *	GPIO_MUX_INPUT1 set pin to work as input function connected with  A_OUT
+ *	GPIO_MUX_INPUT2 set pin to work as input function connected with B_OUT
+ *	GPIO_MUX_OUTPUT1 set pin to work as output function connected with A_IN
+ *	GPIO_MUX_OUTPUT2 set pin to work as output function connected with B_IN
+ *	GPIO_MUX_OUTPUT3 set pin to work as output function connected with C_IN
+ *@return      0 if successful, Non-zero otherwise
+ */
+
+int gpio_config_mux(iomux_pin_name_t pin, gpio_mux_mode_t mode)
+{
+	unsigned long lock_flags;
+	u32 gius_reg, gpr_reg;
+	struct mxc_gpio_port *port;
+	u32 index, gpio = IOMUX_TO_GPIO(pin);
+
+	port = &(mxc_gpio_ports[GPIO_TO_PORT(gpio)]);
+	index = GPIO_TO_INDEX(gpio);
+
+	pr_debug("%s: Configuring PORT %c, bit %d\n",
+		 __FUNCTION__, port->num + 'A', index);
+
+	spin_lock_irqsave(&gpio_mux_lock, lock_flags);
+
+	gius_reg = __raw_readl(port->base + GPIO_GIUS);
+	gpr_reg = __raw_readl(port->base + GPIO_GPR);
+
+	switch (mode) {
+	case GPIO_MUX_PRIMARY:
+		gius_reg &= ~(1L << index);
+		gpr_reg &= ~(1L << index);
+		break;
+	case GPIO_MUX_ALT:
+		gius_reg &= ~(1L << index);
+		gpr_reg |= (1L << index);
+		break;
+	case GPIO_MUX_GPIO:
+		gius_reg |= (1L << index);
+		_gpio_set_ocr(port, index, GPIO_OUTPUT_DR);
+		break;
+	case GPIO_MUX_INPUT1:
+		gius_reg |= (1L << index);
+		_gpio_set_iconfa(port, index, GPIO_INPUT_GPIO);
+		break;
+	case GPIO_MUX_INPUT2:
+		gius_reg |= (1L << index);
+		_gpio_set_iconfb(port, index, GPIO_INPUT_GPIO);
+		break;
+	case GPIO_MUX_OUTPUT1:
+		gius_reg |= (1L << index);
+		_gpio_set_ocr(port, index, GPIO_OUTPUT_A);
+		break;
+	case GPIO_MUX_OUTPUT2:
+		gius_reg |= (1L << index);
+		_gpio_set_ocr(port, index, GPIO_OUTPUT_B);
+		break;
+	case GPIO_MUX_OUTPUT3:
+		gius_reg |= (1L << index);
+		_gpio_set_ocr(port, index, GPIO_OUTPUT_C);
+		break;
+	default:
+		spin_unlock_irqrestore(&gpio_mux_lock, lock_flags);
+		return -1;
+	}
+
+	__raw_writel(gius_reg, port->base + GPIO_GIUS);
+	__raw_writel(gpr_reg, port->base + GPIO_GPR);
+
+	spin_unlock_irqrestore(&gpio_mux_lock, lock_flags);
+	return 0;
+}
+
+/*!
+ * This function is just used to enable or disable the pull up feature .
+ * @param pin   a pin number as defined in \b #iomux_pin_name_t
+ * @param en    0 if disable, Non-zero enable
+ * @return      0 if successful, Non-zero otherwise
+ */
+int gpio_set_puen(iomux_pin_name_t pin, bool en)
+{
+	unsigned long lock_flags;
+
+	struct mxc_gpio_port *port;
+	u32 index, gpio = IOMUX_TO_GPIO(pin);
+
+	port = &(mxc_gpio_ports[GPIO_TO_PORT(gpio)]);
+	index = GPIO_TO_INDEX(gpio);
+
+	pr_debug("%s: Configuring output mode of PORT %c, bit %d\n",
+		 __FUNCTION__, port->num + 'A', index);
+
+	spin_lock_irqsave(&gpio_mux_lock, lock_flags);
+
+	_gpio_set_puen(port, index, en);
+	spin_unlock_irqrestore(&gpio_mux_lock, lock_flags);
+	return 0;
+
+}
+
+/*!
+ * This function is just used to request a pin and configure it.
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @param mode	a module as define in \b #gpio_mux_mode_t;
+ * @return	0 if successful, Non-zero otherwise
+ */
+int gpio_request_mux(iomux_pin_name_t pin, gpio_mux_mode_t mode)
+{
+	int ret;
+	ret = mxc_request_gpio(pin);
+	if (ret == 0) {
+		ret = gpio_config_mux(pin, mode);
+		if (ret) {
+			mxc_free_gpio(pin);
+		}
+	}
+	return ret;
+}
+
+/*!
+ * This function is just used to release a pin.
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @return	none	
+ */
+void gpio_free_mux(iomux_pin_name_t pin)
+{
+	mxc_free_gpio(pin);
+}
--- linux-2.6.19.2/arch/arm/mach-mx27/gpio_mux.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/gpio_mux.h	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@file gpio_mux.h
+ *@brief This file contains the private definition  .
+ * @ingroup GPIO
+ */
+
+#ifndef __ARCH_ARM_MACH_MX27_GPIO_MUX_H__
+#define __ARCH_ARM_MACH_MX27_GPIO_MUX_H__
+
+/*!
+ * This enumeration data type defines the modes of the pin .
+ *	GPIO_MUX_PRIMARY is the primary mode.
+ *	GPIO_MUX_ALT is the alternate mode.
+ *	GPIO_MUX_GPIO is the output mode and the signal source is data register.
+ *	GPIO_MUX_INPUT1 is the input mode and the signal destination is A_OUT.
+ *	GPIO_MUX_INPUT2 is the input mode and the signal destination is B_OUT.
+ *	GPIO_MUX_OUTPUT1 is the output mode and the signal destination is A_IN.
+ *	GPIO_MUX_OUTPUT2 is the output mode and the signal destination is B_IN.
+ *	GPIO_MUX_OUTPUT3 is the output mode and the signal destination is C_IN.
+ */
+typedef enum {
+	GPIO_MUX_PRIMARY,
+	GPIO_MUX_ALT,
+	GPIO_MUX_GPIO,
+	GPIO_MUX_INPUT1,
+	GPIO_MUX_INPUT2,
+	GPIO_MUX_OUTPUT1,
+	GPIO_MUX_OUTPUT2,
+	GPIO_MUX_OUTPUT3,
+} gpio_mux_mode_t;
+
+/*!
+ * This function is just used to request a pin and configure it.
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @param mode	a module as define in \b #gpio_mux_mode_t;
+ * @return	0 if successful, Non-zero otherwise
+ */
+extern int gpio_request_mux(iomux_pin_name_t pin, gpio_mux_mode_t mode);
+
+/*!
+ * This function is just used to configure a pin .
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @param mode	a module as define in \b #gpio_mux_mode_t;
+ * @return	0 if successful, Non-zero otherwise
+ */
+extern int gpio_config_mux(iomux_pin_name_t pin, gpio_mux_mode_t mode);
+
+/*!
+ * This function is just used to enable or disable the pull up feature .
+ * @param pin   a pin number as defined in \b #iomux_pin_name_t
+ * @param en    0 if disable, Non-zero enable
+ * @return      0 if successful, Non-zero otherwise
+ */
+extern int gpio_set_puen(iomux_pin_name_t pin, bool en);
+
+/*!
+ * This function is just used to release a pin.
+ * @param pin	a pin number as defined in \b #iomux_pin_name_t
+ * @return	none	
+ */
+extern void gpio_free_mux(iomux_pin_name_t pin);
+
+#endif				/* __ARCH_ARM_MACH_MX27_GPIO_MUX_H__ */
--- linux-2.6.19.2/arch/arm/mach-mx27/Kconfig	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/Kconfig	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,26 @@
+menu "MX27 Options"
+	depends on ARCH_MX27
+
+config MACH_MX27ADS
+	bool "Support MX27ADS platforms"
+	default y
+	help
+	  Include support for MX27ADS platform. This includes specific 
+	  configurations for the board and its peripherals.
+	
+config ISP1504_MXC
+	tristate "ISP1504 transceiver support"
+	select ISP1504_MXC_OTG if USB_GADGET && USB_EHCI_HCD && USB_OTG
+	help
+	  Support for the ISP1504 USB transceiver on MXC platforms.
+
+config ISP1504_MXC_OTG
+	tristate
+	help
+	  Support for USB OTG using the ISP1504 transceiver on MXC platforms.
+
+config ISP1301_MXC
+	bool
+	select I2C_MXC
+
+endmenu
--- linux-2.6.19.2/arch/arm/mach-mx27/Makefile.boot	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/Makefile.boot	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,3 @@
+   zreladdr-y	:= 0xA0008000
+params_phys-y	:= 0xA0000100
+initrd_phys-y	:= 0xA0800000
--- linux-2.6.19.2/arch/arm/mach-mx27/Makefile	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/Makefile	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,12 @@
+#
+# Makefile for the linux kernel.
+#
+
+# Object file lists.
+
+obj-y		:= mm.o time.o dma.o gpio_mux.o clock.o devices.o serial.o system.o usb.o
+obj-$(CONFIG_MACH_MX27ADS)	+= mx27ads.o mx27ads_gpio.o
+
+# power management
+obj-$(CONFIG_PM) 		+= pm.o mxc_pm.o
+obj-$(CONFIG_DPM)		+= dpm.o
--- linux-2.6.19.2/arch/arm/mach-mx27/mm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/mm.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mm.c
+ *
+ * @brief This file creates static mapping between physical to virtual memory.
+ *
+ * @ingroup Memory
+ */
+
+#include <linux/mm.h>
+#include <linux/init.h>
+
+#include <asm/hardware.h>
+#include <asm/pgtable.h>
+#include <asm/mach/map.h>
+
+static struct map_desc mxc_io_desc[] __initdata = {
+	{
+	 .virtual = AIPI_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(AIPI_BASE_ADDR),
+	 .length = AIPI_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = SAHB1_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(SAHB1_BASE_ADDR),
+	 .length = SAHB1_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = X_MEMC_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(X_MEMC_BASE_ADDR),
+	 .length = X_MEMC_SIZE,
+	 .type = MT_DEVICE},
+	{
+	 .virtual = CS4_BASE_ADDR_VIRT,
+	 .pfn = __phys_to_pfn(CS4_BASE_ADDR),
+	 .length = CS4_SIZE,
+	 .type = MT_DEVICE}
+};
+
+void __init mxc_map_io(void)
+{
+	iotable_init(mxc_io_desc, ARRAY_SIZE(mxc_io_desc));
+}
--- linux-2.6.19.2/arch/arm/mach-mx27/mx27ads.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/mx27ads.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,704 @@
+/*
+ *  Copyright (C) 2000 Deep Blue Solutions Ltd
+ *  Copyright (C) 2002 Shane Nay (shane@minirl.com)
+ *  Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/device.h>
+#include <linux/input.h>
+#include <linux/nodemask.h>
+#include <linux/spi/spi.h>
+#include <linux/serial_8250.h>
+#if defined(CONFIG_MTD) || defined(CONFIG_MTD_MODULE)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach/flash.h>
+#endif
+
+#include <asm/hardware.h>
+#include <asm/irq.h>
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/irq.h>
+#include <asm/arch/memory.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/mach/keypad.h>
+#include "gpio_mux.h"
+
+/*!
+ * @file mx27ads.c
+ * @brief This file contains the board specific initialization routines.
+ *
+ * @ingroup System
+ */
+
+extern void mxc_map_io(void);
+extern void mxc_init_irq(void);
+extern struct sys_timer mxc_timer;
+
+static char command_line[COMMAND_LINE_SIZE];
+static int mxc_card_status;
+int mxc_board_is_ads = 1;
+
+static void mxc_nop_release(struct device *dev)
+{
+	/* Nothing */
+}
+
+#if defined(CONFIG_KEYBOARD_MXC) || defined(CONFIG_KEYBOARD_MXC_MODULE)
+
+/*!
+ * This array is used for mapping mx27 ADS keypad scancodes to input keyboard
+ * keycodes.
+ */
+static u16 mxckpd_keycodes[(MAXROW * MAXCOL)] = {
+	KEY_KP9, KEY_LEFTSHIFT, KEY_0, KEY_KPASTERISK, KEY_RECORD, KEY_POWER,
+	KEY_KP8, KEY_9, KEY_8, KEY_7, KEY_KP5, KEY_VOLUMEDOWN,
+	KEY_KP7, KEY_6, KEY_5, KEY_4, KEY_KP4, KEY_VOLUMEUP,
+	KEY_KP6, KEY_3, KEY_2, KEY_1, KEY_KP3, KEY_DOWN,
+	KEY_BACK, KEY_RIGHT, KEY_ENTER, KEY_LEFT, KEY_HOME, KEY_KP2,
+	KEY_END, KEY_F2, KEY_UP, KEY_F1, KEY_F4, KEY_KP1,
+};
+
+static struct keypad_data evb_6_by_6_keypad = {
+	.rowmax = 6,
+	.colmax = 6,
+	.irq = INT_KPP,
+	.learning = 0,
+	.delay = 2,
+	.matrix = mxckpd_keycodes,
+};
+
+static struct resource mxc_kpp_resources[] = {
+	[0] = {
+	       .start = INT_KPP,
+	       .end = INT_KPP,
+	       .flags = IORESOURCE_IRQ,
+	       }
+};
+
+/* mxc keypad driver */
+static struct platform_device mxc_keypad_device = {
+	.name = "mxc_keypad",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(mxc_kpp_resources),
+	.resource = mxc_kpp_resources,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &evb_6_by_6_keypad,
+		},
+};
+
+static void mxc_init_keypad(void)
+{
+	printk("mx27ads.c: registering mxc keypad device...\n");
+	(void)platform_device_register(&mxc_keypad_device);
+}
+#else
+static inline void mxc_init_keypad(void)
+{
+}
+#endif
+
+/* MTD NOR flash */
+
+#if defined(CONFIG_MTD_MXC) || defined(CONFIG_MTD_MXC_MODULE)
+
+static struct mtd_partition mxc_nor_partitions[] = {
+	{
+	 .name = "Bootloader",
+	 .size = 512 * 1024,
+	 .offset = 0x00000000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "nor.Kernel",
+	 .size = 2 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "nor.userfs",
+	 .size = 14 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = 0},
+	{
+	 .name = "nor.rootfs",
+	 .size = 12 * 1024 * 1024,
+	 .offset = MTDPART_OFS_APPEND,
+	 .mask_flags = MTD_WRITEABLE},
+	{
+	 .name = "FIS directory",
+	 .size = 12 * 1024,
+	 .offset = 0x01FE0000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+	{
+	 .name = "Redboot config",
+	 .size = MTDPART_SIZ_FULL,
+	 .offset = 0x01FFF000,
+	 .mask_flags = MTD_WRITEABLE	/* force read-only */
+	 },
+};
+
+static struct flash_platform_data mxc_flash_data = {
+	.map_name = "cfi_probe",
+	.width = 2,
+	.parts = mxc_nor_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nor_partitions),
+};
+
+static struct resource mxc_flash_resource = {
+	.start = 0xc0000000,
+	.end = 0xc0000000 + 0x02000000 - 1,
+	.flags = IORESOURCE_MEM,
+
+};
+
+static struct platform_device mxc_nor_mtd_device = {
+	.name = "mxc_nor_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_flash_data,
+		},
+	.num_resources = 1,
+	.resource = &mxc_flash_resource,
+};
+
+static void mxc_init_nor_mtd(void)
+{
+	(void)platform_device_register(&mxc_nor_mtd_device);
+}
+#else
+static void mxc_init_nor_mtd(void)
+{
+}
+#endif
+
+/* MTD NAND flash */
+
+#if defined(CONFIG_MTD_NAND_MXC) || defined(CONFIG_MTD_NAND_MXC_MODULE)
+
+static struct mtd_partition mxc_nand_partitions[4] = {
+	{
+	 .name = "IPL-SPL",
+	 .offset = 0,
+	 .size = 128 * 1024},
+	{
+	 .name = "nand.kernel",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 4 * 1024 * 1024},
+	{
+	 .name = "nand.rootfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = 22 * 1024 * 1024},
+	{
+	 .name = "nand.userfs",
+	 .offset = MTDPART_OFS_APPEND,
+	 .size = MTDPART_SIZ_FULL},
+};
+
+static struct flash_platform_data mxc_nand_data = {
+	.parts = mxc_nand_partitions,
+	.nr_parts = ARRAY_SIZE(mxc_nand_partitions),
+	.width = 1,
+};
+
+static struct platform_device mxc_nand_mtd_device = {
+	.name = "mxc_nand_flash",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &mxc_nand_data,
+		},
+};
+
+static void mxc_init_nand_mtd(void)
+{
+	(void)platform_device_register(&mxc_nand_mtd_device);
+}
+#else
+static inline void mxc_init_nand_mtd(void)
+{
+}
+#endif
+
+#if defined(CONFIG_FB_MXC_SYNC_PANEL) || defined(CONFIG_FB_MXC_SYNC_PANEL_MODULE)
+static const char fb_default_mode[] = "Sharp-QVGA";
+
+/* mxc lcd driver */
+static struct platform_device mxc_fb_device = {
+	.name = "mxc_sdc_fb",
+	.id = 0,
+	.dev = {
+		.release = mxc_nop_release,
+		.platform_data = &fb_default_mode,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		},
+};
+
+static void mxc_init_fb(void)
+{
+	(void)platform_device_register(&mxc_fb_device);
+}
+#else
+static inline void mxc_init_fb(void)
+{
+}
+#endif
+
+static struct spi_board_info mxc_spi_board_info[] __initdata = {
+	{
+	 .modalias = "pmic_spi",
+	 .irq = IOMUX_TO_IRQ(MX27_PIN_TOUT),
+	 .max_speed_hz = 4000000,
+	 .bus_num = 1,
+	 .chip_select = 0,
+	 },
+};
+
+#if 0
+#define MXC_CARD_DEBUG
+#endif
+
+static const int pbc_card_bit[4][3] = {
+	/* BSTAT            IMR enable       IMR removal */
+	{PBC_BSTAT_SD2_DET, PBC_INTR_SD2_EN, PBC_INTR_SD2_R_EN},
+	{PBC_BSTAT_SD3_DET, PBC_INTR_SD3_EN, PBC_INTR_SD3_R_EN},
+	{PBC_BSTAT_MS_DET, PBC_INTR_MS_EN, PBC_INTR_MS_R_EN},
+	{PBC_BSTAT_SD1_DET, PBC_INTR_SD1_EN, PBC_INTR_SD1_R_EN},
+};
+
+/*!
+ * Check if a SD card has been inserted or not.
+ *
+ * @param  num		a card number as defined in \b enum \b mxc_card_no
+ * @return 0 if a card is not present; non-zero otherwise.
+ */
+int mxc_card_detected(enum mxc_card_no num)
+{
+	u32 status;
+
+	status = __raw_readw(PBC_BSTAT1_REG);
+	return ((status & MXC_BSTAT_BIT(num)) == 0);
+}
+
+/*
+ * Check if there is any state change by reading the IMR register and the
+ * previous and current states of the board status register (offset 0x28).
+ * A state change is defined to be card insertion OR removal. So the driver
+ * may have to call the mxc_card_detected() function to see if it is card
+ * insertion or removal.
+ *
+ * @param  mask		current IMR value
+ * @param  s0		previous status register value (offset 0x28)
+ * @param  s1		current status register value (offset 0x28)
+ *
+ * @return 0 if no card status change OR the corresponding bits in the IMR
+ *           (passed in as 'mask') is NOT set.
+ *         A non-zero value indicates some card state changes. For example,
+ *         0b0001 means SD3 has a card state change (bit0 is set) AND its
+ *               associated insertion or removal bits in IMR is SET.
+ *         0b0100 means SD1 has a card state change (bit2 is set) AND its
+ *               associated insertion or removal bits in IMR is SET.
+ *         0b1001 means both MS and SD3 have state changes
+ */
+static u32 mxc_card_state_changed(u32 mask, u32 s0, u32 s1)
+{
+	u32 i, retval = 0;
+	u32 stat = (s0 ^ s1) & 0x7800;
+
+	if (stat == 0)
+		return 0;
+
+	for (i = MXC_CARD_MIN; i <= MXC_CARD_MAX; i++) {
+		if ((stat & pbc_card_bit[i][0]) != 0 &&
+		    (mask & (pbc_card_bit[i][1] | pbc_card_bit[i][2])) != 0) {
+			retval |= 1 << i;
+		}
+	}
+#ifdef MXC_CARD_DEBUG
+	printk("\nmask=%x, s0=%x, s1=%x\n", mask, s0, s1);
+	printk("retval=%x, stat=%x\n", retval, stat);
+#endif
+	return retval;
+}
+
+/*!
+ * Interrupt handler for the expio (CPLD) to deal with interrupts from
+ * FEC, external UART, CS8900 Ethernet and SD cards, etc.
+ */
+static void mxc_expio_irq_handler(u32 irq, struct irqdesc *desc,
+				  struct pt_regs *regs)
+{
+	u32 imr, card_int, i;
+	u32 int_valid;
+	u32 expio_irq;
+	u32 stat = __raw_readw(PBC_BSTAT1_REG);
+
+	desc->chip->mask(irq);	/* irq = gpio irq number */
+
+	imr = __raw_readw(PBC_INTMASK_SET_REG);
+
+	card_int = mxc_card_state_changed(imr, mxc_card_status, stat);
+	mxc_card_status = stat;
+
+	if (card_int != 0) {
+		for (i = MXC_CARD_MIN; i <= MXC_CARD_MAX - 1; i++) {
+			if ((card_int & (1 << i)) != 0) {
+				pr_info("card no %d state changed\n", i);
+			}
+		}
+	}
+
+	/* Bits defined in PBC_INTSTATUS_REG at 0x2C */
+	int_valid = __raw_readw(PBC_INTSTATUS_REG) & imr;
+	/*  combined with the card interrupt valid information */
+	int_valid = (int_valid & 0x0F8E) | (card_int << PBC_INTR_SD2_EN_BIT);
+
+	if (unlikely(!int_valid)) {
+		printk(KERN_ERR "\nEXPIO: Spurious interrupt:0x%0x\n\n",
+		       int_valid);
+		pr_info("CPLD IMR(0x38)=0x%x, BSTAT1(0x28)=0x%x\n", imr, stat);
+		goto out;
+	}
+
+	expio_irq = MXC_EXP_IO_BASE;
+	for (; int_valid != 0; int_valid >>= 1, expio_irq++) {
+		struct irqdesc *d;
+		if ((int_valid & 1) == 0)
+			continue;
+		d = irq_desc + expio_irq;
+		if (unlikely(!(d->handle_irq))) {
+			printk(KERN_ERR "\nEXPIO irq: %d unhandeled\n",
+			       expio_irq);
+			BUG();	/* oops */
+		}
+		d->handle_irq(expio_irq, d, regs);
+	}
+
+      out:
+	desc->chip->ack(irq);
+	desc->chip->unmask(irq);
+}
+
+#ifdef MXC_CARD_DEBUG
+
+static irqreturn_t mxc_sd_test_handler(int irq, void *desc,
+				       struct pt_regs *regs)
+{
+	int s = -1;
+
+	printk("%s(irq=%d) for ", __FUNCTION__, irq);
+	if (irq == EXPIO_INT_SD1_EN) {
+		printk("SD1");
+		s = MXC_CARD_SD1;
+	} else if (irq == EXPIO_INT_SD2_EN) {
+		printk("SD2");
+		s = MXC_CARD_SD2;
+	} else if (irq == EXPIO_INT_SD3_EN) {
+		printk("SD3");
+		s = MXC_CARD_SD3;
+	} else if (irq == EXPIO_INT_MS_EN) {
+		printk("MS");
+		s = MXC_CARD_MS;
+	} else {
+		printk("None!!!!");
+	}
+	if (mxc_card_detected(s)) {
+		printk(" inserted\n");
+	} else {
+		printk(" removed\n");
+	}
+
+	return IRQ_HANDLED;
+}
+#endif				/* MXC_CARD_DEBUG */
+
+/*
+ * Disable an expio pin's interrupt by setting the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_mask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+
+	/* mask the interrupt */
+	if (irq < EXPIO_INT_SD2_EN) {
+		__raw_writew(1 << expio, PBC_INTMASK_CLEAR_REG);
+	} else {
+		irq -= EXPIO_INT_SD2_EN;
+		/* clear both SDx_EN and SDx_R_EN bits */
+		__raw_writew((pbc_card_bit[irq][1] | pbc_card_bit[irq][2]),
+			     PBC_INTMASK_CLEAR_REG);
+	}
+}
+
+/*
+ * Acknowledge an expanded io pin's interrupt by clearing the bit in the isr.
+ * @param irq		an expanded io virtual irq number
+ */
+static void expio_ack_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+	/* clear the interrupt status */
+	__raw_writew(1 << expio, PBC_INTSTATUS_REG);
+	/* mask the interrupt */
+	expio_mask_irq(irq);
+}
+
+/*
+ * Enable a expio pin's interrupt by clearing the bit in the imr.
+ * @param irq		an expio virtual irq number
+ */
+static void expio_unmask_irq(u32 irq)
+{
+	u32 expio = MXC_IRQ_TO_EXPIO(irq);
+
+	/* unmask the interrupt */
+	if (irq < EXPIO_INT_SD2_EN) {
+		if (irq == EXPIO_INT_XUART_INTA) {
+			/* Set 8250 MCR register bit 3 - Forces the INT (A-B
+			 * outputs to the active mode and sets OP2 to logic 0.
+			 * This is needed to avoid spurious int caused by the
+			 * internal CPLD pull-up for the interrupt pin.
+			 */
+			u16 val = __raw_readw(MXC_LL_EXTUART_VADDR + 8);
+			__raw_writew(val | 0x8, MXC_LL_EXTUART_VADDR + 8);
+		}
+		__raw_writew(1 << expio, PBC_INTMASK_SET_REG);
+	} else {
+		irq -= EXPIO_INT_SD2_EN;
+
+		if (mxc_card_detected(irq)) {
+			__raw_writew(pbc_card_bit[irq][2], PBC_INTMASK_SET_REG);
+		} else {
+			__raw_writew(pbc_card_bit[irq][1], PBC_INTMASK_SET_REG);
+		}
+	}
+}
+
+static struct irqchip expio_irq_chip = {
+	.ack = expio_ack_irq,
+	.mask = expio_mask_irq,
+	.unmask = expio_unmask_irq,
+};
+
+static int __init mxc_expio_init(void)
+{
+	int i, ver;
+
+	ver = (__raw_readw(PBC_VERSION_REG) >> 8) & 0xFF;
+	if ((ver & 0x80) != 0) {
+		pr_info("MX27 ADS EXPIO(CPLD) hardware\n");
+		pr_info("CPLD version: 0x%x\n", ver);
+	} else {
+		mxc_board_is_ads = 0;
+		ver &= 0x0F;
+		pr_info("MX27 EVB EXPIO(CPLD) hardware\n");
+		if (ver == 0xF || ver <= MXC_CPLD_VER_1_50)
+			pr_info("Wrong CPLD version: %d\n", ver);
+		else {
+			pr_info("CPLD version: %d\n", ver);
+		}
+	}
+
+	mxc_card_status = __raw_readw(PBC_BSTAT1_REG);
+
+#ifdef MXC_CARD_DEBUG
+	for (i = MXC_CARD_MIN; i <= MXC_CARD_MAX; i++) {
+		if (mxc_card_detected(i)) {
+			pr_info("Card %d is detected\n", 3 - i);
+		}
+	}
+#endif
+	/*
+	 * Configure INT line as GPIO input
+	 */
+	gpio_config_mux(MX27_PIN_TIN, GPIO_MUX_GPIO);
+	mxc_set_gpio_direction(MX27_PIN_TIN, 1);
+
+	/* disable the interrupt and clear the status */
+	__raw_writew(0xFFFF, PBC_INTMASK_CLEAR_REG);
+	__raw_writew(0xFFFF, PBC_INTSTATUS_REG);
+
+	for (i = MXC_EXP_IO_BASE; i < (MXC_EXP_IO_BASE + MXC_MAX_EXP_IO_LINES);
+	     i++) {
+		set_irq_chip(i, &expio_irq_chip);
+		set_irq_handler(i, do_level_IRQ);
+		set_irq_flags(i, IRQF_VALID);
+	}
+	set_irq_type(EXPIO_PARENT_INT, IRQT_HIGH);
+	set_irq_chained_handler(EXPIO_PARENT_INT, mxc_expio_irq_handler);
+
+	return 0;
+}
+
+#if defined(CONFIG_SERIAL_8250) || defined(CONFIG_SERIAL_8250_MODULE)
+
+/*!
+ * The serial port definition structure. The fields contain:
+ * {UART, CLK, PORT, IRQ, FLAGS}
+ */
+static struct plat_serial8250_port serial_platform_data[] = {
+	{
+	 .membase = (void __iomem *)(CS4_BASE_ADDR_VIRT + 0x20000),
+	 .mapbase = (unsigned long)(CS4_BASE_ADDR + 0x20000),
+	 .irq = EXPIO_INT_XUART_INTA,
+	 .uartclk = 3686400,
+	 .regshift = 1,
+	 .iotype = UPIO_MEM,
+	 .flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST | UPF_AUTO_IRQ,
+	 /*.pm = serial_platform_pm, */
+	 },
+	{},
+};
+
+/*!
+ * REVISIT: document me
+ */
+static struct platform_device serial_device = {
+	.name = "serial8250",
+	.id = 0,
+	.dev = {
+		.platform_data = &serial_platform_data[0],
+		},
+};
+
+/*!
+ * REVISIT: document me
+ */
+static int __init mxc_init_extuart(void)
+{
+	int value;
+	/*reset ext uart in cpld */
+	__raw_writew(PBC_BCTRL1_URST, PBC_BCTRL1_SET_REG);
+	/*delay some time for reset finish */
+	for (value = 0; value < 1000; value++) ;
+	__raw_writew(PBC_BCTRL1_URST, PBC_BCTRL1_CLEAR_REG);
+	return platform_device_register(&serial_device);
+}
+#else
+static inline int mxc_init_extuart(void)
+{
+	return 0;
+}
+#endif
+
+#if defined(CONFIG_MXC_PMIC_MC13783) && defined(CONFIG_SND_MXC_PMIC)
+extern void gpio_ssi_active(int ssi_num);
+
+static inline int mxc_init_pmic_audio(void)
+{
+	/* Assign CLK_26M to CLKO */
+	mxc_set_clock_output(CKO, CKIH_CLK, 1);
+	gpio_ssi_active(0);
+	gpio_ssi_active(1);
+	mxc_clks_enable(SSI1_BAUD);
+	mxc_clks_enable(SSI2_BAUD);
+	return 0;
+}
+#else
+static inline int mxc_init_pmic_audio(void)
+{
+	return 0;
+}
+#endif
+
+static void mxc_board_init(void)
+{
+	pr_info("AIPI VA base: 0x%x\n", IO_ADDRESS(AIPI_BASE_ADDR));
+	mxc_gpio_init();
+	mxc_expio_init();
+	mxc_init_keypad();
+	mxc_init_nor_mtd();
+	mxc_init_nand_mtd();
+	mxc_init_extuart();
+	mxc_init_pmic_audio();
+#ifdef MXC_CARD_DEBUG
+	request_irq(EXPIO_INT_SD1_EN, mxc_sd_test_handler, 0, "SD_card1", NULL);
+	request_irq(EXPIO_INT_SD2_EN, mxc_sd_test_handler, 0, "SD_card2", NULL);
+	request_irq(EXPIO_INT_SD3_EN, mxc_sd_test_handler, 0, "SD_card3", NULL);
+	request_irq(EXPIO_INT_MS_EN, mxc_sd_test_handler, 0, "MS_card", NULL);
+#endif
+
+	spi_register_board_info(mxc_spi_board_info,
+				ARRAY_SIZE(mxc_spi_board_info));
+
+	mxc_init_fb();
+}
+
+static void __init fixup_mxc_board(struct machine_desc *desc, struct tag *tags,
+				   char **cmdline, struct meminfo *mi)
+{
+#ifdef CONFIG_KGDB_8250
+	int i;
+	for (i = 0;
+	     i <
+	     (sizeof(serial_platform_data) / sizeof(serial_platform_data[0]));
+	     i += 1)
+		kgdb8250_add_platform_port(i, &serial_platform_data[i]);
+#endif
+
+	/* Store command line for use on mxc_board_init */
+	strcpy(command_line, *cmdline);
+
+#ifdef CONFIG_DISCONTIGMEM
+	do {
+		int nid;
+		mi->nr_banks = MXC_NUMNODES;
+		for (nid = 0; nid < mi->nr_banks; nid++) {
+			SET_NODE(mi, nid);
+		}
+	} while (0);
+#endif
+}
+
+EXPORT_SYMBOL(mxc_card_detected);
+EXPORT_SYMBOL(mxc_board_is_ads);
+
+/*
+ * The following uses standard kernel macros define in arch.h in order to
+ * initialize __mach_desc_MX27ADS data structure.
+ */
+/* *INDENT-OFF* */
+MACHINE_START(MX27ADS, "Freescale i.MX27ADS")
+	/* maintainer: Freescale Semiconductor, Inc. */
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	.phys_io        = CS4_BASE_ADDR,
+	.io_pg_offst    = ((CS4_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+#else
+	.phys_io        = AIPI_BASE_ADDR,
+	.io_pg_offst    = ((AIPI_BASE_ADDR_VIRT) >> 18) & 0xfffc,
+#endif
+	.boot_params    = PHYS_OFFSET_ASM + 0x100,
+	.fixup          = fixup_mxc_board,
+	.map_io         = mxc_map_io,
+	.init_irq       = mxc_init_irq,
+	.init_machine   = mxc_board_init,
+	.timer          = &mxc_timer,
+MACHINE_END
--- linux-2.6.19.2/arch/arm/mach-mx27/mx27ads_gpio.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/mx27ads_gpio.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,1174 @@
+/*
+ *  Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <asm/io.h>
+#include <asm/hardware.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/gpio.h>
+
+#include "gpio_mux.h"
+#include "crm_regs.h"
+
+static int g_uart_activated[MXC_UART_NR] = { 0, 0, 0, 0, 0, 0 };
+
+/*!
+ * @file mx27ads_gpio.c
+ * 
+ * @brief This file contains all the GPIO setup functions for the board. 
+ * 
+ * @ingroup GPIO
+ */
+
+/*!
+ * Setup GPIO for a UART port to be active
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_active(int port, int no_irda)
+{
+	if (port < 0 || port >= MXC_UART_NR) {
+		pr_info("Wrong port number: %d\n", port);
+		BUG();
+	}
+
+	if (g_uart_activated[port]) {
+		pr_info("UART %d has been activated multiple times\n", port + 1);
+		return;
+	}
+	g_uart_activated[port] = 1;
+
+	switch (port) {
+	case 0:
+		gpio_request_mux(MX27_PIN_UART1_TXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART1_RXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART1_CTS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART1_RTS, GPIO_MUX_PRIMARY);
+		break;
+	case 1:
+		gpio_request_mux(MX27_PIN_UART2_TXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART2_RXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART2_CTS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART2_RTS, GPIO_MUX_PRIMARY);
+		break;
+	case 2:
+		gpio_request_mux(MX27_PIN_UART3_TXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART3_RXD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART3_CTS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_UART3_RTS, GPIO_MUX_PRIMARY);
+
+		/* Enable IRDA in CPLD */
+		__raw_writew(PBC_BCTRL2_IRDA_EN, PBC_BCTRL2_CLEAR_REG);
+		break;
+	case 3:
+		gpio_request_mux(MX27_PIN_USBH1_TXDM, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_USBH1_RXDP, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_USBH1_TXDP, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_USBH1_FS, GPIO_MUX_ALT);
+		break;
+	case 4:
+		gpio_request_mux(MX27_PIN_CSI_D6, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_D7, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_VSYNC, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_HSYNC, GPIO_MUX_ALT);
+		break;
+	case 5:
+		gpio_request_mux(MX27_PIN_CSI_D0, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_D1, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_D2, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_CSI_D3, GPIO_MUX_ALT);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a UART port to be inactive
+ *
+ * @param  port         a UART port
+ * @param  no_irda      indicates if the port is used for SIR
+ */
+void gpio_uart_inactive(int port, int no_irda)
+{
+	if (port < 0 || port >= MXC_UART_NR) {
+		pr_info("Wrong port number: %d\n", port);
+		BUG();
+	}
+
+	if (g_uart_activated[port] == 0) {
+		pr_info("UART %d has not been activated \n", port + 1);
+		return;
+	}
+	g_uart_activated[port] = 0;
+
+	switch (port) {
+	case 0:
+		gpio_free_mux(MX27_PIN_UART1_TXD);
+		gpio_free_mux(MX27_PIN_UART1_RXD);
+		gpio_free_mux(MX27_PIN_UART1_CTS);
+		gpio_free_mux(MX27_PIN_UART1_RTS);
+		break;
+	case 1:
+		gpio_free_mux(MX27_PIN_UART2_TXD);
+		gpio_free_mux(MX27_PIN_UART2_RXD);
+		gpio_free_mux(MX27_PIN_UART2_CTS);
+		gpio_free_mux(MX27_PIN_UART2_RTS);
+		break;
+	case 2:
+		gpio_free_mux(MX27_PIN_UART3_TXD);
+		gpio_free_mux(MX27_PIN_UART3_RXD);
+		gpio_free_mux(MX27_PIN_UART3_CTS);
+		gpio_free_mux(MX27_PIN_UART3_RTS);
+
+		/* Disable IRDA in CPLD */
+		__raw_writew(PBC_BCTRL2_IRDA_EN, PBC_BCTRL2_SET_REG);
+		break;
+	case 3:
+		gpio_free_mux(MX27_PIN_USBH1_TXDM);
+		gpio_free_mux(MX27_PIN_USBH1_RXDP);
+		gpio_free_mux(MX27_PIN_USBH1_TXDP);
+		gpio_free_mux(MX27_PIN_USBH1_FS);
+		break;
+	case 4:
+		gpio_free_mux(MX27_PIN_CSI_D6);
+		gpio_free_mux(MX27_PIN_CSI_D7);
+		gpio_free_mux(MX27_PIN_CSI_VSYNC);
+		gpio_free_mux(MX27_PIN_CSI_HSYNC);
+		break;
+	case 5:
+		gpio_free_mux(MX27_PIN_CSI_D0);
+		gpio_free_mux(MX27_PIN_CSI_D1);
+		gpio_free_mux(MX27_PIN_CSI_D2);
+		gpio_free_mux(MX27_PIN_CSI_D3);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Configure the IOMUX GPR register to receive shared SDMA UART events
+ *
+ * @param  port         a UART port
+ */
+void config_uartdma_event(int port)
+{
+	return;
+}
+
+/*!
+ * Setup GPIO for USB, Total 34 signals
+ * PIN Configuration for USBOTG:   High/Full speed OTG
+ *	PE2,PE1,PE0,PE24,PE25 -- PRIMARY
+ 	PC7 - PC13  -- PRIMARY
+ 	PB23,PB24 -- PRIMARY
+ 
+  * PIN Configuration for USBH2:    : High/Full/Low speed host
+  *	PA0 - PA4 -- PRIMARY
+       PD19, PD20,PD21,PD22,PD23,PD24,PD26 --Alternate (SECONDARY)
+
+  * PIN Configuration for USBH1:  Full/low speed host
+  *  PB25 - PB31  -- PRIMARY
+      PB22  -- PRIMARY
+ */
+void gpio_usbh1_active(void)
+{
+	gpio_request_mux(MX27_PIN_USBH1_SUSP, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_RCV, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_FS, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_OE_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_TXDM, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_TXDP, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_RXDM, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH1_RXDP, GPIO_MUX_PRIMARY);
+}
+void gpio_usbh1_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_USBH1_SUSP);
+	gpio_free_mux(MX27_PIN_USBH1_RCV);
+	gpio_free_mux(MX27_PIN_USBH1_FS);
+	gpio_free_mux(MX27_PIN_USBH1_OE_B);
+	gpio_free_mux(MX27_PIN_USBH1_TXDM);
+	gpio_free_mux(MX27_PIN_USBH1_TXDP);
+	gpio_free_mux(MX27_PIN_USBH1_RXDM);
+	gpio_free_mux(MX27_PIN_USBH1_RXDP);
+}
+
+/*
+ * conflicts with CSPI1 (MC13783) and CSPI2 (Connector)
+ */
+void gpio_usbh2_active(void)
+{
+	gpio_set_puen(MX27_PIN_USBH2_CLK, 0);
+	gpio_set_puen(MX27_PIN_USBH2_DIR, 0);
+	gpio_set_puen(MX27_PIN_USBH2_DATA7, 0);
+	gpio_set_puen(MX27_PIN_USBH2_NXT, 0);
+	gpio_set_puen(MX27_PIN_USBH2_STP, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_SS2, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_SS1, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_SS0, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_SCLK, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_MISO, 0);
+	gpio_set_puen(MX27_PIN_CSPI2_MOSI, 0);
+	gpio_set_puen(MX27_PIN_CSPI1_SS2, 0);
+
+	gpio_request_mux(MX27_PIN_USBH2_CLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH2_DIR, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH2_DATA7, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH2_NXT, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBH2_STP, GPIO_MUX_PRIMARY);
+
+	gpio_request_mux(MX27_PIN_CSPI2_SS2, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_SS1, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_SS0, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_SCLK, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_MISO, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI2_MOSI, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_CSPI1_SS2, GPIO_MUX_ALT);
+}
+void gpio_usbh2_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_USBH2_CLK);
+	gpio_free_mux(MX27_PIN_USBH2_DIR);
+	gpio_free_mux(MX27_PIN_USBH2_DATA7);
+	gpio_free_mux(MX27_PIN_USBH2_NXT);
+	gpio_free_mux(MX27_PIN_USBH2_STP);
+
+	gpio_free_mux(MX27_PIN_CSPI2_SS2);
+	gpio_free_mux(MX27_PIN_CSPI2_SS1);
+	gpio_free_mux(MX27_PIN_CSPI2_SS0);
+	gpio_free_mux(MX27_PIN_CSPI2_SCLK);
+	gpio_free_mux(MX27_PIN_CSPI2_MISO);
+	gpio_free_mux(MX27_PIN_CSPI2_MOSI);
+	gpio_free_mux(MX27_PIN_CSPI1_SS2);
+
+	gpio_set_puen(MX27_PIN_USBH2_CLK, 1);
+	gpio_set_puen(MX27_PIN_USBH2_DIR, 1);
+	gpio_set_puen(MX27_PIN_USBH2_DATA7, 1);
+	gpio_set_puen(MX27_PIN_USBH2_NXT, 1);
+	gpio_set_puen(MX27_PIN_USBH2_STP, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_SS2, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_SS1, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_SS0, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_SCLK, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_MISO, 1);
+	gpio_set_puen(MX27_PIN_CSPI2_MOSI, 1);
+	gpio_set_puen(MX27_PIN_CSPI1_SS2, 1);
+}
+
+void gpio_usbotg_hs_active(void)
+{
+	gpio_request_mux(MX27_PIN_USBOTG_DATA5, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA6, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA0, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA2, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA1, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA3, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA4, GPIO_MUX_PRIMARY);
+
+	gpio_request_mux(MX27_PIN_USBOTG_DIR, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_STP, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_NXT, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_CLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USBOTG_DATA7, GPIO_MUX_PRIMARY);
+
+	gpio_request_mux(MX27_PIN_USB_OC_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_USB_PWR, GPIO_MUX_PRIMARY);
+}
+
+void gpio_usbotg_hs_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_USBOTG_DATA5);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA6);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA0);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA2);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA1);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA3);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA4);
+
+	gpio_free_mux(MX27_PIN_USBOTG_DIR);
+	gpio_free_mux(MX27_PIN_USBOTG_STP);
+	gpio_free_mux(MX27_PIN_USBOTG_NXT);
+	gpio_free_mux(MX27_PIN_USBOTG_CLK);
+	gpio_free_mux(MX27_PIN_USBOTG_DATA7);
+
+	gpio_free_mux(MX27_PIN_USB_OC_B);
+	gpio_free_mux(MX27_PIN_USB_PWR);
+}
+
+void gpio_usbotg_fs_active(void)
+{
+	return gpio_usbotg_hs_active();
+}
+
+void gpio_usbotg_fs_inactive(void)
+{
+	return gpio_usbotg_hs_inactive();
+}
+
+/*!
+ * end Setup GPIO for USB
+ * 
+ */
+
+/************************************************************************/
+/* for i2c gpio                                                         */
+/* I2C1:  PD17,PD18 -- Primary 					*/
+/* I2C2:  PC5,PC6    -- Primary					*/
+/************************************************************************/
+/*!
+* Setup GPIO for an I2C device to be active
+*
+* @param  i2c_num         an I2C device
+*/
+void gpio_i2c_active(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		gpio_request_mux(MX27_PIN_I2C_CLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_I2C_DATA, GPIO_MUX_PRIMARY);
+		break;
+	case 1:
+		gpio_request_mux(MX27_PIN_I2C2_SCL, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_I2C2_SDA, GPIO_MUX_PRIMARY);
+		break;
+	default:
+		printk("gpio_i2c_active no compatible I2C adapter\n");
+		break;
+	}
+}
+
+/*!
+ *  * Setup GPIO for an I2C device to be inactive
+ *   *
+ *    * @param  i2c_num         an I2C device
+ */
+void gpio_i2c_inactive(int i2c_num)
+{
+	switch (i2c_num) {
+	case 0:
+		gpio_free_mux(MX27_PIN_I2C_CLK);
+		gpio_free_mux(MX27_PIN_I2C_DATA);
+		break;
+	case 1:
+		gpio_free_mux(MX27_PIN_I2C2_SCL);
+		gpio_free_mux(MX27_PIN_I2C2_SDA);
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a CSPI device to be active
+ *
+ * @param  cspi_mod         an CSPI device
+ */
+void gpio_spi_active(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		gpio_request_mux(MX27_PIN_CSPI1_MOSI, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_MISO, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_SCLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_RDY, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_SS0, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_SS1, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI1_SS2, GPIO_MUX_PRIMARY);
+		break;
+	case 1:
+		/*SPI2  */
+		gpio_request_mux(MX27_PIN_CSPI2_MOSI, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_MISO, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_SCLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_SS0, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_SS1, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_CSPI2_SS2, GPIO_MUX_PRIMARY);
+		break;
+	case 2:
+		/*SPI3  */
+		gpio_request_mux(MX27_PIN_SD1_D0, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_SD1_CMD, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_SD1_CLK, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_SD1_D3, GPIO_MUX_ALT);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a CSPI device to be inactive
+ *
+ * @param  cspi_mod         a CSPI device
+ */
+void gpio_spi_inactive(int cspi_mod)
+{
+	switch (cspi_mod) {
+	case 0:
+		/* SPI1 */
+		gpio_free_mux(MX27_PIN_CSPI1_MOSI);
+		gpio_free_mux(MX27_PIN_CSPI1_MISO);
+		gpio_free_mux(MX27_PIN_CSPI1_SCLK);
+		gpio_free_mux(MX27_PIN_CSPI1_RDY);
+		gpio_free_mux(MX27_PIN_CSPI1_SS0);
+		gpio_free_mux(MX27_PIN_CSPI1_SS1);
+		gpio_free_mux(MX27_PIN_CSPI1_SS2);
+		break;
+	case 1:
+		/*SPI2  */
+		gpio_free_mux(MX27_PIN_CSPI2_MOSI);
+		gpio_free_mux(MX27_PIN_CSPI2_MISO);
+		gpio_free_mux(MX27_PIN_CSPI2_SCLK);
+		gpio_free_mux(MX27_PIN_CSPI2_SS0);
+		gpio_free_mux(MX27_PIN_CSPI2_SS1);
+		gpio_free_mux(MX27_PIN_CSPI2_SS2);
+		break;
+	case 2:
+		/*SPI3  */
+		gpio_free_mux(MX27_PIN_SD1_D0);
+		gpio_free_mux(MX27_PIN_SD1_CMD);
+		gpio_free_mux(MX27_PIN_SD1_CLK);
+		gpio_free_mux(MX27_PIN_SD1_D3);
+		break;
+
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for a nand flash device to be active
+ *
+ */
+void gpio_nand_active(void)
+{
+	unsigned long reg;
+	reg = __raw_readl(IO_ADDRESS(SYSCTRL_BASE_ADDR) + SYS_FMCR);
+	reg &= ~(1 << 4);
+	__raw_writel(reg, IO_ADDRESS(SYSCTRL_BASE_ADDR) + SYS_FMCR);
+
+	gpio_request_mux(MX27_PIN_NFRB, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFCE_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFWP_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFCLE, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFALE, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFRE_B, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_NFWE_B, GPIO_MUX_PRIMARY);
+}
+
+/*!
+ * Setup GPIO for a nand flash device to be inactive
+ *
+ */
+void gpio_nand_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_NFRB);
+	gpio_free_mux(MX27_PIN_NFCE_B);
+	gpio_free_mux(MX27_PIN_NFWP_B);
+	gpio_free_mux(MX27_PIN_NFCLE);
+	gpio_free_mux(MX27_PIN_NFALE);
+	gpio_free_mux(MX27_PIN_NFRE_B);
+	gpio_free_mux(MX27_PIN_NFWE_B);
+}
+
+/*!
+ * Setup GPIO for CSI device to be active
+ *
+ */
+void gpio_sensor_active(void)
+{
+	gpio_request_mux(MX27_PIN_CSI_D0, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D1, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D2, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D3, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D4, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_MCLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_PIXCLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D5, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D6, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_D7, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_VSYNC, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CSI_HSYNC, GPIO_MUX_PRIMARY);
+
+	__raw_writew(0x400, PBC_BCTRL2_SET_REG);
+}
+
+void gpio_sensor_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_CSI_D0);
+	gpio_free_mux(MX27_PIN_CSI_D1);
+	gpio_free_mux(MX27_PIN_CSI_D2);
+	gpio_free_mux(MX27_PIN_CSI_D3);
+	gpio_free_mux(MX27_PIN_CSI_D4);
+	gpio_free_mux(MX27_PIN_CSI_MCLK);
+	gpio_free_mux(MX27_PIN_CSI_PIXCLK);
+	gpio_free_mux(MX27_PIN_CSI_D5);
+	gpio_free_mux(MX27_PIN_CSI_D6);
+	gpio_free_mux(MX27_PIN_CSI_D7);
+	gpio_free_mux(MX27_PIN_CSI_VSYNC);
+	gpio_free_mux(MX27_PIN_CSI_HSYNC);
+
+	__raw_writew(0x400, PBC_BCTRL2_CLEAR_REG);
+}
+
+/*!
+ * Setup GPIO for LCDC device to be active
+ *
+ */
+void gpio_lcdc_active(void)
+{
+	gpio_request_mux(MX27_PIN_LSCLK, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD0, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD1, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD2, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD3, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD4, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD5, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD6, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD7, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD8, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD9, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD10, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD11, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD12, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD13, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD14, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD15, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD16, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_LD17, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_REV, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CLS, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_PS, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_SPL_SPR, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_HSYNC, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_VSYNC, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_CONTRAST, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_OE_ACD, GPIO_MUX_PRIMARY);
+}
+
+/*!
+ * Setup GPIO for LCDC device to be inactive
+ *
+ */
+void gpio_lcdc_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_LSCLK);
+	gpio_free_mux(MX27_PIN_LD0);
+	gpio_free_mux(MX27_PIN_LD1);
+	gpio_free_mux(MX27_PIN_LD2);
+	gpio_free_mux(MX27_PIN_LD3);
+	gpio_free_mux(MX27_PIN_LD4);
+	gpio_free_mux(MX27_PIN_LD5);
+	gpio_free_mux(MX27_PIN_LD6);
+	gpio_free_mux(MX27_PIN_LD7);
+	gpio_free_mux(MX27_PIN_LD8);
+	gpio_free_mux(MX27_PIN_LD9);
+	gpio_free_mux(MX27_PIN_LD10);
+	gpio_free_mux(MX27_PIN_LD11);
+	gpio_free_mux(MX27_PIN_LD12);
+	gpio_free_mux(MX27_PIN_LD13);
+	gpio_free_mux(MX27_PIN_LD14);
+	gpio_free_mux(MX27_PIN_LD15);
+	gpio_free_mux(MX27_PIN_LD16);
+	gpio_free_mux(MX27_PIN_LD17);
+	gpio_free_mux(MX27_PIN_REV);
+	gpio_free_mux(MX27_PIN_CLS);
+	gpio_free_mux(MX27_PIN_PS);
+	gpio_free_mux(MX27_PIN_SPL_SPR);
+	gpio_free_mux(MX27_PIN_HSYNC);
+	gpio_free_mux(MX27_PIN_VSYNC);
+	gpio_free_mux(MX27_PIN_CONTRAST);
+	gpio_free_mux(MX27_PIN_OE_ACD);
+}
+
+/*!
+ * Setup GPIO PA25 low to start hard reset FS453 TV encoder
+ *
+ */
+void gpio_fs453_reset_low(void)
+{
+	gpio_free_mux(MX27_PIN_CLS);
+	if (gpio_request_mux(MX27_PIN_CLS, GPIO_MUX_GPIO)) {
+		printk("bug: request GPIO PA25 failed.\n");
+		return;
+	}
+
+	/* PA25 (CLS) as output */
+	mxc_set_gpio_direction(MX27_PIN_CLS, 0);
+	gpio_config_mux(MX27_PIN_CLS, GPIO_MUX_GPIO);
+	mxc_set_gpio_dataout(MX27_PIN_CLS, 0);
+}
+
+/*!
+ * Setup GPIO PA25 high to end hard reset FS453 TV encoder
+ *
+ */
+void gpio_fs453_reset_high(void)
+{
+	gpio_free_mux(MX27_PIN_CLS);
+	if (gpio_request_mux(MX27_PIN_CLS, GPIO_MUX_GPIO)) {
+		printk("bug: request GPIO PA25 failed.\n");
+		return;
+	}
+
+	/* PA25 (CLS) as output */
+	mxc_set_gpio_direction(MX27_PIN_CLS, 0);
+	gpio_config_mux(MX27_PIN_CLS, GPIO_MUX_GPIO);
+	mxc_set_gpio_dataout(MX27_PIN_CLS, 1);
+}
+
+/*!
+ * This function configures the IOMux block for PMIC standard operations.
+ *
+ */
+void gpio_pmic_active(void)
+{
+	gpio_config_mux(MX27_PIN_TOUT, GPIO_MUX_GPIO);
+	mxc_set_gpio_direction(MX27_PIN_TOUT, 1);
+}
+
+/*!
+ * GPIO settings not required for keypad 
+ *
+ */
+void gpio_keypad_active(void)
+{
+}
+
+/*!
+ * GPIO settings not required for keypad 
+ *
+ */
+void gpio_keypad_inactive(void)
+{
+}
+
+/*!
+ * Setup GPIO for ATA device to be active
+ *
+ */
+void gpio_ata_active(void)
+{
+	gpio_request_mux(MX27_PIN_ATA_DATA0, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA1, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA2, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA3, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA4, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA5, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA6, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA7, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA8, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA9, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA10, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA11, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA12, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA13, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA14, GPIO_MUX_PRIMARY);
+	gpio_request_mux(MX27_PIN_ATA_DATA15, GPIO_MUX_PRIMARY);
+
+	gpio_request_mux(MX27_PIN_PC_CD1_B, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_CD2_B, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_WAIT_B, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_READY, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_PWRON, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_VS1, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_VS2, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_BVD1, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_BVD2, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_RST, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_IOIS16, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_RW_B, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_PC_POE, GPIO_MUX_ALT);
+
+	printk("ATA interface call clock enable ATA CLK \n");
+	mxc_clks_enable(ATA_CLK);
+}
+
+/*!
+ * Setup GPIO for ATA device to be inactive
+ *
+ */
+void gpio_ata_inactive(void)
+{
+	printk("ATA interface call clock disable ATA CLK \n");
+	mxc_clks_disable(ATA_CLK);
+
+	gpio_free_mux(MX27_PIN_ATA_DATA0);
+	gpio_free_mux(MX27_PIN_ATA_DATA1);
+	gpio_free_mux(MX27_PIN_ATA_DATA2);
+	gpio_free_mux(MX27_PIN_ATA_DATA3);
+	gpio_free_mux(MX27_PIN_ATA_DATA4);
+	gpio_free_mux(MX27_PIN_ATA_DATA5);
+	gpio_free_mux(MX27_PIN_ATA_DATA6);
+	gpio_free_mux(MX27_PIN_ATA_DATA7);
+	gpio_free_mux(MX27_PIN_ATA_DATA8);
+	gpio_free_mux(MX27_PIN_ATA_DATA9);
+	gpio_free_mux(MX27_PIN_ATA_DATA10);
+	gpio_free_mux(MX27_PIN_ATA_DATA11);
+	gpio_free_mux(MX27_PIN_ATA_DATA12);
+	gpio_free_mux(MX27_PIN_ATA_DATA13);
+	gpio_free_mux(MX27_PIN_ATA_DATA14);
+	gpio_free_mux(MX27_PIN_ATA_DATA15);
+
+	gpio_free_mux(MX27_PIN_PC_CD1_B);
+	gpio_free_mux(MX27_PIN_PC_CD2_B);
+	gpio_free_mux(MX27_PIN_PC_WAIT_B);
+	gpio_free_mux(MX27_PIN_PC_READY);
+	gpio_free_mux(MX27_PIN_PC_PWRON);
+	gpio_free_mux(MX27_PIN_PC_VS1);
+	gpio_free_mux(MX27_PIN_PC_VS2);
+	gpio_free_mux(MX27_PIN_PC_BVD1);
+	gpio_free_mux(MX27_PIN_PC_BVD2);
+	gpio_free_mux(MX27_PIN_PC_RST);
+	gpio_free_mux(MX27_PIN_IOIS16);
+	gpio_free_mux(MX27_PIN_PC_RW_B);
+	gpio_free_mux(MX27_PIN_PC_POE);
+}
+
+/*!
+ * Setup GPIO for FEC device to be active
+ *
+ */
+void gpio_fec_active(void)
+{
+	gpio_request_mux(MX27_PIN_ATA_DATA15, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA15, 0);
+	gpio_request_mux(MX27_PIN_ATA_DATA14, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA14, 0);
+	gpio_request_mux(MX27_PIN_ATA_DATA13, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA13, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA12, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA12, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA11, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA11, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA10, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA10, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA9, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA9, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA8, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA8, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA7, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA7, 0);
+
+	gpio_request_mux(MX27_PIN_ATA_DATA6, GPIO_MUX_ALT);
+	gpio_request_mux(MX27_PIN_ATA_DATA5, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA5, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA4, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA4, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA3, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA3, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA2, GPIO_MUX_INPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA2, 1);
+	gpio_request_mux(MX27_PIN_ATA_DATA1, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA1, 0);
+	gpio_request_mux(MX27_PIN_ATA_DATA0, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_ATA_DATA0, 0);
+	gpio_request_mux(MX27_PIN_SD3_CLK, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_SD3_CLK, 0);
+	gpio_request_mux(MX27_PIN_SD3_CMD, GPIO_MUX_OUTPUT1);
+	mxc_set_gpio_direction(MX27_PIN_SD3_CMD, 0);
+
+	__raw_writew(PBC_BCTRL2_ATAFEC_EN, PBC_BCTRL2_CLEAR_REG);
+	__raw_writew(PBC_BCTRL2_ATAFEC_SEL, PBC_BCTRL2_SET_REG);
+}
+
+/*!
+ * Setup GPIO for FEC device to be inactive
+ *
+ */
+void gpio_fec_inactive(void)
+{
+	gpio_free_mux(MX27_PIN_ATA_DATA0);
+	gpio_free_mux(MX27_PIN_ATA_DATA1);
+	gpio_free_mux(MX27_PIN_ATA_DATA2);
+	gpio_free_mux(MX27_PIN_ATA_DATA3);
+	gpio_free_mux(MX27_PIN_ATA_DATA4);
+	gpio_free_mux(MX27_PIN_ATA_DATA5);
+	gpio_free_mux(MX27_PIN_ATA_DATA6);
+	gpio_free_mux(MX27_PIN_ATA_DATA7);
+	gpio_free_mux(MX27_PIN_ATA_DATA8);
+	gpio_free_mux(MX27_PIN_ATA_DATA9);
+	gpio_free_mux(MX27_PIN_ATA_DATA10);
+	gpio_free_mux(MX27_PIN_ATA_DATA11);
+	gpio_free_mux(MX27_PIN_ATA_DATA12);
+	gpio_free_mux(MX27_PIN_ATA_DATA13);
+	gpio_free_mux(MX27_PIN_ATA_DATA14);
+	gpio_free_mux(MX27_PIN_ATA_DATA15);
+
+	gpio_free_mux(MX27_PIN_SD3_CMD);
+	gpio_free_mux(MX27_PIN_SD3_CLK);
+}
+
+/*!
+ * Setup GPIO for SLCDC device to be active
+ *
+ */
+void gpio_slcdc_active(int type)
+{
+	switch (type) {
+	case 0:
+		gpio_request_mux(MX27_PIN_SSI3_CLK, GPIO_MUX_ALT);	/* CLK */
+		gpio_request_mux(MX27_PIN_SSI3_TXDAT, GPIO_MUX_ALT);	/* CS  */
+		gpio_request_mux(MX27_PIN_SSI3_RXDAT, GPIO_MUX_ALT);	/* RS  */
+		gpio_request_mux(MX27_PIN_SSI3_FS, GPIO_MUX_ALT);	/* D0  */
+		break;
+
+	case 1:
+		gpio_request_mux(MX27_PIN_SD2_D1, GPIO_MUX_GPIO);	/* CLK */
+		gpio_request_mux(MX27_PIN_SD2_D2, GPIO_MUX_GPIO);	/* D0  */
+		gpio_request_mux(MX27_PIN_SD2_D3, GPIO_MUX_GPIO);	/* RS  */
+		gpio_request_mux(MX27_PIN_SD2_CMD, GPIO_MUX_GPIO);	/* CS  */
+		break;
+
+	case 2:
+		gpio_request_mux(MX27_PIN_LD0, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD1, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD2, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD3, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD4, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD5, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD6, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD7, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD8, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD9, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD10, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD11, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD12, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD13, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD14, GPIO_MUX_GPIO);
+		gpio_request_mux(MX27_PIN_LD15, GPIO_MUX_GPIO);
+		break;
+
+	default:
+		break;
+	}
+
+	return;
+}
+
+/*!
+ * Setup GPIO for SLCDC device to be inactive
+ *
+ */
+void gpio_slcdc_inactive(int type)
+{
+	switch (type) {
+	case 0:
+		gpio_free_mux(MX27_PIN_SSI3_CLK);	/* CLK */
+		gpio_free_mux(MX27_PIN_SSI3_TXDAT);	/* CS  */
+		gpio_free_mux(MX27_PIN_SSI3_RXDAT);	/* RS  */
+		gpio_free_mux(MX27_PIN_SSI3_FS);	/* D0  */
+		break;
+
+	case 1:
+		gpio_free_mux(MX27_PIN_SD2_D1);	/* CLK */
+		gpio_free_mux(MX27_PIN_SD2_D2);	/* D0  */
+		gpio_free_mux(MX27_PIN_SD2_D3);	/* RS  */
+		gpio_free_mux(MX27_PIN_SD2_CMD);	/* CS  */
+		break;
+
+	case 2:
+		gpio_free_mux(MX27_PIN_LD0);
+		gpio_free_mux(MX27_PIN_LD1);
+		gpio_free_mux(MX27_PIN_LD2);
+		gpio_free_mux(MX27_PIN_LD3);
+		gpio_free_mux(MX27_PIN_LD4);
+		gpio_free_mux(MX27_PIN_LD5);
+		gpio_free_mux(MX27_PIN_LD6);
+		gpio_free_mux(MX27_PIN_LD7);
+		gpio_free_mux(MX27_PIN_LD8);
+		gpio_free_mux(MX27_PIN_LD9);
+		gpio_free_mux(MX27_PIN_LD10);
+		gpio_free_mux(MX27_PIN_LD11);
+		gpio_free_mux(MX27_PIN_LD12);
+		gpio_free_mux(MX27_PIN_LD13);
+		gpio_free_mux(MX27_PIN_LD14);
+		gpio_free_mux(MX27_PIN_LD15);
+		break;
+
+	default:
+		break;
+	}
+
+	return;
+}
+
+void gpio_ssi_active(int ssi_num)
+{
+	switch (ssi_num) {
+	case 0:
+		gpio_request_mux(MX27_PIN_SSI1_FS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI1_RXDAT, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI1_TXDAT, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI1_CLK, GPIO_MUX_PRIMARY);
+		gpio_set_puen(MX27_PIN_SSI1_FS, 0);
+		gpio_set_puen(MX27_PIN_SSI1_RXDAT, 0);
+		gpio_set_puen(MX27_PIN_SSI1_TXDAT, 0);
+		gpio_set_puen(MX27_PIN_SSI1_CLK, 0);
+		break;
+	case 1:
+		gpio_request_mux(MX27_PIN_SSI2_FS, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI2_RXDAT, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI2_TXDAT, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SSI2_CLK, GPIO_MUX_PRIMARY);
+		gpio_set_puen(MX27_PIN_SSI2_FS, 0);
+		gpio_set_puen(MX27_PIN_SSI2_RXDAT, 0);
+		gpio_set_puen(MX27_PIN_SSI2_TXDAT, 0);
+		gpio_set_puen(MX27_PIN_SSI2_CLK, 0);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+/*!
+ *  * Setup GPIO for a SSI port to be inactive
+ *   *
+ *    * @param  ssi_num         an SSI port num
+ */
+
+void gpio_ssi_inactive(int ssi_num)
+{
+	switch (ssi_num) {
+	case 0:
+		gpio_free_mux(MX27_PIN_SSI1_FS);
+		gpio_free_mux(MX27_PIN_SSI1_RXDAT);
+		gpio_free_mux(MX27_PIN_SSI1_TXDAT);
+		gpio_free_mux(MX27_PIN_SSI1_CLK);
+		break;
+	case 1:
+		gpio_free_mux(MX27_PIN_SSI2_FS);
+		gpio_free_mux(MX27_PIN_SSI2_RXDAT);
+		gpio_free_mux(MX27_PIN_SSI2_TXDAT);
+		gpio_free_mux(MX27_PIN_SSI2_CLK);
+		break;
+	default:
+		break;
+	}
+	return;
+}
+
+/*!
+ * Setup GPIO for SDHC to be active
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_active(int module)
+{
+	u16 data;
+	switch (module) {
+	case 0:
+		gpio_request_mux(MX27_PIN_SD1_CLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_CMD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_D0, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_D1, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_D2, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD1_D3, GPIO_MUX_PRIMARY);
+		/* 22k pull up for sd1 dat3 pins */
+		data = __raw_readw(IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x54));
+		data |= 0x0c;
+		__raw_writew(data, IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x54));
+		/*mxc_clks_enable(SDHC1_CLK);
+		   mxc_clks_enable(PERCLK2); */
+		break;
+	case 1:
+		gpio_request_mux(MX27_PIN_SD2_CLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_CMD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_D0, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_D1, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_D2, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD2_D3, GPIO_MUX_PRIMARY);
+		/* 22k pull up for sd2 pins */
+		data = __raw_readw(IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x54));
+		data &= ~0xfff0;
+		data |= 0xfff0;
+		__raw_writew(data, IO_ADDRESS(SYSCTRL_BASE_ADDR + 0x54));
+		/*mxc_clks_enable(SDHC2_CLK);
+		   mxc_clks_enable(PERCLK2); */
+		break;
+	case 2:
+		gpio_request_mux(MX27_PIN_SD3_CLK, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_SD3_CMD, GPIO_MUX_PRIMARY);
+		gpio_request_mux(MX27_PIN_ATA_DATA0, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_ATA_DATA1, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_ATA_DATA2, GPIO_MUX_ALT);
+		gpio_request_mux(MX27_PIN_ATA_DATA3, GPIO_MUX_ALT);
+		/*mxc_clks_enable(SDHC3_CLK);
+		   mxc_clks_enable(PERCLK2); */
+		break;
+	default:
+		break;
+	}
+}
+
+/*!
+ * Setup GPIO for SDHC1 to be inactive
+ *
+ * @param module SDHC module number
+ */
+void gpio_sdhc_inactive(int module)
+{
+	switch (module) {
+	case 0:
+		gpio_free_mux(MX27_PIN_SD1_CLK);
+		gpio_free_mux(MX27_PIN_SD1_CMD);
+		gpio_free_mux(MX27_PIN_SD1_D0);
+		gpio_free_mux(MX27_PIN_SD1_D1);
+		gpio_free_mux(MX27_PIN_SD1_D2);
+		gpio_free_mux(MX27_PIN_SD1_D3);
+		/*mxc_clks_disable(SDHC1_CLK); */
+		break;
+	case 1:
+		gpio_free_mux(MX27_PIN_SD2_CLK);
+		gpio_free_mux(MX27_PIN_SD2_CMD);
+		gpio_free_mux(MX27_PIN_SD2_D0);
+		gpio_free_mux(MX27_PIN_SD2_D1);
+		gpio_free_mux(MX27_PIN_SD2_D2);
+		gpio_free_mux(MX27_PIN_SD2_D3);
+		/*mxc_clks_disable(SDHC2_CLK); */
+		break;
+	case 2:
+		gpio_free_mux(MX27_PIN_SD3_CLK);
+		gpio_free_mux(MX27_PIN_SD3_CMD);
+		gpio_free_mux(MX27_PIN_ATA_DATA0);
+		gpio_free_mux(MX27_PIN_ATA_DATA1);
+		gpio_free_mux(MX27_PIN_ATA_DATA2);
+		gpio_free_mux(MX27_PIN_ATA_DATA3);
+		/*mxc_clks_disable(SDHC3_CLK); */
+		break;
+	default:
+		break;
+	}
+}
+
+/*
+ * Probe for the card. If present the GPIO data would be set.
+ */
+int sdhc_get_card_det_status(struct device *dev)
+{
+	return 0;
+}
+
+/*
+ * Return the card detect pin.
+ */
+int sdhc_init_card_det(int id)
+{
+	int ret = 0;
+	switch (id) {
+	case 0:
+		ret = EXPIO_INT_SD1_EN;
+		break;
+	case 1:
+		ret = EXPIO_INT_SD2_EN;
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+	return ret;
+}
+
+/*
+ * Power on/off Sharp QVGA panel.
+ */
+void board_power_lcd(int on)
+{
+	if (on)
+		__raw_writew(PBC_BCTRL1_LCDON, PBC_BCTRL1_SET_REG);
+	else
+		__raw_writew(PBC_BCTRL1_LCDON, PBC_BCTRL1_CLEAR_REG);
+}
+
+void gpio_owire_active(void)
+{
+	gpio_request_mux(MX27_PIN_RTCK, GPIO_MUX_ALT);
+}
+
+void gpio_owire_inactive(void)
+{
+	gpio_request_mux(MX27_PIN_RTCK, GPIO_MUX_PRIMARY);
+}
+
+void gpio_irda_active(void)
+{
+	gpio_uart_active(2, 0);
+	mxc_clks_enable(UART2_BAUD);
+	/* Band width select */
+	//__raw_writew(PBC_BCTRL2_IRDA_SD, PBC_BCTRL2_SET_REG);
+}
+
+void gpio_irda_inactive(void)
+{
+	mxc_clks_disable(UART2_BAUD);
+	gpio_uart_inactive(2, 0);
+}
+
+unsigned int irda_get_clocks(void)
+{
+	return mxc_get_clocks(UART2_BAUD);
+}
+
+EXPORT_SYMBOL(gpio_uart_active);
+EXPORT_SYMBOL(gpio_uart_inactive);
+EXPORT_SYMBOL(config_uartdma_event);
+EXPORT_SYMBOL(gpio_usbh1_active);
+EXPORT_SYMBOL(gpio_usbh1_inactive);
+EXPORT_SYMBOL(gpio_usbh2_active);
+EXPORT_SYMBOL(gpio_usbh2_inactive);
+EXPORT_SYMBOL(gpio_usbotg_hs_active);
+EXPORT_SYMBOL(gpio_usbotg_hs_inactive);
+EXPORT_SYMBOL(gpio_usbotg_fs_active);
+EXPORT_SYMBOL(gpio_usbotg_fs_inactive);
+EXPORT_SYMBOL(gpio_i2c_active);
+EXPORT_SYMBOL(gpio_i2c_inactive);
+EXPORT_SYMBOL(gpio_spi_active);
+EXPORT_SYMBOL(gpio_spi_inactive);
+EXPORT_SYMBOL(gpio_nand_active);
+EXPORT_SYMBOL(gpio_nand_inactive);
+EXPORT_SYMBOL(gpio_sensor_active);
+EXPORT_SYMBOL(gpio_sensor_inactive);
+EXPORT_SYMBOL(gpio_lcdc_active);
+EXPORT_SYMBOL(gpio_lcdc_inactive);
+EXPORT_SYMBOL(gpio_fs453_reset_low);
+EXPORT_SYMBOL(gpio_fs453_reset_high);
+EXPORT_SYMBOL(gpio_pmic_active);
+EXPORT_SYMBOL(gpio_keypad_active);
+EXPORT_SYMBOL(gpio_keypad_inactive);
+EXPORT_SYMBOL(gpio_ata_active);
+EXPORT_SYMBOL(gpio_ata_inactive);
+EXPORT_SYMBOL(gpio_fec_active);
+EXPORT_SYMBOL(gpio_fec_inactive);
+EXPORT_SYMBOL(gpio_slcdc_active);
+EXPORT_SYMBOL(gpio_slcdc_inactive);
+EXPORT_SYMBOL(gpio_ssi_active);
+EXPORT_SYMBOL(gpio_ssi_inactive);
+EXPORT_SYMBOL(gpio_sdhc_active);
+EXPORT_SYMBOL(gpio_sdhc_inactive);
+EXPORT_SYMBOL(sdhc_get_card_det_status);
+EXPORT_SYMBOL(sdhc_init_card_det);
+EXPORT_SYMBOL(board_power_lcd);
+EXPORT_SYMBOL(gpio_owire_active);
+EXPORT_SYMBOL(gpio_owire_inactive);
+EXPORT_SYMBOL(gpio_irda_active);
+EXPORT_SYMBOL(gpio_irda_inactive);
+EXPORT_SYMBOL(irda_get_clocks);
+
--- linux-2.6.19.2/arch/arm/mach-mx27/mxc_pm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/mxc_pm.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,522 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ * @file mxc_pm.c
+ *
+ * @brief This file contains the implementation of the Low-level power
+ * management driver. It modifies the registers of the PLL and clock module
+ * of the i.MX27.
+ *
+ * @ingroup LPMD
+ */
+
+/*
+ * Include Files
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <asm/arch/mxc_pm.h>
+#include <asm/arch/mxc.h>
+#include <asm/arch/system.h>
+#include <asm/arch/clock.h>
+#include <asm/irq.h>
+#include "crm_regs.h"
+
+/* Local defines */
+#define MAX_ARM_FREQ        400000000
+#define MAX_AHB_FREQ        133000000
+#define MAX_IPG_FREQ        66500000
+#define FREQ_COMP_TOLERANCE      100	/* tolerance percentage times 100 */
+#define MX27_LLPM_DEBUG	    0
+/*
+ * CKO pins configuration
+ */
+#define CLKO_CLK32              0
+#define CLKO_PREMCLK            1
+#define CLKO_CLK26M             2
+#define CLKO_MPLLREF            3
+#define CLKO_SPLLREF            4
+#define CLKO_MPLLCLK            5
+#define CLKO_SPLLCLK            6
+#define CLKO_FCLK               7
+#define CLKO_HCLK               8
+#define CLKO_IPGCLK             9
+#define CLKO_PERCLK1            10
+#define CLKO_PERCLK2            11
+#define CLKO_PERCLK3            12
+#define CLKO_PERCLK4            13
+#define CLKO_SSI1BAUD           14
+#define CLKO_SSI2BAUD           15
+#define CLKO_NFCBAUD            16
+#define CLKO_MSHCBAUD           17
+#define CLKO_VPUBAUD           18
+#define CLKO_CLK60M_ALWAYS      19
+#define CLKO_CLK32K_ALWAYS      20
+#define CLKO_CLK60M             21
+#define CLKO_CLKDPTC            22
+
+#define CLKO_MAX                23
+
+/*
+ * Global variables
+ */
+
+/*!
+ * These variables hold the various clock values when the module is loaded.
+ * This is needed because these clocks are derived from MPLL and when MPLL
+ * output changes, these clocks need to be adjusted.
+ */
+static u32 perclk1, perclk2, perclk3, perclk4, nfcclk, cpuclk;
+
+/*!
+ * Compare two frequences using allowable tolerance
+ *
+ * The MX27 PLL can generate many frequencies. This function
+ * compares the generated frequency to the requested frequency
+ * and determines it they are within and acceptable tolerance.
+ *
+ * @param   freq1  desired frequency
+ * @param   freq2  generated frequency
+ *
+ * @return       Returns 0 is frequencies are within talerance
+ *               and non-zero is they are not.
+ */
+static s32 freq_equal(u32 freq1, u32 freq2)
+{
+	if (freq1 > freq2) {
+		return (freq1 - freq2) <= (freq1 / FREQ_COMP_TOLERANCE);
+	}
+	return (freq2 - freq1) <= (freq1 / FREQ_COMP_TOLERANCE);
+}
+
+/*!
+ * Select the PLL frequency based on the desired ARM frequency.
+ *
+ * The MPLL will be configured to output three frequencies, 400/333/266 MHz.
+ *
+ * @param       armfreq         Desired ARM frequency
+ *
+ * @return      Returns one of the selected PLL frequency (400/333/266 MHz).
+ *              Returns -1 on error.
+ *
+ */
+static s32 select_freq_pll(u32 armfreq)
+{
+	u32 div;
+
+	div = 266000000 / armfreq;
+	if ((div == 0) || (!freq_equal(armfreq, 266000000 / div))) {
+		div = 400000000 / armfreq;
+		if ((div == 0) || (!freq_equal(armfreq, 400000000 / div))) {
+			return -1;
+		}
+
+		return 400000000;
+	}
+
+	return 266000000;
+}
+
+/*!
+ * Check whether the desired ARM and AHB frequencies are valid.
+ *
+ * @param       armfreq         Desired ARM frequency
+ * @param       ahbfreq         Desired AHB frequency
+ *
+ * @return      Returns 0 on success
+ *              Return -1 on error
+ */
+static s32 mx27_pm_check_parameters(u32 armfreq, u32 ahbfreq)
+{
+	u32 ahbdiv;
+
+	/* No idea about minimum frequencies.. just a guess! */
+	if ((armfreq < 1000000) || (ahbfreq < 1000000)) {
+		printk("arm or ahb frequencies are less\n");
+		return -1;
+	}
+
+	if ((armfreq > MAX_ARM_FREQ) || (ahbfreq > MAX_AHB_FREQ)) {
+		printk("arm or ahb freq. are too much\n");
+		return -1;
+	}
+
+	/* AHB divider value is restricted to less than 8 */
+	ahbdiv = armfreq / ahbfreq;
+	if ((ahbdiv == 0) || (ahbdiv > 8)) {
+		printk("Invalid ahb frequency\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+/*!
+ * Integer clock scaling
+ *
+ * Change the main ARM clock frequencies without changing the MPLL.
+ * The integer dividers (PRESC and BCLKDIV) are changed to obtain the
+ * desired frequency. Since NFC clock is derived from ARM frequency,
+ * NFCDIV is also adjusted.
+ *
+ * @param       arm_freq        Desired ARM frequency
+ * @param       ahb_freq        Desired AHB frequency
+ * @param       pll_freq        Current PLL frequency
+ *
+ * @return      Returns 0
+ */
+static s32 mx27_pm_intscale(u32 arm_freq, u32 ahb_freq, s32 pll_freq)
+{
+	u32 pre_div, bclk_div, nfc_div;
+
+	/* Calculate ARM divider */
+	pre_div = pll_freq / arm_freq;
+	if (pre_div == 0)
+		pre_div = 1;
+
+	/* Calculate AHB divider */
+	bclk_div = arm_freq / ahb_freq;
+	if (bclk_div == 0)
+		bclk_div = 1;
+
+	if ((arm_freq / bclk_div) > ahb_freq)
+		bclk_div++;
+
+	/* NFC clock is dependent on ARM clock */
+	nfc_div = arm_freq / nfcclk;
+	if ((arm_freq / nfc_div) > nfcclk)
+		nfc_div++;
+
+	/* Adjust NFC divider */
+	mxc_set_clocks_div(NFC_CLK, nfc_div);
+
+#if MX27_LLPM_DEBUG
+	printk("DIVIDERS: PreDiv = %d BCLKDIV = %d \n", pre_div, bclk_div);
+	printk("Integer scaling\n");
+	printk("PLL = %d : ARM = %d: AHB = %d\n", pll_freq, arm_freq, ahb_freq);
+#endif
+
+	/*
+	 * This part is tricky. What to adjust first (PRESC or BCLKDIV)?
+	 * After trial and error, if current ARM frequency is greater than
+	 * desired ARM frequency, then adjust PRESC first, else if current
+	 * ARM frequency is less than desired ARM frequency, then adjust
+	 * BCLKDIV first.
+	 */
+	if (cpuclk > arm_freq) {
+		mxc_set_clocks_div(CPU_CLK, pre_div);
+		mxc_set_clocks_div(AHB_CLK, bclk_div);
+	} else {
+		mxc_set_clocks_div(AHB_CLK, bclk_div);
+		mxc_set_clocks_div(CPU_CLK, pre_div);
+	}
+
+	cpuclk = arm_freq;
+	mdelay(50);
+	return 0;
+}
+
+/*!
+ * Set dividers for various peripheral clocks.
+ *
+ * PERCLK1, PERCLK2, PERCLK3 and PERCLK4 are adjusted based on the MPLL
+ * output frequency.
+ *
+ * @param       pll_freq        Desired MPLL output frequency
+ */
+static void mx27_set_dividers(u32 pll_freq)
+{
+	s32 perdiv1, perdiv2, perdiv3, perdiv4;
+
+	perdiv1 = pll_freq / perclk1;
+	if ((pll_freq / perdiv1) > perclk1)
+		perdiv1++;
+
+	perdiv2 = pll_freq / perclk2;
+	if ((pll_freq / perdiv2) > perclk2)
+		perdiv2++;
+
+	perdiv3 = pll_freq / perclk3;
+	if ((pll_freq / perdiv3) > perclk3)
+		perdiv3++;
+
+	perdiv4 = pll_freq / perclk4;
+	if ((pll_freq / perdiv4) > perclk4)
+		perdiv4++;
+
+	mxc_set_clocks_div(PERCLK1, perdiv1);
+	mxc_set_clocks_div(PERCLK2, perdiv2);
+	mxc_set_clocks_div(PERCLK3, perdiv3);
+	mxc_set_clocks_div(PERCLK4, perdiv4);
+}
+
+/*!
+ * Change MPLL output frequency and adjust derived clocks to produce the
+ * desired frequencies.
+ *
+ * @param       arm_freq        Desired ARM frequency
+ * @param       ahb_freq        Desired AHB frequency
+ * @param       org_pll         Current PLL frequency
+ *
+ * @return      Returns 0 on success
+ *              Returns -1 on error
+ */
+static s32 mx27_pm_pllscale(u32 arm_freq, u32 ahb_freq, s32 org_pll)
+{
+	u32 mfi, mfn, mfd, pd = 1, cscr;
+	s32 pll_freq;
+
+	/* Obtain the PLL frequency for the desired ARM frequency */
+	pll_freq = select_freq_pll(arm_freq);
+	if (pll_freq == -1) {
+		return -1;
+	}
+
+	/* The MPCTL0 register values are programmed based on the oscillator */
+	cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+	if ((cscr & CCM_CSCR_OSC26M) == 0) {
+		/* MPCTL0 register values are programmed for 400/266 MHz */
+		switch (pll_freq) {
+		case 400000000:
+			mfi = 7;
+			mfn = 9;
+			mfd = 12;
+			pd = 0;
+			break;
+
+		case 266000000:
+			mfi = 10;
+			mfn = 6;
+			mfd = 25;
+			break;
+
+		default:
+			return -1;
+		}
+	} else {
+		/* MPCTL0 register values are programmed for 400/266 MHz */
+		switch (pll_freq) {
+		case 400000000:
+			mfi = 12;
+			mfn = 2;
+			mfd = 3;
+			break;
+
+		case 266000000:
+			mfi = 8;
+			mfn = 10;
+			mfd = 31;
+			break;
+
+		default:
+			return -1;
+		}
+	}
+
+#if MX27_LLPM_DEBUG
+	printk("PLL scaling\n");
+	printk("PLL = %d : ARM = %d: AHB = %d\n", pll_freq, arm_freq, ahb_freq);
+#endif
+
+	/* Adjust the peripheral clock dividers for new PLL frequency */
+	mx27_set_dividers(pll_freq);
+
+	if (pll_freq > org_pll) {
+		/* Set the dividers first */
+		mx27_pm_intscale(arm_freq, ahb_freq, pll_freq);
+
+		/* Set the PLL */
+		mxc_pll_set(MCUPLL, mfi, pd, mfd, mfn);
+		mdelay(50);
+	} else {
+		/* Set the PLL first */
+		mxc_pll_set(MCUPLL, mfi, pd, mfd, mfn);
+		mdelay(50);
+
+		/* Set the dividers later */
+		mx27_pm_intscale(arm_freq, ahb_freq, pll_freq);
+	}
+
+	return 0;
+}
+
+/*!
+ * Implement steps required to transition to low-power modes.
+ *
+ * @param       mode    The desired low-power mode. Possible values are,
+ *                      DOZE_MODE
+ *                      WAIT_MODE
+ *                      STOP_MODE
+ *                      DSM_MODE
+ */
+void mxc_pm_lowpower(s32 mode)
+{
+	u32 interrupt_disabled = 0, cscr;
+	u32 reg_intenableh = 0, reg_intenablel = 0;
+
+	local_irq_disable();
+
+	/* WAIT and DOZE execute WFI only */
+	switch (mode) {
+	case STOP_MODE:
+	case DSM_MODE:
+
+		reg_intenableh = __raw_readl(AVIC_INTENABLEH);
+		reg_intenablel = __raw_readl(AVIC_INTENABLEL);
+
+		/* Disable All interrupts except keypad */
+		__raw_writel(0, IO_ADDRESS(AVIC_BASE_ADDR) + 0x10);
+		__raw_writel((1 << INT_KPP), IO_ADDRESS(AVIC_BASE_ADDR) + 0x14);
+
+		interrupt_disabled = 1;
+
+		/* Clear MPEN and SPEN to disable MPLL/SPLL */
+		cscr = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		cscr &= 0xFFFFFFFC;
+		__raw_writel(cscr, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CSCR);
+		break;
+	}
+
+	/* Executes WFI */
+	arch_idle();
+
+	if (interrupt_disabled) {
+		__raw_writel(reg_intenableh, AVIC_INTENABLEH);
+		__raw_writel(reg_intenablel, AVIC_INTENABLEL);
+	}
+
+	local_irq_enable();
+}
+
+/*!
+ * Configure the desired clock to be output on CLKO pin.
+ *
+ * @param       opt     desired CLK for CLKO
+ */
+void mxc_pm_ckosel(u32 opt)
+{
+	u32 reg;
+
+	if (opt < 0 || opt >= CLKO_MAX)
+		return;
+
+	reg = __raw_readl(IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
+	reg = (reg & (~CCM_CCSR_CLKOSEL_MASK)) | opt;
+	__raw_writel(reg, IO_ADDRESS(CCM_BASE_ADDR) + CCM_CCSR);
+	return;
+}
+
+/*!
+ * Called to change the core frequency. This function internally decides
+ * whether to do integer scaling or pll scaling.
+ *
+ * @param       arm_freq        Desired ARM frequency
+ * @param       ahb_freq        Desired AHB frequency
+ * @param       ipg_freq        Desired IP frequency, constant AHB / 2 always.
+ *
+ * @return      Returns 0 on success
+ *              Returns -1 on error
+ */
+int mxc_pm_dvfs(unsigned long arm_freq, long ahb_freq, long ipg_freq)
+{
+	u32 divider;
+	s32 pll_freq, ret;
+	unsigned long flags;
+
+	if (mx27_pm_check_parameters(arm_freq, ahb_freq) != 0) {
+		return -1;
+	}
+
+	local_irq_save(flags);
+
+	/* Get the current PLL frequency */
+	pll_freq = mxc_pll_clock(MCUPLL);
+
+#if MX27_LLPM_DEBUG
+	printk("MCU PLL frequency is %d\n", pll_freq);
+#endif
+
+	/* Decide whether to do integer scaling or pll scaling */
+	if (arm_freq > pll_freq) {
+		/* Do PLL scaling */
+		ret = mx27_pm_pllscale(arm_freq, ahb_freq, pll_freq);
+	} else {
+		/* We need integer divider values */
+		divider = pll_freq / arm_freq;
+		if (!freq_equal(arm_freq, pll_freq / divider)) {
+			/* Do PLL scaling */
+			ret = mx27_pm_pllscale(arm_freq, ahb_freq, pll_freq);
+		} else {
+			/* Do integer scaling */
+			ret = mx27_pm_intscale(arm_freq, ahb_freq, pll_freq);
+		}
+	}
+
+	local_irq_restore(flags);
+	return ret;
+}
+
+/*
+ * This API is not supported on i.MX27
+ */
+int mxc_pm_intscale(long armfreq, long ahbfreq, long ipfreq)
+{
+	return -MXC_PM_API_NOT_SUPPORTED;
+}
+
+/*
+ * This API is not supported on i.MX27
+ */
+int mxc_pm_pllscale(long armfreq, long ahbfreq, long ipfreq)
+{
+	return -MXC_PM_API_NOT_SUPPORTED;
+}
+
+/*!
+ * This function is used to load the module.
+ *
+ * @return   Returns an Integer on success
+ */
+static int __init mxc_pm_init_module(void)
+{
+	printk("MX27: Power management module initialized\n");
+	perclk1 = mxc_get_clocks(PERCLK1);
+	perclk2 = mxc_get_clocks(PERCLK2);
+	perclk3 = mxc_get_clocks(PERCLK3);
+	perclk4 = mxc_get_clocks(PERCLK4);
+	nfcclk = mxc_get_clocks(NFC_CLK);
+	cpuclk = mxc_get_clocks(CPU_CLK);
+	return 0;
+}
+
+/*!
+ * This function is used to unload the module
+ */
+static void __exit mxc_pm_cleanup_module(void)
+{
+	printk("MX27: Power management module exit\n");
+}
+
+module_init(mxc_pm_init_module);
+module_exit(mxc_pm_cleanup_module);
+
+EXPORT_SYMBOL(mxc_pm_lowpower);
+EXPORT_SYMBOL(mxc_pm_dvfs);
+EXPORT_SYMBOL(mxc_pm_pllscale);
+EXPORT_SYMBOL(mxc_pm_intscale);
+
+MODULE_AUTHOR("Freescale Semiconductor, Inc.");
+MODULE_DESCRIPTION("i.MX27 low level PM driver");
+MODULE_LICENSE("GPL");
--- linux-2.6.19.2/arch/arm/mach-mx27/pm.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/pm.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,106 @@
+/*
+ * linux/arch/arm/mach-mx27/pm.c
+ *
+ * MX27 Power Management Routines
+ *
+ * Original code for the SA11x0:
+ * Copyright (c) 2001 Cliff Brake <cbrake@accelent.com>
+ *
+ * Modified for the PXA250 by Nicolas Pitre:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Modified for the OMAP1510 by David Singleton:
+ * Copyright (c) 2002 Monta Vista Software, Inc.
+ *
+ * Cleanup 2004 for OMAP1510/1610 by Dirk Behme <dirk.behme@de.bosch.com>
+ *
+ * Modified for the MX27
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ * NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/pm.h>
+#include <linux/sched.h>
+#include <linux/proc_fs.h>
+#include <linux/pm.h>
+
+#include <asm/io.h>
+#include <asm/arch/mxc_pm.h>
+
+/*
+ * TODO: whatta save?
+ */
+
+static int mx27_pm_enter(suspend_state_t state)
+{
+	pr_debug("Hi, from mx27_pm_enter\n");
+	switch (state) {
+	case PM_SUSPEND_MEM:
+		mxc_pm_lowpower(STOP_MODE);
+		break;
+
+	case PM_SUSPEND_STANDBY:
+		mxc_pm_lowpower(WAIT_MODE);
+		break;
+
+	case PM_SUSPEND_STOP:
+		mxc_pm_lowpower(DSM_MODE);
+		break;
+
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+/*
+ * Called after processes are frozen, but before we shut down devices.
+ */
+static int mx27_pm_prepare(suspend_state_t state)
+{
+	return 0;
+}
+
+/*
+ * Called after devices are re-setup, but before processes are thawed.
+ */
+static int mx27_pm_finish(suspend_state_t state)
+{
+	return 0;
+}
+
+struct pm_ops mx27_pm_ops = {
+	.pm_disk_mode = 0,
+	.prepare = mx27_pm_prepare,
+	.enter = mx27_pm_enter,
+	.finish = mx27_pm_finish,
+};
+
+static int __init mx27_pm_init(void)
+{
+	pr_debug("Power Management for Freescale MX27\n");
+	pm_set_ops(&mx27_pm_ops);
+
+	return 0;
+}
+
+late_initcall(mx27_pm_init);
--- linux-2.6.19.2/arch/arm/mach-mx27/serial.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/serial.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,269 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/*!
+ * @file serial.c
+ *
+ * @brief This file contains the UART initiliazation.
+ *
+ * @ingroup System
+ */
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/serial.h>
+#include <asm/hardware.h>
+#include <asm/arch/mxc_uart.h>
+#include "serial.h"
+
+#if defined(CONFIG_SERIAL_MXC) || defined(CONFIG_SERIAL_MXC_MODULE)
+
+/*!
+ * This is an array where each element holds information about a UART port,
+ * like base address of the UART, interrupt numbers etc. This structure is
+ * passed to the serial_core.c file. Based on which UART is used, the core file
+ * passes back the appropriate port structure as an argument to the control
+ * functions.
+ */
+static uart_mxc_port mxc_ports[] = {
+	[0] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART1_BASE_ADDR),
+			.mapbase = UART1_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART1_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 0,
+			},
+	       .ints_muxed = UART1_MUX_INTS,
+	       .irqs = {UART1_INT2, UART1_INT3},
+	       .mode = UART1_MODE,
+	       .ir_mode = UART1_IR,
+	       .enabled = UART1_ENABLED,
+	       .hardware_flow = UART1_HW_FLOW,
+	       .cts_threshold = UART1_UCR4_CTSTL,
+	       .dma_enabled = UART1_DMA_ENABLE,
+	       .dma_rxbuf_size = UART1_DMA_RXBUFSIZE,
+	       .rx_threshold = UART1_UFCR_RXTL,
+	       .tx_threshold = UART1_UFCR_TXTL,
+	       .shared = UART1_SHARED_PERI,
+	       .clock_id = UART1_BAUD,
+	       .dma_tx_id = MXC_DMA_UART1_TX,
+	       .dma_rx_id = MXC_DMA_UART1_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[1] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART2_BASE_ADDR),
+			.mapbase = UART2_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART2_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 1,
+			},
+	       .ints_muxed = UART2_MUX_INTS,
+	       .irqs = {UART2_INT2, UART2_INT3},
+	       .mode = UART2_MODE,
+	       .ir_mode = UART2_IR,
+	       .enabled = UART2_ENABLED,
+	       .hardware_flow = UART2_HW_FLOW,
+	       .cts_threshold = UART2_UCR4_CTSTL,
+	       .dma_enabled = UART2_DMA_ENABLE,
+	       .dma_rxbuf_size = UART2_DMA_RXBUFSIZE,
+	       .rx_threshold = UART2_UFCR_RXTL,
+	       .tx_threshold = UART2_UFCR_TXTL,
+	       .shared = UART2_SHARED_PERI,
+	       .clock_id = UART2_BAUD,
+	       .dma_tx_id = MXC_DMA_UART2_TX,
+	       .dma_rx_id = MXC_DMA_UART2_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[2] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART3_BASE_ADDR),
+			.mapbase = UART3_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART3_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 2,
+			},
+	       .ints_muxed = UART3_MUX_INTS,
+	       .irqs = {UART3_INT2, UART3_INT3},
+	       .mode = UART3_MODE,
+	       .ir_mode = UART3_IR,
+	       .enabled = UART3_ENABLED,
+	       .hardware_flow = UART3_HW_FLOW,
+	       .cts_threshold = UART3_UCR4_CTSTL,
+	       .dma_enabled = UART3_DMA_ENABLE,
+	       .dma_rxbuf_size = UART3_DMA_RXBUFSIZE,
+	       .rx_threshold = UART3_UFCR_RXTL,
+	       .tx_threshold = UART3_UFCR_TXTL,
+	       .shared = UART3_SHARED_PERI,
+	       .clock_id = UART3_BAUD,
+	       .dma_tx_id = MXC_DMA_UART3_TX,
+	       .dma_rx_id = MXC_DMA_UART3_RX,
+	       .rxd_mux = MXC_UART_IR_RXDMUX,
+	       },
+	[3] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART4_BASE_ADDR),
+			.mapbase = UART4_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART4_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 3,
+			},
+	       .ints_muxed = UART4_MUX_INTS,
+	       .irqs = {UART4_INT2, UART4_INT3},
+	       .mode = UART4_MODE,
+	       .ir_mode = UART4_IR,
+	       .enabled = UART4_ENABLED,
+	       .hardware_flow = UART4_HW_FLOW,
+	       .cts_threshold = UART4_UCR4_CTSTL,
+	       .dma_enabled = UART4_DMA_ENABLE,
+	       .dma_rxbuf_size = UART4_DMA_RXBUFSIZE,
+	       .rx_threshold = UART4_UFCR_RXTL,
+	       .tx_threshold = UART4_UFCR_TXTL,
+	       .shared = UART4_SHARED_PERI,
+	       .clock_id = UART4_BAUD,
+	       .dma_tx_id = MXC_DMA_UART4_TX,
+	       .dma_rx_id = MXC_DMA_UART4_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[4] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART5_BASE_ADDR),
+			.mapbase = UART5_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART5_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 4,
+			},
+	       .ints_muxed = UART5_MUX_INTS,
+	       .irqs = {UART5_INT2, UART5_INT3},
+	       .mode = UART5_MODE,
+	       .ir_mode = UART5_IR,
+	       .enabled = UART5_ENABLED,
+	       .hardware_flow = UART5_HW_FLOW,
+	       .cts_threshold = UART5_UCR4_CTSTL,
+	       .dma_enabled = UART5_DMA_ENABLE,
+	       .dma_rxbuf_size = UART5_DMA_RXBUFSIZE,
+	       .rx_threshold = UART5_UFCR_RXTL,
+	       .tx_threshold = UART5_UFCR_TXTL,
+	       .shared = UART5_SHARED_PERI,
+	       .clock_id = UART5_BAUD,
+	       .dma_tx_id = MXC_DMA_UART5_TX,
+	       .dma_rx_id = MXC_DMA_UART5_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+	[5] = {
+	       .port = {
+			.membase = (void *)IO_ADDRESS(UART6_BASE_ADDR),
+			.mapbase = UART6_BASE_ADDR,
+			.iotype = SERIAL_IO_MEM,
+			.irq = UART6_INT1,
+			.fifosize = 32,
+			.flags = ASYNC_BOOT_AUTOCONF,
+			.line = 5,
+			},
+	       .ints_muxed = UART6_MUX_INTS,
+	       .irqs = {UART6_INT2, UART6_INT3},
+	       .mode = UART6_MODE,
+	       .ir_mode = UART6_IR,
+	       .enabled = UART6_ENABLED,
+	       .hardware_flow = UART6_HW_FLOW,
+	       .cts_threshold = UART6_UCR4_CTSTL,
+	       .dma_enabled = UART6_DMA_ENABLE,
+	       .dma_rxbuf_size = UART6_DMA_RXBUFSIZE,
+	       .rx_threshold = UART6_UFCR_RXTL,
+	       .tx_threshold = UART6_UFCR_TXTL,
+	       .shared = UART6_SHARED_PERI,
+	       .clock_id = UART6_BAUD,
+	       .dma_tx_id = MXC_DMA_UART6_TX,
+	       .dma_rx_id = MXC_DMA_UART6_RX,
+	       .rxd_mux = MXC_UART_RXDMUX,
+	       },
+};
+
+static struct platform_device mxc_uart_device1 = {
+	.name = "mxcintuart",
+	.id = 0,
+	.dev = {
+		.platform_data = &mxc_ports[0],
+		},
+};
+
+static struct platform_device mxc_uart_device2 = {
+	.name = "mxcintuart",
+	.id = 1,
+	.dev = {
+		.platform_data = &mxc_ports[1],
+		},
+};
+
+static struct platform_device mxc_uart_device3 = {
+	.name = "mxcintuart",
+	.id = 2,
+	.dev = {
+		.platform_data = &mxc_ports[2],
+		},
+};
+
+static struct platform_device mxc_uart_device4 = {
+	.name = "mxcintuart",
+	.id = 3,
+	.dev = {
+		.platform_data = &mxc_ports[3],
+		},
+};
+static struct platform_device mxc_uart_device5 = {
+	.name = "mxcintuart",
+	.id = 4,
+	.dev = {
+		.platform_data = &mxc_ports[4],
+		},
+};
+static struct platform_device mxc_uart_device6 = {
+	.name = "mxcintuart",
+	.id = 5,
+	.dev = {
+		.platform_data = &mxc_ports[5],
+		},
+};
+
+static int __init mxc_init_uart(void)
+{
+	/* Register all the MXC UART platform device structures */
+	platform_device_register(&mxc_uart_device1);
+	platform_device_register(&mxc_uart_device2);
+#ifndef CONFIG_MXC_IRDA
+	platform_device_register(&mxc_uart_device3);
+#endif
+	platform_device_register(&mxc_uart_device4);
+
+	platform_device_register(&mxc_uart_device5);
+	platform_device_register(&mxc_uart_device6);
+	return 0;
+}
+
+#else
+static int __init mxc_init_uart(void)
+{
+	return 0;
+}
+#endif
+
+arch_initcall(mxc_init_uart);
--- linux-2.6.19.2/arch/arm/mach-mx27/serial.h	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/serial.h	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#ifndef __ARCH_ARM_MACH_MX27_SERIAL_H__
+#define __ARCH_ARM_MACH_MX27_SERIAL_H__
+
+#include <asm/arch/mxc_uart.h>
+
+/* UART 1 configuration */
+/*!
+ * This option allows to choose either an interrupt-driven software controlled
+ * hardware flow control (set this option to 0) or hardware-driven hardware
+ * flow control (set this option to 1).
+ */
+#define UART1_HW_FLOW           1
+/*!
+ * This specifies the threshold at which the CTS pin is deasserted by the
+ * RXFIFO. Set this value in Decimal to anything from 0 to 32 for
+ * hardware-driven hardware flow control. Read the HW spec while specifying
+ * this value. When using interrupt-driven software controlled hardware
+ * flow control set this option to -1.
+ */
+#define UART1_UCR4_CTSTL        16
+/*!
+ * This is option to enable (set this option to 1) or disable DMA data transfer
+ */
+#define UART1_DMA_ENABLE        0
+/*!
+ * Specify the size of the DMA receive buffer. The buffer size should be same with
+ * sub buffer size which is defined in mxc_uart.c for all data can be transfered.
+ */
+#define UART1_DMA_RXBUFSIZE     128
+/*!
+ * Specify the MXC UART's Receive Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the RxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_RXTL         16
+/*!
+ * Specify the MXC UART's Transmit Trigger Level. This controls the threshold at
+ * which a maskable interrupt is generated by the TxFIFO. Set this value in
+ * Decimal to anything from 0 to 32. Read the HW spec while specifying this
+ * value.
+ */
+#define UART1_UFCR_TXTL         16
+/* UART 2 configuration */
+#define UART2_HW_FLOW           1
+#define UART2_UCR4_CTSTL        16
+#define UART2_DMA_ENABLE        0
+#define UART2_DMA_RXBUFSIZE     512
+#define UART2_UFCR_RXTL         16
+#define UART2_UFCR_TXTL         16
+/* UART 3 configuration */
+#define UART3_HW_FLOW           0
+#define UART3_UCR4_CTSTL        -1
+#define UART3_DMA_ENABLE        0
+#define UART3_DMA_RXBUFSIZE     512
+#define UART3_UFCR_RXTL         16
+#define UART3_UFCR_TXTL         16
+/* UART 4 configuration */
+#define UART4_HW_FLOW           1
+#define UART4_UCR4_CTSTL        16
+#define UART4_DMA_ENABLE        0
+#define UART4_DMA_RXBUFSIZE     512
+#define UART4_UFCR_RXTL         16
+#define UART4_UFCR_TXTL         16
+/* UART 5 configuration */
+#define UART5_HW_FLOW           1
+#define UART5_UCR4_CTSTL        16
+#define UART5_DMA_ENABLE        0
+#define UART5_DMA_RXBUFSIZE     512
+#define UART5_UFCR_RXTL         16
+#define UART5_UFCR_TXTL         16
+/* UART 6 configuration */
+#define UART6_HW_FLOW           1
+#define UART6_UCR4_CTSTL        16
+#define UART6_DMA_ENABLE        0
+#define UART6_DMA_RXBUFSIZE     512
+#define UART6_UFCR_RXTL         16
+#define UART6_UFCR_TXTL         16
+/*
+ * UART Chip level Configuration that a user may not have to edit. These
+ * configuration vary depending on how the UART module is integrated with
+ * the ARM core
+ */
+/*
+ * Is the MUXED interrupt output sent to the ARM core
+ */
+#define INTS_NOTMUXED           0
+#define INTS_MUXED              1
+/* UART 1 configuration */
+/*!
+ * This define specifies whether the muxed ANDed interrupt line or the
+ * individual interrupts from the UART port is integrated with the ARM core.
+ * There exists a define like this for each UART port. Valid values that can
+ * be used are \b INTS_NOTMUXED or \b INTS_MUXED.
+ */
+#define UART1_MUX_INTS          INTS_MUXED
+/*!
+ * This define specifies the transmitter interrupt number or the interrupt
+ * number of the ANDed interrupt in case the interrupts are muxed. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_INT1              INT_UART1
+/*!
+ * This define specifies the receiver interrupt number. If the interrupts of
+ * the UART are muxed, then we specify here a dummy value -1. There exists a
+ * define like this for each UART port.
+ */
+#define UART1_INT2              -1
+/*!
+ * This specifies the master interrupt number. If the interrupts of the UART
+ * are muxed, then we specify here a dummy value of -1. There exists a define
+ * like this for each UART port.
+ */
+#define UART1_INT3              -1
+/*!
+ * This specifies if the UART is a shared peripheral. It holds the shared
+ * peripheral number if it is shared or -1 if it is not shared. There exists
+ * a define like this for each UART port.
+ */
+#define UART1_SHARED_PERI       -1
+/* UART 2 configuration */
+#define UART2_MUX_INTS          INTS_MUXED
+#define UART2_INT1              INT_UART2
+#define UART2_INT2              -1
+#define UART2_INT3              -1
+#define UART2_SHARED_PERI       -1
+/* UART 3 configuration */
+#define UART3_MUX_INTS          INTS_MUXED
+#define UART3_INT1              INT_UART3
+#define UART3_INT2              -1
+#define UART3_INT3              -1
+#define UART3_SHARED_PERI       -1
+/* UART 4 configuration */
+#define UART4_MUX_INTS          INTS_MUXED
+#define UART4_INT1              INT_UART4
+#define UART4_INT2              -1
+#define UART4_INT3              -1
+#define UART4_SHARED_PERI       -1
+/* UART 5 configuration */
+#define UART5_MUX_INTS          INTS_MUXED
+#define UART5_INT1              INT_UART5
+#define UART5_INT2              -1
+#define UART5_INT3              -1
+#define UART5_SHARED_PERI       -1
+/* UART 6 configuration */
+#define UART6_MUX_INTS          INTS_MUXED
+#define UART6_INT1              INT_UART6
+#define UART6_INT2              -1
+#define UART6_INT3              -1
+#define UART6_SHARED_PERI       -1
+
+#endif				/* __ARCH_ARM_MACH_MX27_SERIAL_H__ */
--- linux-2.6.19.2/arch/arm/mach-mx27/system.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/system.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 1999 ARM Limited
+ * Copyright (C) 2000 Deep Blue Solutions Ltd
+ * Copyright 2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <asm/io.h>
+#include <asm/arch/hardware.h>
+#include <asm/proc-fns.h>
+#include <asm/system.h>
+#include <asm/arch/clock.h>
+
+/*!
+ * @defgroup MSL Machine Specific Layer (MSL)
+ */
+
+/*!
+ * @defgroup System System-wide Misc Files for MSL
+ * @ingroup MSL
+ */
+
+/*!
+ * @file system.c
+ * @brief This file contains idle and reset functions.
+ *
+ * @ingroup System
+ */
+
+/*!
+ * This function puts the CPU into idle mode. It is called by default_idle()
+ * in process.c file.
+ */
+void arch_idle(void)
+{
+	/*
+	 * This should do all the clock switching
+	 * and wait for interrupt tricks.
+	 */
+	cpu_do_idle();
+}
+
+#define WDT_WCR_WDE             0x0004
+
+/*
+ * This function resets the system. It is called by machine_restart().
+ *
+ * @param  mode         indicates different kinds of resets
+ */
+void arch_reset(char mode)
+{
+	volatile u16 v;
+	mxc_clks_enable(WDOG_CLK);
+	v = __raw_readw(IO_ADDRESS(WDOG_BASE_ADDR));
+	__raw_writew(v | WDT_WCR_WDE, IO_ADDRESS(WDOG_BASE_ADDR));
+}
--- linux-2.6.19.2/arch/arm/mach-mx27/time.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/time.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/* System Timer Interrupt reconfigured to run in free-run mode.
+ * Author: Vitaly Wool
+ * Copyright 2004 MontaVista Software Inc.
+ */
+
+/*!
+ * @file time.c
+ * @brief This file contains OS tick implementations.
+ *
+ * This file contains OS tick implementations.
+ *
+ * @ingroup Timers
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/mach/time.h>
+
+#include <asm/arch/hardware.h>
+#include <asm/arch/clock.h>
+
+#ifndef __noinstrument
+#define __noinstrument
+#endif
+
+/* OS tick defines */
+#define MXC_GPT_INT_TICK		INT_GPT
+#define MXC_GPT_CLOCK_TICK		GPT1_CLK
+#define MXC_GPT_TCMP_TICK		MXC_GPT_TCMP(MXC_TIMER_GPT1)
+#define MXC_GPT_TSTAT_TICK		MXC_GPT_TSTAT(MXC_TIMER_GPT1)
+#define MXC_GPT_TCTL_TICK		MXC_GPT_TCTL(MXC_TIMER_GPT1)
+#define MXC_GPT_TPRER_TICK		MXC_GPT_TPRER(MXC_TIMER_GPT1)
+#define MXC_GPT_TCN_TICK		MXC_GPT_TCN(MXC_TIMER_GPT1)
+/* High resolution timer defines */
+#define MXC_GPT_INT_HRT			INT_GPT2
+#define MXC_GPT_CLOCK_HRT		GPT2_CLK
+#define MXC_GPT_TCMP_HRT		MXC_GPT_TCMP(MXC_TIMER_GPT2)
+#define MXC_GPT_TSTAT_HRT		MXC_GPT_TSTAT(MXC_TIMER_GPT2)
+#define MXC_GPT_TCTL_HRT		MXC_GPT_TCTL(MXC_TIMER_GPT2)
+#define MXC_GPT_TPRER_HRT		MXC_GPT_TPRER(MXC_TIMER_GPT2)
+#define MXC_GPT_TCN_HRT			MXC_GPT_TCN(MXC_TIMER_GPT2)
+
+/*!
+ * This is the timer interrupt service routine to do required tasks.
+ *
+ * @param  irq          GPT interrupt source number (not used)
+ * @param  dev_id       this parameter is not used
+ * @param  regs         pointer to a structure containing the processor
+ *                      registers and state prior to servicing the interrupt
+ * @return always returns \b IRQ_HANDLED as defined in
+ *         include/linux/interrupt.h.
+ */
+static irqreturn_t mxc_timer_interrupt(int irq, void *dev_id,
+				       struct pt_regs *regs)
+{
+	unsigned int next_match;
+
+	write_seqlock(&xtime_lock);
+
+	do {
+		timer_tick(regs);
+		next_match = __raw_readl(MXC_GPT_TCMP_TICK) + LATCH;
+		__raw_writel(GPT_TSTAT_COMP, MXC_GPT_TSTAT_TICK);
+		__raw_writel(next_match, MXC_GPT_TCMP_TICK);
+	} while ((signed long)(next_match - __raw_readl(MXC_GPT_TCN_TICK)) <=
+		 0);
+
+	write_sequnlock(&xtime_lock);
+
+	return IRQ_HANDLED;
+}
+
+/*!
+ * This function is used to obtain the number of microseconds since the last
+ * timer interrupt. Note that interrupts is disabled by do_gettimeofday().
+ *
+ * @return the number of microseconds since the last timer interrupt.
+ */
+static unsigned long __noinstrument mxc_gettimeoffset(void)
+{
+	unsigned long ticks_to_match, elapsed, usec, tick_usec, i;
+
+	/* Get ticks before next timer match */
+	ticks_to_match =
+	    __raw_readl(MXC_GPT_TCMP_TICK) - __raw_readl(MXC_GPT_TCN_TICK);
+
+	/* We need elapsed ticks since last match */
+	elapsed = LATCH - ticks_to_match;
+
+	/* Now convert them to usec */
+	/* Insure no overflow when calculating the usec below */
+	for (i = 1, tick_usec = tick_nsec / 1000;; i *= 2) {
+		tick_usec /= i;
+		if ((0xFFFFFFFF / tick_usec) > elapsed)
+			break;
+	}
+	usec = (unsigned long)(elapsed * tick_usec) / (LATCH / i);
+
+	return usec;
+}
+
+/*!
+ * The OS tick timer interrupt structure.
+ */
+static struct irqaction timer_irq = {
+	.name = "MXC Timer Tick",
+	.flags = IRQF_DISABLED | IRQF_TIMER,
+	.handler = mxc_timer_interrupt
+};
+
+/*!
+ * This function is used to initialize the GPT to produce an interrupt
+ * every 10 msec. It is called by the start_kernel() during system startup.
+ */
+void __init mxc_init_time(void)
+{
+	u32 reg, v;
+
+	mxc_clks_enable(MXC_GPT_CLOCK_TICK);
+	__raw_writel(0, MXC_GPT_TCTL_TICK);
+	__raw_writel(GPT_TCTL_SWR, MXC_GPT_TCTL_TICK);
+
+	while ((__raw_readl(MXC_GPT_TCTL_TICK) & GPT_TCTL_SWR) != 0)
+		mb();
+
+	reg = GPT_TCTL_FRR | GPT_TCTL_COMPEN | GPT_TCTL_SRC_PER1;
+
+	__raw_writel(reg, MXC_GPT_TCTL_TICK);
+
+	v = mxc_get_clocks(MXC_GPT_CLOCK_TICK);
+	__raw_writel((v / CLOCK_TICK_RATE) - 1, MXC_GPT_TPRER_TICK);
+
+	if ((v % CLOCK_TICK_RATE) != 0) {
+		pr_info("\nWARNING: Can't generate CLOCK_TICK_RATE at %d Hz\n",
+			CLOCK_TICK_RATE);
+	}
+	pr_info("Actual CLOCK_TICK_RATE is %d Hz\n",
+		v / ((__raw_readl(MXC_GPT_TPRER_TICK) & 0x7FF) + 1));
+
+	reg = __raw_readl(MXC_GPT_TCN_TICK);
+	reg += LATCH;
+	__raw_writel(reg, MXC_GPT_TCMP_TICK);
+
+	setup_irq(MXC_GPT_INT_TICK, &timer_irq);
+
+	reg = __raw_readl(MXC_GPT_TCTL_TICK) | GPT_TCTL_TEN;
+	__raw_writel(reg, MXC_GPT_TCTL_TICK);
+
+#ifdef CONFIG_KFI
+	os_timer_initialized = 1;
+#endif
+}
+
+struct sys_timer mxc_timer = {
+	.init = mxc_init_time,
+	.offset = mxc_gettimeoffset,
+};
--- linux-2.6.19.2/arch/arm/mach-mx27/usb.c	1969-12-31 17:00:00.000000000 -0700
+++ linux-2.6.19.2-mx/arch/arm/mach-mx27/usb.c	2007-01-10 17:09:57.000000000 -0700
@@ -0,0 +1,828 @@
+/*
+ * Copyright 2004-2006 Freescale Semiconductor, Inc. All Rights Reserved.
+ *
+ *	otg_{get,set}_transceiver() are from arm/plat-omap/usb.c.
+ *	which is Copyright (C) 2004 Texas Instruments, Inc.
+ */
+
+/*
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+/*!
+ *@defgroup USB ARC OTG USB Driver
+ */
+
+/*!
+ * @file usb.c
+ *
+ * @brief platform related part of usb driver.
+ * @ingroup USB
+ */
+
+/*!
+ * Include files
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/usb_otg.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/board.h>
+#include <asm/arch/arc_otg.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/isp1504.h>
+#include <asm/arch/isp1301.h>
+
+#define PBC3_CLEAR	PBC_BCTRL3_CLEAR_REG
+#define PBC3_SET	PBC_BCTRL3_SET_REG
+
+#undef DEBUG
+#undef VERBOSE
+
+#ifdef DEBUG
+#define dbg(fmt, args...)	printk("%s: " fmt "\n", __FUNCTION__, ## args)
+#else
+#define dbg(fmt, args...)	do {} while (0)
+#endif
+
+#ifdef VERBOSE
+#define vdbg	dbg
+#else
+#define vdbg(fmt, args...)	do {} while (0)
+#endif
+
+extern void gpio_usbh1_active(void);
+extern void gpio_usbh1_inactive(void);
+extern void gpio_usbh2_active(void);
+extern void gpio_usbh2_inactive(void);
+extern void gpio_usbotg_hs_active(void);
+extern void gpio_usbotg_hs_inactive(void);
+extern void gpio_usbotg_fs_active(void);
+extern void gpio_usbotg_fs_inactive(void);
+
+/* The dmamask must be set for EHCI to work */
+static u64 ehci_dmamask = ~(u32) 0;
+
+/*
+ * make sure USB_CLK is running at 60 MHz +/- 1000 Hz
+ */
+static int check_usbclk(void)
+{
+	unsigned long clk;
+
+	clk = mxc_get_clocks(USB_CLK);
+	if ((clk < 59999000) || (clk > 60001000)) {
+		printk(KERN_ERR "USB_CLK=%lu, should be 60MHz\n", clk);
+		return -1;
+	}
+	return 0;
+}
+
+#if defined(CONFIG_ISP1504_MXC) || defined(CONFIG_ISP1504_MXC_MODULE)
+/*!
+ * read ULPI register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       reg   register to read
+ * @param       view  the ULPI VIEWPORT register address
+ * @return	return isp1504 register value
+ */
+u8 isp1504_read(int reg, volatile u32 * view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	/* read the register */
+	__raw_writel((ULPIVW_RUN | (reg << ULPIVW_ADDR_SHIFT)), view);
+
+	do {			/* wait for completion */
+		data = __raw_readl(view);
+	} while (data & ULPIVW_RUN);
+
+	return (u8) (data >> ULPIVW_RDATA_SHIFT) & ULPIVW_RDATA_MASK;
+}
+
+EXPORT_SYMBOL(isp1504_read);
+
+/*!
+ * set bits into OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  set value
+ * @param	reg   which register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+void isp1504_set(u8 bits, int reg, volatile u32 * view)
+{
+	u32 data;
+
+	/* make sure interface is running */
+	if (!(__raw_readl(view) && ULPIVW_SS)) {
+		printk("\nSS=0\n");
+		__raw_writel(ULPIVW_WU, view);
+		do {		/* wait for wakeup */
+			data = __raw_readl(view);
+		} while (data & ULPIVW_WU);
+	}
+
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_SET) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+EXPORT_SYMBOL(isp1504_set);
+
+/*!
+ * clear bits in OTG ISP1504 register 'reg' thru VIEWPORT register 'view'
+ *
+ * @param       bits  bits to clear
+ * @param	reg   in this register
+ * @param       view  the ULPI VIEWPORT register address
+ */
+void isp1504_clear(u8 bits, int reg, volatile u32 * view)
+{
+	__raw_writel((ULPIVW_RUN | ULPIVW_WRITE |
+		      ((reg + ISP1504_REG_CLEAR) << ULPIVW_ADDR_SHIFT) |
+		      ((bits & ULPIVW_WDATA_MASK) << ULPIVW_WDATA_SHIFT)),
+		     view);
+
+	while (__raw_readl(view) & ULPIVW_RUN)	/* wait for completion */
+		continue;
+}
+
+EXPORT_SYMBOL(isp1504_clear);
+
+/*!
+ * set vbus power
+ *
+ * @param       on    power on or off
+ * @param       view  the ULPI view register address
+ */
+static void __attribute((unused)) ulpi_set_vbus_power(int on,
+						      volatile u32 * view)
+{
+	dbg("on=%d  view=0x%p", on, view);
+
+	vdbg("ULPI Vendor ID 0x%x    Product ID 0x%x",
+	     (isp1504_read(ISP1504_VID_HIGH, view) << 8) |
+	     isp1504_read(ISP1504_VID_LOW, view),
+	     (isp1504_read(ISP1504_PID_HIGH, view) << 8) |
+	     isp1504_read(ISP1504_PID_LOW, view));
+
+	vdbg("OTG Control before = 0x%x", isp1504_read(ISP1504_OTGCTL, view));
+
+	if (on) {
+		isp1504_set(DRV_VBUS_EXT |	/* enable external Vbus */
+			    DRV_VBUS |	/* enable internal Vbus */
+			    USE_EXT_VBUS_IND |	/* use external indicator */
+			    CHRG_VBUS,	/* charge Vbus */
+			    ISP1504_OTGCTL, view);
+
+	} else {
+		isp1504_clear(DRV_VBUS_EXT |	/* disable external Vbus */
+			      DRV_VBUS,	/* disable internal Vbus */
+			      ISP1504_OTGCTL, view);
+
+		isp1504_set(USE_EXT_VBUS_IND |	/* use external indicator */
+			    DISCHRG_VBUS,	/* discharge Vbus */
+			    ISP1504_OTGCTL, view);
+	}
+
+	vdbg("OTG Control after = 0x%x\n", isp1504_read(ISP1504_OTGCTL, view));
+}
+#endif
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGHS) || defined(CONFIG_USB_GADGET_ARC_OTGHS)
+static int otg_used = 0;	/* OTG use-count */
+
+static void otg_hs_set_xcvr(void)
+{
+	u32 tmp;
+
+	/* set ULPI xcvr */
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_ULPI;
+	UOG_PORTSC1 = tmp;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	UOG_USBCMD |= UCMD_RESET;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	mdelay(10);
+}
+
+static int otg_hs_init(void)
+{
+	if (!otg_used) {
+		if (check_usbclk() != 0)
+			return -EINVAL;
+
+		dbg("grab OTG-HS pins");
+
+		/* enable OTG/HS */
+		mxc_clks_disable(USB_CLK);
+		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_CLEAR);
+		mxc_clks_enable(USB_CLK);
+
+		gpio_usbotg_hs_active();	/* grab our pins */
+		mdelay(1);
+
+		USBCTRL &= ~UCTRL_BPE;	/* disable bypass mode */
+		USBCTRL |= UCTRL_OUIE |	/* ULPI intr enable */
+		    UCTRL_OWIE |	/* OTG wakeup intr enable */
+		    UCTRL_OPM;	/* power mask */
+
+		otg_hs_set_xcvr();	/* set transciever type */
+	}
+
+	isp1504_set(ID_PULL_UP, ISP1504_OTGCTL, &UOG_ULPIVIEW);
+#ifdef DEBUG
+	if (!(isp1504_read(ISP1504_OTGCTL, &UOG_ULPIVIEW) & ID_PULL_UP)) {
+		printk(KERN_ERR "ID_PULL_UP not set in OTGCTL!!\n");
+	}
+#endif
+
+	otg_used++;
+	return 0;
+}
+
+static void otg_hs_uninit(void)
+{
+	dbg();
+
+	otg_used--;
+	if (!otg_used) {
+		/* disable  OTG/HS */
+		__raw_writew(PBC_BCTRL3_OTG_HS_EN, PBC3_SET);
+
+		dbg("free OTG-HS pins");
+		gpio_usbotg_hs_inactive();	/* release our pins */
+	}
+}
+
+static void otg_hs_set_vbus_power(int on)
+{
+	dbg("on=%d", on);
+	ulpi_set_vbus_power(on, &UOG_ULPIVIEW);
+}
+
+/*!
+ * OTG HS host config
+ */
+#ifdef CONFIG_USB_EHCI_ARC_OTGHS
+/* *INDENT-OFF* */
+static struct arc_usb_config otg_hs_host_config = {
+	.name            = "OTG HS Host",
+	.platform_init   = otg_hs_init,
+	.platform_uninit = otg_hs_uninit,
+	.set_vbus_power  = otg_hs_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.does_otg        = 1,
+	.power_budget    = 500,		/* 500 mA max power */
+};
+/* *INDENT-ON* */
+
+static struct platform_device *otg_hs_host_device;
+#endif				/* CONFIG_USB_EHCI_ARC_OTGHS */
+#endif				/* CONFIG_USB_EHCI_ARC_OTGHS || CONFIG_USB_GADGET_ARC_OTGHS */
+
+/* *INDENT-OFF* */
+static struct resource otg_resources[] = {
+	{
+		.start = (u32) (USB_OTGREGS_BASE),
+		.end   = (u32) (USB_OTGREGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+/* *INDENT-ON* */
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGFS) || defined(CONFIG_USB_GADGET_ARC_OTGFS)
+static void otg_fs_set_xcvr(void)
+{
+	u32 tmp;
+
+	tmp = UOG_PORTSC1 & ~PORTSC_PTS_MASK;
+	tmp |= PORTSC_PTS_SERIAL;
+	UOG_PORTSC1 = tmp;
+}
+#endif				/* CONFIG_USB_EHCI_ARC_OTGFS || CONFIG_USB_GADGET_ARC_OTGFS */
+
+#ifdef CONFIG_USB_EHCI_ARC_OTGFS
+static int otg_fs_host_init(void)
+{
+	dbg("grab OTG-FS pins");
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	isp1301_init();
+
+	isp1301_set_serial_host();
+	gpio_usbotg_fs_active();	/* grab our pins */
+	mdelay(1);
+
+	/* enable OTG VBUS */
+	mxc_clks_disable(USB_CLK);
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_CLEAR);
+	mxc_clks_enable(USB_CLK);
+
+	otg_fs_set_xcvr();	/* set transceiver type */
+
+	USBCTRL &= ~(UCTRL_OSIC_MASK | UCTRL_BPE);	/* disable bypass mode */
+	USBCTRL |= UCTRL_OSIC_SU6 |	/* single-ended, unidir, 6 wire */
+	    UCTRL_OWIE |	/* OTG wakeup intr enable */
+	    UCTRL_OPM;		/* power mask */
+
+	/* need reset */
+	UOG_USBCMD |= UCMD_RESET;
+	mdelay(10);
+
+	return 0;
+}
+
+static void otg_fs_host_uninit(void)
+{
+	dbg();
+
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);	/* disable OTG VBUS */
+
+	isp1301_uninit();
+
+	gpio_usbotg_fs_inactive();	/* release our pins */
+}
+
+/*!
+ * OTG FS host config
+ */
+/* *INDENT-OFF* */
+static struct arc_usb_config otg_fs_host_config = {
+	.name            = "OTG FS Host",
+	.platform_init   = otg_fs_host_init,
+	.platform_uninit = otg_fs_host_uninit,
+	.set_vbus_power  = isp1301_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UOG_USBMODE,
+	.does_otg        = 1,
+	.power_budget    = 500,		/* 500 mA max power */
+};
+/* *INDENT-ON* */
+
+static struct platform_device *otg_fs_host_device;
+#endif				/* CONFIG_USB_EHCI_ARC_OTGFS */
+
+/* Host 1 */
+#ifdef CONFIG_USB_EHCI_ARC_H1
+static void usbh1_set_xcvr(void)
+{
+	UH1_PORTSC1 &= ~PORTSC_PTS_MASK;
+	UH1_PORTSC1 |= PORTSC_PTS_SERIAL;
+}
+
+static int usbh1_init(void)
+{
+	dbg("grab H1 pins");
+
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	gpio_usbh1_active();
+	mdelay(1);
+
+	mxc_clks_disable(USB_CLK);
+	__raw_writew(PBC_BCTRL3_FSH_MOD, PBC3_CLEAR);	/* single ended */
+	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_CLEAR);	/* enable FSH VBUS */
+	mxc_clks_enable(USB_CLK);
+
+	USBCTRL &= ~(UCTRL_H1SIC_MASK | UCTRL_BPE);	/* disable bypass mode */
+	USBCTRL |= UCTRL_H1SIC_SU6 |	/* single-ended / unidir. */
+	    UCTRL_H1WIE | UCTRL_H1DT |	/* disable H1 TLL */
+	    UCTRL_H1PM;		/* power mask */
+
+	usbh1_set_xcvr();
+	return 0;
+}
+
+static void usbh1_uninit(void)
+{
+	dbg();
+
+	__raw_writew(PBC_BCTRL3_FSH_VBUS_EN, PBC3_SET);	/* disable FSH VBUS */
+
+	gpio_usbh1_inactive();	/* release our pins */
+}
+
+/* *INDENT-OFF* */
+static struct arc_usb_config usbh1_config = {
+	.name            = "Host 1",
+	.platform_init   = usbh1_init,
+	.platform_uninit = usbh1_uninit,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UH1_USBMODE,
+	.power_budget    = 500,		/* 500 mA max power */
+};
+
+static struct resource usbh1_resources[] = {
+	{
+		.start = (u32) (USB_H1REGS_BASE),
+		.end   = (u32) (USB_H1REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = INT_USB1,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+/* *INDENT-ON* */
+
+static struct platform_device *usbh1_device;
+#endif				/* CONFIG_USB_EHCI_ARC_H1 */
+
+#ifdef CONFIG_USB_EHCI_ARC_H2
+static void usbh2_set_xcvr(void)
+{
+	UH2_PORTSC1 &= ~PORTSC_PTS_MASK;	/* set ULPI xcvr */
+	UH2_PORTSC1 |= PORTSC_PTS_ULPI;
+
+	/* need to reset the controller here so that the ID pin
+	 * is correctly detected.
+	 */
+	UH2_USBCMD |= UCMD_RESET;
+
+	/* allow controller to reset, and leave time for
+	 * the ULPI transceiver to reset too.
+	 */
+	mdelay(10);
+
+}
+
+static int usbh2_init(void)
+{
+	dbg("grab H2 pins");
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	mxc_clks_disable(USB_CLK);
+	__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_CLEAR);	/* enable OTG_VBUS_EN */
+	mxc_clks_enable(USB_CLK);
+	gpio_usbh2_active();	/* grab our pins */
+	mdelay(1);
+
+	USBCTRL &= ~(UCTRL_BPE);	/* disable bypass mode */
+	USBCTRL |= UCTRL_H2WIE |	/* wakeup intr enable */
+	    UCTRL_H2UIE |	/* ULPI intr enable */
+	    UCTRL_H2DT |	/* disable H2 TLL */
+	    UCTRL_H2PM;		/* power mask */
+
+	dbg("success");
+	usbh2_set_xcvr();	/* set transceiver type */
+	return 0;
+}
+
+static void usbh2_uninit(void)
+{
+	dbg();
+
+	__raw_writew(PBC_BCTRL3_HSH_EN, PBC3_SET);	/* disable HSH */
+
+	gpio_usbh2_inactive();	/* release our pins */
+}
+
+static void usbh2_set_vbus_power(int on)
+{
+	dbg("on=%d", on);
+	ulpi_set_vbus_power(on, &UH2_ULPIVIEW);
+}
+
+/* *INDENT-OFF* */
+static struct arc_usb_config usbh2_config = {
+	.name            = "Host 2",
+	.platform_init   = usbh2_init,
+	.platform_uninit = usbh2_uninit,
+	.set_vbus_power  = usbh2_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UH2_USBMODE,
+	.power_budget    = 500,		/* 500 mA max power */
+};
+
+static struct resource usbh2_resources[] = {
+	{
+		.start = (u32) (USB_H2REGS_BASE),
+		.end   = (u32) (USB_H2REGS_BASE + 0x1ff),
+		.flags = IORESOURCE_MEM,
+	},
+	{
+		.start = INT_USB2,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+/* *INDENT-ON* */
+
+static struct platform_device *usbh2_device;
+#endif				/* CONFIG_USB_EHCI_ARC_H2 */
+
+#ifdef CONFIG_USB_GADGET_ARC
+#ifdef CONFIG_USB_GADGET_ARC_OTGHS
+/* *INDENT-OFF* */
+static struct arc_usb_config udc_hs_config = {
+	.name            = "OTG HS Gadget",
+	.platform_init   = otg_hs_init,
+	.platform_uninit = otg_hs_uninit,
+	.set_vbus_power  = otg_hs_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_ULPI,
+	.usbmode         = (u32) &UOG_USBMODE,
+};
+/* *INDENT-ON* */
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC_OTGFS
+int otg_fs_dev_init(void)
+{
+	dbg("grab OTG-FS pins");
+	if (check_usbclk() != 0)
+		return -EINVAL;
+
+	isp1301_init();
+
+	isp1301_set_serial_dev();
+	gpio_usbotg_fs_active();	/* grab our pins */
+	mdelay(1);
+
+	/* disable OTG VBUS */
+	mxc_clks_disable(USB_CLK);
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);
+	mxc_clks_enable(USB_CLK);
+
+	otg_fs_set_xcvr();	/* set transceiver type */
+
+	USBCTRL &= ~(UCTRL_OSIC_MASK | UCTRL_BPE);	/* disable bypass */
+	USBCTRL |= UCTRL_OSIC_DU6 |	/* differential, unidir, 6 wire */
+	    UCTRL_OWIE |	/* OTG wakeup intr enable */
+	    UCTRL_OPM;		/* power mask */
+
+	USB_OTG_MIRROR = 0xd;
+	return 0;
+}
+
+static void otg_fs_dev_uninit(void)
+{
+	dbg();
+
+	/* disable OTG VBUS */
+	__raw_writew(PBC_BCTRL3_OTG_VBUS_EN, PBC3_SET);
+
+	isp1301_uninit();
+	gpio_usbotg_fs_inactive();	/* release our pins */
+}
+
+/* *INDENT-OFF* */
+static struct arc_usb_config udc_fs_config = {
+	.name            = "OTG FS Gadget",
+	.platform_init   = otg_fs_dev_init,
+	.platform_uninit = otg_fs_dev_uninit,
+	.set_vbus_power  = isp1301_set_vbus_power,
+	.xcvr_type       = PORTSC_PTS_SERIAL,
+	.usbmode         = (u32) &UOG_USBMODE,
+};
+/* *INDENT-ON* */
+#endif				/* CONFIG_USB_GADGET_ARC_OTGFS */
+
+/*!
+ * OTG HS/FS gadget device
+ */
+
+static void usb_release(struct device *dev)
+{
+	/* normally not freed */
+}
+
+static u64 udc_dmamask = ~(u32) 0;
+/* *INDENT-OFF* */
+static struct platform_device udc_device = {
+	.name = "arc_udc",
+	.id   = -1,
+	.dev  = {
+		.release           = usb_release,
+		.dma_mask          = &udc_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+#if   defined CONFIG_USB_GADGET_ARC_OTGHS
+		.platform_data     = &udc_hs_config,
+#elif defined CONFIG_USB_GADGET_ARC_OTGFS
+		.platform_data     = &udc_fs_config,
+#else
+#error "No OTG port configured."
+#endif
+		},
+	.num_resources = ARRAY_SIZE(otg_resources),
+	.resource      = otg_resources,
+};
+/* *INDENT-ON* */
+#endif				/* CONFIG_USB_GADGET_ARC */
+
+#if defined(CONFIG_USB_OTG)
+static struct otg_transceiver *xceiv;
+
+/**
+ * otg_get_transceiver - find the (single) OTG transceiver driver
+ *
+ * Returns the transceiver driver, after getting a refcount to it; or
+ * null if there is no such transceiver.  The caller is responsible for
+ * releasing that count.
+ */
+struct otg_transceiver *otg_get_transceiver(void)
+{
+	dbg("%s xceiv=0x%p\n", __FUNCTION__, xceiv);
+	if (xceiv)
+		get_device(xceiv->dev);
+	return xceiv;
+}
+
+EXPORT_SYMBOL(otg_get_transceiver);
+
+int otg_set_transceiver(struct otg_transceiver *x)
+{
+	dbg("%s xceiv=0x%p  x=0x%p\n", __FUNCTION__, xceiv, x);
+	if (xceiv && x)
+		return -EBUSY;
+	xceiv = x;
+	return 0;
+}
+
+EXPORT_SYMBOL(otg_set_transceiver);
+
+static void isp1504_release(struct device *dev)
+{
+	/* normally not freed */
+}
+
+/* *INDENT-OFF* */
+static struct arc_xcvr_config isp1504_config = {
+	.name            = "isp1504",
+	.platform_init   = otg_hs_init,
+	.platform_uninit = otg_hs_uninit,
+	.regs            = (void *)&UOG_ID,
+};
+
+static struct resource isp1504_resources[] = {
+	{
+		.start = INT_USB3,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+/*!
+ * ISP1504 device
+ */
+static u64 isp1504_dmamask = ~(u32) 0;
+static struct platform_device isp1504_device = {
+	.name = "isp1504_arc",
+	.id   = -1,
+	.dev  = {
+		.release           = isp1504_release,
+		.dma_mask          = &isp1504_dmamask,
+		.coherent_dma_mask = 0xffffffff,
+		.platform_data     = &isp1504_config,
+		},
+	.num_resources = ARRAY_SIZE(isp1504_resources),
+	.resource      = isp1504_resources,
+};
+/* *INDENT-ON* */
+#endif				/* CONFIG_USB_OTG */
+
+/*!
+ * Register an instance of a USB host platform device.
+ *
+ * @param	res:	resource pointer
+ * @param       n_res:	number of resources
+ * @param       config: config pointer
+ *
+ * @return      newly-registered platform_device
+ *
+ * The USB controller supports 3 host interfaces, and the
+ * kernel can be configured to support some number of them.
+ * Each supported host interface is registered as an instance
+ * of the "fsl-ehci" device.  Call this function multiple times
+ * to register each host interface.
+ */
+static int instance_id = 0;
+static struct platform_device *host_pdev_register(struct resource *res,
+						  int n_res,
+						  struct arc_usb_config *config)
+{
+	int rc;
+	struct platform_device *pdev;
+
+	pdev = platform_device_register_simple("fsl-ehci",
+					       instance_id, res, n_res);
+	if (IS_ERR(pdev)) {
+		pr_debug("can't register %s Host, %d\n",
+			 config->name, PTR_ERR(pdev));
+		return NULL;
+	}
+
+	pdev->dev.coherent_dma_mask = 0xffffffff;
+	pdev->dev.dma_mask = &ehci_dmamask;
+	rc = platform_device_add_data(pdev, config,
+				      sizeof(struct arc_usb_config));
+	if (rc) {
+		platform_device_unregister(pdev);
+		return NULL;
+	}
+
+	printk(KERN_INFO "usb: %s registered\n", config->name);
+	dbg("pdev=0x%p  dev=0x%p  resources=0x%p  pdata=0x%p",
+	    pdev, &pdev->dev, pdev->resource, pdev->dev.platform_data);
+	instance_id++;
+
+	return pdev;
+}
+
+static int __init mx27_usb_init(void)
+{
+	int rc __attribute((unused));
+
+	dbg();
+
+#if defined(CONFIG_USB_OTG)
+	rc = platform_device_register(&isp1504_device);
+	if (rc) {
+		pr_debug("can't register isp1504 dvc, %d\n", rc);
+	} else {
+		printk(KERN_INFO "usb: isp1504 registered\n");
+		dbg("isp1504: platform_device_register succeeded.");
+		dbg("isp1504_device=0x%p  resources=0x%p.",
+		    &isp1504_device, isp1504_device.resource);
+	}
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_H1
+	usbh1_device = host_pdev_register(usbh1_resources,
+					  ARRAY_SIZE(usbh1_resources),
+					  &usbh1_config);
+#endif
+
+#ifdef CONFIG_USB_EHCI_ARC_H2
+	usbh2_device = host_pdev_register(usbh2_resources,
+					  ARRAY_SIZE(usbh2_resources),
+					  &usbh2_config);
+#endif
+
+#if defined(CONFIG_USB_EHCI_ARC_OTGHS)
+	otg_hs_host_device = host_pdev_register(otg_resources,
+						ARRAY_SIZE(otg_resources),
+						&otg_hs_host_config);
+#elif defined(CONFIG_USB_EHCI_ARC_OTGFS)
+	otg_fs_host_device = host_pdev_register(otg_resources,
+						ARRAY_SIZE(otg_resources),
+						&otg_fs_host_config);
+#endif
+
+#ifdef CONFIG_USB_GADGET_ARC
+	rc = platform_device_register(&udc_device);
+	if (rc)
+		pr_debug("can't register OTG Gadget, %d\n", rc);
+	else
+		printk(KERN_INFO "usb: %s registered\n",
+		       ((struct arc_usb_config *)udc_device.dev.platform_data)->
+		       name);
+#endif
+	return 0;
+}
+
+subsys_initcall(mx27_usb_init);
